import {
  __commonJS,
  __export,
  __publicField,
  __require,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p3 = string.length;
      if (!p3)
        return 0;
      var n31 = 0;
      while (--p3 % 4 > 1 && string.charAt(p3) === "=")
        ++n31;
      return Math.ceil(string.length * 3) / 4 - n31;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i17 = 0; i17 < 64; )
      s64[b64[i17] = i17 < 26 ? i17 + 65 : i17 < 52 ? i17 + 71 : i17 < 62 ? i17 - 4 : i17 - 59 | 43] = i17++;
    var i17;
    base64.encode = function encode5(buffer, start, end) {
      var parts = null, chunk = [];
      var i18 = 0, j2 = 0, t35;
      while (start < end) {
        var b5 = buffer[start++];
        switch (j2) {
          case 0:
            chunk[i18++] = b64[b5 >> 2];
            t35 = (b5 & 3) << 4;
            j2 = 1;
            break;
          case 1:
            chunk[i18++] = b64[t35 | b5 >> 4];
            t35 = (b5 & 15) << 2;
            j2 = 2;
            break;
          case 2:
            chunk[i18++] = b64[t35 | b5 >> 6];
            chunk[i18++] = b64[b5 & 63];
            j2 = 0;
            break;
        }
        if (i18 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i18 = 0;
        }
      }
      if (j2) {
        chunk[i18++] = b64[t35];
        chunk[i18++] = 61;
        if (j2 === 1)
          chunk[i18++] = 61;
      }
      if (parts) {
        if (i18)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i18)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i18));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode7(string, buffer, offset) {
      var start = offset;
      var j2 = 0, t35;
      for (var i18 = 0; i18 < string.length; ) {
        var c17 = string.charCodeAt(i18++);
        if (c17 === 61 && j2 > 1)
          break;
        if ((c17 = s64[c17]) === void 0)
          throw Error(invalidEncoding);
        switch (j2) {
          case 0:
            t35 = c17;
            j2 = 1;
            break;
          case 1:
            buffer[offset++] = t35 << 2 | (c17 & 48) >> 4;
            t35 = c17;
            j2 = 2;
            break;
          case 2:
            buffer[offset++] = (t35 & 15) << 4 | (c17 & 60) >> 2;
            t35 = c17;
            j2 = 3;
            break;
          case 3:
            buffer[offset++] = (t35 & 3) << 6 | c17;
            j2 = 0;
            break;
        }
      }
      if (j2 === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i17 = 0; i17 < listeners.length; )
            if (listeners[i17].fn === fn)
              listeners.splice(i17, 1);
            else
              ++i17;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i17 = 1;
        for (; i17 < arguments.length; )
          args.push(arguments[i17++]);
        for (i17 = 0; i17 < listeners.length; )
          listeners[i17].fn.apply(listeners[i17++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign2 << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign2 = val < 0 ? 1 : 0;
          if (sign2)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign2 << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e39) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c17 = 0;
      for (var i17 = 0; i17 < string.length; ++i17) {
        c17 = string.charCodeAt(i17);
        if (c17 < 128)
          len += 1;
        else if (c17 < 2048)
          len += 2;
        else if ((c17 & 64512) === 55296 && (string.charCodeAt(i17 + 1) & 64512) === 56320) {
          ++i17;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i17 = 0, t35;
      while (start < end) {
        t35 = buffer[start++];
        if (t35 < 128)
          chunk[i17++] = t35;
        else if (t35 > 191 && t35 < 224)
          chunk[i17++] = (t35 & 31) << 6 | buffer[start++] & 63;
        else if (t35 > 239 && t35 < 365) {
          t35 = ((t35 & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i17++] = 55296 + (t35 >> 10);
          chunk[i17++] = 56320 + (t35 & 1023);
        } else
          chunk[i17++] = (t35 & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i17 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i17 = 0;
        }
      }
      if (parts) {
        if (i17)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i17)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i17));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c22;
      for (var i17 = 0; i17 < string.length; ++i17) {
        c1 = string.charCodeAt(i17);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c22 = string.charCodeAt(i17 + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
          ++i17;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX2 = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX2)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber2(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber2(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
        (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger2(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = (function() {
      try {
        var Buffer5 = util.inquire("buffer").Buffer;
        return Buffer5.prototype.utf8Write ? Buffer5 : (
          /* istanbul ignore next */
          null
        );
      } catch (e39) {
        return null;
      }
    })();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i17 = 0; i17 < keys.length; ++i17)
        if (dst[keys[i17]] === void 0 || !ifNotSet)
          dst[keys[i17]] = src[keys[i17]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i17 = 0; i17 < fieldNames.length; ++i17)
        fieldMap[fieldNames[i17]] = 1;
      return function() {
        for (var keys = Object.keys(this), i18 = keys.length - 1; i18 > -1; --i18)
          if (fieldMap[keys[i18]] === 1 && this[keys[i18]] !== void 0 && this[keys[i18]] !== null)
            return keys[i18];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i17 = 0; i17 < fieldNames.length; ++i17)
          if (fieldNames[i17] !== name)
            delete this[fieldNames[i17]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer5 = util.Buffer;
      if (!Buffer5) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer5.from !== Uint8Array.from && Buffer5.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer5(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer5.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer5(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer2;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer2() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer2.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer2();
      };
    };
    Writer2.create = create();
    Writer2.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer2.alloc = util.pool(Writer2.alloc, util.Array.prototype.subarray);
    Writer2.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer2.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer2.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer2.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer2.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.int64 = Writer2.prototype.uint64;
    Writer2.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer2.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer2.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer2.prototype.sfixed32 = Writer2.prototype.fixed32;
    Writer2.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer2.prototype.sfixed64 = Writer2.prototype.fixed64;
    Writer2.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer2.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i17 = 0; i17 < val.length; ++i17)
        buf[pos + i17] = val[i17];
    };
    Writer2.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer2.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer2.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer2.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer2.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer2.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer2.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer2._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer2.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer2 = require_writer();
    (BufferWriter.prototype = Object.create(Writer2.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer2.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i17 = 0; i17 < val.length; )
          buf[pos++] = val[i17++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader2;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader2(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader2(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader2(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader2.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader2.create = create();
    Reader2.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader2.prototype.uint32 = /* @__PURE__ */ (function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    })();
    Reader2.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader2.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i17 = 0;
      if (this.len - this.pos > 4) {
        for (; i17 < 4; ++i17) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i17 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i17 = 0;
      } else {
        for (; i17 < 3; ++i17) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i17 * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i17 * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i17 < 5; ++i17) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i17 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i17 < 5; ++i17) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i17 * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader2.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader2.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader2.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader2.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader2.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader2.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader2.prototype.string = function read_string() {
      var bytes3 = this.bytes();
      return utf8.read(bytes3, 0, bytes3.length);
    };
    Reader2.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader2.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader2._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader2.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader2.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader2 = require_reader();
    (BufferReader.prototype = Object.create(Reader2.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader2.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/long/umd/index.js
var require_umd = __commonJS({
  "node_modules/long/umd/index.js"(exports2, module2) {
    (function(global2, factory) {
      function preferDefault(exports3) {
        return exports3.default || exports3;
      }
      if (typeof define === "function" && define.amd) {
        define([], function() {
          var exports3 = {};
          factory(exports3);
          return preferDefault(exports3);
        });
      } else if (typeof exports2 === "object") {
        factory(exports2);
        if (typeof module2 === "object") module2.exports = preferDefault(exports2);
      } else {
        (function() {
          var exports3 = {};
          factory(exports3);
          global2.Long = preferDefault(exports3);
        })();
      }
    })(
      typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports2,
      function(_exports) {
        "use strict";
        Object.defineProperty(_exports, "__esModule", {
          value: true
        });
        _exports.default = void 0;
        var wasm2 = null;
        try {
          wasm2 = new WebAssembly.Instance(
            new WebAssembly.Module(
              new Uint8Array([
                // \0asm
                0,
                97,
                115,
                109,
                // version 1
                1,
                0,
                0,
                0,
                // section "type"
                1,
                13,
                2,
                // 0, () => i32
                96,
                0,
                1,
                127,
                // 1, (i32, i32, i32, i32) => i32
                96,
                4,
                127,
                127,
                127,
                127,
                1,
                127,
                // section "function"
                3,
                7,
                6,
                // 0, type 0
                0,
                // 1, type 1
                1,
                // 2, type 1
                1,
                // 3, type 1
                1,
                // 4, type 1
                1,
                // 5, type 1
                1,
                // section "global"
                6,
                6,
                1,
                // 0, "high", mutable i32
                127,
                1,
                65,
                0,
                11,
                // section "export"
                7,
                50,
                6,
                // 0, "mul"
                3,
                109,
                117,
                108,
                0,
                1,
                // 1, "div_s"
                5,
                100,
                105,
                118,
                95,
                115,
                0,
                2,
                // 2, "div_u"
                5,
                100,
                105,
                118,
                95,
                117,
                0,
                3,
                // 3, "rem_s"
                5,
                114,
                101,
                109,
                95,
                115,
                0,
                4,
                // 4, "rem_u"
                5,
                114,
                101,
                109,
                95,
                117,
                0,
                5,
                // 5, "get_high"
                8,
                103,
                101,
                116,
                95,
                104,
                105,
                103,
                104,
                0,
                0,
                // section "code"
                10,
                191,
                1,
                6,
                // 0, "get_high"
                4,
                0,
                35,
                0,
                11,
                // 1, "mul"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                126,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11,
                // 2, "div_s"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                127,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11,
                // 3, "div_u"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                128,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11,
                // 4, "rem_s"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                129,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11,
                // 5, "rem_u"
                36,
                1,
                1,
                126,
                32,
                0,
                173,
                32,
                1,
                173,
                66,
                32,
                134,
                132,
                32,
                2,
                173,
                32,
                3,
                173,
                66,
                32,
                134,
                132,
                130,
                34,
                4,
                66,
                32,
                135,
                167,
                36,
                0,
                32,
                4,
                167,
                11
              ])
            ),
            {}
          ).exports;
        } catch {
        }
        function Long2(low, high, unsigned) {
          this.low = low | 0;
          this.high = high | 0;
          this.unsigned = !!unsigned;
        }
        Long2.prototype.__isLong__;
        Object.defineProperty(Long2.prototype, "__isLong__", {
          value: true
        });
        function isLong2(obj) {
          return (obj && obj["__isLong__"]) === true;
        }
        function ctz322(value) {
          var c17 = Math.clz32(value & -value);
          return value ? 31 - c17 : c17;
        }
        Long2.isLong = isLong2;
        var INT_CACHE2 = {};
        var UINT_CACHE2 = {};
        function fromInt2(value, unsigned) {
          var obj, cachedObj, cache;
          if (unsigned) {
            value >>>= 0;
            if (cache = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE2[value];
              if (cachedObj) return cachedObj;
            }
            obj = fromBits2(value, 0, true);
            if (cache) UINT_CACHE2[value] = obj;
            return obj;
          } else {
            value |= 0;
            if (cache = -128 <= value && value < 128) {
              cachedObj = INT_CACHE2[value];
              if (cachedObj) return cachedObj;
            }
            obj = fromBits2(value, value < 0 ? -1 : 0, false);
            if (cache) INT_CACHE2[value] = obj;
            return obj;
          }
        }
        Long2.fromInt = fromInt2;
        function fromNumber2(value, unsigned) {
          if (isNaN(value)) return unsigned ? UZERO2 : ZERO2;
          if (unsigned) {
            if (value < 0) return UZERO2;
            if (value >= TWO_PWR_64_DBL2) return MAX_UNSIGNED_VALUE2;
          } else {
            if (value <= -TWO_PWR_63_DBL2) return MIN_VALUE2;
            if (value + 1 >= TWO_PWR_63_DBL2) return MAX_VALUE2;
          }
          if (value < 0) return fromNumber2(-value, unsigned).neg();
          return fromBits2(
            value % TWO_PWR_32_DBL2 | 0,
            value / TWO_PWR_32_DBL2 | 0,
            unsigned
          );
        }
        Long2.fromNumber = fromNumber2;
        function fromBits2(lowBits, highBits, unsigned) {
          return new Long2(lowBits, highBits, unsigned);
        }
        Long2.fromBits = fromBits2;
        var pow_dbl2 = Math.pow;
        function fromString2(str, unsigned, radix) {
          if (str.length === 0) throw Error("empty string");
          if (typeof unsigned === "number") {
            radix = unsigned;
            unsigned = false;
          } else {
            unsigned = !!unsigned;
          }
          if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return unsigned ? UZERO2 : ZERO2;
          radix = radix || 10;
          if (radix < 2 || 36 < radix) throw RangeError("radix");
          var p3;
          if ((p3 = str.indexOf("-")) > 0) throw Error("interior hyphen");
          else if (p3 === 0) {
            return fromString2(str.substring(1), unsigned, radix).neg();
          }
          var radixToPower = fromNumber2(pow_dbl2(radix, 8));
          var result = ZERO2;
          for (var i17 = 0; i17 < str.length; i17 += 8) {
            var size = Math.min(8, str.length - i17), value = parseInt(str.substring(i17, i17 + size), radix);
            if (size < 8) {
              var power = fromNumber2(pow_dbl2(radix, size));
              result = result.mul(power).add(fromNumber2(value));
            } else {
              result = result.mul(radixToPower);
              result = result.add(fromNumber2(value));
            }
          }
          result.unsigned = unsigned;
          return result;
        }
        Long2.fromString = fromString2;
        function fromValue2(val, unsigned) {
          if (typeof val === "number") return fromNumber2(val, unsigned);
          if (typeof val === "string") return fromString2(val, unsigned);
          return fromBits2(
            val.low,
            val.high,
            typeof unsigned === "boolean" ? unsigned : val.unsigned
          );
        }
        Long2.fromValue = fromValue2;
        var TWO_PWR_16_DBL2 = 1 << 16;
        var TWO_PWR_24_DBL2 = 1 << 24;
        var TWO_PWR_32_DBL2 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
        var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL2 * TWO_PWR_32_DBL2;
        var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
        var TWO_PWR_242 = fromInt2(TWO_PWR_24_DBL2);
        var ZERO2 = fromInt2(0);
        Long2.ZERO = ZERO2;
        var UZERO2 = fromInt2(0, true);
        Long2.UZERO = UZERO2;
        var ONE3 = fromInt2(1);
        Long2.ONE = ONE3;
        var UONE2 = fromInt2(1, true);
        Long2.UONE = UONE2;
        var NEG_ONE2 = fromInt2(-1);
        Long2.NEG_ONE = NEG_ONE2;
        var MAX_VALUE2 = fromBits2(4294967295 | 0, 2147483647 | 0, false);
        Long2.MAX_VALUE = MAX_VALUE2;
        var MAX_UNSIGNED_VALUE2 = fromBits2(4294967295 | 0, 4294967295 | 0, true);
        Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE2;
        var MIN_VALUE2 = fromBits2(0, 2147483648 | 0, false);
        Long2.MIN_VALUE = MIN_VALUE2;
        var LongPrototype2 = Long2.prototype;
        LongPrototype2.toInt = function toInt2() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        LongPrototype2.toNumber = function toNumber2() {
          if (this.unsigned)
            return (this.high >>> 0) * TWO_PWR_32_DBL2 + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL2 + (this.low >>> 0);
        };
        LongPrototype2.toString = function toString2(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix) throw RangeError("radix");
          if (this.isZero()) return "0";
          if (this.isNegative()) {
            if (this.eq(MIN_VALUE2)) {
              var radixLong = fromNumber2(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
              return div.toString(radix) + rem1.toInt().toString(radix);
            } else return "-" + this.neg().toString(radix);
          }
          var radixToPower = fromNumber2(pow_dbl2(radix, 6), this.unsigned), rem = this;
          var result = "";
          while (true) {
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) return digits + result;
            else {
              while (digits.length < 6) digits = "0" + digits;
              result = "" + digits + result;
            }
          }
        };
        LongPrototype2.getHighBits = function getHighBits2() {
          return this.high;
        };
        LongPrototype2.getHighBitsUnsigned = function getHighBitsUnsigned2() {
          return this.high >>> 0;
        };
        LongPrototype2.getLowBits = function getLowBits2() {
          return this.low;
        };
        LongPrototype2.getLowBitsUnsigned = function getLowBitsUnsigned2() {
          return this.low >>> 0;
        };
        LongPrototype2.getNumBitsAbs = function getNumBitsAbs2() {
          if (this.isNegative())
            return this.eq(MIN_VALUE2) ? 64 : this.neg().getNumBitsAbs();
          var val = this.high != 0 ? this.high : this.low;
          for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
          return this.high != 0 ? bit + 33 : bit + 1;
        };
        LongPrototype2.isSafeInteger = function isSafeInteger2() {
          var top11Bits = this.high >> 21;
          if (!top11Bits) return true;
          if (this.unsigned) return false;
          return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
        };
        LongPrototype2.isZero = function isZero2() {
          return this.high === 0 && this.low === 0;
        };
        LongPrototype2.eqz = LongPrototype2.isZero;
        LongPrototype2.isNegative = function isNegative2() {
          return !this.unsigned && this.high < 0;
        };
        LongPrototype2.isPositive = function isPositive2() {
          return this.unsigned || this.high >= 0;
        };
        LongPrototype2.isOdd = function isOdd3() {
          return (this.low & 1) === 1;
        };
        LongPrototype2.isEven = function isEven2() {
          return (this.low & 1) === 0;
        };
        LongPrototype2.equals = function equals2(other) {
          if (!isLong2(other)) other = fromValue2(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
          return this.high === other.high && this.low === other.low;
        };
        LongPrototype2.eq = LongPrototype2.equals;
        LongPrototype2.notEquals = function notEquals2(other) {
          return !this.eq(
            /* validates */
            other
          );
        };
        LongPrototype2.neq = LongPrototype2.notEquals;
        LongPrototype2.ne = LongPrototype2.notEquals;
        LongPrototype2.lessThan = function lessThan2(other) {
          return this.comp(
            /* validates */
            other
          ) < 0;
        };
        LongPrototype2.lt = LongPrototype2.lessThan;
        LongPrototype2.lessThanOrEqual = function lessThanOrEqual2(other) {
          return this.comp(
            /* validates */
            other
          ) <= 0;
        };
        LongPrototype2.lte = LongPrototype2.lessThanOrEqual;
        LongPrototype2.le = LongPrototype2.lessThanOrEqual;
        LongPrototype2.greaterThan = function greaterThan2(other) {
          return this.comp(
            /* validates */
            other
          ) > 0;
        };
        LongPrototype2.gt = LongPrototype2.greaterThan;
        LongPrototype2.greaterThanOrEqual = function greaterThanOrEqual2(other) {
          return this.comp(
            /* validates */
            other
          ) >= 0;
        };
        LongPrototype2.gte = LongPrototype2.greaterThanOrEqual;
        LongPrototype2.ge = LongPrototype2.greaterThanOrEqual;
        LongPrototype2.compare = function compare3(other) {
          if (!isLong2(other)) other = fromValue2(other);
          if (this.eq(other)) return 0;
          var thisNeg = this.isNegative(), otherNeg = other.isNegative();
          if (thisNeg && !otherNeg) return -1;
          if (!thisNeg && otherNeg) return 1;
          if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        };
        LongPrototype2.comp = LongPrototype2.compare;
        LongPrototype2.negate = function negate2() {
          if (!this.unsigned && this.eq(MIN_VALUE2)) return MIN_VALUE2;
          return this.not().add(ONE3);
        };
        LongPrototype2.neg = LongPrototype2.negate;
        LongPrototype2.add = function add3(addend) {
          if (!isLong2(addend)) addend = fromValue2(addend);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a162 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = addend.high >>> 16;
          var b32 = addend.high & 65535;
          var b16 = addend.low >>> 16;
          var b00 = addend.low & 65535;
          var c48 = 0, c32 = 0, c162 = 0, c00 = 0;
          c00 += a00 + b00;
          c162 += c00 >>> 16;
          c00 &= 65535;
          c162 += a162 + b16;
          c32 += c162 >>> 16;
          c162 &= 65535;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 + b48;
          c48 &= 65535;
          return fromBits2(c162 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype2.subtract = function subtract2(subtrahend) {
          if (!isLong2(subtrahend)) subtrahend = fromValue2(subtrahend);
          return this.add(subtrahend.neg());
        };
        LongPrototype2.sub = LongPrototype2.subtract;
        LongPrototype2.multiply = function multiply2(multiplier) {
          if (this.isZero()) return this;
          if (!isLong2(multiplier)) multiplier = fromValue2(multiplier);
          if (wasm2) {
            var low = wasm2["mul"](
              this.low,
              this.high,
              multiplier.low,
              multiplier.high
            );
            return fromBits2(low, wasm2["get_high"](), this.unsigned);
          }
          if (multiplier.isZero()) return this.unsigned ? UZERO2 : ZERO2;
          if (this.eq(MIN_VALUE2)) return multiplier.isOdd() ? MIN_VALUE2 : ZERO2;
          if (multiplier.eq(MIN_VALUE2)) return this.isOdd() ? MIN_VALUE2 : ZERO2;
          if (this.isNegative()) {
            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
            else return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
          if (this.lt(TWO_PWR_242) && multiplier.lt(TWO_PWR_242))
            return fromNumber2(
              this.toNumber() * multiplier.toNumber(),
              this.unsigned
            );
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a162 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = multiplier.high >>> 16;
          var b32 = multiplier.high & 65535;
          var b16 = multiplier.low >>> 16;
          var b00 = multiplier.low & 65535;
          var c48 = 0, c32 = 0, c162 = 0, c00 = 0;
          c00 += a00 * b00;
          c162 += c00 >>> 16;
          c00 &= 65535;
          c162 += a162 * b00;
          c32 += c162 >>> 16;
          c162 &= 65535;
          c162 += a00 * b16;
          c32 += c162 >>> 16;
          c162 &= 65535;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a162 * b16;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 * b00 + a32 * b16 + a162 * b32 + a00 * b48;
          c48 &= 65535;
          return fromBits2(c162 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype2.mul = LongPrototype2.multiply;
        LongPrototype2.divide = function divide2(divisor) {
          if (!isLong2(divisor)) divisor = fromValue2(divisor);
          if (divisor.isZero()) throw Error("division by zero");
          if (wasm2) {
            if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
              return this;
            }
            var low = (this.unsigned ? wasm2["div_u"] : wasm2["div_s"])(
              this.low,
              this.high,
              divisor.low,
              divisor.high
            );
            return fromBits2(low, wasm2["get_high"](), this.unsigned);
          }
          if (this.isZero()) return this.unsigned ? UZERO2 : ZERO2;
          var approx, rem, res;
          if (!this.unsigned) {
            if (this.eq(MIN_VALUE2)) {
              if (divisor.eq(ONE3) || divisor.eq(NEG_ONE2))
                return MIN_VALUE2;
              else if (divisor.eq(MIN_VALUE2)) return ONE3;
              else {
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO2)) {
                  return divisor.isNegative() ? ONE3 : NEG_ONE2;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
            } else if (divisor.eq(MIN_VALUE2)) return this.unsigned ? UZERO2 : ZERO2;
            if (this.isNegative()) {
              if (divisor.isNegative()) return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
            res = ZERO2;
          } else {
            if (!divisor.unsigned) divisor = divisor.toUnsigned();
            if (divisor.gt(this)) return UZERO2;
            if (divisor.gt(this.shru(1)))
              return UONE2;
            res = UZERO2;
          }
          rem = this;
          while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl2(2, log22 - 48), approxRes = fromNumber2(approx), approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber2(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero()) approxRes = ONE3;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }
          return res;
        };
        LongPrototype2.div = LongPrototype2.divide;
        LongPrototype2.modulo = function modulo2(divisor) {
          if (!isLong2(divisor)) divisor = fromValue2(divisor);
          if (wasm2) {
            var low = (this.unsigned ? wasm2["rem_u"] : wasm2["rem_s"])(
              this.low,
              this.high,
              divisor.low,
              divisor.high
            );
            return fromBits2(low, wasm2["get_high"](), this.unsigned);
          }
          return this.sub(this.div(divisor).mul(divisor));
        };
        LongPrototype2.mod = LongPrototype2.modulo;
        LongPrototype2.rem = LongPrototype2.modulo;
        LongPrototype2.not = function not2() {
          return fromBits2(~this.low, ~this.high, this.unsigned);
        };
        LongPrototype2.countLeadingZeros = function countLeadingZeros2() {
          return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
        };
        LongPrototype2.clz = LongPrototype2.countLeadingZeros;
        LongPrototype2.countTrailingZeros = function countTrailingZeros2() {
          return this.low ? ctz322(this.low) : ctz322(this.high) + 32;
        };
        LongPrototype2.ctz = LongPrototype2.countTrailingZeros;
        LongPrototype2.and = function and2(other) {
          if (!isLong2(other)) other = fromValue2(other);
          return fromBits2(
            this.low & other.low,
            this.high & other.high,
            this.unsigned
          );
        };
        LongPrototype2.or = function or2(other) {
          if (!isLong2(other)) other = fromValue2(other);
          return fromBits2(
            this.low | other.low,
            this.high | other.high,
            this.unsigned
          );
        };
        LongPrototype2.xor = function xor2(other) {
          if (!isLong2(other)) other = fromValue2(other);
          return fromBits2(
            this.low ^ other.low,
            this.high ^ other.high,
            this.unsigned
          );
        };
        LongPrototype2.shiftLeft = function shiftLeft2(numBits) {
          if (isLong2(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          else if (numBits < 32)
            return fromBits2(
              this.low << numBits,
              this.high << numBits | this.low >>> 32 - numBits,
              this.unsigned
            );
          else return fromBits2(0, this.low << numBits - 32, this.unsigned);
        };
        LongPrototype2.shl = LongPrototype2.shiftLeft;
        LongPrototype2.shiftRight = function shiftRight2(numBits) {
          if (isLong2(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          else if (numBits < 32)
            return fromBits2(
              this.low >>> numBits | this.high << 32 - numBits,
              this.high >> numBits,
              this.unsigned
            );
          else
            return fromBits2(
              this.high >> numBits - 32,
              this.high >= 0 ? 0 : -1,
              this.unsigned
            );
        };
        LongPrototype2.shr = LongPrototype2.shiftRight;
        LongPrototype2.shiftRightUnsigned = function shiftRightUnsigned2(numBits) {
          if (isLong2(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          if (numBits < 32)
            return fromBits2(
              this.low >>> numBits | this.high << 32 - numBits,
              this.high >>> numBits,
              this.unsigned
            );
          if (numBits === 32) return fromBits2(this.high, 0, this.unsigned);
          return fromBits2(this.high >>> numBits - 32, 0, this.unsigned);
        };
        LongPrototype2.shru = LongPrototype2.shiftRightUnsigned;
        LongPrototype2.shr_u = LongPrototype2.shiftRightUnsigned;
        LongPrototype2.rotateLeft = function rotateLeft2(numBits) {
          var b5;
          if (isLong2(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          if (numBits === 32) return fromBits2(this.high, this.low, this.unsigned);
          if (numBits < 32) {
            b5 = 32 - numBits;
            return fromBits2(
              this.low << numBits | this.high >>> b5,
              this.high << numBits | this.low >>> b5,
              this.unsigned
            );
          }
          numBits -= 32;
          b5 = 32 - numBits;
          return fromBits2(
            this.high << numBits | this.low >>> b5,
            this.low << numBits | this.high >>> b5,
            this.unsigned
          );
        };
        LongPrototype2.rotl = LongPrototype2.rotateLeft;
        LongPrototype2.rotateRight = function rotateRight2(numBits) {
          var b5;
          if (isLong2(numBits)) numBits = numBits.toInt();
          if ((numBits &= 63) === 0) return this;
          if (numBits === 32) return fromBits2(this.high, this.low, this.unsigned);
          if (numBits < 32) {
            b5 = 32 - numBits;
            return fromBits2(
              this.high << b5 | this.low >>> numBits,
              this.low << b5 | this.high >>> numBits,
              this.unsigned
            );
          }
          numBits -= 32;
          b5 = 32 - numBits;
          return fromBits2(
            this.low << b5 | this.high >>> numBits,
            this.high << b5 | this.low >>> numBits,
            this.unsigned
          );
        };
        LongPrototype2.rotr = LongPrototype2.rotateRight;
        LongPrototype2.toSigned = function toSigned2() {
          if (!this.unsigned) return this;
          return fromBits2(this.low, this.high, false);
        };
        LongPrototype2.toUnsigned = function toUnsigned2() {
          if (this.unsigned) return this;
          return fromBits2(this.low, this.high, true);
        };
        LongPrototype2.toBytes = function toBytes3(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        };
        LongPrototype2.toBytesLE = function toBytesLE2() {
          var hi = this.high, lo = this.low;
          return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24
          ];
        };
        LongPrototype2.toBytesBE = function toBytesBE2() {
          var hi = this.high, lo = this.low;
          return [
            hi >>> 24,
            hi >>> 16 & 255,
            hi >>> 8 & 255,
            hi & 255,
            lo >>> 24,
            lo >>> 16 & 255,
            lo >>> 8 & 255,
            lo & 255
          ];
        };
        Long2.fromBytes = function fromBytes3(bytes3, unsigned, le) {
          return le ? Long2.fromBytesLE(bytes3, unsigned) : Long2.fromBytesBE(bytes3, unsigned);
        };
        Long2.fromBytesLE = function fromBytesLE2(bytes3, unsigned) {
          return new Long2(
            bytes3[0] | bytes3[1] << 8 | bytes3[2] << 16 | bytes3[3] << 24,
            bytes3[4] | bytes3[5] << 8 | bytes3[6] << 16 | bytes3[7] << 24,
            unsigned
          );
        };
        Long2.fromBytesBE = function fromBytesBE2(bytes3, unsigned) {
          return new Long2(
            bytes3[4] << 24 | bytes3[5] << 16 | bytes3[6] << 8 | bytes3[7],
            bytes3[0] << 24 | bytes3[1] << 16 | bytes3[2] << 8 | bytes3[3],
            unsigned
          );
        };
        if (typeof BigInt === "function") {
          Long2.fromBigInt = function fromBigInt(value, unsigned) {
            var lowBits = Number(BigInt.asIntN(32, value));
            var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
            return fromBits2(lowBits, highBits, unsigned);
          };
          Long2.fromValue = function fromValueWithBigInt(value, unsigned) {
            if (typeof value === "bigint") return Long2.fromBigInt(value, unsigned);
            return fromValue2(value, unsigned);
          };
          LongPrototype2.toBigInt = function toBigInt() {
            var lowBigInt = BigInt(this.low >>> 0);
            var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
            return highBigInt << BigInt(32) | lowBigInt;
          };
        }
        var _default = _exports.default = Long2;
      }
    );
  }
});

// node_modules/@hashgraph/proto/lib/proto.js
var require_proto = __commonJS({
  "node_modules/@hashgraph/proto/lib/proto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.proto = exports2.google = exports2.default = exports2.com = void 0;
    var $protobuf = _interopRequireWildcard(require_minimal2());
    function _getRequireWildcardCache(e39) {
      if ("function" != typeof WeakMap) return null;
      var r41 = /* @__PURE__ */ new WeakMap(), t35 = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e40) {
        return e40 ? t35 : r41;
      })(e39);
    }
    function _interopRequireWildcard(e39, r41) {
      if (!r41 && e39 && e39.__esModule) return e39;
      if (null === e39 || "object" != typeof e39 && "function" != typeof e39) return { default: e39 };
      var t35 = _getRequireWildcardCache(r41);
      if (t35 && t35.has(e39)) return t35.get(e39);
      var n31 = { __proto__: null }, a23 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u22 in e39) if ("default" !== u22 && Object.prototype.hasOwnProperty.call(e39, u22)) {
        var i17 = a23 ? Object.getOwnPropertyDescriptor(e39, u22) : null;
        i17 && (i17.get || i17.set) ? Object.defineProperty(n31, u22, i17) : n31[u22] = e39[u22];
      }
      return n31.default = e39, t35 && t35.set(e39, n31), n31;
    }
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots.hashgraph || ($protobuf.roots.hashgraph = {});
    exports2.default = $root;
    var com2 = $root.com = (() => {
      const com3 = {};
      com3.hedera = (function() {
        const hedera = {};
        hedera.mirror = (function() {
          const mirror = {};
          mirror.api = (function() {
            const api = {};
            api.proto = (function() {
              const proto37 = {};
              proto37.ConsensusTopicQuery = (function() {
                function ConsensusTopicQuery(p3) {
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                ConsensusTopicQuery.prototype.topicID = null;
                ConsensusTopicQuery.prototype.consensusStartTime = null;
                ConsensusTopicQuery.prototype.consensusEndTime = null;
                ConsensusTopicQuery.prototype.limit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                ConsensusTopicQuery.create = function create(properties) {
                  return new ConsensusTopicQuery(properties);
                };
                ConsensusTopicQuery.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.topicID != null && Object.hasOwnProperty.call(m6, "topicID")) $root.proto.TopicID.encode(m6.topicID, w5.uint32(10).fork()).ldelim();
                  if (m6.consensusStartTime != null && Object.hasOwnProperty.call(m6, "consensusStartTime")) $root.proto.Timestamp.encode(m6.consensusStartTime, w5.uint32(18).fork()).ldelim();
                  if (m6.consensusEndTime != null && Object.hasOwnProperty.call(m6, "consensusEndTime")) $root.proto.Timestamp.encode(m6.consensusEndTime, w5.uint32(26).fork()).ldelim();
                  if (m6.limit != null && Object.hasOwnProperty.call(m6, "limit")) w5.uint32(32).uint64(m6.limit);
                  return w5;
                };
                ConsensusTopicQuery.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.mirror.api.proto.ConsensusTopicQuery();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.topicID = $root.proto.TopicID.decode(r41, r41.uint32());
                        break;
                      }
                      case 2: {
                        m6.consensusStartTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                        break;
                      }
                      case 3: {
                        m6.consensusEndTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                        break;
                      }
                      case 4: {
                        m6.limit = r41.uint64();
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                ConsensusTopicQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.mirror.api.proto.ConsensusTopicQuery";
                };
                return ConsensusTopicQuery;
              })();
              proto37.ConsensusTopicResponse = (function() {
                function ConsensusTopicResponse(p3) {
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                ConsensusTopicResponse.prototype.consensusTimestamp = null;
                ConsensusTopicResponse.prototype.message = $util.newBuffer([]);
                ConsensusTopicResponse.prototype.runningHash = $util.newBuffer([]);
                ConsensusTopicResponse.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                ConsensusTopicResponse.prototype.runningHashVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                ConsensusTopicResponse.prototype.chunkInfo = null;
                ConsensusTopicResponse.create = function create(properties) {
                  return new ConsensusTopicResponse(properties);
                };
                ConsensusTopicResponse.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.consensusTimestamp != null && Object.hasOwnProperty.call(m6, "consensusTimestamp")) $root.proto.Timestamp.encode(m6.consensusTimestamp, w5.uint32(10).fork()).ldelim();
                  if (m6.message != null && Object.hasOwnProperty.call(m6, "message")) w5.uint32(18).bytes(m6.message);
                  if (m6.runningHash != null && Object.hasOwnProperty.call(m6, "runningHash")) w5.uint32(26).bytes(m6.runningHash);
                  if (m6.sequenceNumber != null && Object.hasOwnProperty.call(m6, "sequenceNumber")) w5.uint32(32).uint64(m6.sequenceNumber);
                  if (m6.runningHashVersion != null && Object.hasOwnProperty.call(m6, "runningHashVersion")) w5.uint32(40).uint64(m6.runningHashVersion);
                  if (m6.chunkInfo != null && Object.hasOwnProperty.call(m6, "chunkInfo")) $root.proto.ConsensusMessageChunkInfo.encode(m6.chunkInfo, w5.uint32(50).fork()).ldelim();
                  return w5;
                };
                ConsensusTopicResponse.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.mirror.api.proto.ConsensusTopicResponse();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.consensusTimestamp = $root.proto.Timestamp.decode(r41, r41.uint32());
                        break;
                      }
                      case 2: {
                        m6.message = r41.bytes();
                        break;
                      }
                      case 3: {
                        m6.runningHash = r41.bytes();
                        break;
                      }
                      case 4: {
                        m6.sequenceNumber = r41.uint64();
                        break;
                      }
                      case 5: {
                        m6.runningHashVersion = r41.uint64();
                        break;
                      }
                      case 6: {
                        m6.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(r41, r41.uint32());
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                ConsensusTopicResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.mirror.api.proto.ConsensusTopicResponse";
                };
                return ConsensusTopicResponse;
              })();
              proto37.ConsensusService = (function() {
                function ConsensusService(rpcImpl, requestDelimited, responseDelimited) {
                  $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
                (ConsensusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ConsensusService;
                ConsensusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
                };
                Object.defineProperty(ConsensusService.prototype.subscribeTopic = function subscribeTopic(request, callback) {
                  return this.rpcCall(subscribeTopic, $root.com.hedera.mirror.api.proto.ConsensusTopicQuery, $root.com.hedera.mirror.api.proto.ConsensusTopicResponse, request, callback);
                }, "name", { value: "subscribeTopic" });
                return ConsensusService;
              })();
              proto37.AddressBookQuery = (function() {
                function AddressBookQuery(p3) {
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                AddressBookQuery.prototype.fileId = null;
                AddressBookQuery.prototype.limit = 0;
                AddressBookQuery.create = function create(properties) {
                  return new AddressBookQuery(properties);
                };
                AddressBookQuery.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.fileId != null && Object.hasOwnProperty.call(m6, "fileId")) $root.proto.FileID.encode(m6.fileId, w5.uint32(10).fork()).ldelim();
                  if (m6.limit != null && Object.hasOwnProperty.call(m6, "limit")) w5.uint32(16).int32(m6.limit);
                  return w5;
                };
                AddressBookQuery.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.mirror.api.proto.AddressBookQuery();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.fileId = $root.proto.FileID.decode(r41, r41.uint32());
                        break;
                      }
                      case 2: {
                        m6.limit = r41.int32();
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                AddressBookQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.mirror.api.proto.AddressBookQuery";
                };
                return AddressBookQuery;
              })();
              proto37.NetworkService = (function() {
                function NetworkService(rpcImpl, requestDelimited, responseDelimited) {
                  $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
                (NetworkService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = NetworkService;
                NetworkService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
                };
                Object.defineProperty(NetworkService.prototype.getNodes = function getNodes(request, callback) {
                  return this.rpcCall(getNodes, $root.com.hedera.mirror.api.proto.AddressBookQuery, $root.proto.NodeAddress, request, callback);
                }, "name", { value: "getNodes" });
                return NetworkService;
              })();
              return proto37;
            })();
            return api;
          })();
          return mirror;
        })();
        hedera.hapi = (function() {
          const hapi = {};
          hapi.node = (function() {
            const node = {};
            node.addressbook = (function() {
              const addressbook = {};
              addressbook.NodeCreateTransactionBody = (function() {
                function NodeCreateTransactionBody(p3) {
                  this.gossipEndpoint = [];
                  this.serviceEndpoint = [];
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                NodeCreateTransactionBody.prototype.accountId = null;
                NodeCreateTransactionBody.prototype.description = "";
                NodeCreateTransactionBody.prototype.gossipEndpoint = $util.emptyArray;
                NodeCreateTransactionBody.prototype.serviceEndpoint = $util.emptyArray;
                NodeCreateTransactionBody.prototype.gossipCaCertificate = $util.newBuffer([]);
                NodeCreateTransactionBody.prototype.grpcCertificateHash = $util.newBuffer([]);
                NodeCreateTransactionBody.prototype.adminKey = null;
                NodeCreateTransactionBody.prototype.declineReward = false;
                NodeCreateTransactionBody.prototype.grpcProxyEndpoint = null;
                NodeCreateTransactionBody.create = function create(properties) {
                  return new NodeCreateTransactionBody(properties);
                };
                NodeCreateTransactionBody.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.accountId != null && Object.hasOwnProperty.call(m6, "accountId")) $root.proto.AccountID.encode(m6.accountId, w5.uint32(10).fork()).ldelim();
                  if (m6.description != null && Object.hasOwnProperty.call(m6, "description")) w5.uint32(18).string(m6.description);
                  if (m6.gossipEndpoint != null && m6.gossipEndpoint.length) {
                    for (var i17 = 0; i17 < m6.gossipEndpoint.length; ++i17) $root.proto.ServiceEndpoint.encode(m6.gossipEndpoint[i17], w5.uint32(26).fork()).ldelim();
                  }
                  if (m6.serviceEndpoint != null && m6.serviceEndpoint.length) {
                    for (var i17 = 0; i17 < m6.serviceEndpoint.length; ++i17) $root.proto.ServiceEndpoint.encode(m6.serviceEndpoint[i17], w5.uint32(34).fork()).ldelim();
                  }
                  if (m6.gossipCaCertificate != null && Object.hasOwnProperty.call(m6, "gossipCaCertificate")) w5.uint32(42).bytes(m6.gossipCaCertificate);
                  if (m6.grpcCertificateHash != null && Object.hasOwnProperty.call(m6, "grpcCertificateHash")) w5.uint32(50).bytes(m6.grpcCertificateHash);
                  if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(58).fork()).ldelim();
                  if (m6.declineReward != null && Object.hasOwnProperty.call(m6, "declineReward")) w5.uint32(64).bool(m6.declineReward);
                  if (m6.grpcProxyEndpoint != null && Object.hasOwnProperty.call(m6, "grpcProxyEndpoint")) $root.proto.ServiceEndpoint.encode(m6.grpcProxyEndpoint, w5.uint32(74).fork()).ldelim();
                  return w5;
                };
                NodeCreateTransactionBody.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.accountId = $root.proto.AccountID.decode(r41, r41.uint32());
                        break;
                      }
                      case 2: {
                        m6.description = r41.string();
                        break;
                      }
                      case 3: {
                        if (!(m6.gossipEndpoint && m6.gossipEndpoint.length)) m6.gossipEndpoint = [];
                        m6.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r41, r41.uint32()));
                        break;
                      }
                      case 4: {
                        if (!(m6.serviceEndpoint && m6.serviceEndpoint.length)) m6.serviceEndpoint = [];
                        m6.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r41, r41.uint32()));
                        break;
                      }
                      case 5: {
                        m6.gossipCaCertificate = r41.bytes();
                        break;
                      }
                      case 6: {
                        m6.grpcCertificateHash = r41.bytes();
                        break;
                      }
                      case 7: {
                        m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                        break;
                      }
                      case 8: {
                        m6.declineReward = r41.bool();
                        break;
                      }
                      case 9: {
                        m6.grpcProxyEndpoint = $root.proto.ServiceEndpoint.decode(r41, r41.uint32());
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                NodeCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.hapi.node.addressbook.NodeCreateTransactionBody";
                };
                return NodeCreateTransactionBody;
              })();
              addressbook.NodeUpdateTransactionBody = (function() {
                function NodeUpdateTransactionBody(p3) {
                  this.gossipEndpoint = [];
                  this.serviceEndpoint = [];
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                NodeUpdateTransactionBody.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                NodeUpdateTransactionBody.prototype.accountId = null;
                NodeUpdateTransactionBody.prototype.description = null;
                NodeUpdateTransactionBody.prototype.gossipEndpoint = $util.emptyArray;
                NodeUpdateTransactionBody.prototype.serviceEndpoint = $util.emptyArray;
                NodeUpdateTransactionBody.prototype.gossipCaCertificate = null;
                NodeUpdateTransactionBody.prototype.grpcCertificateHash = null;
                NodeUpdateTransactionBody.prototype.adminKey = null;
                NodeUpdateTransactionBody.prototype.declineReward = null;
                NodeUpdateTransactionBody.prototype.grpcProxyEndpoint = null;
                NodeUpdateTransactionBody.create = function create(properties) {
                  return new NodeUpdateTransactionBody(properties);
                };
                NodeUpdateTransactionBody.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(8).uint64(m6.nodeId);
                  if (m6.accountId != null && Object.hasOwnProperty.call(m6, "accountId")) $root.proto.AccountID.encode(m6.accountId, w5.uint32(18).fork()).ldelim();
                  if (m6.description != null && Object.hasOwnProperty.call(m6, "description")) $root.google.protobuf.StringValue.encode(m6.description, w5.uint32(26).fork()).ldelim();
                  if (m6.gossipEndpoint != null && m6.gossipEndpoint.length) {
                    for (var i17 = 0; i17 < m6.gossipEndpoint.length; ++i17) $root.proto.ServiceEndpoint.encode(m6.gossipEndpoint[i17], w5.uint32(34).fork()).ldelim();
                  }
                  if (m6.serviceEndpoint != null && m6.serviceEndpoint.length) {
                    for (var i17 = 0; i17 < m6.serviceEndpoint.length; ++i17) $root.proto.ServiceEndpoint.encode(m6.serviceEndpoint[i17], w5.uint32(42).fork()).ldelim();
                  }
                  if (m6.gossipCaCertificate != null && Object.hasOwnProperty.call(m6, "gossipCaCertificate")) $root.google.protobuf.BytesValue.encode(m6.gossipCaCertificate, w5.uint32(50).fork()).ldelim();
                  if (m6.grpcCertificateHash != null && Object.hasOwnProperty.call(m6, "grpcCertificateHash")) $root.google.protobuf.BytesValue.encode(m6.grpcCertificateHash, w5.uint32(58).fork()).ldelim();
                  if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(66).fork()).ldelim();
                  if (m6.declineReward != null && Object.hasOwnProperty.call(m6, "declineReward")) $root.google.protobuf.BoolValue.encode(m6.declineReward, w5.uint32(74).fork()).ldelim();
                  if (m6.grpcProxyEndpoint != null && Object.hasOwnProperty.call(m6, "grpcProxyEndpoint")) $root.proto.ServiceEndpoint.encode(m6.grpcProxyEndpoint, w5.uint32(82).fork()).ldelim();
                  return w5;
                };
                NodeUpdateTransactionBody.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.nodeId = r41.uint64();
                        break;
                      }
                      case 2: {
                        m6.accountId = $root.proto.AccountID.decode(r41, r41.uint32());
                        break;
                      }
                      case 3: {
                        m6.description = $root.google.protobuf.StringValue.decode(r41, r41.uint32());
                        break;
                      }
                      case 4: {
                        if (!(m6.gossipEndpoint && m6.gossipEndpoint.length)) m6.gossipEndpoint = [];
                        m6.gossipEndpoint.push($root.proto.ServiceEndpoint.decode(r41, r41.uint32()));
                        break;
                      }
                      case 5: {
                        if (!(m6.serviceEndpoint && m6.serviceEndpoint.length)) m6.serviceEndpoint = [];
                        m6.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r41, r41.uint32()));
                        break;
                      }
                      case 6: {
                        m6.gossipCaCertificate = $root.google.protobuf.BytesValue.decode(r41, r41.uint32());
                        break;
                      }
                      case 7: {
                        m6.grpcCertificateHash = $root.google.protobuf.BytesValue.decode(r41, r41.uint32());
                        break;
                      }
                      case 8: {
                        m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                        break;
                      }
                      case 9: {
                        m6.declineReward = $root.google.protobuf.BoolValue.decode(r41, r41.uint32());
                        break;
                      }
                      case 10: {
                        m6.grpcProxyEndpoint = $root.proto.ServiceEndpoint.decode(r41, r41.uint32());
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                NodeUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody";
                };
                return NodeUpdateTransactionBody;
              })();
              addressbook.NodeDeleteTransactionBody = (function() {
                function NodeDeleteTransactionBody(p3) {
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                NodeDeleteTransactionBody.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                NodeDeleteTransactionBody.create = function create(properties) {
                  return new NodeDeleteTransactionBody(properties);
                };
                NodeDeleteTransactionBody.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(8).uint64(m6.nodeId);
                  return w5;
                };
                NodeDeleteTransactionBody.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.nodeId = r41.uint64();
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                NodeDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody";
                };
                return NodeDeleteTransactionBody;
              })();
              return addressbook;
            })();
            node.state = (function() {
              const state = {};
              state.hints = (function() {
                const hints = {};
                hints.HintsPartyId = (function() {
                  function HintsPartyId(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HintsPartyId.prototype.partyId = 0;
                  HintsPartyId.prototype.numParties = 0;
                  HintsPartyId.create = function create(properties) {
                    return new HintsPartyId(properties);
                  };
                  HintsPartyId.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.partyId != null && Object.hasOwnProperty.call(m6, "partyId")) w5.uint32(8).uint32(m6.partyId);
                    if (m6.numParties != null && Object.hasOwnProperty.call(m6, "numParties")) w5.uint32(16).uint32(m6.numParties);
                    return w5;
                  };
                  HintsPartyId.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.hints.HintsPartyId();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.partyId = r41.uint32();
                          break;
                        }
                        case 2: {
                          m6.numParties = r41.uint32();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HintsPartyId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.HintsPartyId";
                  };
                  return HintsPartyId;
                })();
                hints.HintsKeySet = (function() {
                  function HintsKeySet(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HintsKeySet.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  HintsKeySet.prototype.adoptionTime = null;
                  HintsKeySet.prototype.key = $util.newBuffer([]);
                  HintsKeySet.prototype.nextKey = $util.newBuffer([]);
                  HintsKeySet.create = function create(properties) {
                    return new HintsKeySet(properties);
                  };
                  HintsKeySet.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(8).uint64(m6.nodeId);
                    if (m6.adoptionTime != null && Object.hasOwnProperty.call(m6, "adoptionTime")) $root.proto.Timestamp.encode(m6.adoptionTime, w5.uint32(18).fork()).ldelim();
                    if (m6.key != null && Object.hasOwnProperty.call(m6, "key")) w5.uint32(26).bytes(m6.key);
                    if (m6.nextKey != null && Object.hasOwnProperty.call(m6, "nextKey")) w5.uint32(34).bytes(m6.nextKey);
                    return w5;
                  };
                  HintsKeySet.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.hints.HintsKeySet();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.nodeId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.adoptionTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                          break;
                        }
                        case 3: {
                          m6.key = r41.bytes();
                          break;
                        }
                        case 4: {
                          m6.nextKey = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HintsKeySet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.HintsKeySet";
                  };
                  return HintsKeySet;
                })();
                hints.PreprocessedKeys = (function() {
                  function PreprocessedKeys(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  PreprocessedKeys.prototype.aggregationKey = $util.newBuffer([]);
                  PreprocessedKeys.prototype.verificationKey = $util.newBuffer([]);
                  PreprocessedKeys.create = function create(properties) {
                    return new PreprocessedKeys(properties);
                  };
                  PreprocessedKeys.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.aggregationKey != null && Object.hasOwnProperty.call(m6, "aggregationKey")) w5.uint32(10).bytes(m6.aggregationKey);
                    if (m6.verificationKey != null && Object.hasOwnProperty.call(m6, "verificationKey")) w5.uint32(18).bytes(m6.verificationKey);
                    return w5;
                  };
                  PreprocessedKeys.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.hints.PreprocessedKeys();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.aggregationKey = r41.bytes();
                          break;
                        }
                        case 2: {
                          m6.verificationKey = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  PreprocessedKeys.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.PreprocessedKeys";
                  };
                  return PreprocessedKeys;
                })();
                hints.PreprocessingVoteId = (function() {
                  function PreprocessingVoteId(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  PreprocessingVoteId.prototype.constructionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  PreprocessingVoteId.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  PreprocessingVoteId.create = function create(properties) {
                    return new PreprocessingVoteId(properties);
                  };
                  PreprocessingVoteId.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.constructionId != null && Object.hasOwnProperty.call(m6, "constructionId")) w5.uint32(8).uint64(m6.constructionId);
                    if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(16).uint64(m6.nodeId);
                    return w5;
                  };
                  PreprocessingVoteId.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.hints.PreprocessingVoteId();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.constructionId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.nodeId = r41.uint64();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  PreprocessingVoteId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.PreprocessingVoteId";
                  };
                  return PreprocessingVoteId;
                })();
                hints.PreprocessingVote = (function() {
                  function PreprocessingVote(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  PreprocessingVote.prototype.preprocessedKeys = null;
                  PreprocessingVote.prototype.congruentNodeId = null;
                  let $oneOfFields;
                  Object.defineProperty(PreprocessingVote.prototype, "vote", { get: $util.oneOfGetter($oneOfFields = ["preprocessedKeys", "congruentNodeId"]), set: $util.oneOfSetter($oneOfFields) });
                  PreprocessingVote.create = function create(properties) {
                    return new PreprocessingVote(properties);
                  };
                  PreprocessingVote.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.preprocessedKeys != null && Object.hasOwnProperty.call(m6, "preprocessedKeys")) $root.com.hedera.hapi.node.state.hints.PreprocessedKeys.encode(m6.preprocessedKeys, w5.uint32(10).fork()).ldelim();
                    if (m6.congruentNodeId != null && Object.hasOwnProperty.call(m6, "congruentNodeId")) w5.uint32(16).uint64(m6.congruentNodeId);
                    return w5;
                  };
                  PreprocessingVote.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.hints.PreprocessingVote();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.preprocessedKeys = $root.com.hedera.hapi.node.state.hints.PreprocessedKeys.decode(r41, r41.uint32());
                          break;
                        }
                        case 2: {
                          m6.congruentNodeId = r41.uint64();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  PreprocessingVote.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.PreprocessingVote";
                  };
                  return PreprocessingVote;
                })();
                hints.NodePartyId = (function() {
                  function NodePartyId(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  NodePartyId.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  NodePartyId.prototype.partyId = 0;
                  NodePartyId.prototype.partyWeight = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  NodePartyId.create = function create(properties) {
                    return new NodePartyId(properties);
                  };
                  NodePartyId.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(8).uint64(m6.nodeId);
                    if (m6.partyId != null && Object.hasOwnProperty.call(m6, "partyId")) w5.uint32(16).uint32(m6.partyId);
                    if (m6.partyWeight != null && Object.hasOwnProperty.call(m6, "partyWeight")) w5.uint32(24).uint64(m6.partyWeight);
                    return w5;
                  };
                  NodePartyId.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.hints.NodePartyId();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.nodeId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.partyId = r41.uint32();
                          break;
                        }
                        case 3: {
                          m6.partyWeight = r41.uint64();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  NodePartyId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.NodePartyId";
                  };
                  return NodePartyId;
                })();
                hints.HintsScheme = (function() {
                  function HintsScheme(p3) {
                    this.nodePartyIds = [];
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HintsScheme.prototype.preprocessedKeys = null;
                  HintsScheme.prototype.nodePartyIds = $util.emptyArray;
                  HintsScheme.create = function create(properties) {
                    return new HintsScheme(properties);
                  };
                  HintsScheme.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.preprocessedKeys != null && Object.hasOwnProperty.call(m6, "preprocessedKeys")) $root.com.hedera.hapi.node.state.hints.PreprocessedKeys.encode(m6.preprocessedKeys, w5.uint32(10).fork()).ldelim();
                    if (m6.nodePartyIds != null && m6.nodePartyIds.length) {
                      for (var i17 = 0; i17 < m6.nodePartyIds.length; ++i17) $root.com.hedera.hapi.node.state.hints.NodePartyId.encode(m6.nodePartyIds[i17], w5.uint32(18).fork()).ldelim();
                    }
                    return w5;
                  };
                  HintsScheme.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.hints.HintsScheme();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.preprocessedKeys = $root.com.hedera.hapi.node.state.hints.PreprocessedKeys.decode(r41, r41.uint32());
                          break;
                        }
                        case 2: {
                          if (!(m6.nodePartyIds && m6.nodePartyIds.length)) m6.nodePartyIds = [];
                          m6.nodePartyIds.push($root.com.hedera.hapi.node.state.hints.NodePartyId.decode(r41, r41.uint32()));
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HintsScheme.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.HintsScheme";
                  };
                  return HintsScheme;
                })();
                hints.HintsConstruction = (function() {
                  function HintsConstruction(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HintsConstruction.prototype.constructionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  HintsConstruction.prototype.sourceRosterHash = $util.newBuffer([]);
                  HintsConstruction.prototype.targetRosterHash = $util.newBuffer([]);
                  HintsConstruction.prototype.gracePeriodEndTime = null;
                  HintsConstruction.prototype.preprocessingStartTime = null;
                  HintsConstruction.prototype.hintsScheme = null;
                  let $oneOfFields;
                  Object.defineProperty(HintsConstruction.prototype, "preprocessingState", { get: $util.oneOfGetter($oneOfFields = ["gracePeriodEndTime", "preprocessingStartTime", "hintsScheme"]), set: $util.oneOfSetter($oneOfFields) });
                  HintsConstruction.create = function create(properties) {
                    return new HintsConstruction(properties);
                  };
                  HintsConstruction.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.constructionId != null && Object.hasOwnProperty.call(m6, "constructionId")) w5.uint32(8).uint64(m6.constructionId);
                    if (m6.sourceRosterHash != null && Object.hasOwnProperty.call(m6, "sourceRosterHash")) w5.uint32(18).bytes(m6.sourceRosterHash);
                    if (m6.targetRosterHash != null && Object.hasOwnProperty.call(m6, "targetRosterHash")) w5.uint32(26).bytes(m6.targetRosterHash);
                    if (m6.gracePeriodEndTime != null && Object.hasOwnProperty.call(m6, "gracePeriodEndTime")) $root.proto.Timestamp.encode(m6.gracePeriodEndTime, w5.uint32(34).fork()).ldelim();
                    if (m6.preprocessingStartTime != null && Object.hasOwnProperty.call(m6, "preprocessingStartTime")) $root.proto.Timestamp.encode(m6.preprocessingStartTime, w5.uint32(42).fork()).ldelim();
                    if (m6.hintsScheme != null && Object.hasOwnProperty.call(m6, "hintsScheme")) $root.com.hedera.hapi.node.state.hints.HintsScheme.encode(m6.hintsScheme, w5.uint32(50).fork()).ldelim();
                    return w5;
                  };
                  HintsConstruction.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.hints.HintsConstruction();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.constructionId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.sourceRosterHash = r41.bytes();
                          break;
                        }
                        case 3: {
                          m6.targetRosterHash = r41.bytes();
                          break;
                        }
                        case 4: {
                          m6.gracePeriodEndTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                          break;
                        }
                        case 5: {
                          m6.preprocessingStartTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                          break;
                        }
                        case 6: {
                          m6.hintsScheme = $root.com.hedera.hapi.node.state.hints.HintsScheme.decode(r41, r41.uint32());
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HintsConstruction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.HintsConstruction";
                  };
                  return HintsConstruction;
                })();
                hints.CRSStage = (function() {
                  const valuesById = {}, values = Object.create(valuesById);
                  values[valuesById[0] = "GATHERING_CONTRIBUTIONS"] = 0;
                  values[valuesById[1] = "WAITING_FOR_ADOPTING_FINAL_CRS"] = 1;
                  values[valuesById[2] = "COMPLETED"] = 2;
                  return values;
                })();
                hints.CRSState = (function() {
                  function CRSState(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  CRSState.prototype.crs = $util.newBuffer([]);
                  CRSState.prototype.stage = 0;
                  CRSState.prototype.nextContributingNodeId = null;
                  CRSState.prototype.contributionEndTime = null;
                  CRSState.create = function create(properties) {
                    return new CRSState(properties);
                  };
                  CRSState.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.crs != null && Object.hasOwnProperty.call(m6, "crs")) w5.uint32(10).bytes(m6.crs);
                    if (m6.stage != null && Object.hasOwnProperty.call(m6, "stage")) w5.uint32(16).int32(m6.stage);
                    if (m6.nextContributingNodeId != null && Object.hasOwnProperty.call(m6, "nextContributingNodeId")) $root.google.protobuf.UInt64Value.encode(m6.nextContributingNodeId, w5.uint32(26).fork()).ldelim();
                    if (m6.contributionEndTime != null && Object.hasOwnProperty.call(m6, "contributionEndTime")) $root.proto.Timestamp.encode(m6.contributionEndTime, w5.uint32(34).fork()).ldelim();
                    return w5;
                  };
                  CRSState.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.hints.CRSState();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.crs = r41.bytes();
                          break;
                        }
                        case 2: {
                          m6.stage = r41.int32();
                          break;
                        }
                        case 3: {
                          m6.nextContributingNodeId = $root.google.protobuf.UInt64Value.decode(r41, r41.uint32());
                          break;
                        }
                        case 4: {
                          m6.contributionEndTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  CRSState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.hints.CRSState";
                  };
                  return CRSState;
                })();
                return hints;
              })();
              state.history = (function() {
                const history = {};
                history.ProofKeySet = (function() {
                  function ProofKeySet(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  ProofKeySet.prototype.adoptionTime = null;
                  ProofKeySet.prototype.key = $util.newBuffer([]);
                  ProofKeySet.prototype.nextKey = $util.newBuffer([]);
                  ProofKeySet.create = function create(properties) {
                    return new ProofKeySet(properties);
                  };
                  ProofKeySet.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.adoptionTime != null && Object.hasOwnProperty.call(m6, "adoptionTime")) $root.proto.Timestamp.encode(m6.adoptionTime, w5.uint32(18).fork()).ldelim();
                    if (m6.key != null && Object.hasOwnProperty.call(m6, "key")) w5.uint32(26).bytes(m6.key);
                    if (m6.nextKey != null && Object.hasOwnProperty.call(m6, "nextKey")) w5.uint32(34).bytes(m6.nextKey);
                    return w5;
                  };
                  ProofKeySet.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.history.ProofKeySet();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 2: {
                          m6.adoptionTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                          break;
                        }
                        case 3: {
                          m6.key = r41.bytes();
                          break;
                        }
                        case 4: {
                          m6.nextKey = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  ProofKeySet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.history.ProofKeySet";
                  };
                  return ProofKeySet;
                })();
                history.ProofKey = (function() {
                  function ProofKey(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  ProofKey.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  ProofKey.prototype.key = $util.newBuffer([]);
                  ProofKey.create = function create(properties) {
                    return new ProofKey(properties);
                  };
                  ProofKey.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(8).uint64(m6.nodeId);
                    if (m6.key != null && Object.hasOwnProperty.call(m6, "key")) w5.uint32(18).bytes(m6.key);
                    return w5;
                  };
                  ProofKey.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.history.ProofKey();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.nodeId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.key = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  ProofKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.history.ProofKey";
                  };
                  return ProofKey;
                })();
                history.History = (function() {
                  function History(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  History.prototype.addressBookHash = $util.newBuffer([]);
                  History.prototype.metadata = $util.newBuffer([]);
                  History.create = function create(properties) {
                    return new History(properties);
                  };
                  History.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.addressBookHash != null && Object.hasOwnProperty.call(m6, "addressBookHash")) w5.uint32(10).bytes(m6.addressBookHash);
                    if (m6.metadata != null && Object.hasOwnProperty.call(m6, "metadata")) w5.uint32(18).bytes(m6.metadata);
                    return w5;
                  };
                  History.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.history.History();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.addressBookHash = r41.bytes();
                          break;
                        }
                        case 2: {
                          m6.metadata = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  History.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.history.History";
                  };
                  return History;
                })();
                history.HistoryProof = (function() {
                  function HistoryProof(p3) {
                    this.targetProofKeys = [];
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HistoryProof.prototype.sourceAddressBookHash = $util.newBuffer([]);
                  HistoryProof.prototype.targetProofKeys = $util.emptyArray;
                  HistoryProof.prototype.targetHistory = null;
                  HistoryProof.prototype.proof = $util.newBuffer([]);
                  HistoryProof.create = function create(properties) {
                    return new HistoryProof(properties);
                  };
                  HistoryProof.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.sourceAddressBookHash != null && Object.hasOwnProperty.call(m6, "sourceAddressBookHash")) w5.uint32(10).bytes(m6.sourceAddressBookHash);
                    if (m6.targetProofKeys != null && m6.targetProofKeys.length) {
                      for (var i17 = 0; i17 < m6.targetProofKeys.length; ++i17) $root.com.hedera.hapi.node.state.history.ProofKey.encode(m6.targetProofKeys[i17], w5.uint32(18).fork()).ldelim();
                    }
                    if (m6.targetHistory != null && Object.hasOwnProperty.call(m6, "targetHistory")) $root.com.hedera.hapi.node.state.history.History.encode(m6.targetHistory, w5.uint32(26).fork()).ldelim();
                    if (m6.proof != null && Object.hasOwnProperty.call(m6, "proof")) w5.uint32(34).bytes(m6.proof);
                    return w5;
                  };
                  HistoryProof.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.history.HistoryProof();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.sourceAddressBookHash = r41.bytes();
                          break;
                        }
                        case 2: {
                          if (!(m6.targetProofKeys && m6.targetProofKeys.length)) m6.targetProofKeys = [];
                          m6.targetProofKeys.push($root.com.hedera.hapi.node.state.history.ProofKey.decode(r41, r41.uint32()));
                          break;
                        }
                        case 3: {
                          m6.targetHistory = $root.com.hedera.hapi.node.state.history.History.decode(r41, r41.uint32());
                          break;
                        }
                        case 4: {
                          m6.proof = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HistoryProof.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.history.HistoryProof";
                  };
                  return HistoryProof;
                })();
                history.HistoryProofConstruction = (function() {
                  function HistoryProofConstruction(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HistoryProofConstruction.prototype.constructionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  HistoryProofConstruction.prototype.sourceRosterHash = $util.newBuffer([]);
                  HistoryProofConstruction.prototype.sourceProof = null;
                  HistoryProofConstruction.prototype.targetRosterHash = $util.newBuffer([]);
                  HistoryProofConstruction.prototype.gracePeriodEndTime = null;
                  HistoryProofConstruction.prototype.assemblyStartTime = null;
                  HistoryProofConstruction.prototype.targetProof = null;
                  HistoryProofConstruction.prototype.failureReason = null;
                  let $oneOfFields;
                  Object.defineProperty(HistoryProofConstruction.prototype, "proofState", { get: $util.oneOfGetter($oneOfFields = ["gracePeriodEndTime", "assemblyStartTime", "targetProof", "failureReason"]), set: $util.oneOfSetter($oneOfFields) });
                  HistoryProofConstruction.create = function create(properties) {
                    return new HistoryProofConstruction(properties);
                  };
                  HistoryProofConstruction.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.constructionId != null && Object.hasOwnProperty.call(m6, "constructionId")) w5.uint32(8).uint64(m6.constructionId);
                    if (m6.sourceRosterHash != null && Object.hasOwnProperty.call(m6, "sourceRosterHash")) w5.uint32(18).bytes(m6.sourceRosterHash);
                    if (m6.sourceProof != null && Object.hasOwnProperty.call(m6, "sourceProof")) $root.com.hedera.hapi.node.state.history.HistoryProof.encode(m6.sourceProof, w5.uint32(26).fork()).ldelim();
                    if (m6.targetRosterHash != null && Object.hasOwnProperty.call(m6, "targetRosterHash")) w5.uint32(34).bytes(m6.targetRosterHash);
                    if (m6.gracePeriodEndTime != null && Object.hasOwnProperty.call(m6, "gracePeriodEndTime")) $root.proto.Timestamp.encode(m6.gracePeriodEndTime, w5.uint32(42).fork()).ldelim();
                    if (m6.assemblyStartTime != null && Object.hasOwnProperty.call(m6, "assemblyStartTime")) $root.proto.Timestamp.encode(m6.assemblyStartTime, w5.uint32(50).fork()).ldelim();
                    if (m6.targetProof != null && Object.hasOwnProperty.call(m6, "targetProof")) $root.com.hedera.hapi.node.state.history.HistoryProof.encode(m6.targetProof, w5.uint32(58).fork()).ldelim();
                    if (m6.failureReason != null && Object.hasOwnProperty.call(m6, "failureReason")) w5.uint32(66).string(m6.failureReason);
                    return w5;
                  };
                  HistoryProofConstruction.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.history.HistoryProofConstruction();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.constructionId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.sourceRosterHash = r41.bytes();
                          break;
                        }
                        case 3: {
                          m6.sourceProof = $root.com.hedera.hapi.node.state.history.HistoryProof.decode(r41, r41.uint32());
                          break;
                        }
                        case 4: {
                          m6.targetRosterHash = r41.bytes();
                          break;
                        }
                        case 5: {
                          m6.gracePeriodEndTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                          break;
                        }
                        case 6: {
                          m6.assemblyStartTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                          break;
                        }
                        case 7: {
                          m6.targetProof = $root.com.hedera.hapi.node.state.history.HistoryProof.decode(r41, r41.uint32());
                          break;
                        }
                        case 8: {
                          m6.failureReason = r41.string();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HistoryProofConstruction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.history.HistoryProofConstruction";
                  };
                  return HistoryProofConstruction;
                })();
                history.ConstructionNodeId = (function() {
                  function ConstructionNodeId(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  ConstructionNodeId.prototype.constructionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  ConstructionNodeId.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  ConstructionNodeId.create = function create(properties) {
                    return new ConstructionNodeId(properties);
                  };
                  ConstructionNodeId.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.constructionId != null && Object.hasOwnProperty.call(m6, "constructionId")) w5.uint32(8).uint64(m6.constructionId);
                    if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(16).uint64(m6.nodeId);
                    return w5;
                  };
                  ConstructionNodeId.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.history.ConstructionNodeId();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.constructionId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.nodeId = r41.uint64();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  ConstructionNodeId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.history.ConstructionNodeId";
                  };
                  return ConstructionNodeId;
                })();
                history.HistoryProofVote = (function() {
                  function HistoryProofVote(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HistoryProofVote.prototype.proof = null;
                  HistoryProofVote.prototype.congruentNodeId = null;
                  let $oneOfFields;
                  Object.defineProperty(HistoryProofVote.prototype, "vote", { get: $util.oneOfGetter($oneOfFields = ["proof", "congruentNodeId"]), set: $util.oneOfSetter($oneOfFields) });
                  HistoryProofVote.create = function create(properties) {
                    return new HistoryProofVote(properties);
                  };
                  HistoryProofVote.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.proof != null && Object.hasOwnProperty.call(m6, "proof")) $root.com.hedera.hapi.node.state.history.HistoryProof.encode(m6.proof, w5.uint32(10).fork()).ldelim();
                    if (m6.congruentNodeId != null && Object.hasOwnProperty.call(m6, "congruentNodeId")) w5.uint32(16).uint64(m6.congruentNodeId);
                    return w5;
                  };
                  HistoryProofVote.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.history.HistoryProofVote();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.proof = $root.com.hedera.hapi.node.state.history.HistoryProof.decode(r41, r41.uint32());
                          break;
                        }
                        case 2: {
                          m6.congruentNodeId = r41.uint64();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HistoryProofVote.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.history.HistoryProofVote";
                  };
                  return HistoryProofVote;
                })();
                history.HistorySignature = (function() {
                  function HistorySignature(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HistorySignature.prototype.history = null;
                  HistorySignature.prototype.signature = $util.newBuffer([]);
                  HistorySignature.create = function create(properties) {
                    return new HistorySignature(properties);
                  };
                  HistorySignature.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.history != null && Object.hasOwnProperty.call(m6, "history")) $root.com.hedera.hapi.node.state.history.History.encode(m6.history, w5.uint32(10).fork()).ldelim();
                    if (m6.signature != null && Object.hasOwnProperty.call(m6, "signature")) w5.uint32(18).bytes(m6.signature);
                    return w5;
                  };
                  HistorySignature.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.history.HistorySignature();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.history = $root.com.hedera.hapi.node.state.history.History.decode(r41, r41.uint32());
                          break;
                        }
                        case 2: {
                          m6.signature = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HistorySignature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.history.HistorySignature";
                  };
                  return HistorySignature;
                })();
                history.RecordedHistorySignature = (function() {
                  function RecordedHistorySignature(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  RecordedHistorySignature.prototype.signingTime = null;
                  RecordedHistorySignature.prototype.historySignature = null;
                  RecordedHistorySignature.create = function create(properties) {
                    return new RecordedHistorySignature(properties);
                  };
                  RecordedHistorySignature.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.signingTime != null && Object.hasOwnProperty.call(m6, "signingTime")) $root.proto.Timestamp.encode(m6.signingTime, w5.uint32(10).fork()).ldelim();
                    if (m6.historySignature != null && Object.hasOwnProperty.call(m6, "historySignature")) $root.com.hedera.hapi.node.state.history.HistorySignature.encode(m6.historySignature, w5.uint32(18).fork()).ldelim();
                    return w5;
                  };
                  RecordedHistorySignature.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.node.state.history.RecordedHistorySignature();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.signingTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                          break;
                        }
                        case 2: {
                          m6.historySignature = $root.com.hedera.hapi.node.state.history.HistorySignature.decode(r41, r41.uint32());
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  RecordedHistorySignature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.node.state.history.RecordedHistorySignature";
                  };
                  return RecordedHistorySignature;
                })();
                return history;
              })();
              return state;
            })();
            return node;
          })();
          hapi.services = (function() {
            const services = {};
            services.auxiliary = (function() {
              const auxiliary = {};
              auxiliary.hints = (function() {
                const hints = {};
                hints.HintsKeyPublicationTransactionBody = (function() {
                  function HintsKeyPublicationTransactionBody(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HintsKeyPublicationTransactionBody.prototype.partyId = 0;
                  HintsKeyPublicationTransactionBody.prototype.numParties = 0;
                  HintsKeyPublicationTransactionBody.prototype.hintsKey = $util.newBuffer([]);
                  HintsKeyPublicationTransactionBody.create = function create(properties) {
                    return new HintsKeyPublicationTransactionBody(properties);
                  };
                  HintsKeyPublicationTransactionBody.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.partyId != null && Object.hasOwnProperty.call(m6, "partyId")) w5.uint32(8).uint32(m6.partyId);
                    if (m6.numParties != null && Object.hasOwnProperty.call(m6, "numParties")) w5.uint32(16).uint32(m6.numParties);
                    if (m6.hintsKey != null && Object.hasOwnProperty.call(m6, "hintsKey")) w5.uint32(26).bytes(m6.hintsKey);
                    return w5;
                  };
                  HintsKeyPublicationTransactionBody.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.partyId = r41.uint32();
                          break;
                        }
                        case 2: {
                          m6.numParties = r41.uint32();
                          break;
                        }
                        case 3: {
                          m6.hintsKey = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HintsKeyPublicationTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody";
                  };
                  return HintsKeyPublicationTransactionBody;
                })();
                hints.HintsPreprocessingVoteTransactionBody = (function() {
                  function HintsPreprocessingVoteTransactionBody(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HintsPreprocessingVoteTransactionBody.prototype.constructionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  HintsPreprocessingVoteTransactionBody.prototype.vote = null;
                  HintsPreprocessingVoteTransactionBody.create = function create(properties) {
                    return new HintsPreprocessingVoteTransactionBody(properties);
                  };
                  HintsPreprocessingVoteTransactionBody.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.constructionId != null && Object.hasOwnProperty.call(m6, "constructionId")) w5.uint32(8).uint64(m6.constructionId);
                    if (m6.vote != null && Object.hasOwnProperty.call(m6, "vote")) $root.com.hedera.hapi.node.state.hints.PreprocessingVote.encode(m6.vote, w5.uint32(18).fork()).ldelim();
                    return w5;
                  };
                  HintsPreprocessingVoteTransactionBody.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.constructionId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.vote = $root.com.hedera.hapi.node.state.hints.PreprocessingVote.decode(r41, r41.uint32());
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HintsPreprocessingVoteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody";
                  };
                  return HintsPreprocessingVoteTransactionBody;
                })();
                hints.HintsPartialSignatureTransactionBody = (function() {
                  function HintsPartialSignatureTransactionBody(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HintsPartialSignatureTransactionBody.prototype.constructionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  HintsPartialSignatureTransactionBody.prototype.message = $util.newBuffer([]);
                  HintsPartialSignatureTransactionBody.prototype.partialSignature = $util.newBuffer([]);
                  HintsPartialSignatureTransactionBody.create = function create(properties) {
                    return new HintsPartialSignatureTransactionBody(properties);
                  };
                  HintsPartialSignatureTransactionBody.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.constructionId != null && Object.hasOwnProperty.call(m6, "constructionId")) w5.uint32(8).uint64(m6.constructionId);
                    if (m6.message != null && Object.hasOwnProperty.call(m6, "message")) w5.uint32(18).bytes(m6.message);
                    if (m6.partialSignature != null && Object.hasOwnProperty.call(m6, "partialSignature")) w5.uint32(26).bytes(m6.partialSignature);
                    return w5;
                  };
                  HintsPartialSignatureTransactionBody.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.constructionId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.message = r41.bytes();
                          break;
                        }
                        case 3: {
                          m6.partialSignature = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HintsPartialSignatureTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody";
                  };
                  return HintsPartialSignatureTransactionBody;
                })();
                hints.CrsPublicationTransactionBody = (function() {
                  function CrsPublicationTransactionBody(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  CrsPublicationTransactionBody.prototype.newCrs = $util.newBuffer([]);
                  CrsPublicationTransactionBody.prototype.proof = $util.newBuffer([]);
                  CrsPublicationTransactionBody.create = function create(properties) {
                    return new CrsPublicationTransactionBody(properties);
                  };
                  CrsPublicationTransactionBody.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.newCrs != null && Object.hasOwnProperty.call(m6, "newCrs")) w5.uint32(10).bytes(m6.newCrs);
                    if (m6.proof != null && Object.hasOwnProperty.call(m6, "proof")) w5.uint32(18).bytes(m6.proof);
                    return w5;
                  };
                  CrsPublicationTransactionBody.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.newCrs = r41.bytes();
                          break;
                        }
                        case 2: {
                          m6.proof = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  CrsPublicationTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody";
                  };
                  return CrsPublicationTransactionBody;
                })();
                return hints;
              })();
              auxiliary.history = (function() {
                const history = {};
                history.HistoryProofSignatureTransactionBody = (function() {
                  function HistoryProofSignatureTransactionBody(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HistoryProofSignatureTransactionBody.prototype.constructionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  HistoryProofSignatureTransactionBody.prototype.signature = null;
                  HistoryProofSignatureTransactionBody.create = function create(properties) {
                    return new HistoryProofSignatureTransactionBody(properties);
                  };
                  HistoryProofSignatureTransactionBody.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.constructionId != null && Object.hasOwnProperty.call(m6, "constructionId")) w5.uint32(8).uint64(m6.constructionId);
                    if (m6.signature != null && Object.hasOwnProperty.call(m6, "signature")) $root.com.hedera.hapi.node.state.history.HistorySignature.encode(m6.signature, w5.uint32(18).fork()).ldelim();
                    return w5;
                  };
                  HistoryProofSignatureTransactionBody.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.constructionId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.signature = $root.com.hedera.hapi.node.state.history.HistorySignature.decode(r41, r41.uint32());
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HistoryProofSignatureTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody";
                  };
                  return HistoryProofSignatureTransactionBody;
                })();
                history.HistoryProofKeyPublicationTransactionBody = (function() {
                  function HistoryProofKeyPublicationTransactionBody(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HistoryProofKeyPublicationTransactionBody.prototype.proofKey = $util.newBuffer([]);
                  HistoryProofKeyPublicationTransactionBody.create = function create(properties) {
                    return new HistoryProofKeyPublicationTransactionBody(properties);
                  };
                  HistoryProofKeyPublicationTransactionBody.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.proofKey != null && Object.hasOwnProperty.call(m6, "proofKey")) w5.uint32(10).bytes(m6.proofKey);
                    return w5;
                  };
                  HistoryProofKeyPublicationTransactionBody.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.proofKey = r41.bytes();
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HistoryProofKeyPublicationTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody";
                  };
                  return HistoryProofKeyPublicationTransactionBody;
                })();
                history.HistoryProofVoteTransactionBody = (function() {
                  function HistoryProofVoteTransactionBody(p3) {
                    if (p3) {
                      for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                    }
                  }
                  HistoryProofVoteTransactionBody.prototype.constructionId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                  HistoryProofVoteTransactionBody.prototype.vote = null;
                  HistoryProofVoteTransactionBody.create = function create(properties) {
                    return new HistoryProofVoteTransactionBody(properties);
                  };
                  HistoryProofVoteTransactionBody.encode = function encode5(m6, w5) {
                    if (!w5) w5 = $Writer.create();
                    if (m6.constructionId != null && Object.hasOwnProperty.call(m6, "constructionId")) w5.uint32(8).uint64(m6.constructionId);
                    if (m6.vote != null && Object.hasOwnProperty.call(m6, "vote")) $root.com.hedera.hapi.node.state.history.HistoryProofVote.encode(m6.vote, w5.uint32(18).fork()).ldelim();
                    return w5;
                  };
                  HistoryProofVoteTransactionBody.decode = function decode7(r41, l19) {
                    if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                    var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody();
                    while (r41.pos < c17) {
                      var t35 = r41.uint32();
                      switch (t35 >>> 3) {
                        case 1: {
                          m6.constructionId = r41.uint64();
                          break;
                        }
                        case 2: {
                          m6.vote = $root.com.hedera.hapi.node.state.history.HistoryProofVote.decode(r41, r41.uint32());
                          break;
                        }
                        default:
                          r41.skipType(t35 & 7);
                          break;
                      }
                    }
                    return m6;
                  };
                  HistoryProofVoteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === void 0) {
                      typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody";
                  };
                  return HistoryProofVoteTransactionBody;
                })();
                return history;
              })();
              return auxiliary;
            })();
            return services;
          })();
          hapi.platform = (function() {
            const platform = {};
            platform.event = (function() {
              const event = {};
              event.EventConsensusData = (function() {
                function EventConsensusData(p3) {
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                EventConsensusData.prototype.consensusTimestamp = null;
                EventConsensusData.prototype.consensusOrder = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
                EventConsensusData.create = function create(properties) {
                  return new EventConsensusData(properties);
                };
                EventConsensusData.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.consensusTimestamp != null && Object.hasOwnProperty.call(m6, "consensusTimestamp")) $root.proto.Timestamp.encode(m6.consensusTimestamp, w5.uint32(10).fork()).ldelim();
                  if (m6.consensusOrder != null && Object.hasOwnProperty.call(m6, "consensusOrder")) w5.uint32(16).uint64(m6.consensusOrder);
                  return w5;
                };
                EventConsensusData.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.platform.event.EventConsensusData();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.consensusTimestamp = $root.proto.Timestamp.decode(r41, r41.uint32());
                        break;
                      }
                      case 2: {
                        m6.consensusOrder = r41.uint64();
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                EventConsensusData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.hapi.platform.event.EventConsensusData";
                };
                return EventConsensusData;
              })();
              event.EventCore = (function() {
                function EventCore(p3) {
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                EventCore.prototype.creatorNodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                EventCore.prototype.birthRound = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                EventCore.prototype.timeCreated = null;
                EventCore.create = function create(properties) {
                  return new EventCore(properties);
                };
                EventCore.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.creatorNodeId != null && Object.hasOwnProperty.call(m6, "creatorNodeId")) w5.uint32(8).int64(m6.creatorNodeId);
                  if (m6.birthRound != null && Object.hasOwnProperty.call(m6, "birthRound")) w5.uint32(16).int64(m6.birthRound);
                  if (m6.timeCreated != null && Object.hasOwnProperty.call(m6, "timeCreated")) $root.proto.Timestamp.encode(m6.timeCreated, w5.uint32(26).fork()).ldelim();
                  return w5;
                };
                EventCore.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.platform.event.EventCore();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.creatorNodeId = r41.int64();
                        break;
                      }
                      case 2: {
                        m6.birthRound = r41.int64();
                        break;
                      }
                      case 3: {
                        m6.timeCreated = $root.proto.Timestamp.decode(r41, r41.uint32());
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                EventCore.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.hapi.platform.event.EventCore";
                };
                return EventCore;
              })();
              event.EventDescriptor = (function() {
                function EventDescriptor(p3) {
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                EventDescriptor.prototype.hash = $util.newBuffer([]);
                EventDescriptor.prototype.creatorNodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                EventDescriptor.prototype.birthRound = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                EventDescriptor.create = function create(properties) {
                  return new EventDescriptor(properties);
                };
                EventDescriptor.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.hash != null && Object.hasOwnProperty.call(m6, "hash")) w5.uint32(10).bytes(m6.hash);
                  if (m6.creatorNodeId != null && Object.hasOwnProperty.call(m6, "creatorNodeId")) w5.uint32(16).int64(m6.creatorNodeId);
                  if (m6.birthRound != null && Object.hasOwnProperty.call(m6, "birthRound")) w5.uint32(24).int64(m6.birthRound);
                  return w5;
                };
                EventDescriptor.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.platform.event.EventDescriptor();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.hash = r41.bytes();
                        break;
                      }
                      case 2: {
                        m6.creatorNodeId = r41.int64();
                        break;
                      }
                      case 3: {
                        m6.birthRound = r41.int64();
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                EventDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.hapi.platform.event.EventDescriptor";
                };
                return EventDescriptor;
              })();
              event.EventTransaction = (function() {
                function EventTransaction(p3) {
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                EventTransaction.prototype.applicationTransaction = null;
                EventTransaction.prototype.stateSignatureTransaction = null;
                let $oneOfFields;
                Object.defineProperty(EventTransaction.prototype, "transaction", { get: $util.oneOfGetter($oneOfFields = ["applicationTransaction", "stateSignatureTransaction"]), set: $util.oneOfSetter($oneOfFields) });
                EventTransaction.create = function create(properties) {
                  return new EventTransaction(properties);
                };
                EventTransaction.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.applicationTransaction != null && Object.hasOwnProperty.call(m6, "applicationTransaction")) w5.uint32(10).bytes(m6.applicationTransaction);
                  if (m6.stateSignatureTransaction != null && Object.hasOwnProperty.call(m6, "stateSignatureTransaction")) $root.com.hedera.hapi.platform.event.StateSignatureTransaction.encode(m6.stateSignatureTransaction, w5.uint32(18).fork()).ldelim();
                  return w5;
                };
                EventTransaction.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.platform.event.EventTransaction();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.applicationTransaction = r41.bytes();
                        break;
                      }
                      case 2: {
                        m6.stateSignatureTransaction = $root.com.hedera.hapi.platform.event.StateSignatureTransaction.decode(r41, r41.uint32());
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                EventTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.hapi.platform.event.EventTransaction";
                };
                return EventTransaction;
              })();
              event.GossipEvent = (function() {
                function GossipEvent(p3) {
                  this.transactions = [];
                  this.parents = [];
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                GossipEvent.prototype.eventCore = null;
                GossipEvent.prototype.signature = $util.newBuffer([]);
                GossipEvent.prototype.transactions = $util.emptyArray;
                GossipEvent.prototype.parents = $util.emptyArray;
                GossipEvent.create = function create(properties) {
                  return new GossipEvent(properties);
                };
                GossipEvent.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.eventCore != null && Object.hasOwnProperty.call(m6, "eventCore")) $root.com.hedera.hapi.platform.event.EventCore.encode(m6.eventCore, w5.uint32(10).fork()).ldelim();
                  if (m6.signature != null && Object.hasOwnProperty.call(m6, "signature")) w5.uint32(18).bytes(m6.signature);
                  if (m6.transactions != null && m6.transactions.length) {
                    for (var i17 = 0; i17 < m6.transactions.length; ++i17) w5.uint32(34).bytes(m6.transactions[i17]);
                  }
                  if (m6.parents != null && m6.parents.length) {
                    for (var i17 = 0; i17 < m6.parents.length; ++i17) $root.com.hedera.hapi.platform.event.EventDescriptor.encode(m6.parents[i17], w5.uint32(42).fork()).ldelim();
                  }
                  return w5;
                };
                GossipEvent.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.platform.event.GossipEvent();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.eventCore = $root.com.hedera.hapi.platform.event.EventCore.decode(r41, r41.uint32());
                        break;
                      }
                      case 2: {
                        m6.signature = r41.bytes();
                        break;
                      }
                      case 4: {
                        if (!(m6.transactions && m6.transactions.length)) m6.transactions = [];
                        m6.transactions.push(r41.bytes());
                        break;
                      }
                      case 5: {
                        if (!(m6.parents && m6.parents.length)) m6.parents = [];
                        m6.parents.push($root.com.hedera.hapi.platform.event.EventDescriptor.decode(r41, r41.uint32()));
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                GossipEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.hapi.platform.event.GossipEvent";
                };
                return GossipEvent;
              })();
              event.StateSignatureTransaction = (function() {
                function StateSignatureTransaction(p3) {
                  if (p3) {
                    for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
                  }
                }
                StateSignatureTransaction.prototype.round = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
                StateSignatureTransaction.prototype.signature = $util.newBuffer([]);
                StateSignatureTransaction.prototype.hash = $util.newBuffer([]);
                StateSignatureTransaction.create = function create(properties) {
                  return new StateSignatureTransaction(properties);
                };
                StateSignatureTransaction.encode = function encode5(m6, w5) {
                  if (!w5) w5 = $Writer.create();
                  if (m6.round != null && Object.hasOwnProperty.call(m6, "round")) w5.uint32(8).int64(m6.round);
                  if (m6.signature != null && Object.hasOwnProperty.call(m6, "signature")) w5.uint32(18).bytes(m6.signature);
                  if (m6.hash != null && Object.hasOwnProperty.call(m6, "hash")) w5.uint32(26).bytes(m6.hash);
                  return w5;
                };
                StateSignatureTransaction.decode = function decode7(r41, l19) {
                  if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
                  var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.com.hedera.hapi.platform.event.StateSignatureTransaction();
                  while (r41.pos < c17) {
                    var t35 = r41.uint32();
                    switch (t35 >>> 3) {
                      case 1: {
                        m6.round = r41.int64();
                        break;
                      }
                      case 2: {
                        m6.signature = r41.bytes();
                        break;
                      }
                      case 3: {
                        m6.hash = r41.bytes();
                        break;
                      }
                      default:
                        r41.skipType(t35 & 7);
                        break;
                    }
                  }
                  return m6;
                };
                StateSignatureTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === void 0) {
                    typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/com.hedera.hapi.platform.event.StateSignatureTransaction";
                };
                return StateSignatureTransaction;
              })();
              return event;
            })();
            return platform;
          })();
          return hapi;
        })();
        return hedera;
      })();
      return com3;
    })();
    exports2.com = com2;
    var proto36 = $root.proto = (() => {
      const proto37 = {};
      proto37.TransactionList = (function() {
        function TransactionList(p3) {
          this.transactionList = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionList.prototype.transactionList = $util.emptyArray;
        TransactionList.create = function create(properties) {
          return new TransactionList(properties);
        };
        TransactionList.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transactionList != null && m6.transactionList.length) {
            for (var i17 = 0; i17 < m6.transactionList.length; ++i17) $root.proto.Transaction.encode(m6.transactionList[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        TransactionList.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionList();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.transactionList && m6.transactionList.length)) m6.transactionList = [];
                m6.transactionList.push($root.proto.Transaction.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionList";
        };
        return TransactionList;
      })();
      proto37.AddressBookService = (function() {
        function AddressBookService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (AddressBookService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AddressBookService;
        AddressBookService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(AddressBookService.prototype.createNode = function createNode(request, callback) {
          return this.rpcCall(createNode, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createNode" });
        Object.defineProperty(AddressBookService.prototype.deleteNode = function deleteNode(request, callback) {
          return this.rpcCall(deleteNode, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteNode" });
        Object.defineProperty(AddressBookService.prototype.updateNode = function updateNode(request, callback) {
          return this.rpcCall(updateNode, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateNode" });
        return AddressBookService;
      })();
      proto37.TransactionResponse = (function() {
        function TransactionResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionResponse.prototype.nodeTransactionPrecheckCode = 0;
        TransactionResponse.prototype.cost = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TransactionResponse.create = function create(properties) {
          return new TransactionResponse(properties);
        };
        TransactionResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(m6, "nodeTransactionPrecheckCode")) w5.uint32(8).int32(m6.nodeTransactionPrecheckCode);
          if (m6.cost != null && Object.hasOwnProperty.call(m6, "cost")) w5.uint32(16).uint64(m6.cost);
          return w5;
        };
        TransactionResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.nodeTransactionPrecheckCode = r41.int32();
                break;
              }
              case 2: {
                m6.cost = r41.uint64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionResponse";
        };
        return TransactionResponse;
      })();
      proto37.ResponseCodeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OK"] = 0;
        values[valuesById[1] = "INVALID_TRANSACTION"] = 1;
        values[valuesById[2] = "PAYER_ACCOUNT_NOT_FOUND"] = 2;
        values[valuesById[3] = "INVALID_NODE_ACCOUNT"] = 3;
        values[valuesById[4] = "TRANSACTION_EXPIRED"] = 4;
        values[valuesById[5] = "INVALID_TRANSACTION_START"] = 5;
        values[valuesById[6] = "INVALID_TRANSACTION_DURATION"] = 6;
        values[valuesById[7] = "INVALID_SIGNATURE"] = 7;
        values[valuesById[8] = "MEMO_TOO_LONG"] = 8;
        values[valuesById[9] = "INSUFFICIENT_TX_FEE"] = 9;
        values[valuesById[10] = "INSUFFICIENT_PAYER_BALANCE"] = 10;
        values[valuesById[11] = "DUPLICATE_TRANSACTION"] = 11;
        values[valuesById[12] = "BUSY"] = 12;
        values[valuesById[13] = "NOT_SUPPORTED"] = 13;
        values[valuesById[14] = "INVALID_FILE_ID"] = 14;
        values[valuesById[15] = "INVALID_ACCOUNT_ID"] = 15;
        values[valuesById[16] = "INVALID_CONTRACT_ID"] = 16;
        values[valuesById[17] = "INVALID_TRANSACTION_ID"] = 17;
        values[valuesById[18] = "RECEIPT_NOT_FOUND"] = 18;
        values[valuesById[19] = "RECORD_NOT_FOUND"] = 19;
        values[valuesById[20] = "INVALID_SOLIDITY_ID"] = 20;
        values[valuesById[21] = "UNKNOWN"] = 21;
        values[valuesById[22] = "SUCCESS"] = 22;
        values[valuesById[23] = "FAIL_INVALID"] = 23;
        values[valuesById[24] = "FAIL_FEE"] = 24;
        values[valuesById[25] = "FAIL_BALANCE"] = 25;
        values[valuesById[26] = "KEY_REQUIRED"] = 26;
        values[valuesById[27] = "BAD_ENCODING"] = 27;
        values[valuesById[28] = "INSUFFICIENT_ACCOUNT_BALANCE"] = 28;
        values[valuesById[29] = "INVALID_SOLIDITY_ADDRESS"] = 29;
        values[valuesById[30] = "INSUFFICIENT_GAS"] = 30;
        values[valuesById[31] = "CONTRACT_SIZE_LIMIT_EXCEEDED"] = 31;
        values[valuesById[32] = "LOCAL_CALL_MODIFICATION_EXCEPTION"] = 32;
        values[valuesById[33] = "CONTRACT_REVERT_EXECUTED"] = 33;
        values[valuesById[34] = "CONTRACT_EXECUTION_EXCEPTION"] = 34;
        values[valuesById[35] = "INVALID_RECEIVING_NODE_ACCOUNT"] = 35;
        values[valuesById[36] = "MISSING_QUERY_HEADER"] = 36;
        values[valuesById[37] = "ACCOUNT_UPDATE_FAILED"] = 37;
        values[valuesById[38] = "INVALID_KEY_ENCODING"] = 38;
        values[valuesById[39] = "NULL_SOLIDITY_ADDRESS"] = 39;
        values[valuesById[40] = "CONTRACT_UPDATE_FAILED"] = 40;
        values[valuesById[41] = "INVALID_QUERY_HEADER"] = 41;
        values[valuesById[42] = "INVALID_FEE_SUBMITTED"] = 42;
        values[valuesById[43] = "INVALID_PAYER_SIGNATURE"] = 43;
        values[valuesById[44] = "KEY_NOT_PROVIDED"] = 44;
        values[valuesById[45] = "INVALID_EXPIRATION_TIME"] = 45;
        values[valuesById[46] = "NO_WACL_KEY"] = 46;
        values[valuesById[47] = "FILE_CONTENT_EMPTY"] = 47;
        values[valuesById[48] = "INVALID_ACCOUNT_AMOUNTS"] = 48;
        values[valuesById[49] = "EMPTY_TRANSACTION_BODY"] = 49;
        values[valuesById[50] = "INVALID_TRANSACTION_BODY"] = 50;
        values[valuesById[51] = "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY"] = 51;
        values[valuesById[52] = "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY"] = 52;
        values[valuesById[53] = "EMPTY_LIVE_HASH_BODY"] = 53;
        values[valuesById[54] = "EMPTY_LIVE_HASH"] = 54;
        values[valuesById[55] = "EMPTY_LIVE_HASH_KEYS"] = 55;
        values[valuesById[56] = "INVALID_LIVE_HASH_SIZE"] = 56;
        values[valuesById[57] = "EMPTY_QUERY_BODY"] = 57;
        values[valuesById[58] = "EMPTY_LIVE_HASH_QUERY"] = 58;
        values[valuesById[59] = "LIVE_HASH_NOT_FOUND"] = 59;
        values[valuesById[60] = "ACCOUNT_ID_DOES_NOT_EXIST"] = 60;
        values[valuesById[61] = "LIVE_HASH_ALREADY_EXISTS"] = 61;
        values[valuesById[62] = "INVALID_FILE_WACL"] = 62;
        values[valuesById[63] = "SERIALIZATION_FAILED"] = 63;
        values[valuesById[64] = "TRANSACTION_OVERSIZE"] = 64;
        values[valuesById[65] = "TRANSACTION_TOO_MANY_LAYERS"] = 65;
        values[valuesById[66] = "CONTRACT_DELETED"] = 66;
        values[valuesById[67] = "PLATFORM_NOT_ACTIVE"] = 67;
        values[valuesById[68] = "KEY_PREFIX_MISMATCH"] = 68;
        values[valuesById[69] = "PLATFORM_TRANSACTION_NOT_CREATED"] = 69;
        values[valuesById[70] = "INVALID_RENEWAL_PERIOD"] = 70;
        values[valuesById[71] = "INVALID_PAYER_ACCOUNT_ID"] = 71;
        values[valuesById[72] = "ACCOUNT_DELETED"] = 72;
        values[valuesById[73] = "FILE_DELETED"] = 73;
        values[valuesById[74] = "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS"] = 74;
        values[valuesById[75] = "SETTING_NEGATIVE_ACCOUNT_BALANCE"] = 75;
        values[valuesById[76] = "OBTAINER_REQUIRED"] = 76;
        values[valuesById[77] = "OBTAINER_SAME_CONTRACT_ID"] = 77;
        values[valuesById[78] = "OBTAINER_DOES_NOT_EXIST"] = 78;
        values[valuesById[79] = "MODIFYING_IMMUTABLE_CONTRACT"] = 79;
        values[valuesById[80] = "FILE_SYSTEM_EXCEPTION"] = 80;
        values[valuesById[81] = "AUTORENEW_DURATION_NOT_IN_RANGE"] = 81;
        values[valuesById[82] = "ERROR_DECODING_BYTESTRING"] = 82;
        values[valuesById[83] = "CONTRACT_FILE_EMPTY"] = 83;
        values[valuesById[84] = "CONTRACT_BYTECODE_EMPTY"] = 84;
        values[valuesById[85] = "INVALID_INITIAL_BALANCE"] = 85;
        values[valuesById[86] = "INVALID_RECEIVE_RECORD_THRESHOLD"] = 86;
        values[valuesById[87] = "INVALID_SEND_RECORD_THRESHOLD"] = 87;
        values[valuesById[88] = "ACCOUNT_IS_NOT_GENESIS_ACCOUNT"] = 88;
        values[valuesById[89] = "PAYER_ACCOUNT_UNAUTHORIZED"] = 89;
        values[valuesById[90] = "INVALID_FREEZE_TRANSACTION_BODY"] = 90;
        values[valuesById[91] = "FREEZE_TRANSACTION_BODY_NOT_FOUND"] = 91;
        values[valuesById[92] = "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 92;
        values[valuesById[93] = "RESULT_SIZE_LIMIT_EXCEEDED"] = 93;
        values[valuesById[94] = "NOT_SPECIAL_ACCOUNT"] = 94;
        values[valuesById[95] = "CONTRACT_NEGATIVE_GAS"] = 95;
        values[valuesById[96] = "CONTRACT_NEGATIVE_VALUE"] = 96;
        values[valuesById[97] = "INVALID_FEE_FILE"] = 97;
        values[valuesById[98] = "INVALID_EXCHANGE_RATE_FILE"] = 98;
        values[valuesById[99] = "INSUFFICIENT_LOCAL_CALL_GAS"] = 99;
        values[valuesById[100] = "ENTITY_NOT_ALLOWED_TO_DELETE"] = 100;
        values[valuesById[101] = "AUTHORIZATION_FAILED"] = 101;
        values[valuesById[102] = "FILE_UPLOADED_PROTO_INVALID"] = 102;
        values[valuesById[103] = "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK"] = 103;
        values[valuesById[104] = "FEE_SCHEDULE_FILE_PART_UPLOADED"] = 104;
        values[valuesById[105] = "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED"] = 105;
        values[valuesById[106] = "MAX_CONTRACT_STORAGE_EXCEEDED"] = 106;
        values[valuesById[107] = "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT"] = 107;
        values[valuesById[108] = "TOTAL_LEDGER_BALANCE_INVALID"] = 108;
        values[valuesById[110] = "EXPIRATION_REDUCTION_NOT_ALLOWED"] = 110;
        values[valuesById[111] = "MAX_GAS_LIMIT_EXCEEDED"] = 111;
        values[valuesById[112] = "MAX_FILE_SIZE_EXCEEDED"] = 112;
        values[valuesById[113] = "RECEIVER_SIG_REQUIRED"] = 113;
        values[valuesById[150] = "INVALID_TOPIC_ID"] = 150;
        values[valuesById[155] = "INVALID_ADMIN_KEY"] = 155;
        values[valuesById[156] = "INVALID_SUBMIT_KEY"] = 156;
        values[valuesById[157] = "UNAUTHORIZED"] = 157;
        values[valuesById[158] = "INVALID_TOPIC_MESSAGE"] = 158;
        values[valuesById[159] = "INVALID_AUTORENEW_ACCOUNT"] = 159;
        values[valuesById[160] = "AUTORENEW_ACCOUNT_NOT_ALLOWED"] = 160;
        values[valuesById[162] = "TOPIC_EXPIRED"] = 162;
        values[valuesById[163] = "INVALID_CHUNK_NUMBER"] = 163;
        values[valuesById[164] = "INVALID_CHUNK_TRANSACTION_ID"] = 164;
        values[valuesById[165] = "ACCOUNT_FROZEN_FOR_TOKEN"] = 165;
        values[valuesById[166] = "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED"] = 166;
        values[valuesById[167] = "INVALID_TOKEN_ID"] = 167;
        values[valuesById[168] = "INVALID_TOKEN_DECIMALS"] = 168;
        values[valuesById[169] = "INVALID_TOKEN_INITIAL_SUPPLY"] = 169;
        values[valuesById[170] = "INVALID_TREASURY_ACCOUNT_FOR_TOKEN"] = 170;
        values[valuesById[171] = "INVALID_TOKEN_SYMBOL"] = 171;
        values[valuesById[172] = "TOKEN_HAS_NO_FREEZE_KEY"] = 172;
        values[valuesById[173] = "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN"] = 173;
        values[valuesById[174] = "MISSING_TOKEN_SYMBOL"] = 174;
        values[valuesById[175] = "TOKEN_SYMBOL_TOO_LONG"] = 175;
        values[valuesById[176] = "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN"] = 176;
        values[valuesById[177] = "TOKEN_HAS_NO_KYC_KEY"] = 177;
        values[valuesById[178] = "INSUFFICIENT_TOKEN_BALANCE"] = 178;
        values[valuesById[179] = "TOKEN_WAS_DELETED"] = 179;
        values[valuesById[180] = "TOKEN_HAS_NO_SUPPLY_KEY"] = 180;
        values[valuesById[181] = "TOKEN_HAS_NO_WIPE_KEY"] = 181;
        values[valuesById[182] = "INVALID_TOKEN_MINT_AMOUNT"] = 182;
        values[valuesById[183] = "INVALID_TOKEN_BURN_AMOUNT"] = 183;
        values[valuesById[184] = "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT"] = 184;
        values[valuesById[185] = "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT"] = 185;
        values[valuesById[186] = "INVALID_KYC_KEY"] = 186;
        values[valuesById[187] = "INVALID_WIPE_KEY"] = 187;
        values[valuesById[188] = "INVALID_FREEZE_KEY"] = 188;
        values[valuesById[189] = "INVALID_SUPPLY_KEY"] = 189;
        values[valuesById[190] = "MISSING_TOKEN_NAME"] = 190;
        values[valuesById[191] = "TOKEN_NAME_TOO_LONG"] = 191;
        values[valuesById[192] = "INVALID_WIPING_AMOUNT"] = 192;
        values[valuesById[193] = "TOKEN_IS_IMMUTABLE"] = 193;
        values[valuesById[194] = "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT"] = 194;
        values[valuesById[195] = "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES"] = 195;
        values[valuesById[196] = "ACCOUNT_IS_TREASURY"] = 196;
        values[valuesById[197] = "TOKEN_ID_REPEATED_IN_TOKEN_LIST"] = 197;
        values[valuesById[198] = "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED"] = 198;
        values[valuesById[199] = "EMPTY_TOKEN_TRANSFER_BODY"] = 199;
        values[valuesById[200] = "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS"] = 200;
        values[valuesById[201] = "INVALID_SCHEDULE_ID"] = 201;
        values[valuesById[202] = "SCHEDULE_IS_IMMUTABLE"] = 202;
        values[valuesById[203] = "INVALID_SCHEDULE_PAYER_ID"] = 203;
        values[valuesById[204] = "INVALID_SCHEDULE_ACCOUNT_ID"] = 204;
        values[valuesById[205] = "NO_NEW_VALID_SIGNATURES"] = 205;
        values[valuesById[206] = "UNRESOLVABLE_REQUIRED_SIGNERS"] = 206;
        values[valuesById[207] = "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST"] = 207;
        values[valuesById[208] = "SOME_SIGNATURES_WERE_INVALID"] = 208;
        values[valuesById[209] = "TRANSACTION_ID_FIELD_NOT_ALLOWED"] = 209;
        values[valuesById[210] = "IDENTICAL_SCHEDULE_ALREADY_CREATED"] = 210;
        values[valuesById[211] = "INVALID_ZERO_BYTE_IN_STRING"] = 211;
        values[valuesById[212] = "SCHEDULE_ALREADY_DELETED"] = 212;
        values[valuesById[213] = "SCHEDULE_ALREADY_EXECUTED"] = 213;
        values[valuesById[214] = "MESSAGE_SIZE_TOO_LARGE"] = 214;
        values[valuesById[215] = "OPERATION_REPEATED_IN_BUCKET_GROUPS"] = 215;
        values[valuesById[216] = "BUCKET_CAPACITY_OVERFLOW"] = 216;
        values[valuesById[217] = "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION"] = 217;
        values[valuesById[218] = "BUCKET_HAS_NO_THROTTLE_GROUPS"] = 218;
        values[valuesById[219] = "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC"] = 219;
        values[valuesById[220] = "SUCCESS_BUT_MISSING_EXPECTED_OPERATION"] = 220;
        values[valuesById[221] = "UNPARSEABLE_THROTTLE_DEFINITIONS"] = 221;
        values[valuesById[222] = "INVALID_THROTTLE_DEFINITIONS"] = 222;
        values[valuesById[223] = "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL"] = 223;
        values[valuesById[224] = "INVALID_TOKEN_MAX_SUPPLY"] = 224;
        values[valuesById[225] = "INVALID_TOKEN_NFT_SERIAL_NUMBER"] = 225;
        values[valuesById[226] = "INVALID_NFT_ID"] = 226;
        values[valuesById[227] = "METADATA_TOO_LONG"] = 227;
        values[valuesById[228] = "BATCH_SIZE_LIMIT_EXCEEDED"] = 228;
        values[valuesById[229] = "INVALID_QUERY_RANGE"] = 229;
        values[valuesById[230] = "FRACTION_DIVIDES_BY_ZERO"] = 230;
        values[valuesById[231] = "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE"] = 231;
        values[valuesById[232] = "CUSTOM_FEES_LIST_TOO_LONG"] = 232;
        values[valuesById[233] = "INVALID_CUSTOM_FEE_COLLECTOR"] = 233;
        values[valuesById[234] = "INVALID_TOKEN_ID_IN_CUSTOM_FEES"] = 234;
        values[valuesById[235] = "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR"] = 235;
        values[valuesById[236] = "TOKEN_MAX_SUPPLY_REACHED"] = 236;
        values[valuesById[237] = "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO"] = 237;
        values[valuesById[238] = "CUSTOM_FEE_NOT_FULLY_SPECIFIED"] = 238;
        values[valuesById[239] = "CUSTOM_FEE_MUST_BE_POSITIVE"] = 239;
        values[valuesById[240] = "TOKEN_HAS_NO_FEE_SCHEDULE_KEY"] = 240;
        values[valuesById[241] = "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE"] = 241;
        values[valuesById[242] = "ROYALTY_FRACTION_CANNOT_EXCEED_ONE"] = 242;
        values[valuesById[243] = "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT"] = 243;
        values[valuesById[244] = "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES"] = 244;
        values[valuesById[245] = "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON"] = 245;
        values[valuesById[246] = "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 246;
        values[valuesById[247] = "INVALID_CUSTOM_FEE_SCHEDULE_KEY"] = 247;
        values[valuesById[248] = "INVALID_TOKEN_MINT_METADATA"] = 248;
        values[valuesById[249] = "INVALID_TOKEN_BURN_METADATA"] = 249;
        values[valuesById[250] = "CURRENT_TREASURY_STILL_OWNS_NFTS"] = 250;
        values[valuesById[251] = "ACCOUNT_STILL_OWNS_NFTS"] = 251;
        values[valuesById[252] = "TREASURY_MUST_OWN_BURNED_NFT"] = 252;
        values[valuesById[253] = "ACCOUNT_DOES_NOT_OWN_WIPED_NFT"] = 253;
        values[valuesById[254] = "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON"] = 254;
        values[valuesById[255] = "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED"] = 255;
        values[valuesById[256] = "PAYER_ACCOUNT_DELETED"] = 256;
        values[valuesById[257] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH"] = 257;
        values[valuesById[258] = "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS"] = 258;
        values[valuesById[259] = "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE"] = 259;
        values[valuesById[260] = "SERIAL_NUMBER_LIMIT_REACHED"] = 260;
        values[valuesById[261] = "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"] = 261;
        values[valuesById[262] = "NO_REMAINING_AUTOMATIC_ASSOCIATIONS"] = 262;
        values[valuesById[263] = "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT"] = 263;
        values[valuesById[264] = "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT"] = 264;
        values[valuesById[265] = "TOKEN_IS_PAUSED"] = 265;
        values[valuesById[266] = "TOKEN_HAS_NO_PAUSE_KEY"] = 266;
        values[valuesById[267] = "INVALID_PAUSE_KEY"] = 267;
        values[valuesById[268] = "FREEZE_UPDATE_FILE_DOES_NOT_EXIST"] = 268;
        values[valuesById[269] = "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH"] = 269;
        values[valuesById[270] = "NO_UPGRADE_HAS_BEEN_PREPARED"] = 270;
        values[valuesById[271] = "NO_FREEZE_IS_SCHEDULED"] = 271;
        values[valuesById[272] = "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE"] = 272;
        values[valuesById[273] = "FREEZE_START_TIME_MUST_BE_FUTURE"] = 273;
        values[valuesById[274] = "PREPARED_UPDATE_FILE_IS_IMMUTABLE"] = 274;
        values[valuesById[275] = "FREEZE_ALREADY_SCHEDULED"] = 275;
        values[valuesById[276] = "FREEZE_UPGRADE_IN_PROGRESS"] = 276;
        values[valuesById[277] = "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED"] = 277;
        values[valuesById[278] = "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED"] = 278;
        values[valuesById[279] = "CONSENSUS_GAS_EXHAUSTED"] = 279;
        values[valuesById[280] = "REVERTED_SUCCESS"] = 280;
        values[valuesById[281] = "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED"] = 281;
        values[valuesById[282] = "INVALID_ALIAS_KEY"] = 282;
        values[valuesById[283] = "UNEXPECTED_TOKEN_DECIMALS"] = 283;
        values[valuesById[284] = "INVALID_PROXY_ACCOUNT_ID"] = 284;
        values[valuesById[285] = "INVALID_TRANSFER_ACCOUNT_ID"] = 285;
        values[valuesById[286] = "INVALID_FEE_COLLECTOR_ACCOUNT_ID"] = 286;
        values[valuesById[287] = "ALIAS_IS_IMMUTABLE"] = 287;
        values[valuesById[288] = "SPENDER_ACCOUNT_SAME_AS_OWNER"] = 288;
        values[valuesById[289] = "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY"] = 289;
        values[valuesById[290] = "NEGATIVE_ALLOWANCE_AMOUNT"] = 290;
        values[valuesById[291] = "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON"] = 291;
        values[valuesById[292] = "SPENDER_DOES_NOT_HAVE_ALLOWANCE"] = 292;
        values[valuesById[293] = "AMOUNT_EXCEEDS_ALLOWANCE"] = 293;
        values[valuesById[294] = "MAX_ALLOWANCES_EXCEEDED"] = 294;
        values[valuesById[295] = "EMPTY_ALLOWANCES"] = 295;
        values[valuesById[296] = "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES"] = 296;
        values[valuesById[297] = "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES"] = 297;
        values[valuesById[298] = "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES"] = 298;
        values[valuesById[299] = "NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES"] = 299;
        values[valuesById[300] = "INVALID_ALLOWANCE_OWNER_ID"] = 300;
        values[valuesById[301] = "INVALID_ALLOWANCE_SPENDER_ID"] = 301;
        values[valuesById[302] = "REPEATED_ALLOWANCES_TO_DELETE"] = 302;
        values[valuesById[303] = "INVALID_DELEGATING_SPENDER"] = 303;
        values[valuesById[304] = "DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL"] = 304;
        values[valuesById[305] = "DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL"] = 305;
        values[valuesById[306] = "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE"] = 306;
        values[valuesById[307] = "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME"] = 307;
        values[valuesById[308] = "SCHEDULE_FUTURE_THROTTLE_EXCEEDED"] = 308;
        values[valuesById[309] = "SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED"] = 309;
        values[valuesById[310] = "INVALID_ETHEREUM_TRANSACTION"] = 310;
        values[valuesById[311] = "WRONG_CHAIN_ID"] = 311;
        values[valuesById[312] = "WRONG_NONCE"] = 312;
        values[valuesById[313] = "ACCESS_LIST_UNSUPPORTED"] = 313;
        values[valuesById[314] = "SCHEDULE_PENDING_EXPIRATION"] = 314;
        values[valuesById[315] = "CONTRACT_IS_TOKEN_TREASURY"] = 315;
        values[valuesById[316] = "CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES"] = 316;
        values[valuesById[317] = "CONTRACT_EXPIRED_AND_PENDING_REMOVAL"] = 317;
        values[valuesById[318] = "CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT"] = 318;
        values[valuesById[319] = "PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION"] = 319;
        values[valuesById[320] = "PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED"] = 320;
        values[valuesById[321] = "SELF_STAKING_IS_NOT_ALLOWED"] = 321;
        values[valuesById[322] = "INVALID_STAKING_ID"] = 322;
        values[valuesById[323] = "STAKING_NOT_ENABLED"] = 323;
        values[valuesById[324] = "INVALID_PRNG_RANGE"] = 324;
        values[valuesById[325] = "MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED"] = 325;
        values[valuesById[326] = "INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE"] = 326;
        values[valuesById[327] = "INSUFFICIENT_BALANCES_FOR_STORAGE_RENT"] = 327;
        values[valuesById[328] = "MAX_CHILD_RECORDS_EXCEEDED"] = 328;
        values[valuesById[329] = "INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES"] = 329;
        values[valuesById[330] = "TRANSACTION_HAS_UNKNOWN_FIELDS"] = 330;
        values[valuesById[331] = "ACCOUNT_IS_IMMUTABLE"] = 331;
        values[valuesById[332] = "ALIAS_ALREADY_ASSIGNED"] = 332;
        values[valuesById[333] = "INVALID_METADATA_KEY"] = 333;
        values[valuesById[334] = "TOKEN_HAS_NO_METADATA_KEY"] = 334;
        values[valuesById[335] = "MISSING_TOKEN_METADATA"] = 335;
        values[valuesById[336] = "MISSING_SERIAL_NUMBERS"] = 336;
        values[valuesById[337] = "TOKEN_HAS_NO_ADMIN_KEY"] = 337;
        values[valuesById[338] = "NODE_DELETED"] = 338;
        values[valuesById[339] = "INVALID_NODE_ID"] = 339;
        values[valuesById[340] = "INVALID_GOSSIP_ENDPOINT"] = 340;
        values[valuesById[341] = "INVALID_NODE_ACCOUNT_ID"] = 341;
        values[valuesById[342] = "INVALID_NODE_DESCRIPTION"] = 342;
        values[valuesById[343] = "INVALID_SERVICE_ENDPOINT"] = 343;
        values[valuesById[344] = "INVALID_GOSSIP_CA_CERTIFICATE"] = 344;
        values[valuesById[345] = "INVALID_GRPC_CERTIFICATE"] = 345;
        values[valuesById[346] = "INVALID_MAX_AUTO_ASSOCIATIONS"] = 346;
        values[valuesById[347] = "MAX_NODES_CREATED"] = 347;
        values[valuesById[348] = "IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT"] = 348;
        values[valuesById[349] = "GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN"] = 349;
        values[valuesById[350] = "FQDN_SIZE_TOO_LARGE"] = 350;
        values[valuesById[351] = "INVALID_ENDPOINT"] = 351;
        values[valuesById[352] = "GOSSIP_ENDPOINTS_EXCEEDED_LIMIT"] = 352;
        values[valuesById[353] = "TOKEN_REFERENCE_REPEATED"] = 353;
        values[valuesById[354] = "INVALID_OWNER_ID"] = 354;
        values[valuesById[355] = "TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED"] = 355;
        values[valuesById[356] = "SERVICE_ENDPOINTS_EXCEEDED_LIMIT"] = 356;
        values[valuesById[357] = "INVALID_IPV4_ADDRESS"] = 357;
        values[valuesById[358] = "EMPTY_TOKEN_REFERENCE_LIST"] = 358;
        values[valuesById[359] = "UPDATE_NODE_ACCOUNT_NOT_ALLOWED"] = 359;
        values[valuesById[360] = "TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY"] = 360;
        values[valuesById[361] = "EMPTY_PENDING_AIRDROP_ID_LIST"] = 361;
        values[valuesById[362] = "PENDING_AIRDROP_ID_REPEATED"] = 362;
        values[valuesById[363] = "PENDING_AIRDROP_ID_LIST_TOO_LONG"] = 363;
        values[valuesById[364] = "PENDING_NFT_AIRDROP_ALREADY_EXISTS"] = 364;
        values[valuesById[365] = "ACCOUNT_HAS_PENDING_AIRDROPS"] = 365;
        values[valuesById[366] = "THROTTLED_AT_CONSENSUS"] = 366;
        values[valuesById[367] = "INVALID_PENDING_AIRDROP_ID"] = 367;
        values[valuesById[368] = "TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY"] = 368;
        values[valuesById[369] = "INVALID_TOKEN_IN_PENDING_AIRDROP"] = 369;
        values[valuesById[370] = "SCHEDULE_EXPIRY_IS_BUSY"] = 370;
        values[valuesById[371] = "INVALID_GRPC_CERTIFICATE_HASH"] = 371;
        values[valuesById[372] = "MISSING_EXPIRY_TIME"] = 372;
        values[valuesById[373] = "NO_SCHEDULING_ALLOWED_AFTER_SCHEDULED_RECURSION"] = 373;
        values[valuesById[374] = "RECURSIVE_SCHEDULING_LIMIT_REACHED"] = 374;
        values[valuesById[375] = "WAITING_FOR_LEDGER_ID"] = 375;
        values[valuesById[376] = "MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED"] = 376;
        values[valuesById[377] = "FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS"] = 377;
        values[valuesById[378] = "INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST"] = 378;
        values[valuesById[379] = "INVALID_FEE_SCHEDULE_KEY"] = 379;
        values[valuesById[380] = "FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED"] = 380;
        values[valuesById[381] = "FEE_SCHEDULE_KEY_NOT_SET"] = 381;
        values[valuesById[382] = "MAX_CUSTOM_FEE_LIMIT_EXCEEDED"] = 382;
        values[valuesById[383] = "NO_VALID_MAX_CUSTOM_FEE"] = 383;
        values[valuesById[384] = "INVALID_MAX_CUSTOM_FEES"] = 384;
        values[valuesById[385] = "DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST"] = 385;
        values[valuesById[386] = "DUPLICATE_ACCOUNT_ID_IN_MAX_CUSTOM_FEE_LIST"] = 386;
        values[valuesById[387] = "MAX_CUSTOM_FEES_IS_NOT_SUPPORTED"] = 387;
        values[valuesById[388] = "BATCH_LIST_EMPTY"] = 388;
        values[valuesById[389] = "BATCH_LIST_CONTAINS_DUPLICATES"] = 389;
        values[valuesById[390] = "BATCH_TRANSACTION_IN_BLACKLIST"] = 390;
        values[valuesById[391] = "INNER_TRANSACTION_FAILED"] = 391;
        values[valuesById[392] = "MISSING_BATCH_KEY"] = 392;
        values[valuesById[393] = "BATCH_KEY_SET_ON_NON_INNER_TRANSACTION"] = 393;
        values[valuesById[394] = "INVALID_BATCH_KEY"] = 394;
        values[valuesById[395] = "SCHEDULE_EXPIRY_NOT_CONFIGURABLE"] = 395;
        values[valuesById[396] = "CREATING_SYSTEM_ENTITIES"] = 396;
        values[valuesById[397] = "THROTTLE_GROUP_LCM_OVERFLOW"] = 397;
        values[valuesById[398] = "AIRDROP_CONTAINS_MULTIPLE_SENDERS_FOR_A_TOKEN"] = 398;
        values[valuesById[399] = "GRPC_WEB_PROXY_NOT_SUPPORTED"] = 399;
        values[valuesById[400] = "NFT_TRANSFERS_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE"] = 400;
        return values;
      })();
      proto37.Transaction = (function() {
        function Transaction(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        Transaction.prototype.body = null;
        Transaction.prototype.sigs = null;
        Transaction.prototype.sigMap = null;
        Transaction.prototype.bodyBytes = $util.newBuffer([]);
        Transaction.prototype.signedTransactionBytes = $util.newBuffer([]);
        Transaction.create = function create(properties) {
          return new Transaction(properties);
        };
        Transaction.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.body != null && Object.hasOwnProperty.call(m6, "body")) $root.proto.TransactionBody.encode(m6.body, w5.uint32(10).fork()).ldelim();
          if (m6.sigs != null && Object.hasOwnProperty.call(m6, "sigs")) $root.proto.SignatureList.encode(m6.sigs, w5.uint32(18).fork()).ldelim();
          if (m6.sigMap != null && Object.hasOwnProperty.call(m6, "sigMap")) $root.proto.SignatureMap.encode(m6.sigMap, w5.uint32(26).fork()).ldelim();
          if (m6.bodyBytes != null && Object.hasOwnProperty.call(m6, "bodyBytes")) w5.uint32(34).bytes(m6.bodyBytes);
          if (m6.signedTransactionBytes != null && Object.hasOwnProperty.call(m6, "signedTransactionBytes")) w5.uint32(42).bytes(m6.signedTransactionBytes);
          return w5;
        };
        Transaction.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.Transaction();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.body = $root.proto.TransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.sigs = $root.proto.SignatureList.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.sigMap = $root.proto.SignatureMap.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.bodyBytes = r41.bytes();
                break;
              }
              case 5: {
                m6.signedTransactionBytes = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        Transaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.Transaction";
        };
        return Transaction;
      })();
      proto37.TransactionBody = (function() {
        function TransactionBody(p3) {
          this.maxCustomFees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionBody.prototype.transactionID = null;
        TransactionBody.prototype.nodeAccountID = null;
        TransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TransactionBody.prototype.transactionValidDuration = null;
        TransactionBody.prototype.generateRecord = false;
        TransactionBody.prototype.memo = "";
        TransactionBody.prototype.batchKey = null;
        TransactionBody.prototype.contractCall = null;
        TransactionBody.prototype.contractCreateInstance = null;
        TransactionBody.prototype.contractUpdateInstance = null;
        TransactionBody.prototype.cryptoAddLiveHash = null;
        TransactionBody.prototype.cryptoCreateAccount = null;
        TransactionBody.prototype.cryptoDelete = null;
        TransactionBody.prototype.cryptoDeleteLiveHash = null;
        TransactionBody.prototype.cryptoTransfer = null;
        TransactionBody.prototype.cryptoUpdateAccount = null;
        TransactionBody.prototype.fileAppend = null;
        TransactionBody.prototype.fileCreate = null;
        TransactionBody.prototype.fileDelete = null;
        TransactionBody.prototype.fileUpdate = null;
        TransactionBody.prototype.systemDelete = null;
        TransactionBody.prototype.systemUndelete = null;
        TransactionBody.prototype.contractDeleteInstance = null;
        TransactionBody.prototype.freeze = null;
        TransactionBody.prototype.consensusCreateTopic = null;
        TransactionBody.prototype.consensusUpdateTopic = null;
        TransactionBody.prototype.consensusDeleteTopic = null;
        TransactionBody.prototype.consensusSubmitMessage = null;
        TransactionBody.prototype.uncheckedSubmit = null;
        TransactionBody.prototype.tokenCreation = null;
        TransactionBody.prototype.tokenFreeze = null;
        TransactionBody.prototype.tokenUnfreeze = null;
        TransactionBody.prototype.tokenGrantKyc = null;
        TransactionBody.prototype.tokenRevokeKyc = null;
        TransactionBody.prototype.tokenDeletion = null;
        TransactionBody.prototype.tokenUpdate = null;
        TransactionBody.prototype.tokenMint = null;
        TransactionBody.prototype.tokenBurn = null;
        TransactionBody.prototype.tokenWipe = null;
        TransactionBody.prototype.tokenAssociate = null;
        TransactionBody.prototype.tokenDissociate = null;
        TransactionBody.prototype.scheduleCreate = null;
        TransactionBody.prototype.scheduleDelete = null;
        TransactionBody.prototype.scheduleSign = null;
        TransactionBody.prototype.tokenFeeScheduleUpdate = null;
        TransactionBody.prototype.tokenPause = null;
        TransactionBody.prototype.tokenUnpause = null;
        TransactionBody.prototype.cryptoApproveAllowance = null;
        TransactionBody.prototype.cryptoDeleteAllowance = null;
        TransactionBody.prototype.ethereumTransaction = null;
        TransactionBody.prototype.nodeStakeUpdate = null;
        TransactionBody.prototype.utilPrng = null;
        TransactionBody.prototype.tokenUpdateNfts = null;
        TransactionBody.prototype.nodeCreate = null;
        TransactionBody.prototype.nodeUpdate = null;
        TransactionBody.prototype.nodeDelete = null;
        TransactionBody.prototype.tokenReject = null;
        TransactionBody.prototype.tokenAirdrop = null;
        TransactionBody.prototype.tokenCancelAirdrop = null;
        TransactionBody.prototype.tokenClaimAirdrop = null;
        TransactionBody.prototype.stateSignatureTransaction = null;
        TransactionBody.prototype.hintsPreprocessingVote = null;
        TransactionBody.prototype.hintsKeyPublication = null;
        TransactionBody.prototype.hintsPartialSignature = null;
        TransactionBody.prototype.historyProofSignature = null;
        TransactionBody.prototype.historyProofKeyPublication = null;
        TransactionBody.prototype.historyProofVote = null;
        TransactionBody.prototype.crsPublication = null;
        TransactionBody.prototype.atomicBatch = null;
        TransactionBody.prototype.maxCustomFees = $util.emptyArray;
        let $oneOfFields;
        Object.defineProperty(TransactionBody.prototype, "data", { get: $util.oneOfGetter($oneOfFields = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "cryptoAddLiveHash", "cryptoCreateAccount", "cryptoDelete", "cryptoDeleteLiveHash", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "contractDeleteInstance", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "uncheckedSubmit", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "scheduleCreate", "scheduleDelete", "scheduleSign", "tokenFeeScheduleUpdate", "tokenPause", "tokenUnpause", "cryptoApproveAllowance", "cryptoDeleteAllowance", "ethereumTransaction", "nodeStakeUpdate", "utilPrng", "tokenUpdateNfts", "nodeCreate", "nodeUpdate", "nodeDelete", "tokenReject", "tokenAirdrop", "tokenCancelAirdrop", "tokenClaimAirdrop", "stateSignatureTransaction", "hintsPreprocessingVote", "hintsKeyPublication", "hintsPartialSignature", "historyProofSignature", "historyProofKeyPublication", "historyProofVote", "crsPublication", "atomicBatch"]), set: $util.oneOfSetter($oneOfFields) });
        TransactionBody.create = function create(properties) {
          return new TransactionBody(properties);
        };
        TransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transactionID != null && Object.hasOwnProperty.call(m6, "transactionID")) $root.proto.TransactionID.encode(m6.transactionID, w5.uint32(10).fork()).ldelim();
          if (m6.nodeAccountID != null && Object.hasOwnProperty.call(m6, "nodeAccountID")) $root.proto.AccountID.encode(m6.nodeAccountID, w5.uint32(18).fork()).ldelim();
          if (m6.transactionFee != null && Object.hasOwnProperty.call(m6, "transactionFee")) w5.uint32(24).uint64(m6.transactionFee);
          if (m6.transactionValidDuration != null && Object.hasOwnProperty.call(m6, "transactionValidDuration")) $root.proto.Duration.encode(m6.transactionValidDuration, w5.uint32(34).fork()).ldelim();
          if (m6.generateRecord != null && Object.hasOwnProperty.call(m6, "generateRecord")) w5.uint32(40).bool(m6.generateRecord);
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(50).string(m6.memo);
          if (m6.contractCall != null && Object.hasOwnProperty.call(m6, "contractCall")) $root.proto.ContractCallTransactionBody.encode(m6.contractCall, w5.uint32(58).fork()).ldelim();
          if (m6.contractCreateInstance != null && Object.hasOwnProperty.call(m6, "contractCreateInstance")) $root.proto.ContractCreateTransactionBody.encode(m6.contractCreateInstance, w5.uint32(66).fork()).ldelim();
          if (m6.contractUpdateInstance != null && Object.hasOwnProperty.call(m6, "contractUpdateInstance")) $root.proto.ContractUpdateTransactionBody.encode(m6.contractUpdateInstance, w5.uint32(74).fork()).ldelim();
          if (m6.cryptoAddLiveHash != null && Object.hasOwnProperty.call(m6, "cryptoAddLiveHash")) $root.proto.CryptoAddLiveHashTransactionBody.encode(m6.cryptoAddLiveHash, w5.uint32(82).fork()).ldelim();
          if (m6.cryptoCreateAccount != null && Object.hasOwnProperty.call(m6, "cryptoCreateAccount")) $root.proto.CryptoCreateTransactionBody.encode(m6.cryptoCreateAccount, w5.uint32(90).fork()).ldelim();
          if (m6.cryptoDelete != null && Object.hasOwnProperty.call(m6, "cryptoDelete")) $root.proto.CryptoDeleteTransactionBody.encode(m6.cryptoDelete, w5.uint32(98).fork()).ldelim();
          if (m6.cryptoDeleteLiveHash != null && Object.hasOwnProperty.call(m6, "cryptoDeleteLiveHash")) $root.proto.CryptoDeleteLiveHashTransactionBody.encode(m6.cryptoDeleteLiveHash, w5.uint32(106).fork()).ldelim();
          if (m6.cryptoTransfer != null && Object.hasOwnProperty.call(m6, "cryptoTransfer")) $root.proto.CryptoTransferTransactionBody.encode(m6.cryptoTransfer, w5.uint32(114).fork()).ldelim();
          if (m6.cryptoUpdateAccount != null && Object.hasOwnProperty.call(m6, "cryptoUpdateAccount")) $root.proto.CryptoUpdateTransactionBody.encode(m6.cryptoUpdateAccount, w5.uint32(122).fork()).ldelim();
          if (m6.fileAppend != null && Object.hasOwnProperty.call(m6, "fileAppend")) $root.proto.FileAppendTransactionBody.encode(m6.fileAppend, w5.uint32(130).fork()).ldelim();
          if (m6.fileCreate != null && Object.hasOwnProperty.call(m6, "fileCreate")) $root.proto.FileCreateTransactionBody.encode(m6.fileCreate, w5.uint32(138).fork()).ldelim();
          if (m6.fileDelete != null && Object.hasOwnProperty.call(m6, "fileDelete")) $root.proto.FileDeleteTransactionBody.encode(m6.fileDelete, w5.uint32(146).fork()).ldelim();
          if (m6.fileUpdate != null && Object.hasOwnProperty.call(m6, "fileUpdate")) $root.proto.FileUpdateTransactionBody.encode(m6.fileUpdate, w5.uint32(154).fork()).ldelim();
          if (m6.systemDelete != null && Object.hasOwnProperty.call(m6, "systemDelete")) $root.proto.SystemDeleteTransactionBody.encode(m6.systemDelete, w5.uint32(162).fork()).ldelim();
          if (m6.systemUndelete != null && Object.hasOwnProperty.call(m6, "systemUndelete")) $root.proto.SystemUndeleteTransactionBody.encode(m6.systemUndelete, w5.uint32(170).fork()).ldelim();
          if (m6.contractDeleteInstance != null && Object.hasOwnProperty.call(m6, "contractDeleteInstance")) $root.proto.ContractDeleteTransactionBody.encode(m6.contractDeleteInstance, w5.uint32(178).fork()).ldelim();
          if (m6.freeze != null && Object.hasOwnProperty.call(m6, "freeze")) $root.proto.FreezeTransactionBody.encode(m6.freeze, w5.uint32(186).fork()).ldelim();
          if (m6.consensusCreateTopic != null && Object.hasOwnProperty.call(m6, "consensusCreateTopic")) $root.proto.ConsensusCreateTopicTransactionBody.encode(m6.consensusCreateTopic, w5.uint32(194).fork()).ldelim();
          if (m6.consensusUpdateTopic != null && Object.hasOwnProperty.call(m6, "consensusUpdateTopic")) $root.proto.ConsensusUpdateTopicTransactionBody.encode(m6.consensusUpdateTopic, w5.uint32(202).fork()).ldelim();
          if (m6.consensusDeleteTopic != null && Object.hasOwnProperty.call(m6, "consensusDeleteTopic")) $root.proto.ConsensusDeleteTopicTransactionBody.encode(m6.consensusDeleteTopic, w5.uint32(210).fork()).ldelim();
          if (m6.consensusSubmitMessage != null && Object.hasOwnProperty.call(m6, "consensusSubmitMessage")) $root.proto.ConsensusSubmitMessageTransactionBody.encode(m6.consensusSubmitMessage, w5.uint32(218).fork()).ldelim();
          if (m6.uncheckedSubmit != null && Object.hasOwnProperty.call(m6, "uncheckedSubmit")) $root.proto.UncheckedSubmitBody.encode(m6.uncheckedSubmit, w5.uint32(226).fork()).ldelim();
          if (m6.tokenCreation != null && Object.hasOwnProperty.call(m6, "tokenCreation")) $root.proto.TokenCreateTransactionBody.encode(m6.tokenCreation, w5.uint32(234).fork()).ldelim();
          if (m6.tokenFreeze != null && Object.hasOwnProperty.call(m6, "tokenFreeze")) $root.proto.TokenFreezeAccountTransactionBody.encode(m6.tokenFreeze, w5.uint32(250).fork()).ldelim();
          if (m6.tokenUnfreeze != null && Object.hasOwnProperty.call(m6, "tokenUnfreeze")) $root.proto.TokenUnfreezeAccountTransactionBody.encode(m6.tokenUnfreeze, w5.uint32(258).fork()).ldelim();
          if (m6.tokenGrantKyc != null && Object.hasOwnProperty.call(m6, "tokenGrantKyc")) $root.proto.TokenGrantKycTransactionBody.encode(m6.tokenGrantKyc, w5.uint32(266).fork()).ldelim();
          if (m6.tokenRevokeKyc != null && Object.hasOwnProperty.call(m6, "tokenRevokeKyc")) $root.proto.TokenRevokeKycTransactionBody.encode(m6.tokenRevokeKyc, w5.uint32(274).fork()).ldelim();
          if (m6.tokenDeletion != null && Object.hasOwnProperty.call(m6, "tokenDeletion")) $root.proto.TokenDeleteTransactionBody.encode(m6.tokenDeletion, w5.uint32(282).fork()).ldelim();
          if (m6.tokenUpdate != null && Object.hasOwnProperty.call(m6, "tokenUpdate")) $root.proto.TokenUpdateTransactionBody.encode(m6.tokenUpdate, w5.uint32(290).fork()).ldelim();
          if (m6.tokenMint != null && Object.hasOwnProperty.call(m6, "tokenMint")) $root.proto.TokenMintTransactionBody.encode(m6.tokenMint, w5.uint32(298).fork()).ldelim();
          if (m6.tokenBurn != null && Object.hasOwnProperty.call(m6, "tokenBurn")) $root.proto.TokenBurnTransactionBody.encode(m6.tokenBurn, w5.uint32(306).fork()).ldelim();
          if (m6.tokenWipe != null && Object.hasOwnProperty.call(m6, "tokenWipe")) $root.proto.TokenWipeAccountTransactionBody.encode(m6.tokenWipe, w5.uint32(314).fork()).ldelim();
          if (m6.tokenAssociate != null && Object.hasOwnProperty.call(m6, "tokenAssociate")) $root.proto.TokenAssociateTransactionBody.encode(m6.tokenAssociate, w5.uint32(322).fork()).ldelim();
          if (m6.tokenDissociate != null && Object.hasOwnProperty.call(m6, "tokenDissociate")) $root.proto.TokenDissociateTransactionBody.encode(m6.tokenDissociate, w5.uint32(330).fork()).ldelim();
          if (m6.scheduleCreate != null && Object.hasOwnProperty.call(m6, "scheduleCreate")) $root.proto.ScheduleCreateTransactionBody.encode(m6.scheduleCreate, w5.uint32(338).fork()).ldelim();
          if (m6.scheduleDelete != null && Object.hasOwnProperty.call(m6, "scheduleDelete")) $root.proto.ScheduleDeleteTransactionBody.encode(m6.scheduleDelete, w5.uint32(346).fork()).ldelim();
          if (m6.scheduleSign != null && Object.hasOwnProperty.call(m6, "scheduleSign")) $root.proto.ScheduleSignTransactionBody.encode(m6.scheduleSign, w5.uint32(354).fork()).ldelim();
          if (m6.tokenFeeScheduleUpdate != null && Object.hasOwnProperty.call(m6, "tokenFeeScheduleUpdate")) $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(m6.tokenFeeScheduleUpdate, w5.uint32(362).fork()).ldelim();
          if (m6.tokenPause != null && Object.hasOwnProperty.call(m6, "tokenPause")) $root.proto.TokenPauseTransactionBody.encode(m6.tokenPause, w5.uint32(370).fork()).ldelim();
          if (m6.tokenUnpause != null && Object.hasOwnProperty.call(m6, "tokenUnpause")) $root.proto.TokenUnpauseTransactionBody.encode(m6.tokenUnpause, w5.uint32(378).fork()).ldelim();
          if (m6.cryptoApproveAllowance != null && Object.hasOwnProperty.call(m6, "cryptoApproveAllowance")) $root.proto.CryptoApproveAllowanceTransactionBody.encode(m6.cryptoApproveAllowance, w5.uint32(386).fork()).ldelim();
          if (m6.cryptoDeleteAllowance != null && Object.hasOwnProperty.call(m6, "cryptoDeleteAllowance")) $root.proto.CryptoDeleteAllowanceTransactionBody.encode(m6.cryptoDeleteAllowance, w5.uint32(394).fork()).ldelim();
          if (m6.ethereumTransaction != null && Object.hasOwnProperty.call(m6, "ethereumTransaction")) $root.proto.EthereumTransactionBody.encode(m6.ethereumTransaction, w5.uint32(402).fork()).ldelim();
          if (m6.nodeStakeUpdate != null && Object.hasOwnProperty.call(m6, "nodeStakeUpdate")) $root.proto.NodeStakeUpdateTransactionBody.encode(m6.nodeStakeUpdate, w5.uint32(410).fork()).ldelim();
          if (m6.utilPrng != null && Object.hasOwnProperty.call(m6, "utilPrng")) $root.proto.UtilPrngTransactionBody.encode(m6.utilPrng, w5.uint32(418).fork()).ldelim();
          if (m6.tokenUpdateNfts != null && Object.hasOwnProperty.call(m6, "tokenUpdateNfts")) $root.proto.TokenUpdateNftsTransactionBody.encode(m6.tokenUpdateNfts, w5.uint32(426).fork()).ldelim();
          if (m6.nodeCreate != null && Object.hasOwnProperty.call(m6, "nodeCreate")) $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.encode(m6.nodeCreate, w5.uint32(434).fork()).ldelim();
          if (m6.nodeUpdate != null && Object.hasOwnProperty.call(m6, "nodeUpdate")) $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.encode(m6.nodeUpdate, w5.uint32(442).fork()).ldelim();
          if (m6.nodeDelete != null && Object.hasOwnProperty.call(m6, "nodeDelete")) $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.encode(m6.nodeDelete, w5.uint32(450).fork()).ldelim();
          if (m6.tokenReject != null && Object.hasOwnProperty.call(m6, "tokenReject")) $root.proto.TokenRejectTransactionBody.encode(m6.tokenReject, w5.uint32(458).fork()).ldelim();
          if (m6.tokenAirdrop != null && Object.hasOwnProperty.call(m6, "tokenAirdrop")) $root.proto.TokenAirdropTransactionBody.encode(m6.tokenAirdrop, w5.uint32(466).fork()).ldelim();
          if (m6.tokenCancelAirdrop != null && Object.hasOwnProperty.call(m6, "tokenCancelAirdrop")) $root.proto.TokenCancelAirdropTransactionBody.encode(m6.tokenCancelAirdrop, w5.uint32(474).fork()).ldelim();
          if (m6.tokenClaimAirdrop != null && Object.hasOwnProperty.call(m6, "tokenClaimAirdrop")) $root.proto.TokenClaimAirdropTransactionBody.encode(m6.tokenClaimAirdrop, w5.uint32(482).fork()).ldelim();
          if (m6.stateSignatureTransaction != null && Object.hasOwnProperty.call(m6, "stateSignatureTransaction")) $root.com.hedera.hapi.platform.event.StateSignatureTransaction.encode(m6.stateSignatureTransaction, w5.uint32(522).fork()).ldelim();
          if (m6.hintsPreprocessingVote != null && Object.hasOwnProperty.call(m6, "hintsPreprocessingVote")) $root.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody.encode(m6.hintsPreprocessingVote, w5.uint32(530).fork()).ldelim();
          if (m6.hintsKeyPublication != null && Object.hasOwnProperty.call(m6, "hintsKeyPublication")) $root.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody.encode(m6.hintsKeyPublication, w5.uint32(538).fork()).ldelim();
          if (m6.hintsPartialSignature != null && Object.hasOwnProperty.call(m6, "hintsPartialSignature")) $root.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody.encode(m6.hintsPartialSignature, w5.uint32(546).fork()).ldelim();
          if (m6.historyProofSignature != null && Object.hasOwnProperty.call(m6, "historyProofSignature")) $root.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody.encode(m6.historyProofSignature, w5.uint32(554).fork()).ldelim();
          if (m6.historyProofKeyPublication != null && Object.hasOwnProperty.call(m6, "historyProofKeyPublication")) $root.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody.encode(m6.historyProofKeyPublication, w5.uint32(562).fork()).ldelim();
          if (m6.historyProofVote != null && Object.hasOwnProperty.call(m6, "historyProofVote")) $root.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody.encode(m6.historyProofVote, w5.uint32(570).fork()).ldelim();
          if (m6.crsPublication != null && Object.hasOwnProperty.call(m6, "crsPublication")) $root.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody.encode(m6.crsPublication, w5.uint32(578).fork()).ldelim();
          if (m6.batchKey != null && Object.hasOwnProperty.call(m6, "batchKey")) $root.proto.Key.encode(m6.batchKey, w5.uint32(586).fork()).ldelim();
          if (m6.atomicBatch != null && Object.hasOwnProperty.call(m6, "atomicBatch")) $root.proto.AtomicBatchTransactionBody.encode(m6.atomicBatch, w5.uint32(594).fork()).ldelim();
          if (m6.maxCustomFees != null && m6.maxCustomFees.length) {
            for (var i17 = 0; i17 < m6.maxCustomFees.length; ++i17) $root.proto.CustomFeeLimit.encode(m6.maxCustomFees[i17], w5.uint32(8010).fork()).ldelim();
          }
          return w5;
        };
        TransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.transactionID = $root.proto.TransactionID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.nodeAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.transactionFee = r41.uint64();
                break;
              }
              case 4: {
                m6.transactionValidDuration = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.generateRecord = r41.bool();
                break;
              }
              case 6: {
                m6.memo = r41.string();
                break;
              }
              case 73: {
                m6.batchKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.contractCall = $root.proto.ContractCallTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.cryptoAddLiveHash = $root.proto.CryptoAddLiveHashTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.cryptoDeleteLiveHash = $root.proto.CryptoDeleteLiveHashTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                m6.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 15: {
                m6.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.fileAppend = $root.proto.FileAppendTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 17: {
                m6.fileCreate = $root.proto.FileCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 18: {
                m6.fileDelete = $root.proto.FileDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 19: {
                m6.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 20: {
                m6.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 21: {
                m6.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 22: {
                m6.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 23: {
                m6.freeze = $root.proto.FreezeTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 24: {
                m6.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 25: {
                m6.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 26: {
                m6.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 27: {
                m6.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 28: {
                m6.uncheckedSubmit = $root.proto.UncheckedSubmitBody.decode(r41, r41.uint32());
                break;
              }
              case 29: {
                m6.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 31: {
                m6.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 32: {
                m6.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 33: {
                m6.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 34: {
                m6.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 35: {
                m6.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 36: {
                m6.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 37: {
                m6.tokenMint = $root.proto.TokenMintTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 38: {
                m6.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 39: {
                m6.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 40: {
                m6.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 41: {
                m6.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 42: {
                m6.scheduleCreate = $root.proto.ScheduleCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 43: {
                m6.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 44: {
                m6.scheduleSign = $root.proto.ScheduleSignTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 45: {
                m6.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 46: {
                m6.tokenPause = $root.proto.TokenPauseTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 47: {
                m6.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 48: {
                m6.cryptoApproveAllowance = $root.proto.CryptoApproveAllowanceTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 49: {
                m6.cryptoDeleteAllowance = $root.proto.CryptoDeleteAllowanceTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 50: {
                m6.ethereumTransaction = $root.proto.EthereumTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 51: {
                m6.nodeStakeUpdate = $root.proto.NodeStakeUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 52: {
                m6.utilPrng = $root.proto.UtilPrngTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 53: {
                m6.tokenUpdateNfts = $root.proto.TokenUpdateNftsTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 54: {
                m6.nodeCreate = $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 55: {
                m6.nodeUpdate = $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 56: {
                m6.nodeDelete = $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 57: {
                m6.tokenReject = $root.proto.TokenRejectTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 58: {
                m6.tokenAirdrop = $root.proto.TokenAirdropTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 59: {
                m6.tokenCancelAirdrop = $root.proto.TokenCancelAirdropTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 60: {
                m6.tokenClaimAirdrop = $root.proto.TokenClaimAirdropTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 65: {
                m6.stateSignatureTransaction = $root.com.hedera.hapi.platform.event.StateSignatureTransaction.decode(r41, r41.uint32());
                break;
              }
              case 66: {
                m6.hintsPreprocessingVote = $root.com.hedera.hapi.services.auxiliary.hints.HintsPreprocessingVoteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 67: {
                m6.hintsKeyPublication = $root.com.hedera.hapi.services.auxiliary.hints.HintsKeyPublicationTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 68: {
                m6.hintsPartialSignature = $root.com.hedera.hapi.services.auxiliary.hints.HintsPartialSignatureTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 69: {
                m6.historyProofSignature = $root.com.hedera.hapi.services.auxiliary.history.HistoryProofSignatureTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 70: {
                m6.historyProofKeyPublication = $root.com.hedera.hapi.services.auxiliary.history.HistoryProofKeyPublicationTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 71: {
                m6.historyProofVote = $root.com.hedera.hapi.services.auxiliary.history.HistoryProofVoteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 72: {
                m6.crsPublication = $root.com.hedera.hapi.services.auxiliary.hints.CrsPublicationTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 74: {
                m6.atomicBatch = $root.proto.AtomicBatchTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 1001: {
                if (!(m6.maxCustomFees && m6.maxCustomFees.length)) m6.maxCustomFees = [];
                m6.maxCustomFees.push($root.proto.CustomFeeLimit.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionBody";
        };
        return TransactionBody;
      })();
      proto37.AtomicBatchTransactionBody = (function() {
        function AtomicBatchTransactionBody(p3) {
          this.transactions = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        AtomicBatchTransactionBody.prototype.transactions = $util.emptyArray;
        AtomicBatchTransactionBody.create = function create(properties) {
          return new AtomicBatchTransactionBody(properties);
        };
        AtomicBatchTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transactions != null && m6.transactions.length) {
            for (var i17 = 0; i17 < m6.transactions.length; ++i17) w5.uint32(10).bytes(m6.transactions[i17]);
          }
          return w5;
        };
        AtomicBatchTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.AtomicBatchTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.transactions && m6.transactions.length)) m6.transactions = [];
                m6.transactions.push(r41.bytes());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        AtomicBatchTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.AtomicBatchTransactionBody";
        };
        return AtomicBatchTransactionBody;
      })();
      proto37.ShardID = (function() {
        function ShardID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ShardID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ShardID.create = function create(properties) {
          return new ShardID(properties);
        };
        ShardID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.shardNum != null && Object.hasOwnProperty.call(m6, "shardNum")) w5.uint32(8).int64(m6.shardNum);
          return w5;
        };
        ShardID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ShardID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.shardNum = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ShardID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ShardID";
        };
        return ShardID;
      })();
      proto37.RealmID = (function() {
        function RealmID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        RealmID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        RealmID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        RealmID.create = function create(properties) {
          return new RealmID(properties);
        };
        RealmID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.shardNum != null && Object.hasOwnProperty.call(m6, "shardNum")) w5.uint32(8).int64(m6.shardNum);
          if (m6.realmNum != null && Object.hasOwnProperty.call(m6, "realmNum")) w5.uint32(16).int64(m6.realmNum);
          return w5;
        };
        RealmID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.RealmID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.shardNum = r41.int64();
                break;
              }
              case 2: {
                m6.realmNum = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        RealmID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.RealmID";
        };
        return RealmID;
      })();
      proto37.TokenID = (function() {
        function TokenID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenID.prototype.tokenNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenID.create = function create(properties) {
          return new TokenID(properties);
        };
        TokenID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.shardNum != null && Object.hasOwnProperty.call(m6, "shardNum")) w5.uint32(8).int64(m6.shardNum);
          if (m6.realmNum != null && Object.hasOwnProperty.call(m6, "realmNum")) w5.uint32(16).int64(m6.realmNum);
          if (m6.tokenNum != null && Object.hasOwnProperty.call(m6, "tokenNum")) w5.uint32(24).int64(m6.tokenNum);
          return w5;
        };
        TokenID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.shardNum = r41.int64();
                break;
              }
              case 2: {
                m6.realmNum = r41.int64();
                break;
              }
              case 3: {
                m6.tokenNum = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenID";
        };
        return TokenID;
      })();
      proto37.BlockHashAlgorithm = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SHA2_384"] = 0;
        return values;
      })();
      proto37.AccountID = (function() {
        function AccountID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        AccountID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AccountID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AccountID.prototype.accountNum = null;
        AccountID.prototype.alias = null;
        let $oneOfFields;
        Object.defineProperty(AccountID.prototype, "account", { get: $util.oneOfGetter($oneOfFields = ["accountNum", "alias"]), set: $util.oneOfSetter($oneOfFields) });
        AccountID.create = function create(properties) {
          return new AccountID(properties);
        };
        AccountID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.shardNum != null && Object.hasOwnProperty.call(m6, "shardNum")) w5.uint32(8).int64(m6.shardNum);
          if (m6.realmNum != null && Object.hasOwnProperty.call(m6, "realmNum")) w5.uint32(16).int64(m6.realmNum);
          if (m6.accountNum != null && Object.hasOwnProperty.call(m6, "accountNum")) w5.uint32(24).int64(m6.accountNum);
          if (m6.alias != null && Object.hasOwnProperty.call(m6, "alias")) w5.uint32(34).bytes(m6.alias);
          return w5;
        };
        AccountID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.AccountID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.shardNum = r41.int64();
                break;
              }
              case 2: {
                m6.realmNum = r41.int64();
                break;
              }
              case 3: {
                m6.accountNum = r41.int64();
                break;
              }
              case 4: {
                m6.alias = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        AccountID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.AccountID";
        };
        return AccountID;
      })();
      proto37.NftID = (function() {
        function NftID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NftID.prototype.token_ID = null;
        NftID.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NftID.create = function create(properties) {
          return new NftID(properties);
        };
        NftID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token_ID != null && Object.hasOwnProperty.call(m6, "token_ID")) $root.proto.TokenID.encode(m6.token_ID, w5.uint32(10).fork()).ldelim();
          if (m6.serialNumber != null && Object.hasOwnProperty.call(m6, "serialNumber")) w5.uint32(16).int64(m6.serialNumber);
          return w5;
        };
        NftID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NftID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token_ID = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.serialNumber = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NftID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NftID";
        };
        return NftID;
      })();
      proto37.FileID = (function() {
        function FileID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FileID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FileID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FileID.prototype.fileNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FileID.create = function create(properties) {
          return new FileID(properties);
        };
        FileID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.shardNum != null && Object.hasOwnProperty.call(m6, "shardNum")) w5.uint32(8).int64(m6.shardNum);
          if (m6.realmNum != null && Object.hasOwnProperty.call(m6, "realmNum")) w5.uint32(16).int64(m6.realmNum);
          if (m6.fileNum != null && Object.hasOwnProperty.call(m6, "fileNum")) w5.uint32(24).int64(m6.fileNum);
          return w5;
        };
        FileID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.shardNum = r41.int64();
                break;
              }
              case 2: {
                m6.realmNum = r41.int64();
                break;
              }
              case 3: {
                m6.fileNum = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FileID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FileID";
        };
        return FileID;
      })();
      proto37.ContractID = (function() {
        function ContractID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractID.prototype.contractNum = null;
        ContractID.prototype.evmAddress = null;
        let $oneOfFields;
        Object.defineProperty(ContractID.prototype, "contract", { get: $util.oneOfGetter($oneOfFields = ["contractNum", "evmAddress"]), set: $util.oneOfSetter($oneOfFields) });
        ContractID.create = function create(properties) {
          return new ContractID(properties);
        };
        ContractID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.shardNum != null && Object.hasOwnProperty.call(m6, "shardNum")) w5.uint32(8).int64(m6.shardNum);
          if (m6.realmNum != null && Object.hasOwnProperty.call(m6, "realmNum")) w5.uint32(16).int64(m6.realmNum);
          if (m6.contractNum != null && Object.hasOwnProperty.call(m6, "contractNum")) w5.uint32(24).int64(m6.contractNum);
          if (m6.evmAddress != null && Object.hasOwnProperty.call(m6, "evmAddress")) w5.uint32(34).bytes(m6.evmAddress);
          return w5;
        };
        ContractID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.shardNum = r41.int64();
                break;
              }
              case 2: {
                m6.realmNum = r41.int64();
                break;
              }
              case 3: {
                m6.contractNum = r41.int64();
                break;
              }
              case 4: {
                m6.evmAddress = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractID";
        };
        return ContractID;
      })();
      proto37.TopicID = (function() {
        function TopicID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TopicID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TopicID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TopicID.prototype.topicNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TopicID.create = function create(properties) {
          return new TopicID(properties);
        };
        TopicID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.shardNum != null && Object.hasOwnProperty.call(m6, "shardNum")) w5.uint32(8).int64(m6.shardNum);
          if (m6.realmNum != null && Object.hasOwnProperty.call(m6, "realmNum")) w5.uint32(16).int64(m6.realmNum);
          if (m6.topicNum != null && Object.hasOwnProperty.call(m6, "topicNum")) w5.uint32(24).int64(m6.topicNum);
          return w5;
        };
        TopicID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TopicID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.shardNum = r41.int64();
                break;
              }
              case 2: {
                m6.realmNum = r41.int64();
                break;
              }
              case 3: {
                m6.topicNum = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TopicID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TopicID";
        };
        return TopicID;
      })();
      proto37.ScheduleID = (function() {
        function ScheduleID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ScheduleID.prototype.shardNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ScheduleID.prototype.realmNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ScheduleID.prototype.scheduleNum = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ScheduleID.create = function create(properties) {
          return new ScheduleID(properties);
        };
        ScheduleID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.shardNum != null && Object.hasOwnProperty.call(m6, "shardNum")) w5.uint32(8).int64(m6.shardNum);
          if (m6.realmNum != null && Object.hasOwnProperty.call(m6, "realmNum")) w5.uint32(16).int64(m6.realmNum);
          if (m6.scheduleNum != null && Object.hasOwnProperty.call(m6, "scheduleNum")) w5.uint32(24).int64(m6.scheduleNum);
          return w5;
        };
        ScheduleID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ScheduleID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.shardNum = r41.int64();
                break;
              }
              case 2: {
                m6.realmNum = r41.int64();
                break;
              }
              case 3: {
                m6.scheduleNum = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ScheduleID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ScheduleID";
        };
        return ScheduleID;
      })();
      proto37.TransactionID = (function() {
        function TransactionID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionID.prototype.transactionValidStart = null;
        TransactionID.prototype.accountID = null;
        TransactionID.prototype.scheduled = false;
        TransactionID.prototype.nonce = 0;
        TransactionID.create = function create(properties) {
          return new TransactionID(properties);
        };
        TransactionID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transactionValidStart != null && Object.hasOwnProperty.call(m6, "transactionValidStart")) $root.proto.Timestamp.encode(m6.transactionValidStart, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          if (m6.scheduled != null && Object.hasOwnProperty.call(m6, "scheduled")) w5.uint32(24).bool(m6.scheduled);
          if (m6.nonce != null && Object.hasOwnProperty.call(m6, "nonce")) w5.uint32(32).int32(m6.nonce);
          return w5;
        };
        TransactionID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.transactionValidStart = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.scheduled = r41.bool();
                break;
              }
              case 4: {
                m6.nonce = r41.int32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionID";
        };
        return TransactionID;
      })();
      proto37.AccountAmount = (function() {
        function AccountAmount(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        AccountAmount.prototype.accountID = null;
        AccountAmount.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AccountAmount.prototype.isApproval = false;
        AccountAmount.create = function create(properties) {
          return new AccountAmount(properties);
        };
        AccountAmount.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(10).fork()).ldelim();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(16).sint64(m6.amount);
          if (m6.isApproval != null && Object.hasOwnProperty.call(m6, "isApproval")) w5.uint32(24).bool(m6.isApproval);
          return w5;
        };
        AccountAmount.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.AccountAmount();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.amount = r41.sint64();
                break;
              }
              case 3: {
                m6.isApproval = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        AccountAmount.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.AccountAmount";
        };
        return AccountAmount;
      })();
      proto37.TransferList = (function() {
        function TransferList(p3) {
          this.accountAmounts = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransferList.prototype.accountAmounts = $util.emptyArray;
        TransferList.create = function create(properties) {
          return new TransferList(properties);
        };
        TransferList.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountAmounts != null && m6.accountAmounts.length) {
            for (var i17 = 0; i17 < m6.accountAmounts.length; ++i17) $root.proto.AccountAmount.encode(m6.accountAmounts[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        TransferList.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransferList();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.accountAmounts && m6.accountAmounts.length)) m6.accountAmounts = [];
                m6.accountAmounts.push($root.proto.AccountAmount.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransferList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransferList";
        };
        return TransferList;
      })();
      proto37.NftTransfer = (function() {
        function NftTransfer(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NftTransfer.prototype.senderAccountID = null;
        NftTransfer.prototype.receiverAccountID = null;
        NftTransfer.prototype.serialNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NftTransfer.prototype.isApproval = false;
        NftTransfer.create = function create(properties) {
          return new NftTransfer(properties);
        };
        NftTransfer.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.senderAccountID != null && Object.hasOwnProperty.call(m6, "senderAccountID")) $root.proto.AccountID.encode(m6.senderAccountID, w5.uint32(10).fork()).ldelim();
          if (m6.receiverAccountID != null && Object.hasOwnProperty.call(m6, "receiverAccountID")) $root.proto.AccountID.encode(m6.receiverAccountID, w5.uint32(18).fork()).ldelim();
          if (m6.serialNumber != null && Object.hasOwnProperty.call(m6, "serialNumber")) w5.uint32(24).int64(m6.serialNumber);
          if (m6.isApproval != null && Object.hasOwnProperty.call(m6, "isApproval")) w5.uint32(32).bool(m6.isApproval);
          return w5;
        };
        NftTransfer.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NftTransfer();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.senderAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.receiverAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.serialNumber = r41.int64();
                break;
              }
              case 4: {
                m6.isApproval = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NftTransfer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NftTransfer";
        };
        return NftTransfer;
      })();
      proto37.TokenTransferList = (function() {
        function TokenTransferList(p3) {
          this.transfers = [];
          this.nftTransfers = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenTransferList.prototype.token = null;
        TokenTransferList.prototype.transfers = $util.emptyArray;
        TokenTransferList.prototype.nftTransfers = $util.emptyArray;
        TokenTransferList.prototype.expectedDecimals = null;
        TokenTransferList.create = function create(properties) {
          return new TokenTransferList(properties);
        };
        TokenTransferList.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.transfers != null && m6.transfers.length) {
            for (var i17 = 0; i17 < m6.transfers.length; ++i17) $root.proto.AccountAmount.encode(m6.transfers[i17], w5.uint32(18).fork()).ldelim();
          }
          if (m6.nftTransfers != null && m6.nftTransfers.length) {
            for (var i17 = 0; i17 < m6.nftTransfers.length; ++i17) $root.proto.NftTransfer.encode(m6.nftTransfers[i17], w5.uint32(26).fork()).ldelim();
          }
          if (m6.expectedDecimals != null && Object.hasOwnProperty.call(m6, "expectedDecimals")) $root.google.protobuf.UInt32Value.encode(m6.expectedDecimals, w5.uint32(34).fork()).ldelim();
          return w5;
        };
        TokenTransferList.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenTransferList();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.transfers && m6.transfers.length)) m6.transfers = [];
                m6.transfers.push($root.proto.AccountAmount.decode(r41, r41.uint32()));
                break;
              }
              case 3: {
                if (!(m6.nftTransfers && m6.nftTransfers.length)) m6.nftTransfers = [];
                m6.nftTransfers.push($root.proto.NftTransfer.decode(r41, r41.uint32()));
                break;
              }
              case 4: {
                m6.expectedDecimals = $root.google.protobuf.UInt32Value.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenTransferList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenTransferList";
        };
        return TokenTransferList;
      })();
      proto37.Fraction = (function() {
        function Fraction(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        Fraction.prototype.numerator = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Fraction.prototype.denominator = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Fraction.create = function create(properties) {
          return new Fraction(properties);
        };
        Fraction.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.numerator != null && Object.hasOwnProperty.call(m6, "numerator")) w5.uint32(8).int64(m6.numerator);
          if (m6.denominator != null && Object.hasOwnProperty.call(m6, "denominator")) w5.uint32(16).int64(m6.denominator);
          return w5;
        };
        Fraction.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.Fraction();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.numerator = r41.int64();
                break;
              }
              case 2: {
                m6.denominator = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        Fraction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.Fraction";
        };
        return Fraction;
      })();
      proto37.TokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FUNGIBLE_COMMON"] = 0;
        values[valuesById[1] = "NON_FUNGIBLE_UNIQUE"] = 1;
        return values;
      })();
      proto37.SubType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT"] = 0;
        values[valuesById[1] = "TOKEN_FUNGIBLE_COMMON"] = 1;
        values[valuesById[2] = "TOKEN_NON_FUNGIBLE_UNIQUE"] = 2;
        values[valuesById[3] = "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES"] = 3;
        values[valuesById[4] = "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES"] = 4;
        values[valuesById[5] = "SCHEDULE_CREATE_CONTRACT_CALL"] = 5;
        values[valuesById[6] = "TOPIC_CREATE_WITH_CUSTOM_FEES"] = 6;
        values[valuesById[7] = "SUBMIT_MESSAGE_WITH_CUSTOM_FEES"] = 7;
        return values;
      })();
      proto37.TokenSupplyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INFINITE"] = 0;
        values[valuesById[1] = "FINITE"] = 1;
        return values;
      })();
      proto37.TokenKeyValidation = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FULL_VALIDATION"] = 0;
        values[valuesById[1] = "NO_VALIDATION"] = 1;
        return values;
      })();
      proto37.TokenFreezeStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FreezeNotApplicable"] = 0;
        values[valuesById[1] = "Frozen"] = 1;
        values[valuesById[2] = "Unfrozen"] = 2;
        return values;
      })();
      proto37.TokenKycStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "KycNotApplicable"] = 0;
        values[valuesById[1] = "Granted"] = 1;
        values[valuesById[2] = "Revoked"] = 2;
        return values;
      })();
      proto37.TokenPauseStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PauseNotApplicable"] = 0;
        values[valuesById[1] = "Paused"] = 1;
        values[valuesById[2] = "Unpaused"] = 2;
        return values;
      })();
      proto37.Key = (function() {
        function Key2(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        Key2.prototype.contractID = null;
        Key2.prototype.ed25519 = null;
        Key2.prototype.RSA_3072 = null;
        Key2.prototype.ECDSA_384 = null;
        Key2.prototype.thresholdKey = null;
        Key2.prototype.keyList = null;
        Key2.prototype.ECDSASecp256k1 = null;
        Key2.prototype.delegatableContractId = null;
        let $oneOfFields;
        Object.defineProperty(Key2.prototype, "key", { get: $util.oneOfGetter($oneOfFields = ["contractID", "ed25519", "RSA_3072", "ECDSA_384", "thresholdKey", "keyList", "ECDSASecp256k1", "delegatableContractId"]), set: $util.oneOfSetter($oneOfFields) });
        Key2.create = function create(properties) {
          return new Key2(properties);
        };
        Key2.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(10).fork()).ldelim();
          if (m6.ed25519 != null && Object.hasOwnProperty.call(m6, "ed25519")) w5.uint32(18).bytes(m6.ed25519);
          if (m6.RSA_3072 != null && Object.hasOwnProperty.call(m6, "RSA_3072")) w5.uint32(26).bytes(m6.RSA_3072);
          if (m6.ECDSA_384 != null && Object.hasOwnProperty.call(m6, "ECDSA_384")) w5.uint32(34).bytes(m6.ECDSA_384);
          if (m6.thresholdKey != null && Object.hasOwnProperty.call(m6, "thresholdKey")) $root.proto.ThresholdKey.encode(m6.thresholdKey, w5.uint32(42).fork()).ldelim();
          if (m6.keyList != null && Object.hasOwnProperty.call(m6, "keyList")) $root.proto.KeyList.encode(m6.keyList, w5.uint32(50).fork()).ldelim();
          if (m6.ECDSASecp256k1 != null && Object.hasOwnProperty.call(m6, "ECDSASecp256k1")) w5.uint32(58).bytes(m6.ECDSASecp256k1);
          if (m6.delegatableContractId != null && Object.hasOwnProperty.call(m6, "delegatableContractId")) $root.proto.ContractID.encode(m6.delegatableContractId, w5.uint32(66).fork()).ldelim();
          return w5;
        };
        Key2.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.Key();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.ed25519 = r41.bytes();
                break;
              }
              case 3: {
                m6.RSA_3072 = r41.bytes();
                break;
              }
              case 4: {
                m6.ECDSA_384 = r41.bytes();
                break;
              }
              case 5: {
                m6.thresholdKey = $root.proto.ThresholdKey.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.keyList = $root.proto.KeyList.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.ECDSASecp256k1 = r41.bytes();
                break;
              }
              case 8: {
                m6.delegatableContractId = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        Key2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.Key";
        };
        return Key2;
      })();
      proto37.ThresholdKey = (function() {
        function ThresholdKey(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ThresholdKey.prototype.threshold = 0;
        ThresholdKey.prototype.keys = null;
        ThresholdKey.create = function create(properties) {
          return new ThresholdKey(properties);
        };
        ThresholdKey.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.threshold != null && Object.hasOwnProperty.call(m6, "threshold")) w5.uint32(8).uint32(m6.threshold);
          if (m6.keys != null && Object.hasOwnProperty.call(m6, "keys")) $root.proto.KeyList.encode(m6.keys, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ThresholdKey.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ThresholdKey();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.threshold = r41.uint32();
                break;
              }
              case 2: {
                m6.keys = $root.proto.KeyList.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ThresholdKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ThresholdKey";
        };
        return ThresholdKey;
      })();
      proto37.KeyList = (function() {
        function KeyList2(p3) {
          this.keys = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        KeyList2.prototype.keys = $util.emptyArray;
        KeyList2.create = function create(properties) {
          return new KeyList2(properties);
        };
        KeyList2.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.keys != null && m6.keys.length) {
            for (var i17 = 0; i17 < m6.keys.length; ++i17) $root.proto.Key.encode(m6.keys[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        KeyList2.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.KeyList();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.keys && m6.keys.length)) m6.keys = [];
                m6.keys.push($root.proto.Key.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        KeyList2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.KeyList";
        };
        return KeyList2;
      })();
      proto37.Signature = (function() {
        function Signature(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        Signature.prototype.contract = null;
        Signature.prototype.ed25519 = null;
        Signature.prototype.RSA_3072 = null;
        Signature.prototype.ECDSA_384 = null;
        Signature.prototype.thresholdSignature = null;
        Signature.prototype.signatureList = null;
        let $oneOfFields;
        Object.defineProperty(Signature.prototype, "signature", { get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "thresholdSignature", "signatureList"]), set: $util.oneOfSetter($oneOfFields) });
        Signature.create = function create(properties) {
          return new Signature(properties);
        };
        Signature.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contract != null && Object.hasOwnProperty.call(m6, "contract")) w5.uint32(10).bytes(m6.contract);
          if (m6.ed25519 != null && Object.hasOwnProperty.call(m6, "ed25519")) w5.uint32(18).bytes(m6.ed25519);
          if (m6.RSA_3072 != null && Object.hasOwnProperty.call(m6, "RSA_3072")) w5.uint32(26).bytes(m6.RSA_3072);
          if (m6.ECDSA_384 != null && Object.hasOwnProperty.call(m6, "ECDSA_384")) w5.uint32(34).bytes(m6.ECDSA_384);
          if (m6.thresholdSignature != null && Object.hasOwnProperty.call(m6, "thresholdSignature")) $root.proto.ThresholdSignature.encode(m6.thresholdSignature, w5.uint32(42).fork()).ldelim();
          if (m6.signatureList != null && Object.hasOwnProperty.call(m6, "signatureList")) $root.proto.SignatureList.encode(m6.signatureList, w5.uint32(50).fork()).ldelim();
          return w5;
        };
        Signature.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.Signature();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contract = r41.bytes();
                break;
              }
              case 2: {
                m6.ed25519 = r41.bytes();
                break;
              }
              case 3: {
                m6.RSA_3072 = r41.bytes();
                break;
              }
              case 4: {
                m6.ECDSA_384 = r41.bytes();
                break;
              }
              case 5: {
                m6.thresholdSignature = $root.proto.ThresholdSignature.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.signatureList = $root.proto.SignatureList.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        Signature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.Signature";
        };
        return Signature;
      })();
      proto37.ThresholdSignature = (function() {
        function ThresholdSignature(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ThresholdSignature.prototype.sigs = null;
        ThresholdSignature.create = function create(properties) {
          return new ThresholdSignature(properties);
        };
        ThresholdSignature.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.sigs != null && Object.hasOwnProperty.call(m6, "sigs")) $root.proto.SignatureList.encode(m6.sigs, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ThresholdSignature.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ThresholdSignature();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 2: {
                m6.sigs = $root.proto.SignatureList.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ThresholdSignature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ThresholdSignature";
        };
        return ThresholdSignature;
      })();
      proto37.SignatureList = (function() {
        function SignatureList(p3) {
          this.sigs = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SignatureList.prototype.sigs = $util.emptyArray;
        SignatureList.create = function create(properties) {
          return new SignatureList(properties);
        };
        SignatureList.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.sigs != null && m6.sigs.length) {
            for (var i17 = 0; i17 < m6.sigs.length; ++i17) $root.proto.Signature.encode(m6.sigs[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        SignatureList.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SignatureList();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 2: {
                if (!(m6.sigs && m6.sigs.length)) m6.sigs = [];
                m6.sigs.push($root.proto.Signature.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SignatureList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SignatureList";
        };
        return SignatureList;
      })();
      proto37.SignaturePair = (function() {
        function SignaturePair(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SignaturePair.prototype.pubKeyPrefix = $util.newBuffer([]);
        SignaturePair.prototype.contract = null;
        SignaturePair.prototype.ed25519 = null;
        SignaturePair.prototype.RSA_3072 = null;
        SignaturePair.prototype.ECDSA_384 = null;
        SignaturePair.prototype.ECDSASecp256k1 = null;
        let $oneOfFields;
        Object.defineProperty(SignaturePair.prototype, "signature", { get: $util.oneOfGetter($oneOfFields = ["contract", "ed25519", "RSA_3072", "ECDSA_384", "ECDSASecp256k1"]), set: $util.oneOfSetter($oneOfFields) });
        SignaturePair.create = function create(properties) {
          return new SignaturePair(properties);
        };
        SignaturePair.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.pubKeyPrefix != null && Object.hasOwnProperty.call(m6, "pubKeyPrefix")) w5.uint32(10).bytes(m6.pubKeyPrefix);
          if (m6.contract != null && Object.hasOwnProperty.call(m6, "contract")) w5.uint32(18).bytes(m6.contract);
          if (m6.ed25519 != null && Object.hasOwnProperty.call(m6, "ed25519")) w5.uint32(26).bytes(m6.ed25519);
          if (m6.RSA_3072 != null && Object.hasOwnProperty.call(m6, "RSA_3072")) w5.uint32(34).bytes(m6.RSA_3072);
          if (m6.ECDSA_384 != null && Object.hasOwnProperty.call(m6, "ECDSA_384")) w5.uint32(42).bytes(m6.ECDSA_384);
          if (m6.ECDSASecp256k1 != null && Object.hasOwnProperty.call(m6, "ECDSASecp256k1")) w5.uint32(50).bytes(m6.ECDSASecp256k1);
          return w5;
        };
        SignaturePair.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SignaturePair();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.pubKeyPrefix = r41.bytes();
                break;
              }
              case 2: {
                m6.contract = r41.bytes();
                break;
              }
              case 3: {
                m6.ed25519 = r41.bytes();
                break;
              }
              case 4: {
                m6.RSA_3072 = r41.bytes();
                break;
              }
              case 5: {
                m6.ECDSA_384 = r41.bytes();
                break;
              }
              case 6: {
                m6.ECDSASecp256k1 = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SignaturePair.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SignaturePair";
        };
        return SignaturePair;
      })();
      proto37.SignatureMap = (function() {
        function SignatureMap(p3) {
          this.sigPair = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SignatureMap.prototype.sigPair = $util.emptyArray;
        SignatureMap.create = function create(properties) {
          return new SignatureMap(properties);
        };
        SignatureMap.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.sigPair != null && m6.sigPair.length) {
            for (var i17 = 0; i17 < m6.sigPair.length; ++i17) $root.proto.SignaturePair.encode(m6.sigPair[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        SignatureMap.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SignatureMap();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.sigPair && m6.sigPair.length)) m6.sigPair = [];
                m6.sigPair.push($root.proto.SignaturePair.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SignatureMap.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SignatureMap";
        };
        return SignatureMap;
      })();
      proto37.HederaFunctionality = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "CryptoTransfer"] = 1;
        values[valuesById[2] = "CryptoUpdate"] = 2;
        values[valuesById[3] = "CryptoDelete"] = 3;
        values[valuesById[4] = "CryptoAddLiveHash"] = 4;
        values[valuesById[5] = "CryptoDeleteLiveHash"] = 5;
        values[valuesById[6] = "ContractCall"] = 6;
        values[valuesById[7] = "ContractCreate"] = 7;
        values[valuesById[8] = "ContractUpdate"] = 8;
        values[valuesById[9] = "FileCreate"] = 9;
        values[valuesById[10] = "FileAppend"] = 10;
        values[valuesById[11] = "FileUpdate"] = 11;
        values[valuesById[12] = "FileDelete"] = 12;
        values[valuesById[13] = "CryptoGetAccountBalance"] = 13;
        values[valuesById[14] = "CryptoGetAccountRecords"] = 14;
        values[valuesById[15] = "CryptoGetInfo"] = 15;
        values[valuesById[16] = "ContractCallLocal"] = 16;
        values[valuesById[17] = "ContractGetInfo"] = 17;
        values[valuesById[18] = "ContractGetBytecode"] = 18;
        values[valuesById[19] = "GetBySolidityID"] = 19;
        values[valuesById[20] = "GetByKey"] = 20;
        values[valuesById[21] = "CryptoGetLiveHash"] = 21;
        values[valuesById[22] = "CryptoGetStakers"] = 22;
        values[valuesById[23] = "FileGetContents"] = 23;
        values[valuesById[24] = "FileGetInfo"] = 24;
        values[valuesById[25] = "TransactionGetRecord"] = 25;
        values[valuesById[26] = "ContractGetRecords"] = 26;
        values[valuesById[27] = "CryptoCreate"] = 27;
        values[valuesById[28] = "SystemDelete"] = 28;
        values[valuesById[29] = "SystemUndelete"] = 29;
        values[valuesById[30] = "ContractDelete"] = 30;
        values[valuesById[31] = "Freeze"] = 31;
        values[valuesById[32] = "CreateTransactionRecord"] = 32;
        values[valuesById[33] = "CryptoAccountAutoRenew"] = 33;
        values[valuesById[34] = "ContractAutoRenew"] = 34;
        values[valuesById[35] = "GetVersionInfo"] = 35;
        values[valuesById[36] = "TransactionGetReceipt"] = 36;
        values[valuesById[50] = "ConsensusCreateTopic"] = 50;
        values[valuesById[51] = "ConsensusUpdateTopic"] = 51;
        values[valuesById[52] = "ConsensusDeleteTopic"] = 52;
        values[valuesById[53] = "ConsensusGetTopicInfo"] = 53;
        values[valuesById[54] = "ConsensusSubmitMessage"] = 54;
        values[valuesById[55] = "UncheckedSubmit"] = 55;
        values[valuesById[56] = "TokenCreate"] = 56;
        values[valuesById[58] = "TokenGetInfo"] = 58;
        values[valuesById[59] = "TokenFreezeAccount"] = 59;
        values[valuesById[60] = "TokenUnfreezeAccount"] = 60;
        values[valuesById[61] = "TokenGrantKycToAccount"] = 61;
        values[valuesById[62] = "TokenRevokeKycFromAccount"] = 62;
        values[valuesById[63] = "TokenDelete"] = 63;
        values[valuesById[64] = "TokenUpdate"] = 64;
        values[valuesById[65] = "TokenMint"] = 65;
        values[valuesById[66] = "TokenBurn"] = 66;
        values[valuesById[67] = "TokenAccountWipe"] = 67;
        values[valuesById[68] = "TokenAssociateToAccount"] = 68;
        values[valuesById[69] = "TokenDissociateFromAccount"] = 69;
        values[valuesById[70] = "ScheduleCreate"] = 70;
        values[valuesById[71] = "ScheduleDelete"] = 71;
        values[valuesById[72] = "ScheduleSign"] = 72;
        values[valuesById[73] = "ScheduleGetInfo"] = 73;
        values[valuesById[74] = "TokenGetAccountNftInfos"] = 74;
        values[valuesById[75] = "TokenGetNftInfo"] = 75;
        values[valuesById[76] = "TokenGetNftInfos"] = 76;
        values[valuesById[77] = "TokenFeeScheduleUpdate"] = 77;
        values[valuesById[78] = "NetworkGetExecutionTime"] = 78;
        values[valuesById[79] = "TokenPause"] = 79;
        values[valuesById[80] = "TokenUnpause"] = 80;
        values[valuesById[81] = "CryptoApproveAllowance"] = 81;
        values[valuesById[82] = "CryptoDeleteAllowance"] = 82;
        values[valuesById[83] = "GetAccountDetails"] = 83;
        values[valuesById[84] = "EthereumTransaction"] = 84;
        values[valuesById[85] = "NodeStakeUpdate"] = 85;
        values[valuesById[86] = "UtilPrng"] = 86;
        values[valuesById[87] = "TransactionGetFastRecord"] = 87;
        values[valuesById[88] = "TokenUpdateNfts"] = 88;
        values[valuesById[89] = "NodeCreate"] = 89;
        values[valuesById[90] = "NodeUpdate"] = 90;
        values[valuesById[91] = "NodeDelete"] = 91;
        values[valuesById[92] = "TokenReject"] = 92;
        values[valuesById[93] = "TokenAirdrop"] = 93;
        values[valuesById[94] = "TokenCancelAirdrop"] = 94;
        values[valuesById[95] = "TokenClaimAirdrop"] = 95;
        values[valuesById[100] = "StateSignatureTransaction"] = 100;
        values[valuesById[101] = "HintsKeyPublication"] = 101;
        values[valuesById[102] = "HintsPreprocessingVote"] = 102;
        values[valuesById[103] = "HintsPartialSignature"] = 103;
        values[valuesById[104] = "HistoryAssemblySignature"] = 104;
        values[valuesById[105] = "HistoryProofKeyPublication"] = 105;
        values[valuesById[106] = "HistoryProofVote"] = 106;
        values[valuesById[107] = "CrsPublication"] = 107;
        values[valuesById[108] = "AtomicBatch"] = 108;
        return values;
      })();
      proto37.FeeComponents = (function() {
        function FeeComponents(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FeeComponents.prototype.min = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.max = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.constant = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.bpt = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.vpt = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.rbh = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.sbh = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.tv = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.bpr = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.prototype.sbpr = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FeeComponents.create = function create(properties) {
          return new FeeComponents(properties);
        };
        FeeComponents.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.min != null && Object.hasOwnProperty.call(m6, "min")) w5.uint32(8).int64(m6.min);
          if (m6.max != null && Object.hasOwnProperty.call(m6, "max")) w5.uint32(16).int64(m6.max);
          if (m6.constant != null && Object.hasOwnProperty.call(m6, "constant")) w5.uint32(24).int64(m6.constant);
          if (m6.bpt != null && Object.hasOwnProperty.call(m6, "bpt")) w5.uint32(32).int64(m6.bpt);
          if (m6.vpt != null && Object.hasOwnProperty.call(m6, "vpt")) w5.uint32(40).int64(m6.vpt);
          if (m6.rbh != null && Object.hasOwnProperty.call(m6, "rbh")) w5.uint32(48).int64(m6.rbh);
          if (m6.sbh != null && Object.hasOwnProperty.call(m6, "sbh")) w5.uint32(56).int64(m6.sbh);
          if (m6.gas != null && Object.hasOwnProperty.call(m6, "gas")) w5.uint32(64).int64(m6.gas);
          if (m6.tv != null && Object.hasOwnProperty.call(m6, "tv")) w5.uint32(72).int64(m6.tv);
          if (m6.bpr != null && Object.hasOwnProperty.call(m6, "bpr")) w5.uint32(80).int64(m6.bpr);
          if (m6.sbpr != null && Object.hasOwnProperty.call(m6, "sbpr")) w5.uint32(88).int64(m6.sbpr);
          return w5;
        };
        FeeComponents.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FeeComponents();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.min = r41.int64();
                break;
              }
              case 2: {
                m6.max = r41.int64();
                break;
              }
              case 3: {
                m6.constant = r41.int64();
                break;
              }
              case 4: {
                m6.bpt = r41.int64();
                break;
              }
              case 5: {
                m6.vpt = r41.int64();
                break;
              }
              case 6: {
                m6.rbh = r41.int64();
                break;
              }
              case 7: {
                m6.sbh = r41.int64();
                break;
              }
              case 8: {
                m6.gas = r41.int64();
                break;
              }
              case 9: {
                m6.tv = r41.int64();
                break;
              }
              case 10: {
                m6.bpr = r41.int64();
                break;
              }
              case 11: {
                m6.sbpr = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FeeComponents.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FeeComponents";
        };
        return FeeComponents;
      })();
      proto37.TransactionFeeSchedule = (function() {
        function TransactionFeeSchedule(p3) {
          this.fees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionFeeSchedule.prototype.hederaFunctionality = 0;
        TransactionFeeSchedule.prototype.feeData = null;
        TransactionFeeSchedule.prototype.fees = $util.emptyArray;
        TransactionFeeSchedule.create = function create(properties) {
          return new TransactionFeeSchedule(properties);
        };
        TransactionFeeSchedule.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.hederaFunctionality != null && Object.hasOwnProperty.call(m6, "hederaFunctionality")) w5.uint32(8).int32(m6.hederaFunctionality);
          if (m6.feeData != null && Object.hasOwnProperty.call(m6, "feeData")) $root.proto.FeeData.encode(m6.feeData, w5.uint32(18).fork()).ldelim();
          if (m6.fees != null && m6.fees.length) {
            for (var i17 = 0; i17 < m6.fees.length; ++i17) $root.proto.FeeData.encode(m6.fees[i17], w5.uint32(26).fork()).ldelim();
          }
          return w5;
        };
        TransactionFeeSchedule.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionFeeSchedule();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.hederaFunctionality = r41.int32();
                break;
              }
              case 2: {
                m6.feeData = $root.proto.FeeData.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                if (!(m6.fees && m6.fees.length)) m6.fees = [];
                m6.fees.push($root.proto.FeeData.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionFeeSchedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionFeeSchedule";
        };
        return TransactionFeeSchedule;
      })();
      proto37.FeeData = (function() {
        function FeeData(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FeeData.prototype.nodedata = null;
        FeeData.prototype.networkdata = null;
        FeeData.prototype.servicedata = null;
        FeeData.prototype.subType = 0;
        FeeData.create = function create(properties) {
          return new FeeData(properties);
        };
        FeeData.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.nodedata != null && Object.hasOwnProperty.call(m6, "nodedata")) $root.proto.FeeComponents.encode(m6.nodedata, w5.uint32(10).fork()).ldelim();
          if (m6.networkdata != null && Object.hasOwnProperty.call(m6, "networkdata")) $root.proto.FeeComponents.encode(m6.networkdata, w5.uint32(18).fork()).ldelim();
          if (m6.servicedata != null && Object.hasOwnProperty.call(m6, "servicedata")) $root.proto.FeeComponents.encode(m6.servicedata, w5.uint32(26).fork()).ldelim();
          if (m6.subType != null && Object.hasOwnProperty.call(m6, "subType")) w5.uint32(32).int32(m6.subType);
          return w5;
        };
        FeeData.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FeeData();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.nodedata = $root.proto.FeeComponents.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.networkdata = $root.proto.FeeComponents.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.servicedata = $root.proto.FeeComponents.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.subType = r41.int32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FeeData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FeeData";
        };
        return FeeData;
      })();
      proto37.FeeSchedule = (function() {
        function FeeSchedule(p3) {
          this.transactionFeeSchedule = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FeeSchedule.prototype.transactionFeeSchedule = $util.emptyArray;
        FeeSchedule.prototype.expiryTime = null;
        FeeSchedule.create = function create(properties) {
          return new FeeSchedule(properties);
        };
        FeeSchedule.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transactionFeeSchedule != null && m6.transactionFeeSchedule.length) {
            for (var i17 = 0; i17 < m6.transactionFeeSchedule.length; ++i17) $root.proto.TransactionFeeSchedule.encode(m6.transactionFeeSchedule[i17], w5.uint32(10).fork()).ldelim();
          }
          if (m6.expiryTime != null && Object.hasOwnProperty.call(m6, "expiryTime")) $root.proto.TimestampSeconds.encode(m6.expiryTime, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        FeeSchedule.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FeeSchedule();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.transactionFeeSchedule && m6.transactionFeeSchedule.length)) m6.transactionFeeSchedule = [];
                m6.transactionFeeSchedule.push($root.proto.TransactionFeeSchedule.decode(r41, r41.uint32()));
                break;
              }
              case 2: {
                m6.expiryTime = $root.proto.TimestampSeconds.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FeeSchedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FeeSchedule";
        };
        return FeeSchedule;
      })();
      proto37.CurrentAndNextFeeSchedule = (function() {
        function CurrentAndNextFeeSchedule(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CurrentAndNextFeeSchedule.prototype.currentFeeSchedule = null;
        CurrentAndNextFeeSchedule.prototype.nextFeeSchedule = null;
        CurrentAndNextFeeSchedule.create = function create(properties) {
          return new CurrentAndNextFeeSchedule(properties);
        };
        CurrentAndNextFeeSchedule.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.currentFeeSchedule != null && Object.hasOwnProperty.call(m6, "currentFeeSchedule")) $root.proto.FeeSchedule.encode(m6.currentFeeSchedule, w5.uint32(10).fork()).ldelim();
          if (m6.nextFeeSchedule != null && Object.hasOwnProperty.call(m6, "nextFeeSchedule")) $root.proto.FeeSchedule.encode(m6.nextFeeSchedule, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        CurrentAndNextFeeSchedule.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CurrentAndNextFeeSchedule();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.currentFeeSchedule = $root.proto.FeeSchedule.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.nextFeeSchedule = $root.proto.FeeSchedule.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CurrentAndNextFeeSchedule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CurrentAndNextFeeSchedule";
        };
        return CurrentAndNextFeeSchedule;
      })();
      proto37.ServiceEndpoint = (function() {
        function ServiceEndpoint(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ServiceEndpoint.prototype.ipAddressV4 = $util.newBuffer([]);
        ServiceEndpoint.prototype.port = 0;
        ServiceEndpoint.prototype.domainName = "";
        ServiceEndpoint.create = function create(properties) {
          return new ServiceEndpoint(properties);
        };
        ServiceEndpoint.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.ipAddressV4 != null && Object.hasOwnProperty.call(m6, "ipAddressV4")) w5.uint32(10).bytes(m6.ipAddressV4);
          if (m6.port != null && Object.hasOwnProperty.call(m6, "port")) w5.uint32(16).int32(m6.port);
          if (m6.domainName != null && Object.hasOwnProperty.call(m6, "domainName")) w5.uint32(26).string(m6.domainName);
          return w5;
        };
        ServiceEndpoint.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ServiceEndpoint();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.ipAddressV4 = r41.bytes();
                break;
              }
              case 2: {
                m6.port = r41.int32();
                break;
              }
              case 3: {
                m6.domainName = r41.string();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ServiceEndpoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ServiceEndpoint";
        };
        return ServiceEndpoint;
      })();
      proto37.NodeAddress = (function() {
        function NodeAddress(p3) {
          this.serviceEndpoint = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NodeAddress.prototype.ipAddress = $util.newBuffer([]);
        NodeAddress.prototype.portno = 0;
        NodeAddress.prototype.memo = $util.newBuffer([]);
        NodeAddress.prototype.RSA_PubKey = "";
        NodeAddress.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeAddress.prototype.nodeAccountId = null;
        NodeAddress.prototype.nodeCertHash = $util.newBuffer([]);
        NodeAddress.prototype.serviceEndpoint = $util.emptyArray;
        NodeAddress.prototype.description = "";
        NodeAddress.prototype.stake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeAddress.create = function create(properties) {
          return new NodeAddress(properties);
        };
        NodeAddress.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.ipAddress != null && Object.hasOwnProperty.call(m6, "ipAddress")) w5.uint32(10).bytes(m6.ipAddress);
          if (m6.portno != null && Object.hasOwnProperty.call(m6, "portno")) w5.uint32(16).int32(m6.portno);
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(26).bytes(m6.memo);
          if (m6.RSA_PubKey != null && Object.hasOwnProperty.call(m6, "RSA_PubKey")) w5.uint32(34).string(m6.RSA_PubKey);
          if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(40).int64(m6.nodeId);
          if (m6.nodeAccountId != null && Object.hasOwnProperty.call(m6, "nodeAccountId")) $root.proto.AccountID.encode(m6.nodeAccountId, w5.uint32(50).fork()).ldelim();
          if (m6.nodeCertHash != null && Object.hasOwnProperty.call(m6, "nodeCertHash")) w5.uint32(58).bytes(m6.nodeCertHash);
          if (m6.serviceEndpoint != null && m6.serviceEndpoint.length) {
            for (var i17 = 0; i17 < m6.serviceEndpoint.length; ++i17) $root.proto.ServiceEndpoint.encode(m6.serviceEndpoint[i17], w5.uint32(66).fork()).ldelim();
          }
          if (m6.description != null && Object.hasOwnProperty.call(m6, "description")) w5.uint32(74).string(m6.description);
          if (m6.stake != null && Object.hasOwnProperty.call(m6, "stake")) w5.uint32(80).int64(m6.stake);
          return w5;
        };
        NodeAddress.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NodeAddress();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.ipAddress = r41.bytes();
                break;
              }
              case 2: {
                m6.portno = r41.int32();
                break;
              }
              case 3: {
                m6.memo = r41.bytes();
                break;
              }
              case 4: {
                m6.RSA_PubKey = r41.string();
                break;
              }
              case 5: {
                m6.nodeId = r41.int64();
                break;
              }
              case 6: {
                m6.nodeAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.nodeCertHash = r41.bytes();
                break;
              }
              case 8: {
                if (!(m6.serviceEndpoint && m6.serviceEndpoint.length)) m6.serviceEndpoint = [];
                m6.serviceEndpoint.push($root.proto.ServiceEndpoint.decode(r41, r41.uint32()));
                break;
              }
              case 9: {
                m6.description = r41.string();
                break;
              }
              case 10: {
                m6.stake = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NodeAddress.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NodeAddress";
        };
        return NodeAddress;
      })();
      proto37.NodeAddressBook = (function() {
        function NodeAddressBook(p3) {
          this.nodeAddress = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NodeAddressBook.prototype.nodeAddress = $util.emptyArray;
        NodeAddressBook.create = function create(properties) {
          return new NodeAddressBook(properties);
        };
        NodeAddressBook.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.nodeAddress != null && m6.nodeAddress.length) {
            for (var i17 = 0; i17 < m6.nodeAddress.length; ++i17) $root.proto.NodeAddress.encode(m6.nodeAddress[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        NodeAddressBook.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NodeAddressBook();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.nodeAddress && m6.nodeAddress.length)) m6.nodeAddress = [];
                m6.nodeAddress.push($root.proto.NodeAddress.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NodeAddressBook.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NodeAddressBook";
        };
        return NodeAddressBook;
      })();
      proto37.SemanticVersion = (function() {
        function SemanticVersion(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SemanticVersion.prototype.major = 0;
        SemanticVersion.prototype.minor = 0;
        SemanticVersion.prototype.patch = 0;
        SemanticVersion.prototype.pre = "";
        SemanticVersion.prototype.build = "";
        SemanticVersion.create = function create(properties) {
          return new SemanticVersion(properties);
        };
        SemanticVersion.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.major != null && Object.hasOwnProperty.call(m6, "major")) w5.uint32(8).int32(m6.major);
          if (m6.minor != null && Object.hasOwnProperty.call(m6, "minor")) w5.uint32(16).int32(m6.minor);
          if (m6.patch != null && Object.hasOwnProperty.call(m6, "patch")) w5.uint32(24).int32(m6.patch);
          if (m6.pre != null && Object.hasOwnProperty.call(m6, "pre")) w5.uint32(34).string(m6.pre);
          if (m6.build != null && Object.hasOwnProperty.call(m6, "build")) w5.uint32(42).string(m6.build);
          return w5;
        };
        SemanticVersion.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SemanticVersion();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.major = r41.int32();
                break;
              }
              case 2: {
                m6.minor = r41.int32();
                break;
              }
              case 3: {
                m6.patch = r41.int32();
                break;
              }
              case 4: {
                m6.pre = r41.string();
                break;
              }
              case 5: {
                m6.build = r41.string();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SemanticVersion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SemanticVersion";
        };
        return SemanticVersion;
      })();
      proto37.Setting = (function() {
        function Setting(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        Setting.prototype.name = "";
        Setting.prototype.value = "";
        Setting.prototype.data = $util.newBuffer([]);
        Setting.create = function create(properties) {
          return new Setting(properties);
        };
        Setting.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.name != null && Object.hasOwnProperty.call(m6, "name")) w5.uint32(10).string(m6.name);
          if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(18).string(m6.value);
          if (m6.data != null && Object.hasOwnProperty.call(m6, "data")) w5.uint32(26).bytes(m6.data);
          return w5;
        };
        Setting.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.Setting();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.name = r41.string();
                break;
              }
              case 2: {
                m6.value = r41.string();
                break;
              }
              case 3: {
                m6.data = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        Setting.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.Setting";
        };
        return Setting;
      })();
      proto37.ServicesConfigurationList = (function() {
        function ServicesConfigurationList(p3) {
          this.nameValue = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ServicesConfigurationList.prototype.nameValue = $util.emptyArray;
        ServicesConfigurationList.create = function create(properties) {
          return new ServicesConfigurationList(properties);
        };
        ServicesConfigurationList.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.nameValue != null && m6.nameValue.length) {
            for (var i17 = 0; i17 < m6.nameValue.length; ++i17) $root.proto.Setting.encode(m6.nameValue[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        ServicesConfigurationList.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ServicesConfigurationList();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.nameValue && m6.nameValue.length)) m6.nameValue = [];
                m6.nameValue.push($root.proto.Setting.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ServicesConfigurationList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ServicesConfigurationList";
        };
        return ServicesConfigurationList;
      })();
      proto37.TokenRelationship = (function() {
        function TokenRelationship(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenRelationship.prototype.tokenId = null;
        TokenRelationship.prototype.symbol = "";
        TokenRelationship.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TokenRelationship.prototype.kycStatus = 0;
        TokenRelationship.prototype.freezeStatus = 0;
        TokenRelationship.prototype.decimals = 0;
        TokenRelationship.prototype.automaticAssociation = false;
        TokenRelationship.create = function create(properties) {
          return new TokenRelationship(properties);
        };
        TokenRelationship.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.symbol != null && Object.hasOwnProperty.call(m6, "symbol")) w5.uint32(18).string(m6.symbol);
          if (m6.balance != null && Object.hasOwnProperty.call(m6, "balance")) w5.uint32(24).uint64(m6.balance);
          if (m6.kycStatus != null && Object.hasOwnProperty.call(m6, "kycStatus")) w5.uint32(32).int32(m6.kycStatus);
          if (m6.freezeStatus != null && Object.hasOwnProperty.call(m6, "freezeStatus")) w5.uint32(40).int32(m6.freezeStatus);
          if (m6.decimals != null && Object.hasOwnProperty.call(m6, "decimals")) w5.uint32(48).uint32(m6.decimals);
          if (m6.automaticAssociation != null && Object.hasOwnProperty.call(m6, "automaticAssociation")) w5.uint32(56).bool(m6.automaticAssociation);
          return w5;
        };
        TokenRelationship.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenRelationship();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.symbol = r41.string();
                break;
              }
              case 3: {
                m6.balance = r41.uint64();
                break;
              }
              case 4: {
                m6.kycStatus = r41.int32();
                break;
              }
              case 5: {
                m6.freezeStatus = r41.int32();
                break;
              }
              case 6: {
                m6.decimals = r41.uint32();
                break;
              }
              case 7: {
                m6.automaticAssociation = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenRelationship.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenRelationship";
        };
        return TokenRelationship;
      })();
      proto37.TokenBalance = (function() {
        function TokenBalance(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenBalance.prototype.tokenId = null;
        TokenBalance.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TokenBalance.prototype.decimals = 0;
        TokenBalance.create = function create(properties) {
          return new TokenBalance(properties);
        };
        TokenBalance.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.balance != null && Object.hasOwnProperty.call(m6, "balance")) w5.uint32(16).uint64(m6.balance);
          if (m6.decimals != null && Object.hasOwnProperty.call(m6, "decimals")) w5.uint32(24).uint32(m6.decimals);
          return w5;
        };
        TokenBalance.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenBalance();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.balance = r41.uint64();
                break;
              }
              case 3: {
                m6.decimals = r41.uint32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenBalance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenBalance";
        };
        return TokenBalance;
      })();
      proto37.TokenBalances = (function() {
        function TokenBalances(p3) {
          this.tokenBalances = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenBalances.prototype.tokenBalances = $util.emptyArray;
        TokenBalances.create = function create(properties) {
          return new TokenBalances(properties);
        };
        TokenBalances.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenBalances != null && m6.tokenBalances.length) {
            for (var i17 = 0; i17 < m6.tokenBalances.length; ++i17) $root.proto.TokenBalance.encode(m6.tokenBalances[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        TokenBalances.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenBalances();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.tokenBalances && m6.tokenBalances.length)) m6.tokenBalances = [];
                m6.tokenBalances.push($root.proto.TokenBalance.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenBalances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenBalances";
        };
        return TokenBalances;
      })();
      proto37.TokenAssociation = (function() {
        function TokenAssociation(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenAssociation.prototype.tokenId = null;
        TokenAssociation.prototype.accountId = null;
        TokenAssociation.create = function create(properties) {
          return new TokenAssociation(properties);
        };
        TokenAssociation.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.accountId != null && Object.hasOwnProperty.call(m6, "accountId")) $root.proto.AccountID.encode(m6.accountId, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenAssociation.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenAssociation();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenAssociation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenAssociation";
        };
        return TokenAssociation;
      })();
      proto37.StakingInfo = (function() {
        function StakingInfo(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        StakingInfo.prototype.declineReward = false;
        StakingInfo.prototype.stakePeriodStart = null;
        StakingInfo.prototype.pendingReward = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        StakingInfo.prototype.stakedToMe = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        StakingInfo.prototype.stakedAccountId = null;
        StakingInfo.prototype.stakedNodeId = null;
        let $oneOfFields;
        Object.defineProperty(StakingInfo.prototype, "stakedId", { get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter($oneOfFields) });
        StakingInfo.create = function create(properties) {
          return new StakingInfo(properties);
        };
        StakingInfo.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.declineReward != null && Object.hasOwnProperty.call(m6, "declineReward")) w5.uint32(8).bool(m6.declineReward);
          if (m6.stakePeriodStart != null && Object.hasOwnProperty.call(m6, "stakePeriodStart")) $root.proto.Timestamp.encode(m6.stakePeriodStart, w5.uint32(18).fork()).ldelim();
          if (m6.pendingReward != null && Object.hasOwnProperty.call(m6, "pendingReward")) w5.uint32(24).int64(m6.pendingReward);
          if (m6.stakedToMe != null && Object.hasOwnProperty.call(m6, "stakedToMe")) w5.uint32(32).int64(m6.stakedToMe);
          if (m6.stakedAccountId != null && Object.hasOwnProperty.call(m6, "stakedAccountId")) $root.proto.AccountID.encode(m6.stakedAccountId, w5.uint32(42).fork()).ldelim();
          if (m6.stakedNodeId != null && Object.hasOwnProperty.call(m6, "stakedNodeId")) w5.uint32(48).int64(m6.stakedNodeId);
          return w5;
        };
        StakingInfo.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.StakingInfo();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.declineReward = r41.bool();
                break;
              }
              case 2: {
                m6.stakePeriodStart = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.pendingReward = r41.int64();
                break;
              }
              case 4: {
                m6.stakedToMe = r41.int64();
                break;
              }
              case 5: {
                m6.stakedAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.stakedNodeId = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        StakingInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.StakingInfo";
        };
        return StakingInfo;
      })();
      proto37.PendingAirdropId = (function() {
        function PendingAirdropId(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        PendingAirdropId.prototype.senderId = null;
        PendingAirdropId.prototype.receiverId = null;
        PendingAirdropId.prototype.fungibleTokenType = null;
        PendingAirdropId.prototype.nonFungibleToken = null;
        let $oneOfFields;
        Object.defineProperty(PendingAirdropId.prototype, "tokenReference", { get: $util.oneOfGetter($oneOfFields = ["fungibleTokenType", "nonFungibleToken"]), set: $util.oneOfSetter($oneOfFields) });
        PendingAirdropId.create = function create(properties) {
          return new PendingAirdropId(properties);
        };
        PendingAirdropId.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.senderId != null && Object.hasOwnProperty.call(m6, "senderId")) $root.proto.AccountID.encode(m6.senderId, w5.uint32(10).fork()).ldelim();
          if (m6.receiverId != null && Object.hasOwnProperty.call(m6, "receiverId")) $root.proto.AccountID.encode(m6.receiverId, w5.uint32(18).fork()).ldelim();
          if (m6.fungibleTokenType != null && Object.hasOwnProperty.call(m6, "fungibleTokenType")) $root.proto.TokenID.encode(m6.fungibleTokenType, w5.uint32(26).fork()).ldelim();
          if (m6.nonFungibleToken != null && Object.hasOwnProperty.call(m6, "nonFungibleToken")) $root.proto.NftID.encode(m6.nonFungibleToken, w5.uint32(34).fork()).ldelim();
          return w5;
        };
        PendingAirdropId.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.PendingAirdropId();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.senderId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.receiverId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.fungibleTokenType = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.nonFungibleToken = $root.proto.NftID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        PendingAirdropId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.PendingAirdropId";
        };
        return PendingAirdropId;
      })();
      proto37.PendingAirdropValue = (function() {
        function PendingAirdropValue(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        PendingAirdropValue.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        PendingAirdropValue.create = function create(properties) {
          return new PendingAirdropValue(properties);
        };
        PendingAirdropValue.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(8).uint64(m6.amount);
          return w5;
        };
        PendingAirdropValue.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.PendingAirdropValue();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.amount = r41.uint64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        PendingAirdropValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.PendingAirdropValue";
        };
        return PendingAirdropValue;
      })();
      proto37.Timestamp = (function() {
        function Timestamp(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Timestamp.prototype.nanos = 0;
        Timestamp.create = function create(properties) {
          return new Timestamp(properties);
        };
        Timestamp.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.seconds != null && Object.hasOwnProperty.call(m6, "seconds")) w5.uint32(8).int64(m6.seconds);
          if (m6.nanos != null && Object.hasOwnProperty.call(m6, "nanos")) w5.uint32(16).int32(m6.nanos);
          return w5;
        };
        Timestamp.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.Timestamp();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.seconds = r41.int64();
                break;
              }
              case 2: {
                m6.nanos = r41.int32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.Timestamp";
        };
        return Timestamp;
      })();
      proto37.TimestampSeconds = (function() {
        function TimestampSeconds(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TimestampSeconds.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TimestampSeconds.create = function create(properties) {
          return new TimestampSeconds(properties);
        };
        TimestampSeconds.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.seconds != null && Object.hasOwnProperty.call(m6, "seconds")) w5.uint32(8).int64(m6.seconds);
          return w5;
        };
        TimestampSeconds.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TimestampSeconds();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.seconds = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TimestampSeconds.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TimestampSeconds";
        };
        return TimestampSeconds;
      })();
      proto37.SystemDeleteTransactionBody = (function() {
        function SystemDeleteTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SystemDeleteTransactionBody.prototype.fileID = null;
        SystemDeleteTransactionBody.prototype.contractID = null;
        SystemDeleteTransactionBody.prototype.expirationTime = null;
        let $oneOfFields;
        Object.defineProperty(SystemDeleteTransactionBody.prototype, "id", { get: $util.oneOfGetter($oneOfFields = ["fileID", "contractID"]), set: $util.oneOfSetter($oneOfFields) });
        SystemDeleteTransactionBody.create = function create(properties) {
          return new SystemDeleteTransactionBody(properties);
        };
        SystemDeleteTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(10).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(18).fork()).ldelim();
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.TimestampSeconds.encode(m6.expirationTime, w5.uint32(26).fork()).ldelim();
          return w5;
        };
        SystemDeleteTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SystemDeleteTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.expirationTime = $root.proto.TimestampSeconds.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SystemDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SystemDeleteTransactionBody";
        };
        return SystemDeleteTransactionBody;
      })();
      proto37.SystemUndeleteTransactionBody = (function() {
        function SystemUndeleteTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SystemUndeleteTransactionBody.prototype.fileID = null;
        SystemUndeleteTransactionBody.prototype.contractID = null;
        let $oneOfFields;
        Object.defineProperty(SystemUndeleteTransactionBody.prototype, "id", { get: $util.oneOfGetter($oneOfFields = ["fileID", "contractID"]), set: $util.oneOfSetter($oneOfFields) });
        SystemUndeleteTransactionBody.create = function create(properties) {
          return new SystemUndeleteTransactionBody(properties);
        };
        SystemUndeleteTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(10).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        SystemUndeleteTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SystemUndeleteTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SystemUndeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SystemUndeleteTransactionBody";
        };
        return SystemUndeleteTransactionBody;
      })();
      proto37.FreezeTransactionBody = (function() {
        function FreezeTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FreezeTransactionBody.prototype.startHour = 0;
        FreezeTransactionBody.prototype.startMin = 0;
        FreezeTransactionBody.prototype.endHour = 0;
        FreezeTransactionBody.prototype.endMin = 0;
        FreezeTransactionBody.prototype.updateFile = null;
        FreezeTransactionBody.prototype.fileHash = $util.newBuffer([]);
        FreezeTransactionBody.prototype.startTime = null;
        FreezeTransactionBody.prototype.freezeType = 0;
        FreezeTransactionBody.create = function create(properties) {
          return new FreezeTransactionBody(properties);
        };
        FreezeTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.startHour != null && Object.hasOwnProperty.call(m6, "startHour")) w5.uint32(8).int32(m6.startHour);
          if (m6.startMin != null && Object.hasOwnProperty.call(m6, "startMin")) w5.uint32(16).int32(m6.startMin);
          if (m6.endHour != null && Object.hasOwnProperty.call(m6, "endHour")) w5.uint32(24).int32(m6.endHour);
          if (m6.endMin != null && Object.hasOwnProperty.call(m6, "endMin")) w5.uint32(32).int32(m6.endMin);
          if (m6.updateFile != null && Object.hasOwnProperty.call(m6, "updateFile")) $root.proto.FileID.encode(m6.updateFile, w5.uint32(42).fork()).ldelim();
          if (m6.fileHash != null && Object.hasOwnProperty.call(m6, "fileHash")) w5.uint32(50).bytes(m6.fileHash);
          if (m6.startTime != null && Object.hasOwnProperty.call(m6, "startTime")) $root.proto.Timestamp.encode(m6.startTime, w5.uint32(58).fork()).ldelim();
          if (m6.freezeType != null && Object.hasOwnProperty.call(m6, "freezeType")) w5.uint32(64).int32(m6.freezeType);
          return w5;
        };
        FreezeTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FreezeTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.startHour = r41.int32();
                break;
              }
              case 2: {
                m6.startMin = r41.int32();
                break;
              }
              case 3: {
                m6.endHour = r41.int32();
                break;
              }
              case 4: {
                m6.endMin = r41.int32();
                break;
              }
              case 5: {
                m6.updateFile = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.fileHash = r41.bytes();
                break;
              }
              case 7: {
                m6.startTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.freezeType = r41.int32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FreezeTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FreezeTransactionBody";
        };
        return FreezeTransactionBody;
      })();
      proto37.FreezeType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_FREEZE_TYPE"] = 0;
        values[valuesById[1] = "FREEZE_ONLY"] = 1;
        values[valuesById[2] = "PREPARE_UPGRADE"] = 2;
        values[valuesById[3] = "FREEZE_UPGRADE"] = 3;
        values[valuesById[4] = "FREEZE_ABORT"] = 4;
        values[valuesById[5] = "TELEMETRY_UPGRADE"] = 5;
        return values;
      })();
      proto37.ContractCallTransactionBody = (function() {
        function ContractCallTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractCallTransactionBody.prototype.contractID = null;
        ContractCallTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractCallTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractCallTransactionBody.prototype.functionParameters = $util.newBuffer([]);
        ContractCallTransactionBody.create = function create(properties) {
          return new ContractCallTransactionBody(properties);
        };
        ContractCallTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(10).fork()).ldelim();
          if (m6.gas != null && Object.hasOwnProperty.call(m6, "gas")) w5.uint32(16).int64(m6.gas);
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(24).int64(m6.amount);
          if (m6.functionParameters != null && Object.hasOwnProperty.call(m6, "functionParameters")) w5.uint32(34).bytes(m6.functionParameters);
          return w5;
        };
        ContractCallTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractCallTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.gas = r41.int64();
                break;
              }
              case 3: {
                m6.amount = r41.int64();
                break;
              }
              case 4: {
                m6.functionParameters = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractCallTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractCallTransactionBody";
        };
        return ContractCallTransactionBody;
      })();
      proto37.ContractCreateTransactionBody = (function() {
        function ContractCreateTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractCreateTransactionBody.prototype.fileID = null;
        ContractCreateTransactionBody.prototype.initcode = null;
        ContractCreateTransactionBody.prototype.adminKey = null;
        ContractCreateTransactionBody.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractCreateTransactionBody.prototype.proxyAccountID = null;
        ContractCreateTransactionBody.prototype.autoRenewPeriod = null;
        ContractCreateTransactionBody.prototype.constructorParameters = $util.newBuffer([]);
        ContractCreateTransactionBody.prototype.shardID = null;
        ContractCreateTransactionBody.prototype.realmID = null;
        ContractCreateTransactionBody.prototype.newRealmAdminKey = null;
        ContractCreateTransactionBody.prototype.memo = "";
        ContractCreateTransactionBody.prototype.maxAutomaticTokenAssociations = 0;
        ContractCreateTransactionBody.prototype.autoRenewAccountId = null;
        ContractCreateTransactionBody.prototype.stakedAccountId = null;
        ContractCreateTransactionBody.prototype.stakedNodeId = null;
        ContractCreateTransactionBody.prototype.declineReward = false;
        let $oneOfFields;
        Object.defineProperty(ContractCreateTransactionBody.prototype, "initcodeSource", { get: $util.oneOfGetter($oneOfFields = ["fileID", "initcode"]), set: $util.oneOfSetter($oneOfFields) });
        Object.defineProperty(ContractCreateTransactionBody.prototype, "stakedId", { get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter($oneOfFields) });
        ContractCreateTransactionBody.create = function create(properties) {
          return new ContractCreateTransactionBody(properties);
        };
        ContractCreateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(10).fork()).ldelim();
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(26).fork()).ldelim();
          if (m6.gas != null && Object.hasOwnProperty.call(m6, "gas")) w5.uint32(32).int64(m6.gas);
          if (m6.initialBalance != null && Object.hasOwnProperty.call(m6, "initialBalance")) w5.uint32(40).int64(m6.initialBalance);
          if (m6.proxyAccountID != null && Object.hasOwnProperty.call(m6, "proxyAccountID")) $root.proto.AccountID.encode(m6.proxyAccountID, w5.uint32(50).fork()).ldelim();
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(66).fork()).ldelim();
          if (m6.constructorParameters != null && Object.hasOwnProperty.call(m6, "constructorParameters")) w5.uint32(74).bytes(m6.constructorParameters);
          if (m6.shardID != null && Object.hasOwnProperty.call(m6, "shardID")) $root.proto.ShardID.encode(m6.shardID, w5.uint32(82).fork()).ldelim();
          if (m6.realmID != null && Object.hasOwnProperty.call(m6, "realmID")) $root.proto.RealmID.encode(m6.realmID, w5.uint32(90).fork()).ldelim();
          if (m6.newRealmAdminKey != null && Object.hasOwnProperty.call(m6, "newRealmAdminKey")) $root.proto.Key.encode(m6.newRealmAdminKey, w5.uint32(98).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(106).string(m6.memo);
          if (m6.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m6, "maxAutomaticTokenAssociations")) w5.uint32(112).int32(m6.maxAutomaticTokenAssociations);
          if (m6.autoRenewAccountId != null && Object.hasOwnProperty.call(m6, "autoRenewAccountId")) $root.proto.AccountID.encode(m6.autoRenewAccountId, w5.uint32(122).fork()).ldelim();
          if (m6.initcode != null && Object.hasOwnProperty.call(m6, "initcode")) w5.uint32(130).bytes(m6.initcode);
          if (m6.stakedAccountId != null && Object.hasOwnProperty.call(m6, "stakedAccountId")) $root.proto.AccountID.encode(m6.stakedAccountId, w5.uint32(138).fork()).ldelim();
          if (m6.stakedNodeId != null && Object.hasOwnProperty.call(m6, "stakedNodeId")) w5.uint32(144).int64(m6.stakedNodeId);
          if (m6.declineReward != null && Object.hasOwnProperty.call(m6, "declineReward")) w5.uint32(152).bool(m6.declineReward);
          return w5;
        };
        ContractCreateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractCreateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.initcode = r41.bytes();
                break;
              }
              case 3: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.gas = r41.int64();
                break;
              }
              case 5: {
                m6.initialBalance = r41.int64();
                break;
              }
              case 6: {
                m6.proxyAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.constructorParameters = r41.bytes();
                break;
              }
              case 10: {
                m6.shardID = $root.proto.ShardID.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.realmID = $root.proto.RealmID.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.newRealmAdminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.memo = r41.string();
                break;
              }
              case 14: {
                m6.maxAutomaticTokenAssociations = r41.int32();
                break;
              }
              case 15: {
                m6.autoRenewAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 17: {
                m6.stakedAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 18: {
                m6.stakedNodeId = r41.int64();
                break;
              }
              case 19: {
                m6.declineReward = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractCreateTransactionBody";
        };
        return ContractCreateTransactionBody;
      })();
      proto37.Duration = (function() {
        function Duration2(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        Duration2.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        Duration2.create = function create(properties) {
          return new Duration2(properties);
        };
        Duration2.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.seconds != null && Object.hasOwnProperty.call(m6, "seconds")) w5.uint32(8).int64(m6.seconds);
          return w5;
        };
        Duration2.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.Duration();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.seconds = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        Duration2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.Duration";
        };
        return Duration2;
      })();
      proto37.ContractUpdateTransactionBody = (function() {
        function ContractUpdateTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractUpdateTransactionBody.prototype.contractID = null;
        ContractUpdateTransactionBody.prototype.expirationTime = null;
        ContractUpdateTransactionBody.prototype.adminKey = null;
        ContractUpdateTransactionBody.prototype.proxyAccountID = null;
        ContractUpdateTransactionBody.prototype.autoRenewPeriod = null;
        ContractUpdateTransactionBody.prototype.fileID = null;
        ContractUpdateTransactionBody.prototype.memo = null;
        ContractUpdateTransactionBody.prototype.memoWrapper = null;
        ContractUpdateTransactionBody.prototype.maxAutomaticTokenAssociations = null;
        ContractUpdateTransactionBody.prototype.autoRenewAccountId = null;
        ContractUpdateTransactionBody.prototype.stakedAccountId = null;
        ContractUpdateTransactionBody.prototype.stakedNodeId = null;
        ContractUpdateTransactionBody.prototype.declineReward = null;
        let $oneOfFields;
        Object.defineProperty(ContractUpdateTransactionBody.prototype, "memoField", { get: $util.oneOfGetter($oneOfFields = ["memo", "memoWrapper"]), set: $util.oneOfSetter($oneOfFields) });
        Object.defineProperty(ContractUpdateTransactionBody.prototype, "stakedId", { get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter($oneOfFields) });
        ContractUpdateTransactionBody.create = function create(properties) {
          return new ContractUpdateTransactionBody(properties);
        };
        ContractUpdateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(10).fork()).ldelim();
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(18).fork()).ldelim();
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(26).fork()).ldelim();
          if (m6.proxyAccountID != null && Object.hasOwnProperty.call(m6, "proxyAccountID")) $root.proto.AccountID.encode(m6.proxyAccountID, w5.uint32(50).fork()).ldelim();
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(58).fork()).ldelim();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(66).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(74).string(m6.memo);
          if (m6.memoWrapper != null && Object.hasOwnProperty.call(m6, "memoWrapper")) $root.google.protobuf.StringValue.encode(m6.memoWrapper, w5.uint32(82).fork()).ldelim();
          if (m6.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m6, "maxAutomaticTokenAssociations")) $root.google.protobuf.Int32Value.encode(m6.maxAutomaticTokenAssociations, w5.uint32(90).fork()).ldelim();
          if (m6.autoRenewAccountId != null && Object.hasOwnProperty.call(m6, "autoRenewAccountId")) $root.proto.AccountID.encode(m6.autoRenewAccountId, w5.uint32(98).fork()).ldelim();
          if (m6.stakedAccountId != null && Object.hasOwnProperty.call(m6, "stakedAccountId")) $root.proto.AccountID.encode(m6.stakedAccountId, w5.uint32(106).fork()).ldelim();
          if (m6.stakedNodeId != null && Object.hasOwnProperty.call(m6, "stakedNodeId")) w5.uint32(112).int64(m6.stakedNodeId);
          if (m6.declineReward != null && Object.hasOwnProperty.call(m6, "declineReward")) $root.google.protobuf.BoolValue.encode(m6.declineReward, w5.uint32(122).fork()).ldelim();
          return w5;
        };
        ContractUpdateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractUpdateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.proxyAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.memo = r41.string();
                break;
              }
              case 10: {
                m6.memoWrapper = $root.google.protobuf.StringValue.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.maxAutomaticTokenAssociations = $root.google.protobuf.Int32Value.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.autoRenewAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.stakedAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                m6.stakedNodeId = r41.int64();
                break;
              }
              case 15: {
                m6.declineReward = $root.google.protobuf.BoolValue.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractUpdateTransactionBody";
        };
        return ContractUpdateTransactionBody;
      })();
      proto37.LiveHash = (function() {
        function LiveHash(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        LiveHash.prototype.accountId = null;
        LiveHash.prototype.hash = $util.newBuffer([]);
        LiveHash.prototype.keys = null;
        LiveHash.prototype.duration = null;
        LiveHash.create = function create(properties) {
          return new LiveHash(properties);
        };
        LiveHash.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountId != null && Object.hasOwnProperty.call(m6, "accountId")) $root.proto.AccountID.encode(m6.accountId, w5.uint32(10).fork()).ldelim();
          if (m6.hash != null && Object.hasOwnProperty.call(m6, "hash")) w5.uint32(18).bytes(m6.hash);
          if (m6.keys != null && Object.hasOwnProperty.call(m6, "keys")) $root.proto.KeyList.encode(m6.keys, w5.uint32(26).fork()).ldelim();
          if (m6.duration != null && Object.hasOwnProperty.call(m6, "duration")) $root.proto.Duration.encode(m6.duration, w5.uint32(42).fork()).ldelim();
          return w5;
        };
        LiveHash.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.LiveHash();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.accountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.hash = r41.bytes();
                break;
              }
              case 3: {
                m6.keys = $root.proto.KeyList.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.duration = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        LiveHash.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.LiveHash";
        };
        return LiveHash;
      })();
      proto37.CryptoAddLiveHashTransactionBody = (function() {
        function CryptoAddLiveHashTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoAddLiveHashTransactionBody.prototype.liveHash = null;
        CryptoAddLiveHashTransactionBody.create = function create(properties) {
          return new CryptoAddLiveHashTransactionBody(properties);
        };
        CryptoAddLiveHashTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.liveHash != null && Object.hasOwnProperty.call(m6, "liveHash")) $root.proto.LiveHash.encode(m6.liveHash, w5.uint32(26).fork()).ldelim();
          return w5;
        };
        CryptoAddLiveHashTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoAddLiveHashTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 3: {
                m6.liveHash = $root.proto.LiveHash.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoAddLiveHashTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoAddLiveHashTransactionBody";
        };
        return CryptoAddLiveHashTransactionBody;
      })();
      proto37.CryptoCreateTransactionBody = (function() {
        function CryptoCreateTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoCreateTransactionBody.prototype.key = null;
        CryptoCreateTransactionBody.prototype.initialBalance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        CryptoCreateTransactionBody.prototype.proxyAccountID = null;
        CryptoCreateTransactionBody.prototype.sendRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        CryptoCreateTransactionBody.prototype.receiveRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        CryptoCreateTransactionBody.prototype.receiverSigRequired = false;
        CryptoCreateTransactionBody.prototype.autoRenewPeriod = null;
        CryptoCreateTransactionBody.prototype.shardID = null;
        CryptoCreateTransactionBody.prototype.realmID = null;
        CryptoCreateTransactionBody.prototype.newRealmAdminKey = null;
        CryptoCreateTransactionBody.prototype.memo = "";
        CryptoCreateTransactionBody.prototype.maxAutomaticTokenAssociations = 0;
        CryptoCreateTransactionBody.prototype.stakedAccountId = null;
        CryptoCreateTransactionBody.prototype.stakedNodeId = null;
        CryptoCreateTransactionBody.prototype.declineReward = false;
        CryptoCreateTransactionBody.prototype.alias = $util.newBuffer([]);
        let $oneOfFields;
        Object.defineProperty(CryptoCreateTransactionBody.prototype, "stakedId", { get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter($oneOfFields) });
        CryptoCreateTransactionBody.create = function create(properties) {
          return new CryptoCreateTransactionBody(properties);
        };
        CryptoCreateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.key != null && Object.hasOwnProperty.call(m6, "key")) $root.proto.Key.encode(m6.key, w5.uint32(10).fork()).ldelim();
          if (m6.initialBalance != null && Object.hasOwnProperty.call(m6, "initialBalance")) w5.uint32(16).uint64(m6.initialBalance);
          if (m6.proxyAccountID != null && Object.hasOwnProperty.call(m6, "proxyAccountID")) $root.proto.AccountID.encode(m6.proxyAccountID, w5.uint32(26).fork()).ldelim();
          if (m6.sendRecordThreshold != null && Object.hasOwnProperty.call(m6, "sendRecordThreshold")) w5.uint32(48).uint64(m6.sendRecordThreshold);
          if (m6.receiveRecordThreshold != null && Object.hasOwnProperty.call(m6, "receiveRecordThreshold")) w5.uint32(56).uint64(m6.receiveRecordThreshold);
          if (m6.receiverSigRequired != null && Object.hasOwnProperty.call(m6, "receiverSigRequired")) w5.uint32(64).bool(m6.receiverSigRequired);
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(74).fork()).ldelim();
          if (m6.shardID != null && Object.hasOwnProperty.call(m6, "shardID")) $root.proto.ShardID.encode(m6.shardID, w5.uint32(82).fork()).ldelim();
          if (m6.realmID != null && Object.hasOwnProperty.call(m6, "realmID")) $root.proto.RealmID.encode(m6.realmID, w5.uint32(90).fork()).ldelim();
          if (m6.newRealmAdminKey != null && Object.hasOwnProperty.call(m6, "newRealmAdminKey")) $root.proto.Key.encode(m6.newRealmAdminKey, w5.uint32(98).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(106).string(m6.memo);
          if (m6.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m6, "maxAutomaticTokenAssociations")) w5.uint32(112).int32(m6.maxAutomaticTokenAssociations);
          if (m6.stakedAccountId != null && Object.hasOwnProperty.call(m6, "stakedAccountId")) $root.proto.AccountID.encode(m6.stakedAccountId, w5.uint32(122).fork()).ldelim();
          if (m6.stakedNodeId != null && Object.hasOwnProperty.call(m6, "stakedNodeId")) w5.uint32(128).int64(m6.stakedNodeId);
          if (m6.declineReward != null && Object.hasOwnProperty.call(m6, "declineReward")) w5.uint32(136).bool(m6.declineReward);
          if (m6.alias != null && Object.hasOwnProperty.call(m6, "alias")) w5.uint32(146).bytes(m6.alias);
          return w5;
        };
        CryptoCreateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoCreateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.key = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.initialBalance = r41.uint64();
                break;
              }
              case 3: {
                m6.proxyAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.sendRecordThreshold = r41.uint64();
                break;
              }
              case 7: {
                m6.receiveRecordThreshold = r41.uint64();
                break;
              }
              case 8: {
                m6.receiverSigRequired = r41.bool();
                break;
              }
              case 9: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.shardID = $root.proto.ShardID.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.realmID = $root.proto.RealmID.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.newRealmAdminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.memo = r41.string();
                break;
              }
              case 14: {
                m6.maxAutomaticTokenAssociations = r41.int32();
                break;
              }
              case 15: {
                m6.stakedAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.stakedNodeId = r41.int64();
                break;
              }
              case 17: {
                m6.declineReward = r41.bool();
                break;
              }
              case 18: {
                m6.alias = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoCreateTransactionBody";
        };
        return CryptoCreateTransactionBody;
      })();
      proto37.CryptoDeleteTransactionBody = (function() {
        function CryptoDeleteTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoDeleteTransactionBody.prototype.transferAccountID = null;
        CryptoDeleteTransactionBody.prototype.deleteAccountID = null;
        CryptoDeleteTransactionBody.create = function create(properties) {
          return new CryptoDeleteTransactionBody(properties);
        };
        CryptoDeleteTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transferAccountID != null && Object.hasOwnProperty.call(m6, "transferAccountID")) $root.proto.AccountID.encode(m6.transferAccountID, w5.uint32(10).fork()).ldelim();
          if (m6.deleteAccountID != null && Object.hasOwnProperty.call(m6, "deleteAccountID")) $root.proto.AccountID.encode(m6.deleteAccountID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        CryptoDeleteTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoDeleteTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.transferAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.deleteAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoDeleteTransactionBody";
        };
        return CryptoDeleteTransactionBody;
      })();
      proto37.CryptoDeleteLiveHashTransactionBody = (function() {
        function CryptoDeleteLiveHashTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoDeleteLiveHashTransactionBody.prototype.accountOfLiveHash = null;
        CryptoDeleteLiveHashTransactionBody.prototype.liveHashToDelete = $util.newBuffer([]);
        CryptoDeleteLiveHashTransactionBody.create = function create(properties) {
          return new CryptoDeleteLiveHashTransactionBody(properties);
        };
        CryptoDeleteLiveHashTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountOfLiveHash != null && Object.hasOwnProperty.call(m6, "accountOfLiveHash")) $root.proto.AccountID.encode(m6.accountOfLiveHash, w5.uint32(10).fork()).ldelim();
          if (m6.liveHashToDelete != null && Object.hasOwnProperty.call(m6, "liveHashToDelete")) w5.uint32(18).bytes(m6.liveHashToDelete);
          return w5;
        };
        CryptoDeleteLiveHashTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoDeleteLiveHashTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.accountOfLiveHash = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.liveHashToDelete = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoDeleteLiveHashTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoDeleteLiveHashTransactionBody";
        };
        return CryptoDeleteLiveHashTransactionBody;
      })();
      proto37.CryptoTransferTransactionBody = (function() {
        function CryptoTransferTransactionBody(p3) {
          this.tokenTransfers = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoTransferTransactionBody.prototype.transfers = null;
        CryptoTransferTransactionBody.prototype.tokenTransfers = $util.emptyArray;
        CryptoTransferTransactionBody.create = function create(properties) {
          return new CryptoTransferTransactionBody(properties);
        };
        CryptoTransferTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transfers != null && Object.hasOwnProperty.call(m6, "transfers")) $root.proto.TransferList.encode(m6.transfers, w5.uint32(10).fork()).ldelim();
          if (m6.tokenTransfers != null && m6.tokenTransfers.length) {
            for (var i17 = 0; i17 < m6.tokenTransfers.length; ++i17) $root.proto.TokenTransferList.encode(m6.tokenTransfers[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        CryptoTransferTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoTransferTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.transfers = $root.proto.TransferList.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.tokenTransfers && m6.tokenTransfers.length)) m6.tokenTransfers = [];
                m6.tokenTransfers.push($root.proto.TokenTransferList.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoTransferTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoTransferTransactionBody";
        };
        return CryptoTransferTransactionBody;
      })();
      proto37.CryptoUpdateTransactionBody = (function() {
        function CryptoUpdateTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoUpdateTransactionBody.prototype.accountIDToUpdate = null;
        CryptoUpdateTransactionBody.prototype.key = null;
        CryptoUpdateTransactionBody.prototype.proxyAccountID = null;
        CryptoUpdateTransactionBody.prototype.proxyFraction = 0;
        CryptoUpdateTransactionBody.prototype.sendRecordThreshold = null;
        CryptoUpdateTransactionBody.prototype.sendRecordThresholdWrapper = null;
        CryptoUpdateTransactionBody.prototype.receiveRecordThreshold = null;
        CryptoUpdateTransactionBody.prototype.receiveRecordThresholdWrapper = null;
        CryptoUpdateTransactionBody.prototype.autoRenewPeriod = null;
        CryptoUpdateTransactionBody.prototype.expirationTime = null;
        CryptoUpdateTransactionBody.prototype.receiverSigRequired = null;
        CryptoUpdateTransactionBody.prototype.receiverSigRequiredWrapper = null;
        CryptoUpdateTransactionBody.prototype.memo = null;
        CryptoUpdateTransactionBody.prototype.maxAutomaticTokenAssociations = null;
        CryptoUpdateTransactionBody.prototype.stakedAccountId = null;
        CryptoUpdateTransactionBody.prototype.stakedNodeId = null;
        CryptoUpdateTransactionBody.prototype.declineReward = null;
        let $oneOfFields;
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "sendRecordThresholdField", { get: $util.oneOfGetter($oneOfFields = ["sendRecordThreshold", "sendRecordThresholdWrapper"]), set: $util.oneOfSetter($oneOfFields) });
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiveRecordThresholdField", { get: $util.oneOfGetter($oneOfFields = ["receiveRecordThreshold", "receiveRecordThresholdWrapper"]), set: $util.oneOfSetter($oneOfFields) });
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "receiverSigRequiredField", { get: $util.oneOfGetter($oneOfFields = ["receiverSigRequired", "receiverSigRequiredWrapper"]), set: $util.oneOfSetter($oneOfFields) });
        Object.defineProperty(CryptoUpdateTransactionBody.prototype, "stakedId", { get: $util.oneOfGetter($oneOfFields = ["stakedAccountId", "stakedNodeId"]), set: $util.oneOfSetter($oneOfFields) });
        CryptoUpdateTransactionBody.create = function create(properties) {
          return new CryptoUpdateTransactionBody(properties);
        };
        CryptoUpdateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountIDToUpdate != null && Object.hasOwnProperty.call(m6, "accountIDToUpdate")) $root.proto.AccountID.encode(m6.accountIDToUpdate, w5.uint32(18).fork()).ldelim();
          if (m6.key != null && Object.hasOwnProperty.call(m6, "key")) $root.proto.Key.encode(m6.key, w5.uint32(26).fork()).ldelim();
          if (m6.proxyAccountID != null && Object.hasOwnProperty.call(m6, "proxyAccountID")) $root.proto.AccountID.encode(m6.proxyAccountID, w5.uint32(34).fork()).ldelim();
          if (m6.proxyFraction != null && Object.hasOwnProperty.call(m6, "proxyFraction")) w5.uint32(40).int32(m6.proxyFraction);
          if (m6.sendRecordThreshold != null && Object.hasOwnProperty.call(m6, "sendRecordThreshold")) w5.uint32(48).uint64(m6.sendRecordThreshold);
          if (m6.receiveRecordThreshold != null && Object.hasOwnProperty.call(m6, "receiveRecordThreshold")) w5.uint32(56).uint64(m6.receiveRecordThreshold);
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(66).fork()).ldelim();
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(74).fork()).ldelim();
          if (m6.receiverSigRequired != null && Object.hasOwnProperty.call(m6, "receiverSigRequired")) w5.uint32(80).bool(m6.receiverSigRequired);
          if (m6.sendRecordThresholdWrapper != null && Object.hasOwnProperty.call(m6, "sendRecordThresholdWrapper")) $root.google.protobuf.UInt64Value.encode(m6.sendRecordThresholdWrapper, w5.uint32(90).fork()).ldelim();
          if (m6.receiveRecordThresholdWrapper != null && Object.hasOwnProperty.call(m6, "receiveRecordThresholdWrapper")) $root.google.protobuf.UInt64Value.encode(m6.receiveRecordThresholdWrapper, w5.uint32(98).fork()).ldelim();
          if (m6.receiverSigRequiredWrapper != null && Object.hasOwnProperty.call(m6, "receiverSigRequiredWrapper")) $root.google.protobuf.BoolValue.encode(m6.receiverSigRequiredWrapper, w5.uint32(106).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) $root.google.protobuf.StringValue.encode(m6.memo, w5.uint32(114).fork()).ldelim();
          if (m6.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m6, "maxAutomaticTokenAssociations")) $root.google.protobuf.Int32Value.encode(m6.maxAutomaticTokenAssociations, w5.uint32(122).fork()).ldelim();
          if (m6.stakedAccountId != null && Object.hasOwnProperty.call(m6, "stakedAccountId")) $root.proto.AccountID.encode(m6.stakedAccountId, w5.uint32(130).fork()).ldelim();
          if (m6.stakedNodeId != null && Object.hasOwnProperty.call(m6, "stakedNodeId")) w5.uint32(136).int64(m6.stakedNodeId);
          if (m6.declineReward != null && Object.hasOwnProperty.call(m6, "declineReward")) $root.google.protobuf.BoolValue.encode(m6.declineReward, w5.uint32(146).fork()).ldelim();
          return w5;
        };
        CryptoUpdateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoUpdateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 2: {
                m6.accountIDToUpdate = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.key = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.proxyAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.proxyFraction = r41.int32();
                break;
              }
              case 6: {
                m6.sendRecordThreshold = r41.uint64();
                break;
              }
              case 11: {
                m6.sendRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.receiveRecordThreshold = r41.uint64();
                break;
              }
              case 12: {
                m6.receiveRecordThresholdWrapper = $root.google.protobuf.UInt64Value.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.receiverSigRequired = r41.bool();
                break;
              }
              case 13: {
                m6.receiverSigRequiredWrapper = $root.google.protobuf.BoolValue.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                m6.memo = $root.google.protobuf.StringValue.decode(r41, r41.uint32());
                break;
              }
              case 15: {
                m6.maxAutomaticTokenAssociations = $root.google.protobuf.Int32Value.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.stakedAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 17: {
                m6.stakedNodeId = r41.int64();
                break;
              }
              case 18: {
                m6.declineReward = $root.google.protobuf.BoolValue.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoUpdateTransactionBody";
        };
        return CryptoUpdateTransactionBody;
      })();
      proto37.CryptoApproveAllowanceTransactionBody = (function() {
        function CryptoApproveAllowanceTransactionBody(p3) {
          this.cryptoAllowances = [];
          this.nftAllowances = [];
          this.tokenAllowances = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoApproveAllowanceTransactionBody.prototype.cryptoAllowances = $util.emptyArray;
        CryptoApproveAllowanceTransactionBody.prototype.nftAllowances = $util.emptyArray;
        CryptoApproveAllowanceTransactionBody.prototype.tokenAllowances = $util.emptyArray;
        CryptoApproveAllowanceTransactionBody.create = function create(properties) {
          return new CryptoApproveAllowanceTransactionBody(properties);
        };
        CryptoApproveAllowanceTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.cryptoAllowances != null && m6.cryptoAllowances.length) {
            for (var i17 = 0; i17 < m6.cryptoAllowances.length; ++i17) $root.proto.CryptoAllowance.encode(m6.cryptoAllowances[i17], w5.uint32(10).fork()).ldelim();
          }
          if (m6.nftAllowances != null && m6.nftAllowances.length) {
            for (var i17 = 0; i17 < m6.nftAllowances.length; ++i17) $root.proto.NftAllowance.encode(m6.nftAllowances[i17], w5.uint32(18).fork()).ldelim();
          }
          if (m6.tokenAllowances != null && m6.tokenAllowances.length) {
            for (var i17 = 0; i17 < m6.tokenAllowances.length; ++i17) $root.proto.TokenAllowance.encode(m6.tokenAllowances[i17], w5.uint32(26).fork()).ldelim();
          }
          return w5;
        };
        CryptoApproveAllowanceTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoApproveAllowanceTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.cryptoAllowances && m6.cryptoAllowances.length)) m6.cryptoAllowances = [];
                m6.cryptoAllowances.push($root.proto.CryptoAllowance.decode(r41, r41.uint32()));
                break;
              }
              case 2: {
                if (!(m6.nftAllowances && m6.nftAllowances.length)) m6.nftAllowances = [];
                m6.nftAllowances.push($root.proto.NftAllowance.decode(r41, r41.uint32()));
                break;
              }
              case 3: {
                if (!(m6.tokenAllowances && m6.tokenAllowances.length)) m6.tokenAllowances = [];
                m6.tokenAllowances.push($root.proto.TokenAllowance.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoApproveAllowanceTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoApproveAllowanceTransactionBody";
        };
        return CryptoApproveAllowanceTransactionBody;
      })();
      proto37.CryptoAllowance = (function() {
        function CryptoAllowance(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoAllowance.prototype.owner = null;
        CryptoAllowance.prototype.spender = null;
        CryptoAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        CryptoAllowance.create = function create(properties) {
          return new CryptoAllowance(properties);
        };
        CryptoAllowance.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.owner != null && Object.hasOwnProperty.call(m6, "owner")) $root.proto.AccountID.encode(m6.owner, w5.uint32(10).fork()).ldelim();
          if (m6.spender != null && Object.hasOwnProperty.call(m6, "spender")) $root.proto.AccountID.encode(m6.spender, w5.uint32(18).fork()).ldelim();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(24).int64(m6.amount);
          return w5;
        };
        CryptoAllowance.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoAllowance();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.owner = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.spender = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.amount = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoAllowance";
        };
        return CryptoAllowance;
      })();
      proto37.NftAllowance = (function() {
        function NftAllowance(p3) {
          this.serialNumbers = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NftAllowance.prototype.tokenId = null;
        NftAllowance.prototype.owner = null;
        NftAllowance.prototype.spender = null;
        NftAllowance.prototype.serialNumbers = $util.emptyArray;
        NftAllowance.prototype.approvedForAll = null;
        NftAllowance.prototype.delegatingSpender = null;
        NftAllowance.create = function create(properties) {
          return new NftAllowance(properties);
        };
        NftAllowance.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.owner != null && Object.hasOwnProperty.call(m6, "owner")) $root.proto.AccountID.encode(m6.owner, w5.uint32(18).fork()).ldelim();
          if (m6.spender != null && Object.hasOwnProperty.call(m6, "spender")) $root.proto.AccountID.encode(m6.spender, w5.uint32(26).fork()).ldelim();
          if (m6.serialNumbers != null && m6.serialNumbers.length) {
            w5.uint32(34).fork();
            for (var i17 = 0; i17 < m6.serialNumbers.length; ++i17) w5.int64(m6.serialNumbers[i17]);
            w5.ldelim();
          }
          if (m6.approvedForAll != null && Object.hasOwnProperty.call(m6, "approvedForAll")) $root.google.protobuf.BoolValue.encode(m6.approvedForAll, w5.uint32(42).fork()).ldelim();
          if (m6.delegatingSpender != null && Object.hasOwnProperty.call(m6, "delegatingSpender")) $root.proto.AccountID.encode(m6.delegatingSpender, w5.uint32(50).fork()).ldelim();
          return w5;
        };
        NftAllowance.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NftAllowance();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.owner = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.spender = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                if (!(m6.serialNumbers && m6.serialNumbers.length)) m6.serialNumbers = [];
                if ((t35 & 7) === 2) {
                  var c22 = r41.uint32() + r41.pos;
                  while (r41.pos < c22) m6.serialNumbers.push(r41.int64());
                } else m6.serialNumbers.push(r41.int64());
                break;
              }
              case 5: {
                m6.approvedForAll = $root.google.protobuf.BoolValue.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.delegatingSpender = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NftAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NftAllowance";
        };
        return NftAllowance;
      })();
      proto37.TokenAllowance = (function() {
        function TokenAllowance(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenAllowance.prototype.tokenId = null;
        TokenAllowance.prototype.owner = null;
        TokenAllowance.prototype.spender = null;
        TokenAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenAllowance.create = function create(properties) {
          return new TokenAllowance(properties);
        };
        TokenAllowance.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.owner != null && Object.hasOwnProperty.call(m6, "owner")) $root.proto.AccountID.encode(m6.owner, w5.uint32(18).fork()).ldelim();
          if (m6.spender != null && Object.hasOwnProperty.call(m6, "spender")) $root.proto.AccountID.encode(m6.spender, w5.uint32(26).fork()).ldelim();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(32).int64(m6.amount);
          return w5;
        };
        TokenAllowance.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenAllowance();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.owner = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.spender = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.amount = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenAllowance";
        };
        return TokenAllowance;
      })();
      proto37.CryptoDeleteAllowanceTransactionBody = (function() {
        function CryptoDeleteAllowanceTransactionBody(p3) {
          this.nftAllowances = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoDeleteAllowanceTransactionBody.prototype.nftAllowances = $util.emptyArray;
        CryptoDeleteAllowanceTransactionBody.create = function create(properties) {
          return new CryptoDeleteAllowanceTransactionBody(properties);
        };
        CryptoDeleteAllowanceTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.nftAllowances != null && m6.nftAllowances.length) {
            for (var i17 = 0; i17 < m6.nftAllowances.length; ++i17) $root.proto.NftRemoveAllowance.encode(m6.nftAllowances[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        CryptoDeleteAllowanceTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoDeleteAllowanceTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 2: {
                if (!(m6.nftAllowances && m6.nftAllowances.length)) m6.nftAllowances = [];
                m6.nftAllowances.push($root.proto.NftRemoveAllowance.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoDeleteAllowanceTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoDeleteAllowanceTransactionBody";
        };
        return CryptoDeleteAllowanceTransactionBody;
      })();
      proto37.NftRemoveAllowance = (function() {
        function NftRemoveAllowance(p3) {
          this.serialNumbers = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NftRemoveAllowance.prototype.tokenId = null;
        NftRemoveAllowance.prototype.owner = null;
        NftRemoveAllowance.prototype.serialNumbers = $util.emptyArray;
        NftRemoveAllowance.create = function create(properties) {
          return new NftRemoveAllowance(properties);
        };
        NftRemoveAllowance.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.owner != null && Object.hasOwnProperty.call(m6, "owner")) $root.proto.AccountID.encode(m6.owner, w5.uint32(18).fork()).ldelim();
          if (m6.serialNumbers != null && m6.serialNumbers.length) {
            w5.uint32(26).fork();
            for (var i17 = 0; i17 < m6.serialNumbers.length; ++i17) w5.int64(m6.serialNumbers[i17]);
            w5.ldelim();
          }
          return w5;
        };
        NftRemoveAllowance.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NftRemoveAllowance();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.owner = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                if (!(m6.serialNumbers && m6.serialNumbers.length)) m6.serialNumbers = [];
                if ((t35 & 7) === 2) {
                  var c22 = r41.uint32() + r41.pos;
                  while (r41.pos < c22) m6.serialNumbers.push(r41.int64());
                } else m6.serialNumbers.push(r41.int64());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NftRemoveAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NftRemoveAllowance";
        };
        return NftRemoveAllowance;
      })();
      proto37.EthereumTransactionBody = (function() {
        function EthereumTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        EthereumTransactionBody.prototype.ethereumData = $util.newBuffer([]);
        EthereumTransactionBody.prototype.callData = null;
        EthereumTransactionBody.prototype.maxGasAllowance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        EthereumTransactionBody.create = function create(properties) {
          return new EthereumTransactionBody(properties);
        };
        EthereumTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.ethereumData != null && Object.hasOwnProperty.call(m6, "ethereumData")) w5.uint32(10).bytes(m6.ethereumData);
          if (m6.callData != null && Object.hasOwnProperty.call(m6, "callData")) $root.proto.FileID.encode(m6.callData, w5.uint32(18).fork()).ldelim();
          if (m6.maxGasAllowance != null && Object.hasOwnProperty.call(m6, "maxGasAllowance")) w5.uint32(24).int64(m6.maxGasAllowance);
          return w5;
        };
        EthereumTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.EthereumTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.ethereumData = r41.bytes();
                break;
              }
              case 2: {
                m6.callData = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.maxGasAllowance = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        EthereumTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.EthereumTransactionBody";
        };
        return EthereumTransactionBody;
      })();
      proto37.FileAppendTransactionBody = (function() {
        function FileAppendTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FileAppendTransactionBody.prototype.fileID = null;
        FileAppendTransactionBody.prototype.contents = $util.newBuffer([]);
        FileAppendTransactionBody.create = function create(properties) {
          return new FileAppendTransactionBody(properties);
        };
        FileAppendTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(18).fork()).ldelim();
          if (m6.contents != null && Object.hasOwnProperty.call(m6, "contents")) w5.uint32(34).bytes(m6.contents);
          return w5;
        };
        FileAppendTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileAppendTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 2: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.contents = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FileAppendTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FileAppendTransactionBody";
        };
        return FileAppendTransactionBody;
      })();
      proto37.FileCreateTransactionBody = (function() {
        function FileCreateTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FileCreateTransactionBody.prototype.expirationTime = null;
        FileCreateTransactionBody.prototype.keys = null;
        FileCreateTransactionBody.prototype.contents = $util.newBuffer([]);
        FileCreateTransactionBody.prototype.shardID = null;
        FileCreateTransactionBody.prototype.realmID = null;
        FileCreateTransactionBody.prototype.newRealmAdminKey = null;
        FileCreateTransactionBody.prototype.memo = "";
        FileCreateTransactionBody.create = function create(properties) {
          return new FileCreateTransactionBody(properties);
        };
        FileCreateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(18).fork()).ldelim();
          if (m6.keys != null && Object.hasOwnProperty.call(m6, "keys")) $root.proto.KeyList.encode(m6.keys, w5.uint32(26).fork()).ldelim();
          if (m6.contents != null && Object.hasOwnProperty.call(m6, "contents")) w5.uint32(34).bytes(m6.contents);
          if (m6.shardID != null && Object.hasOwnProperty.call(m6, "shardID")) $root.proto.ShardID.encode(m6.shardID, w5.uint32(42).fork()).ldelim();
          if (m6.realmID != null && Object.hasOwnProperty.call(m6, "realmID")) $root.proto.RealmID.encode(m6.realmID, w5.uint32(50).fork()).ldelim();
          if (m6.newRealmAdminKey != null && Object.hasOwnProperty.call(m6, "newRealmAdminKey")) $root.proto.Key.encode(m6.newRealmAdminKey, w5.uint32(58).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(66).string(m6.memo);
          return w5;
        };
        FileCreateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileCreateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 2: {
                m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.keys = $root.proto.KeyList.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.contents = r41.bytes();
                break;
              }
              case 5: {
                m6.shardID = $root.proto.ShardID.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.realmID = $root.proto.RealmID.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.newRealmAdminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.memo = r41.string();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FileCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FileCreateTransactionBody";
        };
        return FileCreateTransactionBody;
      })();
      proto37.FileDeleteTransactionBody = (function() {
        function FileDeleteTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FileDeleteTransactionBody.prototype.fileID = null;
        FileDeleteTransactionBody.create = function create(properties) {
          return new FileDeleteTransactionBody(properties);
        };
        FileDeleteTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        FileDeleteTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileDeleteTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 2: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FileDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FileDeleteTransactionBody";
        };
        return FileDeleteTransactionBody;
      })();
      proto37.FileUpdateTransactionBody = (function() {
        function FileUpdateTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FileUpdateTransactionBody.prototype.fileID = null;
        FileUpdateTransactionBody.prototype.expirationTime = null;
        FileUpdateTransactionBody.prototype.keys = null;
        FileUpdateTransactionBody.prototype.contents = $util.newBuffer([]);
        FileUpdateTransactionBody.prototype.memo = null;
        FileUpdateTransactionBody.create = function create(properties) {
          return new FileUpdateTransactionBody(properties);
        };
        FileUpdateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(10).fork()).ldelim();
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(18).fork()).ldelim();
          if (m6.keys != null && Object.hasOwnProperty.call(m6, "keys")) $root.proto.KeyList.encode(m6.keys, w5.uint32(26).fork()).ldelim();
          if (m6.contents != null && Object.hasOwnProperty.call(m6, "contents")) w5.uint32(34).bytes(m6.contents);
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) $root.google.protobuf.StringValue.encode(m6.memo, w5.uint32(42).fork()).ldelim();
          return w5;
        };
        FileUpdateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileUpdateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.keys = $root.proto.KeyList.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.contents = r41.bytes();
                break;
              }
              case 5: {
                m6.memo = $root.google.protobuf.StringValue.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FileUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FileUpdateTransactionBody";
        };
        return FileUpdateTransactionBody;
      })();
      proto37.ContractDeleteTransactionBody = (function() {
        function ContractDeleteTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractDeleteTransactionBody.prototype.contractID = null;
        ContractDeleteTransactionBody.prototype.transferAccountID = null;
        ContractDeleteTransactionBody.prototype.transferContractID = null;
        ContractDeleteTransactionBody.prototype.permanentRemoval = false;
        let $oneOfFields;
        Object.defineProperty(ContractDeleteTransactionBody.prototype, "obtainers", { get: $util.oneOfGetter($oneOfFields = ["transferAccountID", "transferContractID"]), set: $util.oneOfSetter($oneOfFields) });
        ContractDeleteTransactionBody.create = function create(properties) {
          return new ContractDeleteTransactionBody(properties);
        };
        ContractDeleteTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(10).fork()).ldelim();
          if (m6.transferAccountID != null && Object.hasOwnProperty.call(m6, "transferAccountID")) $root.proto.AccountID.encode(m6.transferAccountID, w5.uint32(18).fork()).ldelim();
          if (m6.transferContractID != null && Object.hasOwnProperty.call(m6, "transferContractID")) $root.proto.ContractID.encode(m6.transferContractID, w5.uint32(26).fork()).ldelim();
          if (m6.permanentRemoval != null && Object.hasOwnProperty.call(m6, "permanentRemoval")) w5.uint32(32).bool(m6.permanentRemoval);
          return w5;
        };
        ContractDeleteTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractDeleteTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.transferAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.transferContractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.permanentRemoval = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractDeleteTransactionBody";
        };
        return ContractDeleteTransactionBody;
      })();
      proto37.ConsensusCreateTopicTransactionBody = (function() {
        function ConsensusCreateTopicTransactionBody(p3) {
          this.feeExemptKeyList = [];
          this.customFees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ConsensusCreateTopicTransactionBody.prototype.memo = "";
        ConsensusCreateTopicTransactionBody.prototype.adminKey = null;
        ConsensusCreateTopicTransactionBody.prototype.submitKey = null;
        ConsensusCreateTopicTransactionBody.prototype.autoRenewPeriod = null;
        ConsensusCreateTopicTransactionBody.prototype.autoRenewAccount = null;
        ConsensusCreateTopicTransactionBody.prototype.feeScheduleKey = null;
        ConsensusCreateTopicTransactionBody.prototype.feeExemptKeyList = $util.emptyArray;
        ConsensusCreateTopicTransactionBody.prototype.customFees = $util.emptyArray;
        ConsensusCreateTopicTransactionBody.create = function create(properties) {
          return new ConsensusCreateTopicTransactionBody(properties);
        };
        ConsensusCreateTopicTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(10).string(m6.memo);
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(18).fork()).ldelim();
          if (m6.submitKey != null && Object.hasOwnProperty.call(m6, "submitKey")) $root.proto.Key.encode(m6.submitKey, w5.uint32(26).fork()).ldelim();
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(50).fork()).ldelim();
          if (m6.autoRenewAccount != null && Object.hasOwnProperty.call(m6, "autoRenewAccount")) $root.proto.AccountID.encode(m6.autoRenewAccount, w5.uint32(58).fork()).ldelim();
          if (m6.feeScheduleKey != null && Object.hasOwnProperty.call(m6, "feeScheduleKey")) $root.proto.Key.encode(m6.feeScheduleKey, w5.uint32(66).fork()).ldelim();
          if (m6.feeExemptKeyList != null && m6.feeExemptKeyList.length) {
            for (var i17 = 0; i17 < m6.feeExemptKeyList.length; ++i17) $root.proto.Key.encode(m6.feeExemptKeyList[i17], w5.uint32(74).fork()).ldelim();
          }
          if (m6.customFees != null && m6.customFees.length) {
            for (var i17 = 0; i17 < m6.customFees.length; ++i17) $root.proto.FixedCustomFee.encode(m6.customFees[i17], w5.uint32(82).fork()).ldelim();
          }
          return w5;
        };
        ConsensusCreateTopicTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ConsensusCreateTopicTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.memo = r41.string();
                break;
              }
              case 2: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.submitKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.autoRenewAccount = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.feeScheduleKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                if (!(m6.feeExemptKeyList && m6.feeExemptKeyList.length)) m6.feeExemptKeyList = [];
                m6.feeExemptKeyList.push($root.proto.Key.decode(r41, r41.uint32()));
                break;
              }
              case 10: {
                if (!(m6.customFees && m6.customFees.length)) m6.customFees = [];
                m6.customFees.push($root.proto.FixedCustomFee.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ConsensusCreateTopicTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ConsensusCreateTopicTransactionBody";
        };
        return ConsensusCreateTopicTransactionBody;
      })();
      proto37.FractionalFee = (function() {
        function FractionalFee(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FractionalFee.prototype.fractionalAmount = null;
        FractionalFee.prototype.minimumAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FractionalFee.prototype.maximumAmount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FractionalFee.prototype.netOfTransfers = false;
        FractionalFee.create = function create(properties) {
          return new FractionalFee(properties);
        };
        FractionalFee.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fractionalAmount != null && Object.hasOwnProperty.call(m6, "fractionalAmount")) $root.proto.Fraction.encode(m6.fractionalAmount, w5.uint32(10).fork()).ldelim();
          if (m6.minimumAmount != null && Object.hasOwnProperty.call(m6, "minimumAmount")) w5.uint32(16).int64(m6.minimumAmount);
          if (m6.maximumAmount != null && Object.hasOwnProperty.call(m6, "maximumAmount")) w5.uint32(24).int64(m6.maximumAmount);
          if (m6.netOfTransfers != null && Object.hasOwnProperty.call(m6, "netOfTransfers")) w5.uint32(32).bool(m6.netOfTransfers);
          return w5;
        };
        FractionalFee.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FractionalFee();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.fractionalAmount = $root.proto.Fraction.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.minimumAmount = r41.int64();
                break;
              }
              case 3: {
                m6.maximumAmount = r41.int64();
                break;
              }
              case 4: {
                m6.netOfTransfers = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FractionalFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FractionalFee";
        };
        return FractionalFee;
      })();
      proto37.FixedFee = (function() {
        function FixedFee(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FixedFee.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        FixedFee.prototype.denominatingTokenId = null;
        FixedFee.create = function create(properties) {
          return new FixedFee(properties);
        };
        FixedFee.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(8).int64(m6.amount);
          if (m6.denominatingTokenId != null && Object.hasOwnProperty.call(m6, "denominatingTokenId")) $root.proto.TokenID.encode(m6.denominatingTokenId, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        FixedFee.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FixedFee();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.amount = r41.int64();
                break;
              }
              case 2: {
                m6.denominatingTokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FixedFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FixedFee";
        };
        return FixedFee;
      })();
      proto37.RoyaltyFee = (function() {
        function RoyaltyFee(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        RoyaltyFee.prototype.exchangeValueFraction = null;
        RoyaltyFee.prototype.fallbackFee = null;
        RoyaltyFee.create = function create(properties) {
          return new RoyaltyFee(properties);
        };
        RoyaltyFee.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.exchangeValueFraction != null && Object.hasOwnProperty.call(m6, "exchangeValueFraction")) $root.proto.Fraction.encode(m6.exchangeValueFraction, w5.uint32(10).fork()).ldelim();
          if (m6.fallbackFee != null && Object.hasOwnProperty.call(m6, "fallbackFee")) $root.proto.FixedFee.encode(m6.fallbackFee, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        RoyaltyFee.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.RoyaltyFee();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.exchangeValueFraction = $root.proto.Fraction.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.fallbackFee = $root.proto.FixedFee.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        RoyaltyFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.RoyaltyFee";
        };
        return RoyaltyFee;
      })();
      proto37.CustomFee = (function() {
        function CustomFee(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CustomFee.prototype.fixedFee = null;
        CustomFee.prototype.fractionalFee = null;
        CustomFee.prototype.royaltyFee = null;
        CustomFee.prototype.feeCollectorAccountId = null;
        CustomFee.prototype.allCollectorsAreExempt = false;
        let $oneOfFields;
        Object.defineProperty(CustomFee.prototype, "fee", { get: $util.oneOfGetter($oneOfFields = ["fixedFee", "fractionalFee", "royaltyFee"]), set: $util.oneOfSetter($oneOfFields) });
        CustomFee.create = function create(properties) {
          return new CustomFee(properties);
        };
        CustomFee.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fixedFee != null && Object.hasOwnProperty.call(m6, "fixedFee")) $root.proto.FixedFee.encode(m6.fixedFee, w5.uint32(10).fork()).ldelim();
          if (m6.fractionalFee != null && Object.hasOwnProperty.call(m6, "fractionalFee")) $root.proto.FractionalFee.encode(m6.fractionalFee, w5.uint32(18).fork()).ldelim();
          if (m6.feeCollectorAccountId != null && Object.hasOwnProperty.call(m6, "feeCollectorAccountId")) $root.proto.AccountID.encode(m6.feeCollectorAccountId, w5.uint32(26).fork()).ldelim();
          if (m6.royaltyFee != null && Object.hasOwnProperty.call(m6, "royaltyFee")) $root.proto.RoyaltyFee.encode(m6.royaltyFee, w5.uint32(34).fork()).ldelim();
          if (m6.allCollectorsAreExempt != null && Object.hasOwnProperty.call(m6, "allCollectorsAreExempt")) w5.uint32(40).bool(m6.allCollectorsAreExempt);
          return w5;
        };
        CustomFee.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CustomFee();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.fixedFee = $root.proto.FixedFee.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.fractionalFee = $root.proto.FractionalFee.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.royaltyFee = $root.proto.RoyaltyFee.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.feeCollectorAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.allCollectorsAreExempt = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CustomFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CustomFee";
        };
        return CustomFee;
      })();
      proto37.AssessedCustomFee = (function() {
        function AssessedCustomFee(p3) {
          this.effectivePayerAccountId = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        AssessedCustomFee.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AssessedCustomFee.prototype.tokenId = null;
        AssessedCustomFee.prototype.feeCollectorAccountId = null;
        AssessedCustomFee.prototype.effectivePayerAccountId = $util.emptyArray;
        AssessedCustomFee.create = function create(properties) {
          return new AssessedCustomFee(properties);
        };
        AssessedCustomFee.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(8).int64(m6.amount);
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(18).fork()).ldelim();
          if (m6.feeCollectorAccountId != null && Object.hasOwnProperty.call(m6, "feeCollectorAccountId")) $root.proto.AccountID.encode(m6.feeCollectorAccountId, w5.uint32(26).fork()).ldelim();
          if (m6.effectivePayerAccountId != null && m6.effectivePayerAccountId.length) {
            for (var i17 = 0; i17 < m6.effectivePayerAccountId.length; ++i17) $root.proto.AccountID.encode(m6.effectivePayerAccountId[i17], w5.uint32(34).fork()).ldelim();
          }
          return w5;
        };
        AssessedCustomFee.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.AssessedCustomFee();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.amount = r41.int64();
                break;
              }
              case 2: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.feeCollectorAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                if (!(m6.effectivePayerAccountId && m6.effectivePayerAccountId.length)) m6.effectivePayerAccountId = [];
                m6.effectivePayerAccountId.push($root.proto.AccountID.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        AssessedCustomFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.AssessedCustomFee";
        };
        return AssessedCustomFee;
      })();
      proto37.FixedCustomFee = (function() {
        function FixedCustomFee(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FixedCustomFee.prototype.fixedFee = null;
        FixedCustomFee.prototype.feeCollectorAccountId = null;
        FixedCustomFee.create = function create(properties) {
          return new FixedCustomFee(properties);
        };
        FixedCustomFee.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fixedFee != null && Object.hasOwnProperty.call(m6, "fixedFee")) $root.proto.FixedFee.encode(m6.fixedFee, w5.uint32(10).fork()).ldelim();
          if (m6.feeCollectorAccountId != null && Object.hasOwnProperty.call(m6, "feeCollectorAccountId")) $root.proto.AccountID.encode(m6.feeCollectorAccountId, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        FixedCustomFee.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FixedCustomFee();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.fixedFee = $root.proto.FixedFee.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.feeCollectorAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FixedCustomFee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FixedCustomFee";
        };
        return FixedCustomFee;
      })();
      proto37.FixedCustomFeeList = (function() {
        function FixedCustomFeeList(p3) {
          this.fees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FixedCustomFeeList.prototype.fees = $util.emptyArray;
        FixedCustomFeeList.create = function create(properties) {
          return new FixedCustomFeeList(properties);
        };
        FixedCustomFeeList.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fees != null && m6.fees.length) {
            for (var i17 = 0; i17 < m6.fees.length; ++i17) $root.proto.FixedCustomFee.encode(m6.fees[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        FixedCustomFeeList.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FixedCustomFeeList();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.fees && m6.fees.length)) m6.fees = [];
                m6.fees.push($root.proto.FixedCustomFee.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FixedCustomFeeList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FixedCustomFeeList";
        };
        return FixedCustomFeeList;
      })();
      proto37.FeeExemptKeyList = (function() {
        function FeeExemptKeyList(p3) {
          this.keys = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FeeExemptKeyList.prototype.keys = $util.emptyArray;
        FeeExemptKeyList.create = function create(properties) {
          return new FeeExemptKeyList(properties);
        };
        FeeExemptKeyList.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.keys != null && m6.keys.length) {
            for (var i17 = 0; i17 < m6.keys.length; ++i17) $root.proto.Key.encode(m6.keys[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        FeeExemptKeyList.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FeeExemptKeyList();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.keys && m6.keys.length)) m6.keys = [];
                m6.keys.push($root.proto.Key.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FeeExemptKeyList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FeeExemptKeyList";
        };
        return FeeExemptKeyList;
      })();
      proto37.CustomFeeLimit = (function() {
        function CustomFeeLimit(p3) {
          this.fees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CustomFeeLimit.prototype.accountId = null;
        CustomFeeLimit.prototype.fees = $util.emptyArray;
        CustomFeeLimit.create = function create(properties) {
          return new CustomFeeLimit(properties);
        };
        CustomFeeLimit.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountId != null && Object.hasOwnProperty.call(m6, "accountId")) $root.proto.AccountID.encode(m6.accountId, w5.uint32(10).fork()).ldelim();
          if (m6.fees != null && m6.fees.length) {
            for (var i17 = 0; i17 < m6.fees.length; ++i17) $root.proto.FixedFee.encode(m6.fees[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        CustomFeeLimit.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CustomFeeLimit();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.accountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.fees && m6.fees.length)) m6.fees = [];
                m6.fees.push($root.proto.FixedFee.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CustomFeeLimit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CustomFeeLimit";
        };
        return CustomFeeLimit;
      })();
      proto37.ConsensusUpdateTopicTransactionBody = (function() {
        function ConsensusUpdateTopicTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ConsensusUpdateTopicTransactionBody.prototype.topicID = null;
        ConsensusUpdateTopicTransactionBody.prototype.memo = null;
        ConsensusUpdateTopicTransactionBody.prototype.expirationTime = null;
        ConsensusUpdateTopicTransactionBody.prototype.adminKey = null;
        ConsensusUpdateTopicTransactionBody.prototype.submitKey = null;
        ConsensusUpdateTopicTransactionBody.prototype.autoRenewPeriod = null;
        ConsensusUpdateTopicTransactionBody.prototype.autoRenewAccount = null;
        ConsensusUpdateTopicTransactionBody.prototype.feeScheduleKey = null;
        ConsensusUpdateTopicTransactionBody.prototype.feeExemptKeyList = null;
        ConsensusUpdateTopicTransactionBody.prototype.customFees = null;
        ConsensusUpdateTopicTransactionBody.create = function create(properties) {
          return new ConsensusUpdateTopicTransactionBody(properties);
        };
        ConsensusUpdateTopicTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.topicID != null && Object.hasOwnProperty.call(m6, "topicID")) $root.proto.TopicID.encode(m6.topicID, w5.uint32(10).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) $root.google.protobuf.StringValue.encode(m6.memo, w5.uint32(18).fork()).ldelim();
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(34).fork()).ldelim();
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(50).fork()).ldelim();
          if (m6.submitKey != null && Object.hasOwnProperty.call(m6, "submitKey")) $root.proto.Key.encode(m6.submitKey, w5.uint32(58).fork()).ldelim();
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(66).fork()).ldelim();
          if (m6.autoRenewAccount != null && Object.hasOwnProperty.call(m6, "autoRenewAccount")) $root.proto.AccountID.encode(m6.autoRenewAccount, w5.uint32(74).fork()).ldelim();
          if (m6.feeScheduleKey != null && Object.hasOwnProperty.call(m6, "feeScheduleKey")) $root.proto.Key.encode(m6.feeScheduleKey, w5.uint32(82).fork()).ldelim();
          if (m6.feeExemptKeyList != null && Object.hasOwnProperty.call(m6, "feeExemptKeyList")) $root.proto.FeeExemptKeyList.encode(m6.feeExemptKeyList, w5.uint32(90).fork()).ldelim();
          if (m6.customFees != null && Object.hasOwnProperty.call(m6, "customFees")) $root.proto.FixedCustomFeeList.encode(m6.customFees, w5.uint32(98).fork()).ldelim();
          return w5;
        };
        ConsensusUpdateTopicTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ConsensusUpdateTopicTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.topicID = $root.proto.TopicID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.memo = $root.google.protobuf.StringValue.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.submitKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.autoRenewAccount = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.feeScheduleKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.feeExemptKeyList = $root.proto.FeeExemptKeyList.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.customFees = $root.proto.FixedCustomFeeList.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ConsensusUpdateTopicTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ConsensusUpdateTopicTransactionBody";
        };
        return ConsensusUpdateTopicTransactionBody;
      })();
      proto37.ConsensusDeleteTopicTransactionBody = (function() {
        function ConsensusDeleteTopicTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ConsensusDeleteTopicTransactionBody.prototype.topicID = null;
        ConsensusDeleteTopicTransactionBody.create = function create(properties) {
          return new ConsensusDeleteTopicTransactionBody(properties);
        };
        ConsensusDeleteTopicTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.topicID != null && Object.hasOwnProperty.call(m6, "topicID")) $root.proto.TopicID.encode(m6.topicID, w5.uint32(10).fork()).ldelim();
          return w5;
        };
        ConsensusDeleteTopicTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ConsensusDeleteTopicTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.topicID = $root.proto.TopicID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ConsensusDeleteTopicTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ConsensusDeleteTopicTransactionBody";
        };
        return ConsensusDeleteTopicTransactionBody;
      })();
      proto37.ConsensusMessageChunkInfo = (function() {
        function ConsensusMessageChunkInfo(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ConsensusMessageChunkInfo.prototype.initialTransactionID = null;
        ConsensusMessageChunkInfo.prototype.total = 0;
        ConsensusMessageChunkInfo.prototype.number = 0;
        ConsensusMessageChunkInfo.create = function create(properties) {
          return new ConsensusMessageChunkInfo(properties);
        };
        ConsensusMessageChunkInfo.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.initialTransactionID != null && Object.hasOwnProperty.call(m6, "initialTransactionID")) $root.proto.TransactionID.encode(m6.initialTransactionID, w5.uint32(10).fork()).ldelim();
          if (m6.total != null && Object.hasOwnProperty.call(m6, "total")) w5.uint32(16).int32(m6.total);
          if (m6.number != null && Object.hasOwnProperty.call(m6, "number")) w5.uint32(24).int32(m6.number);
          return w5;
        };
        ConsensusMessageChunkInfo.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ConsensusMessageChunkInfo();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.initialTransactionID = $root.proto.TransactionID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.total = r41.int32();
                break;
              }
              case 3: {
                m6.number = r41.int32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ConsensusMessageChunkInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ConsensusMessageChunkInfo";
        };
        return ConsensusMessageChunkInfo;
      })();
      proto37.ConsensusSubmitMessageTransactionBody = (function() {
        function ConsensusSubmitMessageTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ConsensusSubmitMessageTransactionBody.prototype.topicID = null;
        ConsensusSubmitMessageTransactionBody.prototype.message = $util.newBuffer([]);
        ConsensusSubmitMessageTransactionBody.prototype.chunkInfo = null;
        ConsensusSubmitMessageTransactionBody.create = function create(properties) {
          return new ConsensusSubmitMessageTransactionBody(properties);
        };
        ConsensusSubmitMessageTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.topicID != null && Object.hasOwnProperty.call(m6, "topicID")) $root.proto.TopicID.encode(m6.topicID, w5.uint32(10).fork()).ldelim();
          if (m6.message != null && Object.hasOwnProperty.call(m6, "message")) w5.uint32(18).bytes(m6.message);
          if (m6.chunkInfo != null && Object.hasOwnProperty.call(m6, "chunkInfo")) $root.proto.ConsensusMessageChunkInfo.encode(m6.chunkInfo, w5.uint32(26).fork()).ldelim();
          return w5;
        };
        ConsensusSubmitMessageTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ConsensusSubmitMessageTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.topicID = $root.proto.TopicID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.message = r41.bytes();
                break;
              }
              case 3: {
                m6.chunkInfo = $root.proto.ConsensusMessageChunkInfo.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ConsensusSubmitMessageTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ConsensusSubmitMessageTransactionBody";
        };
        return ConsensusSubmitMessageTransactionBody;
      })();
      proto37.UncheckedSubmitBody = (function() {
        function UncheckedSubmitBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        UncheckedSubmitBody.prototype.transactionBytes = $util.newBuffer([]);
        UncheckedSubmitBody.create = function create(properties) {
          return new UncheckedSubmitBody(properties);
        };
        UncheckedSubmitBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transactionBytes != null && Object.hasOwnProperty.call(m6, "transactionBytes")) w5.uint32(10).bytes(m6.transactionBytes);
          return w5;
        };
        UncheckedSubmitBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.UncheckedSubmitBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.transactionBytes = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        UncheckedSubmitBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.UncheckedSubmitBody";
        };
        return UncheckedSubmitBody;
      })();
      proto37.TokenCreateTransactionBody = (function() {
        function TokenCreateTransactionBody(p3) {
          this.customFees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenCreateTransactionBody.prototype.name = "";
        TokenCreateTransactionBody.prototype.symbol = "";
        TokenCreateTransactionBody.prototype.decimals = 0;
        TokenCreateTransactionBody.prototype.initialSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TokenCreateTransactionBody.prototype.treasury = null;
        TokenCreateTransactionBody.prototype.adminKey = null;
        TokenCreateTransactionBody.prototype.kycKey = null;
        TokenCreateTransactionBody.prototype.freezeKey = null;
        TokenCreateTransactionBody.prototype.wipeKey = null;
        TokenCreateTransactionBody.prototype.supplyKey = null;
        TokenCreateTransactionBody.prototype.freezeDefault = false;
        TokenCreateTransactionBody.prototype.expiry = null;
        TokenCreateTransactionBody.prototype.autoRenewAccount = null;
        TokenCreateTransactionBody.prototype.autoRenewPeriod = null;
        TokenCreateTransactionBody.prototype.memo = "";
        TokenCreateTransactionBody.prototype.tokenType = 0;
        TokenCreateTransactionBody.prototype.supplyType = 0;
        TokenCreateTransactionBody.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenCreateTransactionBody.prototype.feeScheduleKey = null;
        TokenCreateTransactionBody.prototype.customFees = $util.emptyArray;
        TokenCreateTransactionBody.prototype.pauseKey = null;
        TokenCreateTransactionBody.prototype.metadata = $util.newBuffer([]);
        TokenCreateTransactionBody.prototype.metadataKey = null;
        TokenCreateTransactionBody.create = function create(properties) {
          return new TokenCreateTransactionBody(properties);
        };
        TokenCreateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.name != null && Object.hasOwnProperty.call(m6, "name")) w5.uint32(10).string(m6.name);
          if (m6.symbol != null && Object.hasOwnProperty.call(m6, "symbol")) w5.uint32(18).string(m6.symbol);
          if (m6.decimals != null && Object.hasOwnProperty.call(m6, "decimals")) w5.uint32(24).uint32(m6.decimals);
          if (m6.initialSupply != null && Object.hasOwnProperty.call(m6, "initialSupply")) w5.uint32(32).uint64(m6.initialSupply);
          if (m6.treasury != null && Object.hasOwnProperty.call(m6, "treasury")) $root.proto.AccountID.encode(m6.treasury, w5.uint32(42).fork()).ldelim();
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(50).fork()).ldelim();
          if (m6.kycKey != null && Object.hasOwnProperty.call(m6, "kycKey")) $root.proto.Key.encode(m6.kycKey, w5.uint32(58).fork()).ldelim();
          if (m6.freezeKey != null && Object.hasOwnProperty.call(m6, "freezeKey")) $root.proto.Key.encode(m6.freezeKey, w5.uint32(66).fork()).ldelim();
          if (m6.wipeKey != null && Object.hasOwnProperty.call(m6, "wipeKey")) $root.proto.Key.encode(m6.wipeKey, w5.uint32(74).fork()).ldelim();
          if (m6.supplyKey != null && Object.hasOwnProperty.call(m6, "supplyKey")) $root.proto.Key.encode(m6.supplyKey, w5.uint32(82).fork()).ldelim();
          if (m6.freezeDefault != null && Object.hasOwnProperty.call(m6, "freezeDefault")) w5.uint32(88).bool(m6.freezeDefault);
          if (m6.expiry != null && Object.hasOwnProperty.call(m6, "expiry")) $root.proto.Timestamp.encode(m6.expiry, w5.uint32(106).fork()).ldelim();
          if (m6.autoRenewAccount != null && Object.hasOwnProperty.call(m6, "autoRenewAccount")) $root.proto.AccountID.encode(m6.autoRenewAccount, w5.uint32(114).fork()).ldelim();
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(122).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(130).string(m6.memo);
          if (m6.tokenType != null && Object.hasOwnProperty.call(m6, "tokenType")) w5.uint32(136).int32(m6.tokenType);
          if (m6.supplyType != null && Object.hasOwnProperty.call(m6, "supplyType")) w5.uint32(144).int32(m6.supplyType);
          if (m6.maxSupply != null && Object.hasOwnProperty.call(m6, "maxSupply")) w5.uint32(152).int64(m6.maxSupply);
          if (m6.feeScheduleKey != null && Object.hasOwnProperty.call(m6, "feeScheduleKey")) $root.proto.Key.encode(m6.feeScheduleKey, w5.uint32(162).fork()).ldelim();
          if (m6.customFees != null && m6.customFees.length) {
            for (var i17 = 0; i17 < m6.customFees.length; ++i17) $root.proto.CustomFee.encode(m6.customFees[i17], w5.uint32(170).fork()).ldelim();
          }
          if (m6.pauseKey != null && Object.hasOwnProperty.call(m6, "pauseKey")) $root.proto.Key.encode(m6.pauseKey, w5.uint32(178).fork()).ldelim();
          if (m6.metadata != null && Object.hasOwnProperty.call(m6, "metadata")) w5.uint32(186).bytes(m6.metadata);
          if (m6.metadataKey != null && Object.hasOwnProperty.call(m6, "metadataKey")) $root.proto.Key.encode(m6.metadataKey, w5.uint32(194).fork()).ldelim();
          return w5;
        };
        TokenCreateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenCreateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.name = r41.string();
                break;
              }
              case 2: {
                m6.symbol = r41.string();
                break;
              }
              case 3: {
                m6.decimals = r41.uint32();
                break;
              }
              case 4: {
                m6.initialSupply = r41.uint64();
                break;
              }
              case 5: {
                m6.treasury = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.kycKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.freezeKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.wipeKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.supplyKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.freezeDefault = r41.bool();
                break;
              }
              case 13: {
                m6.expiry = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                m6.autoRenewAccount = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 15: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.memo = r41.string();
                break;
              }
              case 17: {
                m6.tokenType = r41.int32();
                break;
              }
              case 18: {
                m6.supplyType = r41.int32();
                break;
              }
              case 19: {
                m6.maxSupply = r41.int64();
                break;
              }
              case 20: {
                m6.feeScheduleKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 21: {
                if (!(m6.customFees && m6.customFees.length)) m6.customFees = [];
                m6.customFees.push($root.proto.CustomFee.decode(r41, r41.uint32()));
                break;
              }
              case 22: {
                m6.pauseKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 23: {
                m6.metadata = r41.bytes();
                break;
              }
              case 24: {
                m6.metadataKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenCreateTransactionBody";
        };
        return TokenCreateTransactionBody;
      })();
      proto37.TokenFreezeAccountTransactionBody = (function() {
        function TokenFreezeAccountTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenFreezeAccountTransactionBody.prototype.token = null;
        TokenFreezeAccountTransactionBody.prototype.account = null;
        TokenFreezeAccountTransactionBody.create = function create(properties) {
          return new TokenFreezeAccountTransactionBody(properties);
        };
        TokenFreezeAccountTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.account != null && Object.hasOwnProperty.call(m6, "account")) $root.proto.AccountID.encode(m6.account, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenFreezeAccountTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenFreezeAccountTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.account = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenFreezeAccountTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenFreezeAccountTransactionBody";
        };
        return TokenFreezeAccountTransactionBody;
      })();
      proto37.TokenUnfreezeAccountTransactionBody = (function() {
        function TokenUnfreezeAccountTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenUnfreezeAccountTransactionBody.prototype.token = null;
        TokenUnfreezeAccountTransactionBody.prototype.account = null;
        TokenUnfreezeAccountTransactionBody.create = function create(properties) {
          return new TokenUnfreezeAccountTransactionBody(properties);
        };
        TokenUnfreezeAccountTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.account != null && Object.hasOwnProperty.call(m6, "account")) $root.proto.AccountID.encode(m6.account, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenUnfreezeAccountTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenUnfreezeAccountTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.account = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenUnfreezeAccountTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenUnfreezeAccountTransactionBody";
        };
        return TokenUnfreezeAccountTransactionBody;
      })();
      proto37.TokenGrantKycTransactionBody = (function() {
        function TokenGrantKycTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenGrantKycTransactionBody.prototype.token = null;
        TokenGrantKycTransactionBody.prototype.account = null;
        TokenGrantKycTransactionBody.create = function create(properties) {
          return new TokenGrantKycTransactionBody(properties);
        };
        TokenGrantKycTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.account != null && Object.hasOwnProperty.call(m6, "account")) $root.proto.AccountID.encode(m6.account, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenGrantKycTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenGrantKycTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.account = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenGrantKycTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenGrantKycTransactionBody";
        };
        return TokenGrantKycTransactionBody;
      })();
      proto37.TokenRevokeKycTransactionBody = (function() {
        function TokenRevokeKycTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenRevokeKycTransactionBody.prototype.token = null;
        TokenRevokeKycTransactionBody.prototype.account = null;
        TokenRevokeKycTransactionBody.create = function create(properties) {
          return new TokenRevokeKycTransactionBody(properties);
        };
        TokenRevokeKycTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.account != null && Object.hasOwnProperty.call(m6, "account")) $root.proto.AccountID.encode(m6.account, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenRevokeKycTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenRevokeKycTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.account = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenRevokeKycTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenRevokeKycTransactionBody";
        };
        return TokenRevokeKycTransactionBody;
      })();
      proto37.TokenDeleteTransactionBody = (function() {
        function TokenDeleteTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenDeleteTransactionBody.prototype.token = null;
        TokenDeleteTransactionBody.create = function create(properties) {
          return new TokenDeleteTransactionBody(properties);
        };
        TokenDeleteTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          return w5;
        };
        TokenDeleteTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenDeleteTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenDeleteTransactionBody";
        };
        return TokenDeleteTransactionBody;
      })();
      proto37.TokenUpdateTransactionBody = (function() {
        function TokenUpdateTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenUpdateTransactionBody.prototype.token = null;
        TokenUpdateTransactionBody.prototype.symbol = "";
        TokenUpdateTransactionBody.prototype.name = "";
        TokenUpdateTransactionBody.prototype.treasury = null;
        TokenUpdateTransactionBody.prototype.adminKey = null;
        TokenUpdateTransactionBody.prototype.kycKey = null;
        TokenUpdateTransactionBody.prototype.freezeKey = null;
        TokenUpdateTransactionBody.prototype.wipeKey = null;
        TokenUpdateTransactionBody.prototype.supplyKey = null;
        TokenUpdateTransactionBody.prototype.autoRenewAccount = null;
        TokenUpdateTransactionBody.prototype.autoRenewPeriod = null;
        TokenUpdateTransactionBody.prototype.expiry = null;
        TokenUpdateTransactionBody.prototype.memo = null;
        TokenUpdateTransactionBody.prototype.feeScheduleKey = null;
        TokenUpdateTransactionBody.prototype.pauseKey = null;
        TokenUpdateTransactionBody.prototype.metadata = null;
        TokenUpdateTransactionBody.prototype.metadataKey = null;
        TokenUpdateTransactionBody.prototype.keyVerificationMode = 0;
        TokenUpdateTransactionBody.create = function create(properties) {
          return new TokenUpdateTransactionBody(properties);
        };
        TokenUpdateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.symbol != null && Object.hasOwnProperty.call(m6, "symbol")) w5.uint32(18).string(m6.symbol);
          if (m6.name != null && Object.hasOwnProperty.call(m6, "name")) w5.uint32(26).string(m6.name);
          if (m6.treasury != null && Object.hasOwnProperty.call(m6, "treasury")) $root.proto.AccountID.encode(m6.treasury, w5.uint32(34).fork()).ldelim();
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(42).fork()).ldelim();
          if (m6.kycKey != null && Object.hasOwnProperty.call(m6, "kycKey")) $root.proto.Key.encode(m6.kycKey, w5.uint32(50).fork()).ldelim();
          if (m6.freezeKey != null && Object.hasOwnProperty.call(m6, "freezeKey")) $root.proto.Key.encode(m6.freezeKey, w5.uint32(58).fork()).ldelim();
          if (m6.wipeKey != null && Object.hasOwnProperty.call(m6, "wipeKey")) $root.proto.Key.encode(m6.wipeKey, w5.uint32(66).fork()).ldelim();
          if (m6.supplyKey != null && Object.hasOwnProperty.call(m6, "supplyKey")) $root.proto.Key.encode(m6.supplyKey, w5.uint32(74).fork()).ldelim();
          if (m6.autoRenewAccount != null && Object.hasOwnProperty.call(m6, "autoRenewAccount")) $root.proto.AccountID.encode(m6.autoRenewAccount, w5.uint32(82).fork()).ldelim();
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(90).fork()).ldelim();
          if (m6.expiry != null && Object.hasOwnProperty.call(m6, "expiry")) $root.proto.Timestamp.encode(m6.expiry, w5.uint32(98).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) $root.google.protobuf.StringValue.encode(m6.memo, w5.uint32(106).fork()).ldelim();
          if (m6.feeScheduleKey != null && Object.hasOwnProperty.call(m6, "feeScheduleKey")) $root.proto.Key.encode(m6.feeScheduleKey, w5.uint32(114).fork()).ldelim();
          if (m6.pauseKey != null && Object.hasOwnProperty.call(m6, "pauseKey")) $root.proto.Key.encode(m6.pauseKey, w5.uint32(122).fork()).ldelim();
          if (m6.metadata != null && Object.hasOwnProperty.call(m6, "metadata")) $root.google.protobuf.BytesValue.encode(m6.metadata, w5.uint32(130).fork()).ldelim();
          if (m6.metadataKey != null && Object.hasOwnProperty.call(m6, "metadataKey")) $root.proto.Key.encode(m6.metadataKey, w5.uint32(138).fork()).ldelim();
          if (m6.keyVerificationMode != null && Object.hasOwnProperty.call(m6, "keyVerificationMode")) w5.uint32(144).int32(m6.keyVerificationMode);
          return w5;
        };
        TokenUpdateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenUpdateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.symbol = r41.string();
                break;
              }
              case 3: {
                m6.name = r41.string();
                break;
              }
              case 4: {
                m6.treasury = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.kycKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.freezeKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.wipeKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.supplyKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.autoRenewAccount = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.expiry = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.memo = $root.google.protobuf.StringValue.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                m6.feeScheduleKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 15: {
                m6.pauseKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.metadata = $root.google.protobuf.BytesValue.decode(r41, r41.uint32());
                break;
              }
              case 17: {
                m6.metadataKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 18: {
                m6.keyVerificationMode = r41.int32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenUpdateTransactionBody";
        };
        return TokenUpdateTransactionBody;
      })();
      proto37.TokenMintTransactionBody = (function() {
        function TokenMintTransactionBody(p3) {
          this.metadata = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenMintTransactionBody.prototype.token = null;
        TokenMintTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TokenMintTransactionBody.prototype.metadata = $util.emptyArray;
        TokenMintTransactionBody.create = function create(properties) {
          return new TokenMintTransactionBody(properties);
        };
        TokenMintTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(16).uint64(m6.amount);
          if (m6.metadata != null && m6.metadata.length) {
            for (var i17 = 0; i17 < m6.metadata.length; ++i17) w5.uint32(26).bytes(m6.metadata[i17]);
          }
          return w5;
        };
        TokenMintTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenMintTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.amount = r41.uint64();
                break;
              }
              case 3: {
                if (!(m6.metadata && m6.metadata.length)) m6.metadata = [];
                m6.metadata.push(r41.bytes());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenMintTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenMintTransactionBody";
        };
        return TokenMintTransactionBody;
      })();
      proto37.TokenBurnTransactionBody = (function() {
        function TokenBurnTransactionBody(p3) {
          this.serialNumbers = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenBurnTransactionBody.prototype.token = null;
        TokenBurnTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TokenBurnTransactionBody.prototype.serialNumbers = $util.emptyArray;
        TokenBurnTransactionBody.create = function create(properties) {
          return new TokenBurnTransactionBody(properties);
        };
        TokenBurnTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(16).uint64(m6.amount);
          if (m6.serialNumbers != null && m6.serialNumbers.length) {
            w5.uint32(26).fork();
            for (var i17 = 0; i17 < m6.serialNumbers.length; ++i17) w5.int64(m6.serialNumbers[i17]);
            w5.ldelim();
          }
          return w5;
        };
        TokenBurnTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenBurnTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.amount = r41.uint64();
                break;
              }
              case 3: {
                if (!(m6.serialNumbers && m6.serialNumbers.length)) m6.serialNumbers = [];
                if ((t35 & 7) === 2) {
                  var c22 = r41.uint32() + r41.pos;
                  while (r41.pos < c22) m6.serialNumbers.push(r41.int64());
                } else m6.serialNumbers.push(r41.int64());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenBurnTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenBurnTransactionBody";
        };
        return TokenBurnTransactionBody;
      })();
      proto37.TokenWipeAccountTransactionBody = (function() {
        function TokenWipeAccountTransactionBody(p3) {
          this.serialNumbers = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenWipeAccountTransactionBody.prototype.token = null;
        TokenWipeAccountTransactionBody.prototype.account = null;
        TokenWipeAccountTransactionBody.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TokenWipeAccountTransactionBody.prototype.serialNumbers = $util.emptyArray;
        TokenWipeAccountTransactionBody.create = function create(properties) {
          return new TokenWipeAccountTransactionBody(properties);
        };
        TokenWipeAccountTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.account != null && Object.hasOwnProperty.call(m6, "account")) $root.proto.AccountID.encode(m6.account, w5.uint32(18).fork()).ldelim();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(24).uint64(m6.amount);
          if (m6.serialNumbers != null && m6.serialNumbers.length) {
            w5.uint32(34).fork();
            for (var i17 = 0; i17 < m6.serialNumbers.length; ++i17) w5.int64(m6.serialNumbers[i17]);
            w5.ldelim();
          }
          return w5;
        };
        TokenWipeAccountTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenWipeAccountTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.account = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.amount = r41.uint64();
                break;
              }
              case 4: {
                if (!(m6.serialNumbers && m6.serialNumbers.length)) m6.serialNumbers = [];
                if ((t35 & 7) === 2) {
                  var c22 = r41.uint32() + r41.pos;
                  while (r41.pos < c22) m6.serialNumbers.push(r41.int64());
                } else m6.serialNumbers.push(r41.int64());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenWipeAccountTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenWipeAccountTransactionBody";
        };
        return TokenWipeAccountTransactionBody;
      })();
      proto37.TokenAssociateTransactionBody = (function() {
        function TokenAssociateTransactionBody(p3) {
          this.tokens = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenAssociateTransactionBody.prototype.account = null;
        TokenAssociateTransactionBody.prototype.tokens = $util.emptyArray;
        TokenAssociateTransactionBody.create = function create(properties) {
          return new TokenAssociateTransactionBody(properties);
        };
        TokenAssociateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.account != null && Object.hasOwnProperty.call(m6, "account")) $root.proto.AccountID.encode(m6.account, w5.uint32(10).fork()).ldelim();
          if (m6.tokens != null && m6.tokens.length) {
            for (var i17 = 0; i17 < m6.tokens.length; ++i17) $root.proto.TokenID.encode(m6.tokens[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        TokenAssociateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenAssociateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.account = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.tokens && m6.tokens.length)) m6.tokens = [];
                m6.tokens.push($root.proto.TokenID.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenAssociateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenAssociateTransactionBody";
        };
        return TokenAssociateTransactionBody;
      })();
      proto37.TokenDissociateTransactionBody = (function() {
        function TokenDissociateTransactionBody(p3) {
          this.tokens = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenDissociateTransactionBody.prototype.account = null;
        TokenDissociateTransactionBody.prototype.tokens = $util.emptyArray;
        TokenDissociateTransactionBody.create = function create(properties) {
          return new TokenDissociateTransactionBody(properties);
        };
        TokenDissociateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.account != null && Object.hasOwnProperty.call(m6, "account")) $root.proto.AccountID.encode(m6.account, w5.uint32(10).fork()).ldelim();
          if (m6.tokens != null && m6.tokens.length) {
            for (var i17 = 0; i17 < m6.tokens.length; ++i17) $root.proto.TokenID.encode(m6.tokens[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        TokenDissociateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenDissociateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.account = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.tokens && m6.tokens.length)) m6.tokens = [];
                m6.tokens.push($root.proto.TokenID.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenDissociateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenDissociateTransactionBody";
        };
        return TokenDissociateTransactionBody;
      })();
      proto37.TokenFeeScheduleUpdateTransactionBody = (function() {
        function TokenFeeScheduleUpdateTransactionBody(p3) {
          this.customFees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenFeeScheduleUpdateTransactionBody.prototype.tokenId = null;
        TokenFeeScheduleUpdateTransactionBody.prototype.customFees = $util.emptyArray;
        TokenFeeScheduleUpdateTransactionBody.create = function create(properties) {
          return new TokenFeeScheduleUpdateTransactionBody(properties);
        };
        TokenFeeScheduleUpdateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.customFees != null && m6.customFees.length) {
            for (var i17 = 0; i17 < m6.customFees.length; ++i17) $root.proto.CustomFee.encode(m6.customFees[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        TokenFeeScheduleUpdateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenFeeScheduleUpdateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.customFees && m6.customFees.length)) m6.customFees = [];
                m6.customFees.push($root.proto.CustomFee.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenFeeScheduleUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenFeeScheduleUpdateTransactionBody";
        };
        return TokenFeeScheduleUpdateTransactionBody;
      })();
      proto37.TokenPauseTransactionBody = (function() {
        function TokenPauseTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenPauseTransactionBody.prototype.token = null;
        TokenPauseTransactionBody.create = function create(properties) {
          return new TokenPauseTransactionBody(properties);
        };
        TokenPauseTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          return w5;
        };
        TokenPauseTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenPauseTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenPauseTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenPauseTransactionBody";
        };
        return TokenPauseTransactionBody;
      })();
      proto37.TokenUnpauseTransactionBody = (function() {
        function TokenUnpauseTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenUnpauseTransactionBody.prototype.token = null;
        TokenUnpauseTransactionBody.create = function create(properties) {
          return new TokenUnpauseTransactionBody(properties);
        };
        TokenUnpauseTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          return w5;
        };
        TokenUnpauseTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenUnpauseTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenUnpauseTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenUnpauseTransactionBody";
        };
        return TokenUnpauseTransactionBody;
      })();
      proto37.TokenUpdateNftsTransactionBody = (function() {
        function TokenUpdateNftsTransactionBody(p3) {
          this.serialNumbers = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenUpdateNftsTransactionBody.prototype.token = null;
        TokenUpdateNftsTransactionBody.prototype.serialNumbers = $util.emptyArray;
        TokenUpdateNftsTransactionBody.prototype.metadata = null;
        TokenUpdateNftsTransactionBody.create = function create(properties) {
          return new TokenUpdateNftsTransactionBody(properties);
        };
        TokenUpdateNftsTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(10).fork()).ldelim();
          if (m6.serialNumbers != null && m6.serialNumbers.length) {
            w5.uint32(18).fork();
            for (var i17 = 0; i17 < m6.serialNumbers.length; ++i17) w5.int64(m6.serialNumbers[i17]);
            w5.ldelim();
          }
          if (m6.metadata != null && Object.hasOwnProperty.call(m6, "metadata")) $root.google.protobuf.BytesValue.encode(m6.metadata, w5.uint32(26).fork()).ldelim();
          return w5;
        };
        TokenUpdateNftsTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenUpdateNftsTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.serialNumbers && m6.serialNumbers.length)) m6.serialNumbers = [];
                if ((t35 & 7) === 2) {
                  var c22 = r41.uint32() + r41.pos;
                  while (r41.pos < c22) m6.serialNumbers.push(r41.int64());
                } else m6.serialNumbers.push(r41.int64());
                break;
              }
              case 3: {
                m6.metadata = $root.google.protobuf.BytesValue.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenUpdateNftsTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenUpdateNftsTransactionBody";
        };
        return TokenUpdateNftsTransactionBody;
      })();
      proto37.TokenRejectTransactionBody = (function() {
        function TokenRejectTransactionBody(p3) {
          this.rejections = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenRejectTransactionBody.prototype.owner = null;
        TokenRejectTransactionBody.prototype.rejections = $util.emptyArray;
        TokenRejectTransactionBody.create = function create(properties) {
          return new TokenRejectTransactionBody(properties);
        };
        TokenRejectTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.owner != null && Object.hasOwnProperty.call(m6, "owner")) $root.proto.AccountID.encode(m6.owner, w5.uint32(10).fork()).ldelim();
          if (m6.rejections != null && m6.rejections.length) {
            for (var i17 = 0; i17 < m6.rejections.length; ++i17) $root.proto.TokenReference.encode(m6.rejections[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        TokenRejectTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenRejectTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.owner = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.rejections && m6.rejections.length)) m6.rejections = [];
                m6.rejections.push($root.proto.TokenReference.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenRejectTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenRejectTransactionBody";
        };
        return TokenRejectTransactionBody;
      })();
      proto37.TokenReference = (function() {
        function TokenReference(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenReference.prototype.fungibleToken = null;
        TokenReference.prototype.nft = null;
        let $oneOfFields;
        Object.defineProperty(TokenReference.prototype, "tokenIdentifier", { get: $util.oneOfGetter($oneOfFields = ["fungibleToken", "nft"]), set: $util.oneOfSetter($oneOfFields) });
        TokenReference.create = function create(properties) {
          return new TokenReference(properties);
        };
        TokenReference.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fungibleToken != null && Object.hasOwnProperty.call(m6, "fungibleToken")) $root.proto.TokenID.encode(m6.fungibleToken, w5.uint32(10).fork()).ldelim();
          if (m6.nft != null && Object.hasOwnProperty.call(m6, "nft")) $root.proto.NftID.encode(m6.nft, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenReference.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenReference();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.fungibleToken = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.nft = $root.proto.NftID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenReference.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenReference";
        };
        return TokenReference;
      })();
      proto37.TokenAirdropTransactionBody = (function() {
        function TokenAirdropTransactionBody(p3) {
          this.tokenTransfers = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenAirdropTransactionBody.prototype.tokenTransfers = $util.emptyArray;
        TokenAirdropTransactionBody.create = function create(properties) {
          return new TokenAirdropTransactionBody(properties);
        };
        TokenAirdropTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenTransfers != null && m6.tokenTransfers.length) {
            for (var i17 = 0; i17 < m6.tokenTransfers.length; ++i17) $root.proto.TokenTransferList.encode(m6.tokenTransfers[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        TokenAirdropTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenAirdropTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.tokenTransfers && m6.tokenTransfers.length)) m6.tokenTransfers = [];
                m6.tokenTransfers.push($root.proto.TokenTransferList.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenAirdropTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenAirdropTransactionBody";
        };
        return TokenAirdropTransactionBody;
      })();
      proto37.TokenCancelAirdropTransactionBody = (function() {
        function TokenCancelAirdropTransactionBody(p3) {
          this.pendingAirdrops = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenCancelAirdropTransactionBody.prototype.pendingAirdrops = $util.emptyArray;
        TokenCancelAirdropTransactionBody.create = function create(properties) {
          return new TokenCancelAirdropTransactionBody(properties);
        };
        TokenCancelAirdropTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.pendingAirdrops != null && m6.pendingAirdrops.length) {
            for (var i17 = 0; i17 < m6.pendingAirdrops.length; ++i17) $root.proto.PendingAirdropId.encode(m6.pendingAirdrops[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        TokenCancelAirdropTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenCancelAirdropTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.pendingAirdrops && m6.pendingAirdrops.length)) m6.pendingAirdrops = [];
                m6.pendingAirdrops.push($root.proto.PendingAirdropId.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenCancelAirdropTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenCancelAirdropTransactionBody";
        };
        return TokenCancelAirdropTransactionBody;
      })();
      proto37.TokenClaimAirdropTransactionBody = (function() {
        function TokenClaimAirdropTransactionBody(p3) {
          this.pendingAirdrops = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenClaimAirdropTransactionBody.prototype.pendingAirdrops = $util.emptyArray;
        TokenClaimAirdropTransactionBody.create = function create(properties) {
          return new TokenClaimAirdropTransactionBody(properties);
        };
        TokenClaimAirdropTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.pendingAirdrops != null && m6.pendingAirdrops.length) {
            for (var i17 = 0; i17 < m6.pendingAirdrops.length; ++i17) $root.proto.PendingAirdropId.encode(m6.pendingAirdrops[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        TokenClaimAirdropTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenClaimAirdropTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.pendingAirdrops && m6.pendingAirdrops.length)) m6.pendingAirdrops = [];
                m6.pendingAirdrops.push($root.proto.PendingAirdropId.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenClaimAirdropTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenClaimAirdropTransactionBody";
        };
        return TokenClaimAirdropTransactionBody;
      })();
      proto37.ScheduleCreateTransactionBody = (function() {
        function ScheduleCreateTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ScheduleCreateTransactionBody.prototype.scheduledTransactionBody = null;
        ScheduleCreateTransactionBody.prototype.memo = "";
        ScheduleCreateTransactionBody.prototype.adminKey = null;
        ScheduleCreateTransactionBody.prototype.payerAccountID = null;
        ScheduleCreateTransactionBody.prototype.expirationTime = null;
        ScheduleCreateTransactionBody.prototype.waitForExpiry = false;
        ScheduleCreateTransactionBody.create = function create(properties) {
          return new ScheduleCreateTransactionBody(properties);
        };
        ScheduleCreateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.scheduledTransactionBody != null && Object.hasOwnProperty.call(m6, "scheduledTransactionBody")) $root.proto.SchedulableTransactionBody.encode(m6.scheduledTransactionBody, w5.uint32(10).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(18).string(m6.memo);
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(26).fork()).ldelim();
          if (m6.payerAccountID != null && Object.hasOwnProperty.call(m6, "payerAccountID")) $root.proto.AccountID.encode(m6.payerAccountID, w5.uint32(34).fork()).ldelim();
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(42).fork()).ldelim();
          if (m6.waitForExpiry != null && Object.hasOwnProperty.call(m6, "waitForExpiry")) w5.uint32(104).bool(m6.waitForExpiry);
          return w5;
        };
        ScheduleCreateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ScheduleCreateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.memo = r41.string();
                break;
              }
              case 3: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.payerAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.waitForExpiry = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ScheduleCreateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ScheduleCreateTransactionBody";
        };
        return ScheduleCreateTransactionBody;
      })();
      proto37.SchedulableTransactionBody = (function() {
        function SchedulableTransactionBody(p3) {
          this.maxCustomFees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SchedulableTransactionBody.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        SchedulableTransactionBody.prototype.memo = "";
        SchedulableTransactionBody.prototype.contractCall = null;
        SchedulableTransactionBody.prototype.contractCreateInstance = null;
        SchedulableTransactionBody.prototype.contractUpdateInstance = null;
        SchedulableTransactionBody.prototype.contractDeleteInstance = null;
        SchedulableTransactionBody.prototype.cryptoCreateAccount = null;
        SchedulableTransactionBody.prototype.cryptoDelete = null;
        SchedulableTransactionBody.prototype.cryptoTransfer = null;
        SchedulableTransactionBody.prototype.cryptoUpdateAccount = null;
        SchedulableTransactionBody.prototype.fileAppend = null;
        SchedulableTransactionBody.prototype.fileCreate = null;
        SchedulableTransactionBody.prototype.fileDelete = null;
        SchedulableTransactionBody.prototype.fileUpdate = null;
        SchedulableTransactionBody.prototype.systemDelete = null;
        SchedulableTransactionBody.prototype.systemUndelete = null;
        SchedulableTransactionBody.prototype.freeze = null;
        SchedulableTransactionBody.prototype.consensusCreateTopic = null;
        SchedulableTransactionBody.prototype.consensusUpdateTopic = null;
        SchedulableTransactionBody.prototype.consensusDeleteTopic = null;
        SchedulableTransactionBody.prototype.consensusSubmitMessage = null;
        SchedulableTransactionBody.prototype.tokenCreation = null;
        SchedulableTransactionBody.prototype.tokenFreeze = null;
        SchedulableTransactionBody.prototype.tokenUnfreeze = null;
        SchedulableTransactionBody.prototype.tokenGrantKyc = null;
        SchedulableTransactionBody.prototype.tokenRevokeKyc = null;
        SchedulableTransactionBody.prototype.tokenDeletion = null;
        SchedulableTransactionBody.prototype.tokenUpdate = null;
        SchedulableTransactionBody.prototype.tokenMint = null;
        SchedulableTransactionBody.prototype.tokenBurn = null;
        SchedulableTransactionBody.prototype.tokenWipe = null;
        SchedulableTransactionBody.prototype.tokenAssociate = null;
        SchedulableTransactionBody.prototype.tokenDissociate = null;
        SchedulableTransactionBody.prototype.scheduleDelete = null;
        SchedulableTransactionBody.prototype.tokenPause = null;
        SchedulableTransactionBody.prototype.tokenUnpause = null;
        SchedulableTransactionBody.prototype.cryptoApproveAllowance = null;
        SchedulableTransactionBody.prototype.cryptoDeleteAllowance = null;
        SchedulableTransactionBody.prototype.tokenFeeScheduleUpdate = null;
        SchedulableTransactionBody.prototype.utilPrng = null;
        SchedulableTransactionBody.prototype.tokenUpdateNfts = null;
        SchedulableTransactionBody.prototype.nodeCreate = null;
        SchedulableTransactionBody.prototype.nodeUpdate = null;
        SchedulableTransactionBody.prototype.nodeDelete = null;
        SchedulableTransactionBody.prototype.tokenReject = null;
        SchedulableTransactionBody.prototype.tokenCancelAirdrop = null;
        SchedulableTransactionBody.prototype.tokenClaimAirdrop = null;
        SchedulableTransactionBody.prototype.tokenAirdrop = null;
        SchedulableTransactionBody.prototype.maxCustomFees = $util.emptyArray;
        let $oneOfFields;
        Object.defineProperty(SchedulableTransactionBody.prototype, "data", { get: $util.oneOfGetter($oneOfFields = ["contractCall", "contractCreateInstance", "contractUpdateInstance", "contractDeleteInstance", "cryptoCreateAccount", "cryptoDelete", "cryptoTransfer", "cryptoUpdateAccount", "fileAppend", "fileCreate", "fileDelete", "fileUpdate", "systemDelete", "systemUndelete", "freeze", "consensusCreateTopic", "consensusUpdateTopic", "consensusDeleteTopic", "consensusSubmitMessage", "tokenCreation", "tokenFreeze", "tokenUnfreeze", "tokenGrantKyc", "tokenRevokeKyc", "tokenDeletion", "tokenUpdate", "tokenMint", "tokenBurn", "tokenWipe", "tokenAssociate", "tokenDissociate", "scheduleDelete", "tokenPause", "tokenUnpause", "cryptoApproveAllowance", "cryptoDeleteAllowance", "tokenFeeScheduleUpdate", "utilPrng", "tokenUpdateNfts", "nodeCreate", "nodeUpdate", "nodeDelete", "tokenReject", "tokenCancelAirdrop", "tokenClaimAirdrop", "tokenAirdrop"]), set: $util.oneOfSetter($oneOfFields) });
        SchedulableTransactionBody.create = function create(properties) {
          return new SchedulableTransactionBody(properties);
        };
        SchedulableTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transactionFee != null && Object.hasOwnProperty.call(m6, "transactionFee")) w5.uint32(8).uint64(m6.transactionFee);
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(18).string(m6.memo);
          if (m6.contractCall != null && Object.hasOwnProperty.call(m6, "contractCall")) $root.proto.ContractCallTransactionBody.encode(m6.contractCall, w5.uint32(26).fork()).ldelim();
          if (m6.contractCreateInstance != null && Object.hasOwnProperty.call(m6, "contractCreateInstance")) $root.proto.ContractCreateTransactionBody.encode(m6.contractCreateInstance, w5.uint32(34).fork()).ldelim();
          if (m6.contractUpdateInstance != null && Object.hasOwnProperty.call(m6, "contractUpdateInstance")) $root.proto.ContractUpdateTransactionBody.encode(m6.contractUpdateInstance, w5.uint32(42).fork()).ldelim();
          if (m6.contractDeleteInstance != null && Object.hasOwnProperty.call(m6, "contractDeleteInstance")) $root.proto.ContractDeleteTransactionBody.encode(m6.contractDeleteInstance, w5.uint32(50).fork()).ldelim();
          if (m6.cryptoCreateAccount != null && Object.hasOwnProperty.call(m6, "cryptoCreateAccount")) $root.proto.CryptoCreateTransactionBody.encode(m6.cryptoCreateAccount, w5.uint32(58).fork()).ldelim();
          if (m6.cryptoDelete != null && Object.hasOwnProperty.call(m6, "cryptoDelete")) $root.proto.CryptoDeleteTransactionBody.encode(m6.cryptoDelete, w5.uint32(66).fork()).ldelim();
          if (m6.cryptoTransfer != null && Object.hasOwnProperty.call(m6, "cryptoTransfer")) $root.proto.CryptoTransferTransactionBody.encode(m6.cryptoTransfer, w5.uint32(74).fork()).ldelim();
          if (m6.cryptoUpdateAccount != null && Object.hasOwnProperty.call(m6, "cryptoUpdateAccount")) $root.proto.CryptoUpdateTransactionBody.encode(m6.cryptoUpdateAccount, w5.uint32(82).fork()).ldelim();
          if (m6.fileAppend != null && Object.hasOwnProperty.call(m6, "fileAppend")) $root.proto.FileAppendTransactionBody.encode(m6.fileAppend, w5.uint32(90).fork()).ldelim();
          if (m6.fileCreate != null && Object.hasOwnProperty.call(m6, "fileCreate")) $root.proto.FileCreateTransactionBody.encode(m6.fileCreate, w5.uint32(98).fork()).ldelim();
          if (m6.fileDelete != null && Object.hasOwnProperty.call(m6, "fileDelete")) $root.proto.FileDeleteTransactionBody.encode(m6.fileDelete, w5.uint32(106).fork()).ldelim();
          if (m6.fileUpdate != null && Object.hasOwnProperty.call(m6, "fileUpdate")) $root.proto.FileUpdateTransactionBody.encode(m6.fileUpdate, w5.uint32(114).fork()).ldelim();
          if (m6.systemDelete != null && Object.hasOwnProperty.call(m6, "systemDelete")) $root.proto.SystemDeleteTransactionBody.encode(m6.systemDelete, w5.uint32(122).fork()).ldelim();
          if (m6.systemUndelete != null && Object.hasOwnProperty.call(m6, "systemUndelete")) $root.proto.SystemUndeleteTransactionBody.encode(m6.systemUndelete, w5.uint32(130).fork()).ldelim();
          if (m6.freeze != null && Object.hasOwnProperty.call(m6, "freeze")) $root.proto.FreezeTransactionBody.encode(m6.freeze, w5.uint32(138).fork()).ldelim();
          if (m6.consensusCreateTopic != null && Object.hasOwnProperty.call(m6, "consensusCreateTopic")) $root.proto.ConsensusCreateTopicTransactionBody.encode(m6.consensusCreateTopic, w5.uint32(146).fork()).ldelim();
          if (m6.consensusUpdateTopic != null && Object.hasOwnProperty.call(m6, "consensusUpdateTopic")) $root.proto.ConsensusUpdateTopicTransactionBody.encode(m6.consensusUpdateTopic, w5.uint32(154).fork()).ldelim();
          if (m6.consensusDeleteTopic != null && Object.hasOwnProperty.call(m6, "consensusDeleteTopic")) $root.proto.ConsensusDeleteTopicTransactionBody.encode(m6.consensusDeleteTopic, w5.uint32(162).fork()).ldelim();
          if (m6.consensusSubmitMessage != null && Object.hasOwnProperty.call(m6, "consensusSubmitMessage")) $root.proto.ConsensusSubmitMessageTransactionBody.encode(m6.consensusSubmitMessage, w5.uint32(170).fork()).ldelim();
          if (m6.tokenCreation != null && Object.hasOwnProperty.call(m6, "tokenCreation")) $root.proto.TokenCreateTransactionBody.encode(m6.tokenCreation, w5.uint32(178).fork()).ldelim();
          if (m6.tokenFreeze != null && Object.hasOwnProperty.call(m6, "tokenFreeze")) $root.proto.TokenFreezeAccountTransactionBody.encode(m6.tokenFreeze, w5.uint32(186).fork()).ldelim();
          if (m6.tokenUnfreeze != null && Object.hasOwnProperty.call(m6, "tokenUnfreeze")) $root.proto.TokenUnfreezeAccountTransactionBody.encode(m6.tokenUnfreeze, w5.uint32(194).fork()).ldelim();
          if (m6.tokenGrantKyc != null && Object.hasOwnProperty.call(m6, "tokenGrantKyc")) $root.proto.TokenGrantKycTransactionBody.encode(m6.tokenGrantKyc, w5.uint32(202).fork()).ldelim();
          if (m6.tokenRevokeKyc != null && Object.hasOwnProperty.call(m6, "tokenRevokeKyc")) $root.proto.TokenRevokeKycTransactionBody.encode(m6.tokenRevokeKyc, w5.uint32(210).fork()).ldelim();
          if (m6.tokenDeletion != null && Object.hasOwnProperty.call(m6, "tokenDeletion")) $root.proto.TokenDeleteTransactionBody.encode(m6.tokenDeletion, w5.uint32(218).fork()).ldelim();
          if (m6.tokenUpdate != null && Object.hasOwnProperty.call(m6, "tokenUpdate")) $root.proto.TokenUpdateTransactionBody.encode(m6.tokenUpdate, w5.uint32(226).fork()).ldelim();
          if (m6.tokenMint != null && Object.hasOwnProperty.call(m6, "tokenMint")) $root.proto.TokenMintTransactionBody.encode(m6.tokenMint, w5.uint32(234).fork()).ldelim();
          if (m6.tokenBurn != null && Object.hasOwnProperty.call(m6, "tokenBurn")) $root.proto.TokenBurnTransactionBody.encode(m6.tokenBurn, w5.uint32(242).fork()).ldelim();
          if (m6.tokenWipe != null && Object.hasOwnProperty.call(m6, "tokenWipe")) $root.proto.TokenWipeAccountTransactionBody.encode(m6.tokenWipe, w5.uint32(250).fork()).ldelim();
          if (m6.tokenAssociate != null && Object.hasOwnProperty.call(m6, "tokenAssociate")) $root.proto.TokenAssociateTransactionBody.encode(m6.tokenAssociate, w5.uint32(258).fork()).ldelim();
          if (m6.tokenDissociate != null && Object.hasOwnProperty.call(m6, "tokenDissociate")) $root.proto.TokenDissociateTransactionBody.encode(m6.tokenDissociate, w5.uint32(266).fork()).ldelim();
          if (m6.scheduleDelete != null && Object.hasOwnProperty.call(m6, "scheduleDelete")) $root.proto.ScheduleDeleteTransactionBody.encode(m6.scheduleDelete, w5.uint32(274).fork()).ldelim();
          if (m6.tokenPause != null && Object.hasOwnProperty.call(m6, "tokenPause")) $root.proto.TokenPauseTransactionBody.encode(m6.tokenPause, w5.uint32(282).fork()).ldelim();
          if (m6.tokenUnpause != null && Object.hasOwnProperty.call(m6, "tokenUnpause")) $root.proto.TokenUnpauseTransactionBody.encode(m6.tokenUnpause, w5.uint32(290).fork()).ldelim();
          if (m6.cryptoApproveAllowance != null && Object.hasOwnProperty.call(m6, "cryptoApproveAllowance")) $root.proto.CryptoApproveAllowanceTransactionBody.encode(m6.cryptoApproveAllowance, w5.uint32(298).fork()).ldelim();
          if (m6.cryptoDeleteAllowance != null && Object.hasOwnProperty.call(m6, "cryptoDeleteAllowance")) $root.proto.CryptoDeleteAllowanceTransactionBody.encode(m6.cryptoDeleteAllowance, w5.uint32(306).fork()).ldelim();
          if (m6.tokenFeeScheduleUpdate != null && Object.hasOwnProperty.call(m6, "tokenFeeScheduleUpdate")) $root.proto.TokenFeeScheduleUpdateTransactionBody.encode(m6.tokenFeeScheduleUpdate, w5.uint32(314).fork()).ldelim();
          if (m6.utilPrng != null && Object.hasOwnProperty.call(m6, "utilPrng")) $root.proto.UtilPrngTransactionBody.encode(m6.utilPrng, w5.uint32(322).fork()).ldelim();
          if (m6.tokenUpdateNfts != null && Object.hasOwnProperty.call(m6, "tokenUpdateNfts")) $root.proto.TokenUpdateNftsTransactionBody.encode(m6.tokenUpdateNfts, w5.uint32(330).fork()).ldelim();
          if (m6.nodeCreate != null && Object.hasOwnProperty.call(m6, "nodeCreate")) $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.encode(m6.nodeCreate, w5.uint32(338).fork()).ldelim();
          if (m6.nodeUpdate != null && Object.hasOwnProperty.call(m6, "nodeUpdate")) $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.encode(m6.nodeUpdate, w5.uint32(346).fork()).ldelim();
          if (m6.nodeDelete != null && Object.hasOwnProperty.call(m6, "nodeDelete")) $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.encode(m6.nodeDelete, w5.uint32(354).fork()).ldelim();
          if (m6.tokenReject != null && Object.hasOwnProperty.call(m6, "tokenReject")) $root.proto.TokenRejectTransactionBody.encode(m6.tokenReject, w5.uint32(362).fork()).ldelim();
          if (m6.tokenCancelAirdrop != null && Object.hasOwnProperty.call(m6, "tokenCancelAirdrop")) $root.proto.TokenCancelAirdropTransactionBody.encode(m6.tokenCancelAirdrop, w5.uint32(370).fork()).ldelim();
          if (m6.tokenClaimAirdrop != null && Object.hasOwnProperty.call(m6, "tokenClaimAirdrop")) $root.proto.TokenClaimAirdropTransactionBody.encode(m6.tokenClaimAirdrop, w5.uint32(378).fork()).ldelim();
          if (m6.tokenAirdrop != null && Object.hasOwnProperty.call(m6, "tokenAirdrop")) $root.proto.TokenAirdropTransactionBody.encode(m6.tokenAirdrop, w5.uint32(386).fork()).ldelim();
          if (m6.maxCustomFees != null && m6.maxCustomFees.length) {
            for (var i17 = 0; i17 < m6.maxCustomFees.length; ++i17) $root.proto.CustomFeeLimit.encode(m6.maxCustomFees[i17], w5.uint32(8010).fork()).ldelim();
          }
          return w5;
        };
        SchedulableTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SchedulableTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.transactionFee = r41.uint64();
                break;
              }
              case 2: {
                m6.memo = r41.string();
                break;
              }
              case 3: {
                m6.contractCall = $root.proto.ContractCallTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.contractCreateInstance = $root.proto.ContractCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.contractUpdateInstance = $root.proto.ContractUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.contractDeleteInstance = $root.proto.ContractDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.cryptoCreateAccount = $root.proto.CryptoCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.cryptoDelete = $root.proto.CryptoDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.cryptoTransfer = $root.proto.CryptoTransferTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.cryptoUpdateAccount = $root.proto.CryptoUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.fileAppend = $root.proto.FileAppendTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.fileCreate = $root.proto.FileCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.fileDelete = $root.proto.FileDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                m6.fileUpdate = $root.proto.FileUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 15: {
                m6.systemDelete = $root.proto.SystemDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.systemUndelete = $root.proto.SystemUndeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 17: {
                m6.freeze = $root.proto.FreezeTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 18: {
                m6.consensusCreateTopic = $root.proto.ConsensusCreateTopicTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 19: {
                m6.consensusUpdateTopic = $root.proto.ConsensusUpdateTopicTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 20: {
                m6.consensusDeleteTopic = $root.proto.ConsensusDeleteTopicTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 21: {
                m6.consensusSubmitMessage = $root.proto.ConsensusSubmitMessageTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 22: {
                m6.tokenCreation = $root.proto.TokenCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 23: {
                m6.tokenFreeze = $root.proto.TokenFreezeAccountTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 24: {
                m6.tokenUnfreeze = $root.proto.TokenUnfreezeAccountTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 25: {
                m6.tokenGrantKyc = $root.proto.TokenGrantKycTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 26: {
                m6.tokenRevokeKyc = $root.proto.TokenRevokeKycTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 27: {
                m6.tokenDeletion = $root.proto.TokenDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 28: {
                m6.tokenUpdate = $root.proto.TokenUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 29: {
                m6.tokenMint = $root.proto.TokenMintTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 30: {
                m6.tokenBurn = $root.proto.TokenBurnTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 31: {
                m6.tokenWipe = $root.proto.TokenWipeAccountTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 32: {
                m6.tokenAssociate = $root.proto.TokenAssociateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 33: {
                m6.tokenDissociate = $root.proto.TokenDissociateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 34: {
                m6.scheduleDelete = $root.proto.ScheduleDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 35: {
                m6.tokenPause = $root.proto.TokenPauseTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 36: {
                m6.tokenUnpause = $root.proto.TokenUnpauseTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 37: {
                m6.cryptoApproveAllowance = $root.proto.CryptoApproveAllowanceTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 38: {
                m6.cryptoDeleteAllowance = $root.proto.CryptoDeleteAllowanceTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 39: {
                m6.tokenFeeScheduleUpdate = $root.proto.TokenFeeScheduleUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 40: {
                m6.utilPrng = $root.proto.UtilPrngTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 41: {
                m6.tokenUpdateNfts = $root.proto.TokenUpdateNftsTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 42: {
                m6.nodeCreate = $root.com.hedera.hapi.node.addressbook.NodeCreateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 43: {
                m6.nodeUpdate = $root.com.hedera.hapi.node.addressbook.NodeUpdateTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 44: {
                m6.nodeDelete = $root.com.hedera.hapi.node.addressbook.NodeDeleteTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 45: {
                m6.tokenReject = $root.proto.TokenRejectTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 46: {
                m6.tokenCancelAirdrop = $root.proto.TokenCancelAirdropTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 47: {
                m6.tokenClaimAirdrop = $root.proto.TokenClaimAirdropTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 48: {
                m6.tokenAirdrop = $root.proto.TokenAirdropTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 1001: {
                if (!(m6.maxCustomFees && m6.maxCustomFees.length)) m6.maxCustomFees = [];
                m6.maxCustomFees.push($root.proto.CustomFeeLimit.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SchedulableTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SchedulableTransactionBody";
        };
        return SchedulableTransactionBody;
      })();
      proto37.ScheduleDeleteTransactionBody = (function() {
        function ScheduleDeleteTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ScheduleDeleteTransactionBody.prototype.scheduleID = null;
        ScheduleDeleteTransactionBody.create = function create(properties) {
          return new ScheduleDeleteTransactionBody(properties);
        };
        ScheduleDeleteTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.scheduleID != null && Object.hasOwnProperty.call(m6, "scheduleID")) $root.proto.ScheduleID.encode(m6.scheduleID, w5.uint32(10).fork()).ldelim();
          return w5;
        };
        ScheduleDeleteTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ScheduleDeleteTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.scheduleID = $root.proto.ScheduleID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ScheduleDeleteTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ScheduleDeleteTransactionBody";
        };
        return ScheduleDeleteTransactionBody;
      })();
      proto37.UtilPrngTransactionBody = (function() {
        function UtilPrngTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        UtilPrngTransactionBody.prototype.range = 0;
        UtilPrngTransactionBody.create = function create(properties) {
          return new UtilPrngTransactionBody(properties);
        };
        UtilPrngTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.range != null && Object.hasOwnProperty.call(m6, "range")) w5.uint32(8).int32(m6.range);
          return w5;
        };
        UtilPrngTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.UtilPrngTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.range = r41.int32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        UtilPrngTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.UtilPrngTransactionBody";
        };
        return UtilPrngTransactionBody;
      })();
      proto37.ScheduleSignTransactionBody = (function() {
        function ScheduleSignTransactionBody(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ScheduleSignTransactionBody.prototype.scheduleID = null;
        ScheduleSignTransactionBody.create = function create(properties) {
          return new ScheduleSignTransactionBody(properties);
        };
        ScheduleSignTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.scheduleID != null && Object.hasOwnProperty.call(m6, "scheduleID")) $root.proto.ScheduleID.encode(m6.scheduleID, w5.uint32(10).fork()).ldelim();
          return w5;
        };
        ScheduleSignTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ScheduleSignTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.scheduleID = $root.proto.ScheduleID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ScheduleSignTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ScheduleSignTransactionBody";
        };
        return ScheduleSignTransactionBody;
      })();
      proto37.NodeStakeUpdateTransactionBody = (function() {
        function NodeStakeUpdateTransactionBody(p3) {
          this.nodeStake = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NodeStakeUpdateTransactionBody.prototype.endOfStakingPeriod = null;
        NodeStakeUpdateTransactionBody.prototype.nodeStake = $util.emptyArray;
        NodeStakeUpdateTransactionBody.prototype.maxStakingRewardRatePerHbar = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.prototype.nodeRewardFeeFraction = null;
        NodeStakeUpdateTransactionBody.prototype.stakingPeriodsStored = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.prototype.stakingPeriod = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.prototype.stakingRewardFeeFraction = null;
        NodeStakeUpdateTransactionBody.prototype.stakingStartThreshold = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.prototype.stakingRewardRate = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.prototype.reservedStakingRewards = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.prototype.unreservedStakingRewardBalance = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.prototype.rewardBalanceThreshold = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.prototype.maxStakeRewarded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.prototype.maxTotalReward = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStakeUpdateTransactionBody.create = function create(properties) {
          return new NodeStakeUpdateTransactionBody(properties);
        };
        NodeStakeUpdateTransactionBody.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.endOfStakingPeriod != null && Object.hasOwnProperty.call(m6, "endOfStakingPeriod")) $root.proto.Timestamp.encode(m6.endOfStakingPeriod, w5.uint32(10).fork()).ldelim();
          if (m6.nodeStake != null && m6.nodeStake.length) {
            for (var i17 = 0; i17 < m6.nodeStake.length; ++i17) $root.proto.NodeStake.encode(m6.nodeStake[i17], w5.uint32(18).fork()).ldelim();
          }
          if (m6.maxStakingRewardRatePerHbar != null && Object.hasOwnProperty.call(m6, "maxStakingRewardRatePerHbar")) w5.uint32(24).int64(m6.maxStakingRewardRatePerHbar);
          if (m6.nodeRewardFeeFraction != null && Object.hasOwnProperty.call(m6, "nodeRewardFeeFraction")) $root.proto.Fraction.encode(m6.nodeRewardFeeFraction, w5.uint32(34).fork()).ldelim();
          if (m6.stakingPeriodsStored != null && Object.hasOwnProperty.call(m6, "stakingPeriodsStored")) w5.uint32(40).int64(m6.stakingPeriodsStored);
          if (m6.stakingPeriod != null && Object.hasOwnProperty.call(m6, "stakingPeriod")) w5.uint32(48).int64(m6.stakingPeriod);
          if (m6.stakingRewardFeeFraction != null && Object.hasOwnProperty.call(m6, "stakingRewardFeeFraction")) $root.proto.Fraction.encode(m6.stakingRewardFeeFraction, w5.uint32(58).fork()).ldelim();
          if (m6.stakingStartThreshold != null && Object.hasOwnProperty.call(m6, "stakingStartThreshold")) w5.uint32(64).int64(m6.stakingStartThreshold);
          if (m6.stakingRewardRate != null && Object.hasOwnProperty.call(m6, "stakingRewardRate")) w5.uint32(72).int64(m6.stakingRewardRate);
          if (m6.reservedStakingRewards != null && Object.hasOwnProperty.call(m6, "reservedStakingRewards")) w5.uint32(80).int64(m6.reservedStakingRewards);
          if (m6.unreservedStakingRewardBalance != null && Object.hasOwnProperty.call(m6, "unreservedStakingRewardBalance")) w5.uint32(88).int64(m6.unreservedStakingRewardBalance);
          if (m6.rewardBalanceThreshold != null && Object.hasOwnProperty.call(m6, "rewardBalanceThreshold")) w5.uint32(96).int64(m6.rewardBalanceThreshold);
          if (m6.maxStakeRewarded != null && Object.hasOwnProperty.call(m6, "maxStakeRewarded")) w5.uint32(104).int64(m6.maxStakeRewarded);
          if (m6.maxTotalReward != null && Object.hasOwnProperty.call(m6, "maxTotalReward")) w5.uint32(112).int64(m6.maxTotalReward);
          return w5;
        };
        NodeStakeUpdateTransactionBody.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NodeStakeUpdateTransactionBody();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.endOfStakingPeriod = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.nodeStake && m6.nodeStake.length)) m6.nodeStake = [];
                m6.nodeStake.push($root.proto.NodeStake.decode(r41, r41.uint32()));
                break;
              }
              case 3: {
                m6.maxStakingRewardRatePerHbar = r41.int64();
                break;
              }
              case 4: {
                m6.nodeRewardFeeFraction = $root.proto.Fraction.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.stakingPeriodsStored = r41.int64();
                break;
              }
              case 6: {
                m6.stakingPeriod = r41.int64();
                break;
              }
              case 7: {
                m6.stakingRewardFeeFraction = $root.proto.Fraction.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.stakingStartThreshold = r41.int64();
                break;
              }
              case 9: {
                m6.stakingRewardRate = r41.int64();
                break;
              }
              case 10: {
                m6.reservedStakingRewards = r41.int64();
                break;
              }
              case 11: {
                m6.unreservedStakingRewardBalance = r41.int64();
                break;
              }
              case 12: {
                m6.rewardBalanceThreshold = r41.int64();
                break;
              }
              case 13: {
                m6.maxStakeRewarded = r41.int64();
                break;
              }
              case 14: {
                m6.maxTotalReward = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NodeStakeUpdateTransactionBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NodeStakeUpdateTransactionBody";
        };
        return NodeStakeUpdateTransactionBody;
      })();
      proto37.NodeStake = (function() {
        function NodeStake(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NodeStake.prototype.maxStake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStake.prototype.minStake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStake.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStake.prototype.rewardRate = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStake.prototype.stake = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStake.prototype.stakeNotRewarded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStake.prototype.stakeRewarded = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        NodeStake.create = function create(properties) {
          return new NodeStake(properties);
        };
        NodeStake.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.maxStake != null && Object.hasOwnProperty.call(m6, "maxStake")) w5.uint32(8).int64(m6.maxStake);
          if (m6.minStake != null && Object.hasOwnProperty.call(m6, "minStake")) w5.uint32(16).int64(m6.minStake);
          if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(24).int64(m6.nodeId);
          if (m6.rewardRate != null && Object.hasOwnProperty.call(m6, "rewardRate")) w5.uint32(32).int64(m6.rewardRate);
          if (m6.stake != null && Object.hasOwnProperty.call(m6, "stake")) w5.uint32(40).int64(m6.stake);
          if (m6.stakeNotRewarded != null && Object.hasOwnProperty.call(m6, "stakeNotRewarded")) w5.uint32(48).int64(m6.stakeNotRewarded);
          if (m6.stakeRewarded != null && Object.hasOwnProperty.call(m6, "stakeRewarded")) w5.uint32(56).int64(m6.stakeRewarded);
          return w5;
        };
        NodeStake.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NodeStake();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.maxStake = r41.int64();
                break;
              }
              case 2: {
                m6.minStake = r41.int64();
                break;
              }
              case 3: {
                m6.nodeId = r41.int64();
                break;
              }
              case 4: {
                m6.rewardRate = r41.int64();
                break;
              }
              case 5: {
                m6.stake = r41.int64();
                break;
              }
              case 6: {
                m6.stakeNotRewarded = r41.int64();
                break;
              }
              case 7: {
                m6.stakeRewarded = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NodeStake.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NodeStake";
        };
        return NodeStake;
      })();
      proto37.ConsensusGetTopicInfoQuery = (function() {
        function ConsensusGetTopicInfoQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ConsensusGetTopicInfoQuery.prototype.header = null;
        ConsensusGetTopicInfoQuery.prototype.topicID = null;
        ConsensusGetTopicInfoQuery.create = function create(properties) {
          return new ConsensusGetTopicInfoQuery(properties);
        };
        ConsensusGetTopicInfoQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.topicID != null && Object.hasOwnProperty.call(m6, "topicID")) $root.proto.TopicID.encode(m6.topicID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ConsensusGetTopicInfoQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ConsensusGetTopicInfoQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.topicID = $root.proto.TopicID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ConsensusGetTopicInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ConsensusGetTopicInfoQuery";
        };
        return ConsensusGetTopicInfoQuery;
      })();
      proto37.ConsensusGetTopicInfoResponse = (function() {
        function ConsensusGetTopicInfoResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ConsensusGetTopicInfoResponse.prototype.header = null;
        ConsensusGetTopicInfoResponse.prototype.topicID = null;
        ConsensusGetTopicInfoResponse.prototype.topicInfo = null;
        ConsensusGetTopicInfoResponse.create = function create(properties) {
          return new ConsensusGetTopicInfoResponse(properties);
        };
        ConsensusGetTopicInfoResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.topicID != null && Object.hasOwnProperty.call(m6, "topicID")) $root.proto.TopicID.encode(m6.topicID, w5.uint32(18).fork()).ldelim();
          if (m6.topicInfo != null && Object.hasOwnProperty.call(m6, "topicInfo")) $root.proto.ConsensusTopicInfo.encode(m6.topicInfo, w5.uint32(42).fork()).ldelim();
          return w5;
        };
        ConsensusGetTopicInfoResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ConsensusGetTopicInfoResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.topicID = $root.proto.TopicID.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.topicInfo = $root.proto.ConsensusTopicInfo.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ConsensusGetTopicInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ConsensusGetTopicInfoResponse";
        };
        return ConsensusGetTopicInfoResponse;
      })();
      proto37.ResponseType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ANSWER_ONLY"] = 0;
        values[valuesById[1] = "ANSWER_STATE_PROOF"] = 1;
        values[valuesById[2] = "COST_ANSWER"] = 2;
        values[valuesById[3] = "COST_ANSWER_STATE_PROOF"] = 3;
        return values;
      })();
      proto37.QueryHeader = (function() {
        function QueryHeader(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        QueryHeader.prototype.payment = null;
        QueryHeader.prototype.responseType = 0;
        QueryHeader.create = function create(properties) {
          return new QueryHeader(properties);
        };
        QueryHeader.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.payment != null && Object.hasOwnProperty.call(m6, "payment")) $root.proto.Transaction.encode(m6.payment, w5.uint32(10).fork()).ldelim();
          if (m6.responseType != null && Object.hasOwnProperty.call(m6, "responseType")) w5.uint32(16).int32(m6.responseType);
          return w5;
        };
        QueryHeader.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.QueryHeader();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.payment = $root.proto.Transaction.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.responseType = r41.int32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        QueryHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.QueryHeader";
        };
        return QueryHeader;
      })();
      proto37.ResponseHeader = (function() {
        function ResponseHeader(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ResponseHeader.prototype.nodeTransactionPrecheckCode = 0;
        ResponseHeader.prototype.responseType = 0;
        ResponseHeader.prototype.cost = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        ResponseHeader.prototype.stateProof = $util.newBuffer([]);
        ResponseHeader.create = function create(properties) {
          return new ResponseHeader(properties);
        };
        ResponseHeader.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.nodeTransactionPrecheckCode != null && Object.hasOwnProperty.call(m6, "nodeTransactionPrecheckCode")) w5.uint32(8).int32(m6.nodeTransactionPrecheckCode);
          if (m6.responseType != null && Object.hasOwnProperty.call(m6, "responseType")) w5.uint32(16).int32(m6.responseType);
          if (m6.cost != null && Object.hasOwnProperty.call(m6, "cost")) w5.uint32(24).uint64(m6.cost);
          if (m6.stateProof != null && Object.hasOwnProperty.call(m6, "stateProof")) w5.uint32(34).bytes(m6.stateProof);
          return w5;
        };
        ResponseHeader.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ResponseHeader();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.nodeTransactionPrecheckCode = r41.int32();
                break;
              }
              case 2: {
                m6.responseType = r41.int32();
                break;
              }
              case 3: {
                m6.cost = r41.uint64();
                break;
              }
              case 4: {
                m6.stateProof = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ResponseHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ResponseHeader";
        };
        return ResponseHeader;
      })();
      proto37.ConsensusTopicInfo = (function() {
        function ConsensusTopicInfo(p3) {
          this.feeExemptKeyList = [];
          this.customFees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ConsensusTopicInfo.prototype.memo = "";
        ConsensusTopicInfo.prototype.runningHash = $util.newBuffer([]);
        ConsensusTopicInfo.prototype.sequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        ConsensusTopicInfo.prototype.expirationTime = null;
        ConsensusTopicInfo.prototype.adminKey = null;
        ConsensusTopicInfo.prototype.submitKey = null;
        ConsensusTopicInfo.prototype.autoRenewPeriod = null;
        ConsensusTopicInfo.prototype.autoRenewAccount = null;
        ConsensusTopicInfo.prototype.ledgerId = $util.newBuffer([]);
        ConsensusTopicInfo.prototype.feeScheduleKey = null;
        ConsensusTopicInfo.prototype.feeExemptKeyList = $util.emptyArray;
        ConsensusTopicInfo.prototype.customFees = $util.emptyArray;
        ConsensusTopicInfo.create = function create(properties) {
          return new ConsensusTopicInfo(properties);
        };
        ConsensusTopicInfo.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(10).string(m6.memo);
          if (m6.runningHash != null && Object.hasOwnProperty.call(m6, "runningHash")) w5.uint32(18).bytes(m6.runningHash);
          if (m6.sequenceNumber != null && Object.hasOwnProperty.call(m6, "sequenceNumber")) w5.uint32(24).uint64(m6.sequenceNumber);
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(34).fork()).ldelim();
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(42).fork()).ldelim();
          if (m6.submitKey != null && Object.hasOwnProperty.call(m6, "submitKey")) $root.proto.Key.encode(m6.submitKey, w5.uint32(50).fork()).ldelim();
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(58).fork()).ldelim();
          if (m6.autoRenewAccount != null && Object.hasOwnProperty.call(m6, "autoRenewAccount")) $root.proto.AccountID.encode(m6.autoRenewAccount, w5.uint32(66).fork()).ldelim();
          if (m6.ledgerId != null && Object.hasOwnProperty.call(m6, "ledgerId")) w5.uint32(74).bytes(m6.ledgerId);
          if (m6.feeScheduleKey != null && Object.hasOwnProperty.call(m6, "feeScheduleKey")) $root.proto.Key.encode(m6.feeScheduleKey, w5.uint32(82).fork()).ldelim();
          if (m6.feeExemptKeyList != null && m6.feeExemptKeyList.length) {
            for (var i17 = 0; i17 < m6.feeExemptKeyList.length; ++i17) $root.proto.Key.encode(m6.feeExemptKeyList[i17], w5.uint32(90).fork()).ldelim();
          }
          if (m6.customFees != null && m6.customFees.length) {
            for (var i17 = 0; i17 < m6.customFees.length; ++i17) $root.proto.FixedCustomFee.encode(m6.customFees[i17], w5.uint32(98).fork()).ldelim();
          }
          return w5;
        };
        ConsensusTopicInfo.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ConsensusTopicInfo();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.memo = r41.string();
                break;
              }
              case 2: {
                m6.runningHash = r41.bytes();
                break;
              }
              case 3: {
                m6.sequenceNumber = r41.uint64();
                break;
              }
              case 4: {
                m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.submitKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.autoRenewAccount = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.ledgerId = r41.bytes();
                break;
              }
              case 10: {
                m6.feeScheduleKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                if (!(m6.feeExemptKeyList && m6.feeExemptKeyList.length)) m6.feeExemptKeyList = [];
                m6.feeExemptKeyList.push($root.proto.Key.decode(r41, r41.uint32()));
                break;
              }
              case 12: {
                if (!(m6.customFees && m6.customFees.length)) m6.customFees = [];
                m6.customFees.push($root.proto.FixedCustomFee.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ConsensusTopicInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ConsensusTopicInfo";
        };
        return ConsensusTopicInfo;
      })();
      proto37.ConsensusService = (function() {
        function ConsensusService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (ConsensusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ConsensusService;
        ConsensusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(ConsensusService.prototype.createTopic = function createTopic(request, callback) {
          return this.rpcCall(createTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createTopic" });
        Object.defineProperty(ConsensusService.prototype.updateTopic = function updateTopic(request, callback) {
          return this.rpcCall(updateTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateTopic" });
        Object.defineProperty(ConsensusService.prototype.deleteTopic = function deleteTopic(request, callback) {
          return this.rpcCall(deleteTopic, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteTopic" });
        Object.defineProperty(ConsensusService.prototype.submitMessage = function submitMessage(request, callback) {
          return this.rpcCall(submitMessage, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "submitMessage" });
        Object.defineProperty(ConsensusService.prototype.getTopicInfo = function getTopicInfo(request, callback) {
          return this.rpcCall(getTopicInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTopicInfo" });
        return ConsensusService;
      })();
      proto37.Query = (function() {
        function Query(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        Query.prototype.getByKey = null;
        Query.prototype.getBySolidityID = null;
        Query.prototype.contractCallLocal = null;
        Query.prototype.contractGetInfo = null;
        Query.prototype.contractGetBytecode = null;
        Query.prototype.ContractGetRecords = null;
        Query.prototype.cryptogetAccountBalance = null;
        Query.prototype.cryptoGetAccountRecords = null;
        Query.prototype.cryptoGetInfo = null;
        Query.prototype.cryptoGetLiveHash = null;
        Query.prototype.cryptoGetProxyStakers = null;
        Query.prototype.fileGetContents = null;
        Query.prototype.fileGetInfo = null;
        Query.prototype.transactionGetReceipt = null;
        Query.prototype.transactionGetRecord = null;
        Query.prototype.transactionGetFastRecord = null;
        Query.prototype.consensusGetTopicInfo = null;
        Query.prototype.networkGetVersionInfo = null;
        Query.prototype.tokenGetInfo = null;
        Query.prototype.scheduleGetInfo = null;
        Query.prototype.tokenGetAccountNftInfos = null;
        Query.prototype.tokenGetNftInfo = null;
        Query.prototype.tokenGetNftInfos = null;
        Query.prototype.networkGetExecutionTime = null;
        Query.prototype.accountDetails = null;
        let $oneOfFields;
        Object.defineProperty(Query.prototype, "query", { get: $util.oneOfGetter($oneOfFields = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetInfo", "contractGetBytecode", "ContractGetRecords", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos", "networkGetExecutionTime", "accountDetails"]), set: $util.oneOfSetter($oneOfFields) });
        Query.create = function create(properties) {
          return new Query(properties);
        };
        Query.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.getByKey != null && Object.hasOwnProperty.call(m6, "getByKey")) $root.proto.GetByKeyQuery.encode(m6.getByKey, w5.uint32(10).fork()).ldelim();
          if (m6.getBySolidityID != null && Object.hasOwnProperty.call(m6, "getBySolidityID")) $root.proto.GetBySolidityIDQuery.encode(m6.getBySolidityID, w5.uint32(18).fork()).ldelim();
          if (m6.contractCallLocal != null && Object.hasOwnProperty.call(m6, "contractCallLocal")) $root.proto.ContractCallLocalQuery.encode(m6.contractCallLocal, w5.uint32(26).fork()).ldelim();
          if (m6.contractGetInfo != null && Object.hasOwnProperty.call(m6, "contractGetInfo")) $root.proto.ContractGetInfoQuery.encode(m6.contractGetInfo, w5.uint32(34).fork()).ldelim();
          if (m6.contractGetBytecode != null && Object.hasOwnProperty.call(m6, "contractGetBytecode")) $root.proto.ContractGetBytecodeQuery.encode(m6.contractGetBytecode, w5.uint32(42).fork()).ldelim();
          if (m6.ContractGetRecords != null && Object.hasOwnProperty.call(m6, "ContractGetRecords")) $root.proto.ContractGetRecordsQuery.encode(m6.ContractGetRecords, w5.uint32(50).fork()).ldelim();
          if (m6.cryptogetAccountBalance != null && Object.hasOwnProperty.call(m6, "cryptogetAccountBalance")) $root.proto.CryptoGetAccountBalanceQuery.encode(m6.cryptogetAccountBalance, w5.uint32(58).fork()).ldelim();
          if (m6.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(m6, "cryptoGetAccountRecords")) $root.proto.CryptoGetAccountRecordsQuery.encode(m6.cryptoGetAccountRecords, w5.uint32(66).fork()).ldelim();
          if (m6.cryptoGetInfo != null && Object.hasOwnProperty.call(m6, "cryptoGetInfo")) $root.proto.CryptoGetInfoQuery.encode(m6.cryptoGetInfo, w5.uint32(74).fork()).ldelim();
          if (m6.cryptoGetLiveHash != null && Object.hasOwnProperty.call(m6, "cryptoGetLiveHash")) $root.proto.CryptoGetLiveHashQuery.encode(m6.cryptoGetLiveHash, w5.uint32(82).fork()).ldelim();
          if (m6.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(m6, "cryptoGetProxyStakers")) $root.proto.CryptoGetStakersQuery.encode(m6.cryptoGetProxyStakers, w5.uint32(90).fork()).ldelim();
          if (m6.fileGetContents != null && Object.hasOwnProperty.call(m6, "fileGetContents")) $root.proto.FileGetContentsQuery.encode(m6.fileGetContents, w5.uint32(98).fork()).ldelim();
          if (m6.fileGetInfo != null && Object.hasOwnProperty.call(m6, "fileGetInfo")) $root.proto.FileGetInfoQuery.encode(m6.fileGetInfo, w5.uint32(106).fork()).ldelim();
          if (m6.transactionGetReceipt != null && Object.hasOwnProperty.call(m6, "transactionGetReceipt")) $root.proto.TransactionGetReceiptQuery.encode(m6.transactionGetReceipt, w5.uint32(114).fork()).ldelim();
          if (m6.transactionGetRecord != null && Object.hasOwnProperty.call(m6, "transactionGetRecord")) $root.proto.TransactionGetRecordQuery.encode(m6.transactionGetRecord, w5.uint32(122).fork()).ldelim();
          if (m6.transactionGetFastRecord != null && Object.hasOwnProperty.call(m6, "transactionGetFastRecord")) $root.proto.TransactionGetFastRecordQuery.encode(m6.transactionGetFastRecord, w5.uint32(130).fork()).ldelim();
          if (m6.consensusGetTopicInfo != null && Object.hasOwnProperty.call(m6, "consensusGetTopicInfo")) $root.proto.ConsensusGetTopicInfoQuery.encode(m6.consensusGetTopicInfo, w5.uint32(402).fork()).ldelim();
          if (m6.networkGetVersionInfo != null && Object.hasOwnProperty.call(m6, "networkGetVersionInfo")) $root.proto.NetworkGetVersionInfoQuery.encode(m6.networkGetVersionInfo, w5.uint32(410).fork()).ldelim();
          if (m6.tokenGetInfo != null && Object.hasOwnProperty.call(m6, "tokenGetInfo")) $root.proto.TokenGetInfoQuery.encode(m6.tokenGetInfo, w5.uint32(418).fork()).ldelim();
          if (m6.scheduleGetInfo != null && Object.hasOwnProperty.call(m6, "scheduleGetInfo")) $root.proto.ScheduleGetInfoQuery.encode(m6.scheduleGetInfo, w5.uint32(426).fork()).ldelim();
          if (m6.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(m6, "tokenGetAccountNftInfos")) $root.proto.TokenGetAccountNftInfosQuery.encode(m6.tokenGetAccountNftInfos, w5.uint32(434).fork()).ldelim();
          if (m6.tokenGetNftInfo != null && Object.hasOwnProperty.call(m6, "tokenGetNftInfo")) $root.proto.TokenGetNftInfoQuery.encode(m6.tokenGetNftInfo, w5.uint32(442).fork()).ldelim();
          if (m6.tokenGetNftInfos != null && Object.hasOwnProperty.call(m6, "tokenGetNftInfos")) $root.proto.TokenGetNftInfosQuery.encode(m6.tokenGetNftInfos, w5.uint32(450).fork()).ldelim();
          if (m6.networkGetExecutionTime != null && Object.hasOwnProperty.call(m6, "networkGetExecutionTime")) $root.proto.NetworkGetExecutionTimeQuery.encode(m6.networkGetExecutionTime, w5.uint32(458).fork()).ldelim();
          if (m6.accountDetails != null && Object.hasOwnProperty.call(m6, "accountDetails")) $root.proto.GetAccountDetailsQuery.encode(m6.accountDetails, w5.uint32(466).fork()).ldelim();
          return w5;
        };
        Query.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.Query();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.getByKey = $root.proto.GetByKeyQuery.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.getBySolidityID = $root.proto.GetBySolidityIDQuery.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.contractCallLocal = $root.proto.ContractCallLocalQuery.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.contractGetInfo = $root.proto.ContractGetInfoQuery.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.contractGetBytecode = $root.proto.ContractGetBytecodeQuery.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.ContractGetRecords = $root.proto.ContractGetRecordsQuery.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceQuery.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsQuery.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.cryptoGetInfo = $root.proto.CryptoGetInfoQuery.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashQuery.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.cryptoGetProxyStakers = $root.proto.CryptoGetStakersQuery.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.fileGetContents = $root.proto.FileGetContentsQuery.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.fileGetInfo = $root.proto.FileGetInfoQuery.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                m6.transactionGetReceipt = $root.proto.TransactionGetReceiptQuery.decode(r41, r41.uint32());
                break;
              }
              case 15: {
                m6.transactionGetRecord = $root.proto.TransactionGetRecordQuery.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.transactionGetFastRecord = $root.proto.TransactionGetFastRecordQuery.decode(r41, r41.uint32());
                break;
              }
              case 50: {
                m6.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoQuery.decode(r41, r41.uint32());
                break;
              }
              case 51: {
                m6.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoQuery.decode(r41, r41.uint32());
                break;
              }
              case 52: {
                m6.tokenGetInfo = $root.proto.TokenGetInfoQuery.decode(r41, r41.uint32());
                break;
              }
              case 53: {
                m6.scheduleGetInfo = $root.proto.ScheduleGetInfoQuery.decode(r41, r41.uint32());
                break;
              }
              case 54: {
                m6.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosQuery.decode(r41, r41.uint32());
                break;
              }
              case 55: {
                m6.tokenGetNftInfo = $root.proto.TokenGetNftInfoQuery.decode(r41, r41.uint32());
                break;
              }
              case 56: {
                m6.tokenGetNftInfos = $root.proto.TokenGetNftInfosQuery.decode(r41, r41.uint32());
                break;
              }
              case 57: {
                m6.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeQuery.decode(r41, r41.uint32());
                break;
              }
              case 58: {
                m6.accountDetails = $root.proto.GetAccountDetailsQuery.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        Query.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.Query";
        };
        return Query;
      })();
      proto37.GetByKeyQuery = (function() {
        function GetByKeyQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        GetByKeyQuery.prototype.header = null;
        GetByKeyQuery.prototype.key = null;
        GetByKeyQuery.create = function create(properties) {
          return new GetByKeyQuery(properties);
        };
        GetByKeyQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.key != null && Object.hasOwnProperty.call(m6, "key")) $root.proto.Key.encode(m6.key, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        GetByKeyQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GetByKeyQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.key = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        GetByKeyQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.GetByKeyQuery";
        };
        return GetByKeyQuery;
      })();
      proto37.EntityID = (function() {
        function EntityID(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        EntityID.prototype.accountID = null;
        EntityID.prototype.liveHash = null;
        EntityID.prototype.fileID = null;
        EntityID.prototype.contractID = null;
        let $oneOfFields;
        Object.defineProperty(EntityID.prototype, "entity", { get: $util.oneOfGetter($oneOfFields = ["accountID", "liveHash", "fileID", "contractID"]), set: $util.oneOfSetter($oneOfFields) });
        EntityID.create = function create(properties) {
          return new EntityID(properties);
        };
        EntityID.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(10).fork()).ldelim();
          if (m6.liveHash != null && Object.hasOwnProperty.call(m6, "liveHash")) $root.proto.LiveHash.encode(m6.liveHash, w5.uint32(18).fork()).ldelim();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(26).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(34).fork()).ldelim();
          return w5;
        };
        EntityID.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.EntityID();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.liveHash = $root.proto.LiveHash.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        EntityID.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.EntityID";
        };
        return EntityID;
      })();
      proto37.GetByKeyResponse = (function() {
        function GetByKeyResponse(p3) {
          this.entities = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        GetByKeyResponse.prototype.header = null;
        GetByKeyResponse.prototype.entities = $util.emptyArray;
        GetByKeyResponse.create = function create(properties) {
          return new GetByKeyResponse(properties);
        };
        GetByKeyResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.entities != null && m6.entities.length) {
            for (var i17 = 0; i17 < m6.entities.length; ++i17) $root.proto.EntityID.encode(m6.entities[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        GetByKeyResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GetByKeyResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.entities && m6.entities.length)) m6.entities = [];
                m6.entities.push($root.proto.EntityID.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        GetByKeyResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.GetByKeyResponse";
        };
        return GetByKeyResponse;
      })();
      proto37.GetBySolidityIDQuery = (function() {
        function GetBySolidityIDQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        GetBySolidityIDQuery.prototype.header = null;
        GetBySolidityIDQuery.prototype.solidityID = "";
        GetBySolidityIDQuery.create = function create(properties) {
          return new GetBySolidityIDQuery(properties);
        };
        GetBySolidityIDQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.solidityID != null && Object.hasOwnProperty.call(m6, "solidityID")) w5.uint32(18).string(m6.solidityID);
          return w5;
        };
        GetBySolidityIDQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GetBySolidityIDQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.solidityID = r41.string();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        GetBySolidityIDQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.GetBySolidityIDQuery";
        };
        return GetBySolidityIDQuery;
      })();
      proto37.GetBySolidityIDResponse = (function() {
        function GetBySolidityIDResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        GetBySolidityIDResponse.prototype.header = null;
        GetBySolidityIDResponse.prototype.accountID = null;
        GetBySolidityIDResponse.prototype.fileID = null;
        GetBySolidityIDResponse.prototype.contractID = null;
        GetBySolidityIDResponse.create = function create(properties) {
          return new GetBySolidityIDResponse(properties);
        };
        GetBySolidityIDResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(26).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(34).fork()).ldelim();
          return w5;
        };
        GetBySolidityIDResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GetBySolidityIDResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        GetBySolidityIDResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.GetBySolidityIDResponse";
        };
        return GetBySolidityIDResponse;
      })();
      proto37.ContractCallLocalQuery = (function() {
        function ContractCallLocalQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractCallLocalQuery.prototype.header = null;
        ContractCallLocalQuery.prototype.contractID = null;
        ContractCallLocalQuery.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractCallLocalQuery.prototype.functionParameters = $util.newBuffer([]);
        ContractCallLocalQuery.prototype.maxResultSize = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractCallLocalQuery.prototype.senderId = null;
        ContractCallLocalQuery.create = function create(properties) {
          return new ContractCallLocalQuery(properties);
        };
        ContractCallLocalQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(18).fork()).ldelim();
          if (m6.gas != null && Object.hasOwnProperty.call(m6, "gas")) w5.uint32(24).int64(m6.gas);
          if (m6.functionParameters != null && Object.hasOwnProperty.call(m6, "functionParameters")) w5.uint32(34).bytes(m6.functionParameters);
          if (m6.maxResultSize != null && Object.hasOwnProperty.call(m6, "maxResultSize")) w5.uint32(40).int64(m6.maxResultSize);
          if (m6.senderId != null && Object.hasOwnProperty.call(m6, "senderId")) $root.proto.AccountID.encode(m6.senderId, w5.uint32(50).fork()).ldelim();
          return w5;
        };
        ContractCallLocalQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractCallLocalQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.gas = r41.int64();
                break;
              }
              case 4: {
                m6.functionParameters = r41.bytes();
                break;
              }
              case 5: {
                m6.maxResultSize = r41.int64();
                break;
              }
              case 6: {
                m6.senderId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractCallLocalQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractCallLocalQuery";
        };
        return ContractCallLocalQuery;
      })();
      proto37.ContractCallLocalResponse = (function() {
        function ContractCallLocalResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractCallLocalResponse.prototype.header = null;
        ContractCallLocalResponse.prototype.functionResult = null;
        ContractCallLocalResponse.create = function create(properties) {
          return new ContractCallLocalResponse(properties);
        };
        ContractCallLocalResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.functionResult != null && Object.hasOwnProperty.call(m6, "functionResult")) $root.proto.ContractFunctionResult.encode(m6.functionResult, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ContractCallLocalResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractCallLocalResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.functionResult = $root.proto.ContractFunctionResult.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractCallLocalResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractCallLocalResponse";
        };
        return ContractCallLocalResponse;
      })();
      proto37.InternalCallContext = (function() {
        function InternalCallContext(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        InternalCallContext.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        InternalCallContext.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        InternalCallContext.prototype.callData = $util.newBuffer([]);
        InternalCallContext.create = function create(properties) {
          return new InternalCallContext(properties);
        };
        InternalCallContext.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.gas != null && Object.hasOwnProperty.call(m6, "gas")) w5.uint32(8).uint64(m6.gas);
          if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(16).uint64(m6.value);
          if (m6.callData != null && Object.hasOwnProperty.call(m6, "callData")) w5.uint32(26).bytes(m6.callData);
          return w5;
        };
        InternalCallContext.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.InternalCallContext();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.gas = r41.uint64();
                break;
              }
              case 2: {
                m6.value = r41.uint64();
                break;
              }
              case 3: {
                m6.callData = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        InternalCallContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.InternalCallContext";
        };
        return InternalCallContext;
      })();
      proto37.EvmTransactionResult = (function() {
        function EvmTransactionResult(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        EvmTransactionResult.prototype.senderId = null;
        EvmTransactionResult.prototype.contractId = null;
        EvmTransactionResult.prototype.resultData = $util.newBuffer([]);
        EvmTransactionResult.prototype.errorMessage = "";
        EvmTransactionResult.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        EvmTransactionResult.prototype.internalCallContext = null;
        EvmTransactionResult.create = function create(properties) {
          return new EvmTransactionResult(properties);
        };
        EvmTransactionResult.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.senderId != null && Object.hasOwnProperty.call(m6, "senderId")) $root.proto.AccountID.encode(m6.senderId, w5.uint32(10).fork()).ldelim();
          if (m6.contractId != null && Object.hasOwnProperty.call(m6, "contractId")) $root.proto.ContractID.encode(m6.contractId, w5.uint32(18).fork()).ldelim();
          if (m6.resultData != null && Object.hasOwnProperty.call(m6, "resultData")) w5.uint32(26).bytes(m6.resultData);
          if (m6.errorMessage != null && Object.hasOwnProperty.call(m6, "errorMessage")) w5.uint32(34).string(m6.errorMessage);
          if (m6.gasUsed != null && Object.hasOwnProperty.call(m6, "gasUsed")) w5.uint32(40).uint64(m6.gasUsed);
          if (m6.internalCallContext != null && Object.hasOwnProperty.call(m6, "internalCallContext")) $root.proto.InternalCallContext.encode(m6.internalCallContext, w5.uint32(50).fork()).ldelim();
          return w5;
        };
        EvmTransactionResult.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.EvmTransactionResult();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.senderId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractId = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.resultData = r41.bytes();
                break;
              }
              case 4: {
                m6.errorMessage = r41.string();
                break;
              }
              case 5: {
                m6.gasUsed = r41.uint64();
                break;
              }
              case 6: {
                m6.internalCallContext = $root.proto.InternalCallContext.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        EvmTransactionResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.EvmTransactionResult";
        };
        return EvmTransactionResult;
      })();
      proto37.ContractNonceInfo = (function() {
        function ContractNonceInfo(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractNonceInfo.prototype.contractId = null;
        ContractNonceInfo.prototype.nonce = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractNonceInfo.create = function create(properties) {
          return new ContractNonceInfo(properties);
        };
        ContractNonceInfo.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractId != null && Object.hasOwnProperty.call(m6, "contractId")) $root.proto.ContractID.encode(m6.contractId, w5.uint32(10).fork()).ldelim();
          if (m6.nonce != null && Object.hasOwnProperty.call(m6, "nonce")) w5.uint32(16).int64(m6.nonce);
          return w5;
        };
        ContractNonceInfo.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractNonceInfo();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contractId = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.nonce = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractNonceInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractNonceInfo";
        };
        return ContractNonceInfo;
      })();
      proto37.ContractLoginfo = (function() {
        function ContractLoginfo(p3) {
          this.topic = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractLoginfo.prototype.contractID = null;
        ContractLoginfo.prototype.bloom = $util.newBuffer([]);
        ContractLoginfo.prototype.topic = $util.emptyArray;
        ContractLoginfo.prototype.data = $util.newBuffer([]);
        ContractLoginfo.create = function create(properties) {
          return new ContractLoginfo(properties);
        };
        ContractLoginfo.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(10).fork()).ldelim();
          if (m6.bloom != null && Object.hasOwnProperty.call(m6, "bloom")) w5.uint32(18).bytes(m6.bloom);
          if (m6.topic != null && m6.topic.length) {
            for (var i17 = 0; i17 < m6.topic.length; ++i17) w5.uint32(26).bytes(m6.topic[i17]);
          }
          if (m6.data != null && Object.hasOwnProperty.call(m6, "data")) w5.uint32(34).bytes(m6.data);
          return w5;
        };
        ContractLoginfo.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractLoginfo();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.bloom = r41.bytes();
                break;
              }
              case 3: {
                if (!(m6.topic && m6.topic.length)) m6.topic = [];
                m6.topic.push(r41.bytes());
                break;
              }
              case 4: {
                m6.data = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractLoginfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractLoginfo";
        };
        return ContractLoginfo;
      })();
      proto37.ContractFunctionResult = (function() {
        function ContractFunctionResult(p3) {
          this.logInfo = [];
          this.createdContractIDs = [];
          this.contractNonces = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractFunctionResult.prototype.contractID = null;
        ContractFunctionResult.prototype.contractCallResult = $util.newBuffer([]);
        ContractFunctionResult.prototype.errorMessage = "";
        ContractFunctionResult.prototype.bloom = $util.newBuffer([]);
        ContractFunctionResult.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        ContractFunctionResult.prototype.logInfo = $util.emptyArray;
        ContractFunctionResult.prototype.createdContractIDs = $util.emptyArray;
        ContractFunctionResult.prototype.evmAddress = null;
        ContractFunctionResult.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractFunctionResult.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractFunctionResult.prototype.functionParameters = $util.newBuffer([]);
        ContractFunctionResult.prototype.senderId = null;
        ContractFunctionResult.prototype.contractNonces = $util.emptyArray;
        ContractFunctionResult.prototype.signerNonce = null;
        ContractFunctionResult.create = function create(properties) {
          return new ContractFunctionResult(properties);
        };
        ContractFunctionResult.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(10).fork()).ldelim();
          if (m6.contractCallResult != null && Object.hasOwnProperty.call(m6, "contractCallResult")) w5.uint32(18).bytes(m6.contractCallResult);
          if (m6.errorMessage != null && Object.hasOwnProperty.call(m6, "errorMessage")) w5.uint32(26).string(m6.errorMessage);
          if (m6.bloom != null && Object.hasOwnProperty.call(m6, "bloom")) w5.uint32(34).bytes(m6.bloom);
          if (m6.gasUsed != null && Object.hasOwnProperty.call(m6, "gasUsed")) w5.uint32(40).uint64(m6.gasUsed);
          if (m6.logInfo != null && m6.logInfo.length) {
            for (var i17 = 0; i17 < m6.logInfo.length; ++i17) $root.proto.ContractLoginfo.encode(m6.logInfo[i17], w5.uint32(50).fork()).ldelim();
          }
          if (m6.createdContractIDs != null && m6.createdContractIDs.length) {
            for (var i17 = 0; i17 < m6.createdContractIDs.length; ++i17) $root.proto.ContractID.encode(m6.createdContractIDs[i17], w5.uint32(58).fork()).ldelim();
          }
          if (m6.evmAddress != null && Object.hasOwnProperty.call(m6, "evmAddress")) $root.google.protobuf.BytesValue.encode(m6.evmAddress, w5.uint32(74).fork()).ldelim();
          if (m6.gas != null && Object.hasOwnProperty.call(m6, "gas")) w5.uint32(80).int64(m6.gas);
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(88).int64(m6.amount);
          if (m6.functionParameters != null && Object.hasOwnProperty.call(m6, "functionParameters")) w5.uint32(98).bytes(m6.functionParameters);
          if (m6.senderId != null && Object.hasOwnProperty.call(m6, "senderId")) $root.proto.AccountID.encode(m6.senderId, w5.uint32(106).fork()).ldelim();
          if (m6.contractNonces != null && m6.contractNonces.length) {
            for (var i17 = 0; i17 < m6.contractNonces.length; ++i17) $root.proto.ContractNonceInfo.encode(m6.contractNonces[i17], w5.uint32(114).fork()).ldelim();
          }
          if (m6.signerNonce != null && Object.hasOwnProperty.call(m6, "signerNonce")) $root.google.protobuf.Int64Value.encode(m6.signerNonce, w5.uint32(122).fork()).ldelim();
          return w5;
        };
        ContractFunctionResult.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractFunctionResult();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractCallResult = r41.bytes();
                break;
              }
              case 3: {
                m6.errorMessage = r41.string();
                break;
              }
              case 4: {
                m6.bloom = r41.bytes();
                break;
              }
              case 5: {
                m6.gasUsed = r41.uint64();
                break;
              }
              case 6: {
                if (!(m6.logInfo && m6.logInfo.length)) m6.logInfo = [];
                m6.logInfo.push($root.proto.ContractLoginfo.decode(r41, r41.uint32()));
                break;
              }
              case 7: {
                if (!(m6.createdContractIDs && m6.createdContractIDs.length)) m6.createdContractIDs = [];
                m6.createdContractIDs.push($root.proto.ContractID.decode(r41, r41.uint32()));
                break;
              }
              case 9: {
                m6.evmAddress = $root.google.protobuf.BytesValue.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.gas = r41.int64();
                break;
              }
              case 11: {
                m6.amount = r41.int64();
                break;
              }
              case 12: {
                m6.functionParameters = r41.bytes();
                break;
              }
              case 13: {
                m6.senderId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                if (!(m6.contractNonces && m6.contractNonces.length)) m6.contractNonces = [];
                m6.contractNonces.push($root.proto.ContractNonceInfo.decode(r41, r41.uint32()));
                break;
              }
              case 15: {
                m6.signerNonce = $root.google.protobuf.Int64Value.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractFunctionResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractFunctionResult";
        };
        return ContractFunctionResult;
      })();
      proto37.ContractGetInfoQuery = (function() {
        function ContractGetInfoQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractGetInfoQuery.prototype.header = null;
        ContractGetInfoQuery.prototype.contractID = null;
        ContractGetInfoQuery.create = function create(properties) {
          return new ContractGetInfoQuery(properties);
        };
        ContractGetInfoQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ContractGetInfoQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractGetInfoQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractGetInfoQuery";
        };
        return ContractGetInfoQuery;
      })();
      proto37.ContractGetInfoResponse = (function() {
        function ContractGetInfoResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractGetInfoResponse.prototype.header = null;
        ContractGetInfoResponse.prototype.contractInfo = null;
        ContractGetInfoResponse.create = function create(properties) {
          return new ContractGetInfoResponse(properties);
        };
        ContractGetInfoResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.contractInfo != null && Object.hasOwnProperty.call(m6, "contractInfo")) $root.proto.ContractGetInfoResponse.ContractInfo.encode(m6.contractInfo, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ContractGetInfoResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractGetInfoResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractInfo = $root.proto.ContractGetInfoResponse.ContractInfo.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractGetInfoResponse";
        };
        ContractGetInfoResponse.ContractInfo = (function() {
          function ContractInfo(p3) {
            this.tokenRelationships = [];
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          ContractInfo.prototype.contractID = null;
          ContractInfo.prototype.accountID = null;
          ContractInfo.prototype.contractAccountID = "";
          ContractInfo.prototype.adminKey = null;
          ContractInfo.prototype.expirationTime = null;
          ContractInfo.prototype.autoRenewPeriod = null;
          ContractInfo.prototype.storage = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          ContractInfo.prototype.memo = "";
          ContractInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          ContractInfo.prototype.deleted = false;
          ContractInfo.prototype.tokenRelationships = $util.emptyArray;
          ContractInfo.prototype.ledgerId = $util.newBuffer([]);
          ContractInfo.prototype.autoRenewAccountId = null;
          ContractInfo.prototype.maxAutomaticTokenAssociations = 0;
          ContractInfo.prototype.stakingInfo = null;
          ContractInfo.create = function create(properties) {
            return new ContractInfo(properties);
          };
          ContractInfo.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(10).fork()).ldelim();
            if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
            if (m6.contractAccountID != null && Object.hasOwnProperty.call(m6, "contractAccountID")) w5.uint32(26).string(m6.contractAccountID);
            if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(34).fork()).ldelim();
            if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(42).fork()).ldelim();
            if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(50).fork()).ldelim();
            if (m6.storage != null && Object.hasOwnProperty.call(m6, "storage")) w5.uint32(56).int64(m6.storage);
            if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(66).string(m6.memo);
            if (m6.balance != null && Object.hasOwnProperty.call(m6, "balance")) w5.uint32(72).uint64(m6.balance);
            if (m6.deleted != null && Object.hasOwnProperty.call(m6, "deleted")) w5.uint32(80).bool(m6.deleted);
            if (m6.tokenRelationships != null && m6.tokenRelationships.length) {
              for (var i17 = 0; i17 < m6.tokenRelationships.length; ++i17) $root.proto.TokenRelationship.encode(m6.tokenRelationships[i17], w5.uint32(90).fork()).ldelim();
            }
            if (m6.ledgerId != null && Object.hasOwnProperty.call(m6, "ledgerId")) w5.uint32(98).bytes(m6.ledgerId);
            if (m6.autoRenewAccountId != null && Object.hasOwnProperty.call(m6, "autoRenewAccountId")) $root.proto.AccountID.encode(m6.autoRenewAccountId, w5.uint32(106).fork()).ldelim();
            if (m6.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m6, "maxAutomaticTokenAssociations")) w5.uint32(112).int32(m6.maxAutomaticTokenAssociations);
            if (m6.stakingInfo != null && Object.hasOwnProperty.call(m6, "stakingInfo")) $root.proto.StakingInfo.encode(m6.stakingInfo, w5.uint32(122).fork()).ldelim();
            return w5;
          };
          ContractInfo.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractGetInfoResponse.ContractInfo();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                  break;
                }
                case 2: {
                  m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                  break;
                }
                case 3: {
                  m6.contractAccountID = r41.string();
                  break;
                }
                case 4: {
                  m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                  break;
                }
                case 5: {
                  m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                  break;
                }
                case 6: {
                  m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                  break;
                }
                case 7: {
                  m6.storage = r41.int64();
                  break;
                }
                case 8: {
                  m6.memo = r41.string();
                  break;
                }
                case 9: {
                  m6.balance = r41.uint64();
                  break;
                }
                case 10: {
                  m6.deleted = r41.bool();
                  break;
                }
                case 11: {
                  if (!(m6.tokenRelationships && m6.tokenRelationships.length)) m6.tokenRelationships = [];
                  m6.tokenRelationships.push($root.proto.TokenRelationship.decode(r41, r41.uint32()));
                  break;
                }
                case 12: {
                  m6.ledgerId = r41.bytes();
                  break;
                }
                case 13: {
                  m6.autoRenewAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                  break;
                }
                case 14: {
                  m6.maxAutomaticTokenAssociations = r41.int32();
                  break;
                }
                case 15: {
                  m6.stakingInfo = $root.proto.StakingInfo.decode(r41, r41.uint32());
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          ContractInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ContractGetInfoResponse.ContractInfo";
          };
          return ContractInfo;
        })();
        return ContractGetInfoResponse;
      })();
      proto37.ContractGetBytecodeQuery = (function() {
        function ContractGetBytecodeQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractGetBytecodeQuery.prototype.header = null;
        ContractGetBytecodeQuery.prototype.contractID = null;
        ContractGetBytecodeQuery.create = function create(properties) {
          return new ContractGetBytecodeQuery(properties);
        };
        ContractGetBytecodeQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ContractGetBytecodeQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractGetBytecodeQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractGetBytecodeQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractGetBytecodeQuery";
        };
        return ContractGetBytecodeQuery;
      })();
      proto37.ContractGetBytecodeResponse = (function() {
        function ContractGetBytecodeResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractGetBytecodeResponse.prototype.header = null;
        ContractGetBytecodeResponse.prototype.bytecode = $util.newBuffer([]);
        ContractGetBytecodeResponse.create = function create(properties) {
          return new ContractGetBytecodeResponse(properties);
        };
        ContractGetBytecodeResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.bytecode != null && Object.hasOwnProperty.call(m6, "bytecode")) w5.uint32(50).bytes(m6.bytecode);
          return w5;
        };
        ContractGetBytecodeResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractGetBytecodeResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.bytecode = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractGetBytecodeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractGetBytecodeResponse";
        };
        return ContractGetBytecodeResponse;
      })();
      proto37.ContractGetRecordsQuery = (function() {
        function ContractGetRecordsQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractGetRecordsQuery.prototype.header = null;
        ContractGetRecordsQuery.prototype.contractID = null;
        ContractGetRecordsQuery.create = function create(properties) {
          return new ContractGetRecordsQuery(properties);
        };
        ContractGetRecordsQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ContractGetRecordsQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractGetRecordsQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractGetRecordsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractGetRecordsQuery";
        };
        return ContractGetRecordsQuery;
      })();
      proto37.ContractGetRecordsResponse = (function() {
        function ContractGetRecordsResponse(p3) {
          this.records = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractGetRecordsResponse.prototype.header = null;
        ContractGetRecordsResponse.prototype.contractID = null;
        ContractGetRecordsResponse.prototype.records = $util.emptyArray;
        ContractGetRecordsResponse.create = function create(properties) {
          return new ContractGetRecordsResponse(properties);
        };
        ContractGetRecordsResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(18).fork()).ldelim();
          if (m6.records != null && m6.records.length) {
            for (var i17 = 0; i17 < m6.records.length; ++i17) $root.proto.TransactionRecord.encode(m6.records[i17], w5.uint32(26).fork()).ldelim();
          }
          return w5;
        };
        ContractGetRecordsResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractGetRecordsResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                if (!(m6.records && m6.records.length)) m6.records = [];
                m6.records.push($root.proto.TransactionRecord.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractGetRecordsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractGetRecordsResponse";
        };
        return ContractGetRecordsResponse;
      })();
      proto37.TransactionRecord = (function() {
        function TransactionRecord(p3) {
          this.tokenTransferLists = [];
          this.assessedCustomFees = [];
          this.automaticTokenAssociations = [];
          this.paidStakingRewards = [];
          this.newPendingAirdrops = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionRecord.prototype.receipt = null;
        TransactionRecord.prototype.transactionHash = $util.newBuffer([]);
        TransactionRecord.prototype.consensusTimestamp = null;
        TransactionRecord.prototype.transactionID = null;
        TransactionRecord.prototype.memo = "";
        TransactionRecord.prototype.transactionFee = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TransactionRecord.prototype.contractCallResult = null;
        TransactionRecord.prototype.contractCreateResult = null;
        TransactionRecord.prototype.transferList = null;
        TransactionRecord.prototype.tokenTransferLists = $util.emptyArray;
        TransactionRecord.prototype.scheduleRef = null;
        TransactionRecord.prototype.assessedCustomFees = $util.emptyArray;
        TransactionRecord.prototype.automaticTokenAssociations = $util.emptyArray;
        TransactionRecord.prototype.parentConsensusTimestamp = null;
        TransactionRecord.prototype.alias = $util.newBuffer([]);
        TransactionRecord.prototype.ethereumHash = $util.newBuffer([]);
        TransactionRecord.prototype.paidStakingRewards = $util.emptyArray;
        TransactionRecord.prototype.prngBytes = null;
        TransactionRecord.prototype.prngNumber = null;
        TransactionRecord.prototype.evmAddress = $util.newBuffer([]);
        TransactionRecord.prototype.newPendingAirdrops = $util.emptyArray;
        let $oneOfFields;
        Object.defineProperty(TransactionRecord.prototype, "body", { get: $util.oneOfGetter($oneOfFields = ["contractCallResult", "contractCreateResult"]), set: $util.oneOfSetter($oneOfFields) });
        Object.defineProperty(TransactionRecord.prototype, "entropy", { get: $util.oneOfGetter($oneOfFields = ["prngBytes", "prngNumber"]), set: $util.oneOfSetter($oneOfFields) });
        TransactionRecord.create = function create(properties) {
          return new TransactionRecord(properties);
        };
        TransactionRecord.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.receipt != null && Object.hasOwnProperty.call(m6, "receipt")) $root.proto.TransactionReceipt.encode(m6.receipt, w5.uint32(10).fork()).ldelim();
          if (m6.transactionHash != null && Object.hasOwnProperty.call(m6, "transactionHash")) w5.uint32(18).bytes(m6.transactionHash);
          if (m6.consensusTimestamp != null && Object.hasOwnProperty.call(m6, "consensusTimestamp")) $root.proto.Timestamp.encode(m6.consensusTimestamp, w5.uint32(26).fork()).ldelim();
          if (m6.transactionID != null && Object.hasOwnProperty.call(m6, "transactionID")) $root.proto.TransactionID.encode(m6.transactionID, w5.uint32(34).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(42).string(m6.memo);
          if (m6.transactionFee != null && Object.hasOwnProperty.call(m6, "transactionFee")) w5.uint32(48).uint64(m6.transactionFee);
          if (m6.contractCallResult != null && Object.hasOwnProperty.call(m6, "contractCallResult")) $root.proto.ContractFunctionResult.encode(m6.contractCallResult, w5.uint32(58).fork()).ldelim();
          if (m6.contractCreateResult != null && Object.hasOwnProperty.call(m6, "contractCreateResult")) $root.proto.ContractFunctionResult.encode(m6.contractCreateResult, w5.uint32(66).fork()).ldelim();
          if (m6.transferList != null && Object.hasOwnProperty.call(m6, "transferList")) $root.proto.TransferList.encode(m6.transferList, w5.uint32(82).fork()).ldelim();
          if (m6.tokenTransferLists != null && m6.tokenTransferLists.length) {
            for (var i17 = 0; i17 < m6.tokenTransferLists.length; ++i17) $root.proto.TokenTransferList.encode(m6.tokenTransferLists[i17], w5.uint32(90).fork()).ldelim();
          }
          if (m6.scheduleRef != null && Object.hasOwnProperty.call(m6, "scheduleRef")) $root.proto.ScheduleID.encode(m6.scheduleRef, w5.uint32(98).fork()).ldelim();
          if (m6.assessedCustomFees != null && m6.assessedCustomFees.length) {
            for (var i17 = 0; i17 < m6.assessedCustomFees.length; ++i17) $root.proto.AssessedCustomFee.encode(m6.assessedCustomFees[i17], w5.uint32(106).fork()).ldelim();
          }
          if (m6.automaticTokenAssociations != null && m6.automaticTokenAssociations.length) {
            for (var i17 = 0; i17 < m6.automaticTokenAssociations.length; ++i17) $root.proto.TokenAssociation.encode(m6.automaticTokenAssociations[i17], w5.uint32(114).fork()).ldelim();
          }
          if (m6.parentConsensusTimestamp != null && Object.hasOwnProperty.call(m6, "parentConsensusTimestamp")) $root.proto.Timestamp.encode(m6.parentConsensusTimestamp, w5.uint32(122).fork()).ldelim();
          if (m6.alias != null && Object.hasOwnProperty.call(m6, "alias")) w5.uint32(130).bytes(m6.alias);
          if (m6.ethereumHash != null && Object.hasOwnProperty.call(m6, "ethereumHash")) w5.uint32(138).bytes(m6.ethereumHash);
          if (m6.paidStakingRewards != null && m6.paidStakingRewards.length) {
            for (var i17 = 0; i17 < m6.paidStakingRewards.length; ++i17) $root.proto.AccountAmount.encode(m6.paidStakingRewards[i17], w5.uint32(146).fork()).ldelim();
          }
          if (m6.prngBytes != null && Object.hasOwnProperty.call(m6, "prngBytes")) w5.uint32(154).bytes(m6.prngBytes);
          if (m6.prngNumber != null && Object.hasOwnProperty.call(m6, "prngNumber")) w5.uint32(160).int32(m6.prngNumber);
          if (m6.evmAddress != null && Object.hasOwnProperty.call(m6, "evmAddress")) w5.uint32(170).bytes(m6.evmAddress);
          if (m6.newPendingAirdrops != null && m6.newPendingAirdrops.length) {
            for (var i17 = 0; i17 < m6.newPendingAirdrops.length; ++i17) $root.proto.PendingAirdropRecord.encode(m6.newPendingAirdrops[i17], w5.uint32(178).fork()).ldelim();
          }
          return w5;
        };
        TransactionRecord.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionRecord();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.receipt = $root.proto.TransactionReceipt.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.transactionHash = r41.bytes();
                break;
              }
              case 3: {
                m6.consensusTimestamp = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.transactionID = $root.proto.TransactionID.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.memo = r41.string();
                break;
              }
              case 6: {
                m6.transactionFee = r41.uint64();
                break;
              }
              case 7: {
                m6.contractCallResult = $root.proto.ContractFunctionResult.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.contractCreateResult = $root.proto.ContractFunctionResult.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.transferList = $root.proto.TransferList.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                if (!(m6.tokenTransferLists && m6.tokenTransferLists.length)) m6.tokenTransferLists = [];
                m6.tokenTransferLists.push($root.proto.TokenTransferList.decode(r41, r41.uint32()));
                break;
              }
              case 12: {
                m6.scheduleRef = $root.proto.ScheduleID.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                if (!(m6.assessedCustomFees && m6.assessedCustomFees.length)) m6.assessedCustomFees = [];
                m6.assessedCustomFees.push($root.proto.AssessedCustomFee.decode(r41, r41.uint32()));
                break;
              }
              case 14: {
                if (!(m6.automaticTokenAssociations && m6.automaticTokenAssociations.length)) m6.automaticTokenAssociations = [];
                m6.automaticTokenAssociations.push($root.proto.TokenAssociation.decode(r41, r41.uint32()));
                break;
              }
              case 15: {
                m6.parentConsensusTimestamp = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.alias = r41.bytes();
                break;
              }
              case 17: {
                m6.ethereumHash = r41.bytes();
                break;
              }
              case 18: {
                if (!(m6.paidStakingRewards && m6.paidStakingRewards.length)) m6.paidStakingRewards = [];
                m6.paidStakingRewards.push($root.proto.AccountAmount.decode(r41, r41.uint32()));
                break;
              }
              case 19: {
                m6.prngBytes = r41.bytes();
                break;
              }
              case 20: {
                m6.prngNumber = r41.int32();
                break;
              }
              case 21: {
                m6.evmAddress = r41.bytes();
                break;
              }
              case 22: {
                if (!(m6.newPendingAirdrops && m6.newPendingAirdrops.length)) m6.newPendingAirdrops = [];
                m6.newPendingAirdrops.push($root.proto.PendingAirdropRecord.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionRecord";
        };
        return TransactionRecord;
      })();
      proto37.PendingAirdropRecord = (function() {
        function PendingAirdropRecord(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        PendingAirdropRecord.prototype.pendingAirdropId = null;
        PendingAirdropRecord.prototype.pendingAirdropValue = null;
        PendingAirdropRecord.create = function create(properties) {
          return new PendingAirdropRecord(properties);
        };
        PendingAirdropRecord.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.pendingAirdropId != null && Object.hasOwnProperty.call(m6, "pendingAirdropId")) $root.proto.PendingAirdropId.encode(m6.pendingAirdropId, w5.uint32(10).fork()).ldelim();
          if (m6.pendingAirdropValue != null && Object.hasOwnProperty.call(m6, "pendingAirdropValue")) $root.proto.PendingAirdropValue.encode(m6.pendingAirdropValue, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        PendingAirdropRecord.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.PendingAirdropRecord();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.pendingAirdropId = $root.proto.PendingAirdropId.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.pendingAirdropValue = $root.proto.PendingAirdropValue.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        PendingAirdropRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.PendingAirdropRecord";
        };
        return PendingAirdropRecord;
      })();
      proto37.TransactionReceipt = (function() {
        function TransactionReceipt(p3) {
          this.serialNumbers = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionReceipt.prototype.status = 0;
        TransactionReceipt.prototype.accountID = null;
        TransactionReceipt.prototype.fileID = null;
        TransactionReceipt.prototype.contractID = null;
        TransactionReceipt.prototype.exchangeRate = null;
        TransactionReceipt.prototype.topicID = null;
        TransactionReceipt.prototype.topicSequenceNumber = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TransactionReceipt.prototype.topicRunningHash = $util.newBuffer([]);
        TransactionReceipt.prototype.topicRunningHashVersion = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TransactionReceipt.prototype.tokenID = null;
        TransactionReceipt.prototype.newTotalSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TransactionReceipt.prototype.scheduleID = null;
        TransactionReceipt.prototype.scheduledTransactionID = null;
        TransactionReceipt.prototype.serialNumbers = $util.emptyArray;
        TransactionReceipt.prototype.nodeId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TransactionReceipt.create = function create(properties) {
          return new TransactionReceipt(properties);
        };
        TransactionReceipt.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.status != null && Object.hasOwnProperty.call(m6, "status")) w5.uint32(8).int32(m6.status);
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(26).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(34).fork()).ldelim();
          if (m6.exchangeRate != null && Object.hasOwnProperty.call(m6, "exchangeRate")) $root.proto.ExchangeRateSet.encode(m6.exchangeRate, w5.uint32(42).fork()).ldelim();
          if (m6.topicID != null && Object.hasOwnProperty.call(m6, "topicID")) $root.proto.TopicID.encode(m6.topicID, w5.uint32(50).fork()).ldelim();
          if (m6.topicSequenceNumber != null && Object.hasOwnProperty.call(m6, "topicSequenceNumber")) w5.uint32(56).uint64(m6.topicSequenceNumber);
          if (m6.topicRunningHash != null && Object.hasOwnProperty.call(m6, "topicRunningHash")) w5.uint32(66).bytes(m6.topicRunningHash);
          if (m6.topicRunningHashVersion != null && Object.hasOwnProperty.call(m6, "topicRunningHashVersion")) w5.uint32(72).uint64(m6.topicRunningHashVersion);
          if (m6.tokenID != null && Object.hasOwnProperty.call(m6, "tokenID")) $root.proto.TokenID.encode(m6.tokenID, w5.uint32(82).fork()).ldelim();
          if (m6.newTotalSupply != null && Object.hasOwnProperty.call(m6, "newTotalSupply")) w5.uint32(88).uint64(m6.newTotalSupply);
          if (m6.scheduleID != null && Object.hasOwnProperty.call(m6, "scheduleID")) $root.proto.ScheduleID.encode(m6.scheduleID, w5.uint32(98).fork()).ldelim();
          if (m6.scheduledTransactionID != null && Object.hasOwnProperty.call(m6, "scheduledTransactionID")) $root.proto.TransactionID.encode(m6.scheduledTransactionID, w5.uint32(106).fork()).ldelim();
          if (m6.serialNumbers != null && m6.serialNumbers.length) {
            w5.uint32(114).fork();
            for (var i17 = 0; i17 < m6.serialNumbers.length; ++i17) w5.int64(m6.serialNumbers[i17]);
            w5.ldelim();
          }
          if (m6.nodeId != null && Object.hasOwnProperty.call(m6, "nodeId")) w5.uint32(120).uint64(m6.nodeId);
          return w5;
        };
        TransactionReceipt.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionReceipt();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.status = r41.int32();
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.exchangeRate = $root.proto.ExchangeRateSet.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.topicID = $root.proto.TopicID.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.topicSequenceNumber = r41.uint64();
                break;
              }
              case 8: {
                m6.topicRunningHash = r41.bytes();
                break;
              }
              case 9: {
                m6.topicRunningHashVersion = r41.uint64();
                break;
              }
              case 10: {
                m6.tokenID = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.newTotalSupply = r41.uint64();
                break;
              }
              case 12: {
                m6.scheduleID = $root.proto.ScheduleID.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.scheduledTransactionID = $root.proto.TransactionID.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                if (!(m6.serialNumbers && m6.serialNumbers.length)) m6.serialNumbers = [];
                if ((t35 & 7) === 2) {
                  var c22 = r41.uint32() + r41.pos;
                  while (r41.pos < c22) m6.serialNumbers.push(r41.int64());
                } else m6.serialNumbers.push(r41.int64());
                break;
              }
              case 15: {
                m6.nodeId = r41.uint64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionReceipt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionReceipt";
        };
        return TransactionReceipt;
      })();
      proto37.ExchangeRate = (function() {
        function ExchangeRate(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ExchangeRate.prototype.hbarEquiv = 0;
        ExchangeRate.prototype.centEquiv = 0;
        ExchangeRate.prototype.expirationTime = null;
        ExchangeRate.create = function create(properties) {
          return new ExchangeRate(properties);
        };
        ExchangeRate.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.hbarEquiv != null && Object.hasOwnProperty.call(m6, "hbarEquiv")) w5.uint32(8).int32(m6.hbarEquiv);
          if (m6.centEquiv != null && Object.hasOwnProperty.call(m6, "centEquiv")) w5.uint32(16).int32(m6.centEquiv);
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.TimestampSeconds.encode(m6.expirationTime, w5.uint32(26).fork()).ldelim();
          return w5;
        };
        ExchangeRate.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ExchangeRate();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.hbarEquiv = r41.int32();
                break;
              }
              case 2: {
                m6.centEquiv = r41.int32();
                break;
              }
              case 3: {
                m6.expirationTime = $root.proto.TimestampSeconds.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ExchangeRate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ExchangeRate";
        };
        return ExchangeRate;
      })();
      proto37.ExchangeRateSet = (function() {
        function ExchangeRateSet(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ExchangeRateSet.prototype.currentRate = null;
        ExchangeRateSet.prototype.nextRate = null;
        ExchangeRateSet.create = function create(properties) {
          return new ExchangeRateSet(properties);
        };
        ExchangeRateSet.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.currentRate != null && Object.hasOwnProperty.call(m6, "currentRate")) $root.proto.ExchangeRate.encode(m6.currentRate, w5.uint32(10).fork()).ldelim();
          if (m6.nextRate != null && Object.hasOwnProperty.call(m6, "nextRate")) $root.proto.ExchangeRate.encode(m6.nextRate, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ExchangeRateSet.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ExchangeRateSet();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.currentRate = $root.proto.ExchangeRate.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.nextRate = $root.proto.ExchangeRate.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ExchangeRateSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ExchangeRateSet";
        };
        return ExchangeRateSet;
      })();
      proto37.CryptoGetAccountBalanceQuery = (function() {
        function CryptoGetAccountBalanceQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetAccountBalanceQuery.prototype.header = null;
        CryptoGetAccountBalanceQuery.prototype.accountID = null;
        CryptoGetAccountBalanceQuery.prototype.contractID = null;
        let $oneOfFields;
        Object.defineProperty(CryptoGetAccountBalanceQuery.prototype, "balanceSource", { get: $util.oneOfGetter($oneOfFields = ["accountID", "contractID"]), set: $util.oneOfSetter($oneOfFields) });
        CryptoGetAccountBalanceQuery.create = function create(properties) {
          return new CryptoGetAccountBalanceQuery(properties);
        };
        CryptoGetAccountBalanceQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          if (m6.contractID != null && Object.hasOwnProperty.call(m6, "contractID")) $root.proto.ContractID.encode(m6.contractID, w5.uint32(26).fork()).ldelim();
          return w5;
        };
        CryptoGetAccountBalanceQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetAccountBalanceQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.contractID = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetAccountBalanceQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetAccountBalanceQuery";
        };
        return CryptoGetAccountBalanceQuery;
      })();
      proto37.CryptoGetAccountBalanceResponse = (function() {
        function CryptoGetAccountBalanceResponse(p3) {
          this.tokenBalances = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetAccountBalanceResponse.prototype.header = null;
        CryptoGetAccountBalanceResponse.prototype.accountID = null;
        CryptoGetAccountBalanceResponse.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        CryptoGetAccountBalanceResponse.prototype.tokenBalances = $util.emptyArray;
        CryptoGetAccountBalanceResponse.create = function create(properties) {
          return new CryptoGetAccountBalanceResponse(properties);
        };
        CryptoGetAccountBalanceResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          if (m6.balance != null && Object.hasOwnProperty.call(m6, "balance")) w5.uint32(24).uint64(m6.balance);
          if (m6.tokenBalances != null && m6.tokenBalances.length) {
            for (var i17 = 0; i17 < m6.tokenBalances.length; ++i17) $root.proto.TokenBalance.encode(m6.tokenBalances[i17], w5.uint32(34).fork()).ldelim();
          }
          return w5;
        };
        CryptoGetAccountBalanceResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetAccountBalanceResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.balance = r41.uint64();
                break;
              }
              case 4: {
                if (!(m6.tokenBalances && m6.tokenBalances.length)) m6.tokenBalances = [];
                m6.tokenBalances.push($root.proto.TokenBalance.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetAccountBalanceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetAccountBalanceResponse";
        };
        return CryptoGetAccountBalanceResponse;
      })();
      proto37.CryptoGetAccountRecordsQuery = (function() {
        function CryptoGetAccountRecordsQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetAccountRecordsQuery.prototype.header = null;
        CryptoGetAccountRecordsQuery.prototype.accountID = null;
        CryptoGetAccountRecordsQuery.create = function create(properties) {
          return new CryptoGetAccountRecordsQuery(properties);
        };
        CryptoGetAccountRecordsQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        CryptoGetAccountRecordsQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetAccountRecordsQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetAccountRecordsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetAccountRecordsQuery";
        };
        return CryptoGetAccountRecordsQuery;
      })();
      proto37.CryptoGetAccountRecordsResponse = (function() {
        function CryptoGetAccountRecordsResponse(p3) {
          this.records = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetAccountRecordsResponse.prototype.header = null;
        CryptoGetAccountRecordsResponse.prototype.accountID = null;
        CryptoGetAccountRecordsResponse.prototype.records = $util.emptyArray;
        CryptoGetAccountRecordsResponse.create = function create(properties) {
          return new CryptoGetAccountRecordsResponse(properties);
        };
        CryptoGetAccountRecordsResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          if (m6.records != null && m6.records.length) {
            for (var i17 = 0; i17 < m6.records.length; ++i17) $root.proto.TransactionRecord.encode(m6.records[i17], w5.uint32(26).fork()).ldelim();
          }
          return w5;
        };
        CryptoGetAccountRecordsResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetAccountRecordsResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                if (!(m6.records && m6.records.length)) m6.records = [];
                m6.records.push($root.proto.TransactionRecord.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetAccountRecordsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetAccountRecordsResponse";
        };
        return CryptoGetAccountRecordsResponse;
      })();
      proto37.CryptoGetInfoQuery = (function() {
        function CryptoGetInfoQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetInfoQuery.prototype.header = null;
        CryptoGetInfoQuery.prototype.accountID = null;
        CryptoGetInfoQuery.create = function create(properties) {
          return new CryptoGetInfoQuery(properties);
        };
        CryptoGetInfoQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        CryptoGetInfoQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetInfoQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetInfoQuery";
        };
        return CryptoGetInfoQuery;
      })();
      proto37.CryptoGetInfoResponse = (function() {
        function CryptoGetInfoResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetInfoResponse.prototype.header = null;
        CryptoGetInfoResponse.prototype.accountInfo = null;
        CryptoGetInfoResponse.create = function create(properties) {
          return new CryptoGetInfoResponse(properties);
        };
        CryptoGetInfoResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountInfo != null && Object.hasOwnProperty.call(m6, "accountInfo")) $root.proto.CryptoGetInfoResponse.AccountInfo.encode(m6.accountInfo, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        CryptoGetInfoResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetInfoResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountInfo = $root.proto.CryptoGetInfoResponse.AccountInfo.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetInfoResponse";
        };
        CryptoGetInfoResponse.AccountInfo = (function() {
          function AccountInfo(p3) {
            this.liveHashes = [];
            this.tokenRelationships = [];
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          AccountInfo.prototype.accountID = null;
          AccountInfo.prototype.contractAccountID = "";
          AccountInfo.prototype.deleted = false;
          AccountInfo.prototype.proxyAccountID = null;
          AccountInfo.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          AccountInfo.prototype.key = null;
          AccountInfo.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          AccountInfo.prototype.generateSendRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          AccountInfo.prototype.generateReceiveRecordThreshold = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          AccountInfo.prototype.receiverSigRequired = false;
          AccountInfo.prototype.expirationTime = null;
          AccountInfo.prototype.autoRenewPeriod = null;
          AccountInfo.prototype.liveHashes = $util.emptyArray;
          AccountInfo.prototype.tokenRelationships = $util.emptyArray;
          AccountInfo.prototype.memo = "";
          AccountInfo.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          AccountInfo.prototype.maxAutomaticTokenAssociations = 0;
          AccountInfo.prototype.alias = $util.newBuffer([]);
          AccountInfo.prototype.ledgerId = $util.newBuffer([]);
          AccountInfo.prototype.ethereumNonce = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          AccountInfo.prototype.stakingInfo = null;
          AccountInfo.create = function create(properties) {
            return new AccountInfo(properties);
          };
          AccountInfo.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(10).fork()).ldelim();
            if (m6.contractAccountID != null && Object.hasOwnProperty.call(m6, "contractAccountID")) w5.uint32(18).string(m6.contractAccountID);
            if (m6.deleted != null && Object.hasOwnProperty.call(m6, "deleted")) w5.uint32(24).bool(m6.deleted);
            if (m6.proxyAccountID != null && Object.hasOwnProperty.call(m6, "proxyAccountID")) $root.proto.AccountID.encode(m6.proxyAccountID, w5.uint32(34).fork()).ldelim();
            if (m6.proxyReceived != null && Object.hasOwnProperty.call(m6, "proxyReceived")) w5.uint32(48).int64(m6.proxyReceived);
            if (m6.key != null && Object.hasOwnProperty.call(m6, "key")) $root.proto.Key.encode(m6.key, w5.uint32(58).fork()).ldelim();
            if (m6.balance != null && Object.hasOwnProperty.call(m6, "balance")) w5.uint32(64).uint64(m6.balance);
            if (m6.generateSendRecordThreshold != null && Object.hasOwnProperty.call(m6, "generateSendRecordThreshold")) w5.uint32(72).uint64(m6.generateSendRecordThreshold);
            if (m6.generateReceiveRecordThreshold != null && Object.hasOwnProperty.call(m6, "generateReceiveRecordThreshold")) w5.uint32(80).uint64(m6.generateReceiveRecordThreshold);
            if (m6.receiverSigRequired != null && Object.hasOwnProperty.call(m6, "receiverSigRequired")) w5.uint32(88).bool(m6.receiverSigRequired);
            if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(98).fork()).ldelim();
            if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(106).fork()).ldelim();
            if (m6.liveHashes != null && m6.liveHashes.length) {
              for (var i17 = 0; i17 < m6.liveHashes.length; ++i17) $root.proto.LiveHash.encode(m6.liveHashes[i17], w5.uint32(114).fork()).ldelim();
            }
            if (m6.tokenRelationships != null && m6.tokenRelationships.length) {
              for (var i17 = 0; i17 < m6.tokenRelationships.length; ++i17) $root.proto.TokenRelationship.encode(m6.tokenRelationships[i17], w5.uint32(122).fork()).ldelim();
            }
            if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(130).string(m6.memo);
            if (m6.ownedNfts != null && Object.hasOwnProperty.call(m6, "ownedNfts")) w5.uint32(136).int64(m6.ownedNfts);
            if (m6.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m6, "maxAutomaticTokenAssociations")) w5.uint32(144).int32(m6.maxAutomaticTokenAssociations);
            if (m6.alias != null && Object.hasOwnProperty.call(m6, "alias")) w5.uint32(154).bytes(m6.alias);
            if (m6.ledgerId != null && Object.hasOwnProperty.call(m6, "ledgerId")) w5.uint32(162).bytes(m6.ledgerId);
            if (m6.ethereumNonce != null && Object.hasOwnProperty.call(m6, "ethereumNonce")) w5.uint32(168).int64(m6.ethereumNonce);
            if (m6.stakingInfo != null && Object.hasOwnProperty.call(m6, "stakingInfo")) $root.proto.StakingInfo.encode(m6.stakingInfo, w5.uint32(178).fork()).ldelim();
            return w5;
          };
          AccountInfo.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetInfoResponse.AccountInfo();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                  break;
                }
                case 2: {
                  m6.contractAccountID = r41.string();
                  break;
                }
                case 3: {
                  m6.deleted = r41.bool();
                  break;
                }
                case 4: {
                  m6.proxyAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                  break;
                }
                case 6: {
                  m6.proxyReceived = r41.int64();
                  break;
                }
                case 7: {
                  m6.key = $root.proto.Key.decode(r41, r41.uint32());
                  break;
                }
                case 8: {
                  m6.balance = r41.uint64();
                  break;
                }
                case 9: {
                  m6.generateSendRecordThreshold = r41.uint64();
                  break;
                }
                case 10: {
                  m6.generateReceiveRecordThreshold = r41.uint64();
                  break;
                }
                case 11: {
                  m6.receiverSigRequired = r41.bool();
                  break;
                }
                case 12: {
                  m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                  break;
                }
                case 13: {
                  m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                  break;
                }
                case 14: {
                  if (!(m6.liveHashes && m6.liveHashes.length)) m6.liveHashes = [];
                  m6.liveHashes.push($root.proto.LiveHash.decode(r41, r41.uint32()));
                  break;
                }
                case 15: {
                  if (!(m6.tokenRelationships && m6.tokenRelationships.length)) m6.tokenRelationships = [];
                  m6.tokenRelationships.push($root.proto.TokenRelationship.decode(r41, r41.uint32()));
                  break;
                }
                case 16: {
                  m6.memo = r41.string();
                  break;
                }
                case 17: {
                  m6.ownedNfts = r41.int64();
                  break;
                }
                case 18: {
                  m6.maxAutomaticTokenAssociations = r41.int32();
                  break;
                }
                case 19: {
                  m6.alias = r41.bytes();
                  break;
                }
                case 20: {
                  m6.ledgerId = r41.bytes();
                  break;
                }
                case 21: {
                  m6.ethereumNonce = r41.int64();
                  break;
                }
                case 22: {
                  m6.stakingInfo = $root.proto.StakingInfo.decode(r41, r41.uint32());
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          AccountInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.CryptoGetInfoResponse.AccountInfo";
          };
          return AccountInfo;
        })();
        return CryptoGetInfoResponse;
      })();
      proto37.CryptoGetLiveHashQuery = (function() {
        function CryptoGetLiveHashQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetLiveHashQuery.prototype.header = null;
        CryptoGetLiveHashQuery.prototype.accountID = null;
        CryptoGetLiveHashQuery.prototype.hash = $util.newBuffer([]);
        CryptoGetLiveHashQuery.create = function create(properties) {
          return new CryptoGetLiveHashQuery(properties);
        };
        CryptoGetLiveHashQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          if (m6.hash != null && Object.hasOwnProperty.call(m6, "hash")) w5.uint32(26).bytes(m6.hash);
          return w5;
        };
        CryptoGetLiveHashQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetLiveHashQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.hash = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetLiveHashQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetLiveHashQuery";
        };
        return CryptoGetLiveHashQuery;
      })();
      proto37.CryptoGetLiveHashResponse = (function() {
        function CryptoGetLiveHashResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetLiveHashResponse.prototype.header = null;
        CryptoGetLiveHashResponse.prototype.liveHash = null;
        CryptoGetLiveHashResponse.create = function create(properties) {
          return new CryptoGetLiveHashResponse(properties);
        };
        CryptoGetLiveHashResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.liveHash != null && Object.hasOwnProperty.call(m6, "liveHash")) $root.proto.LiveHash.encode(m6.liveHash, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        CryptoGetLiveHashResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetLiveHashResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.liveHash = $root.proto.LiveHash.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetLiveHashResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetLiveHashResponse";
        };
        return CryptoGetLiveHashResponse;
      })();
      proto37.CryptoGetStakersQuery = (function() {
        function CryptoGetStakersQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetStakersQuery.prototype.header = null;
        CryptoGetStakersQuery.prototype.accountID = null;
        CryptoGetStakersQuery.create = function create(properties) {
          return new CryptoGetStakersQuery(properties);
        };
        CryptoGetStakersQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        CryptoGetStakersQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetStakersQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetStakersQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetStakersQuery";
        };
        return CryptoGetStakersQuery;
      })();
      proto37.ProxyStaker = (function() {
        function ProxyStaker(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ProxyStaker.prototype.accountID = null;
        ProxyStaker.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ProxyStaker.create = function create(properties) {
          return new ProxyStaker(properties);
        };
        ProxyStaker.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(10).fork()).ldelim();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(16).int64(m6.amount);
          return w5;
        };
        ProxyStaker.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ProxyStaker();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.amount = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ProxyStaker.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ProxyStaker";
        };
        return ProxyStaker;
      })();
      proto37.AllProxyStakers = (function() {
        function AllProxyStakers(p3) {
          this.proxyStaker = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        AllProxyStakers.prototype.accountID = null;
        AllProxyStakers.prototype.proxyStaker = $util.emptyArray;
        AllProxyStakers.create = function create(properties) {
          return new AllProxyStakers(properties);
        };
        AllProxyStakers.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(10).fork()).ldelim();
          if (m6.proxyStaker != null && m6.proxyStaker.length) {
            for (var i17 = 0; i17 < m6.proxyStaker.length; ++i17) $root.proto.ProxyStaker.encode(m6.proxyStaker[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        AllProxyStakers.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.AllProxyStakers();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.proxyStaker && m6.proxyStaker.length)) m6.proxyStaker = [];
                m6.proxyStaker.push($root.proto.ProxyStaker.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        AllProxyStakers.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.AllProxyStakers";
        };
        return AllProxyStakers;
      })();
      proto37.CryptoGetStakersResponse = (function() {
        function CryptoGetStakersResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        CryptoGetStakersResponse.prototype.header = null;
        CryptoGetStakersResponse.prototype.stakers = null;
        CryptoGetStakersResponse.create = function create(properties) {
          return new CryptoGetStakersResponse(properties);
        };
        CryptoGetStakersResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.stakers != null && Object.hasOwnProperty.call(m6, "stakers")) $root.proto.AllProxyStakers.encode(m6.stakers, w5.uint32(26).fork()).ldelim();
          return w5;
        };
        CryptoGetStakersResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.CryptoGetStakersResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.stakers = $root.proto.AllProxyStakers.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        CryptoGetStakersResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.CryptoGetStakersResponse";
        };
        return CryptoGetStakersResponse;
      })();
      proto37.FileGetContentsQuery = (function() {
        function FileGetContentsQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FileGetContentsQuery.prototype.header = null;
        FileGetContentsQuery.prototype.fileID = null;
        FileGetContentsQuery.create = function create(properties) {
          return new FileGetContentsQuery(properties);
        };
        FileGetContentsQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        FileGetContentsQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileGetContentsQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FileGetContentsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FileGetContentsQuery";
        };
        return FileGetContentsQuery;
      })();
      proto37.FileGetContentsResponse = (function() {
        function FileGetContentsResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FileGetContentsResponse.prototype.header = null;
        FileGetContentsResponse.prototype.fileContents = null;
        FileGetContentsResponse.create = function create(properties) {
          return new FileGetContentsResponse(properties);
        };
        FileGetContentsResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.fileContents != null && Object.hasOwnProperty.call(m6, "fileContents")) $root.proto.FileGetContentsResponse.FileContents.encode(m6.fileContents, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        FileGetContentsResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileGetContentsResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.fileContents = $root.proto.FileGetContentsResponse.FileContents.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FileGetContentsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FileGetContentsResponse";
        };
        FileGetContentsResponse.FileContents = (function() {
          function FileContents(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          FileContents.prototype.fileID = null;
          FileContents.prototype.contents = $util.newBuffer([]);
          FileContents.create = function create(properties) {
            return new FileContents(properties);
          };
          FileContents.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(10).fork()).ldelim();
            if (m6.contents != null && Object.hasOwnProperty.call(m6, "contents")) w5.uint32(18).bytes(m6.contents);
            return w5;
          };
          FileContents.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileGetContentsResponse.FileContents();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                  break;
                }
                case 2: {
                  m6.contents = r41.bytes();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          FileContents.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetContentsResponse.FileContents";
          };
          return FileContents;
        })();
        return FileGetContentsResponse;
      })();
      proto37.FileGetInfoQuery = (function() {
        function FileGetInfoQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FileGetInfoQuery.prototype.header = null;
        FileGetInfoQuery.prototype.fileID = null;
        FileGetInfoQuery.create = function create(properties) {
          return new FileGetInfoQuery(properties);
        };
        FileGetInfoQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        FileGetInfoQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileGetInfoQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FileGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FileGetInfoQuery";
        };
        return FileGetInfoQuery;
      })();
      proto37.FileGetInfoResponse = (function() {
        function FileGetInfoResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        FileGetInfoResponse.prototype.header = null;
        FileGetInfoResponse.prototype.fileInfo = null;
        FileGetInfoResponse.create = function create(properties) {
          return new FileGetInfoResponse(properties);
        };
        FileGetInfoResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.fileInfo != null && Object.hasOwnProperty.call(m6, "fileInfo")) $root.proto.FileGetInfoResponse.FileInfo.encode(m6.fileInfo, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        FileGetInfoResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileGetInfoResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.fileInfo = $root.proto.FileGetInfoResponse.FileInfo.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        FileGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.FileGetInfoResponse";
        };
        FileGetInfoResponse.FileInfo = (function() {
          function FileInfo(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          FileInfo.prototype.fileID = null;
          FileInfo.prototype.size = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          FileInfo.prototype.expirationTime = null;
          FileInfo.prototype.deleted = false;
          FileInfo.prototype.keys = null;
          FileInfo.prototype.memo = "";
          FileInfo.prototype.ledgerId = $util.newBuffer([]);
          FileInfo.create = function create(properties) {
            return new FileInfo(properties);
          };
          FileInfo.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.fileID != null && Object.hasOwnProperty.call(m6, "fileID")) $root.proto.FileID.encode(m6.fileID, w5.uint32(10).fork()).ldelim();
            if (m6.size != null && Object.hasOwnProperty.call(m6, "size")) w5.uint32(16).int64(m6.size);
            if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(26).fork()).ldelim();
            if (m6.deleted != null && Object.hasOwnProperty.call(m6, "deleted")) w5.uint32(32).bool(m6.deleted);
            if (m6.keys != null && Object.hasOwnProperty.call(m6, "keys")) $root.proto.KeyList.encode(m6.keys, w5.uint32(42).fork()).ldelim();
            if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(50).string(m6.memo);
            if (m6.ledgerId != null && Object.hasOwnProperty.call(m6, "ledgerId")) w5.uint32(58).bytes(m6.ledgerId);
            return w5;
          };
          FileInfo.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.FileGetInfoResponse.FileInfo();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.fileID = $root.proto.FileID.decode(r41, r41.uint32());
                  break;
                }
                case 2: {
                  m6.size = r41.int64();
                  break;
                }
                case 3: {
                  m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                  break;
                }
                case 4: {
                  m6.deleted = r41.bool();
                  break;
                }
                case 5: {
                  m6.keys = $root.proto.KeyList.decode(r41, r41.uint32());
                  break;
                }
                case 6: {
                  m6.memo = r41.string();
                  break;
                }
                case 7: {
                  m6.ledgerId = r41.bytes();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          FileInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FileGetInfoResponse.FileInfo";
          };
          return FileInfo;
        })();
        return FileGetInfoResponse;
      })();
      proto37.TransactionGetReceiptQuery = (function() {
        function TransactionGetReceiptQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionGetReceiptQuery.prototype.header = null;
        TransactionGetReceiptQuery.prototype.transactionID = null;
        TransactionGetReceiptQuery.prototype.includeDuplicates = false;
        TransactionGetReceiptQuery.prototype.includeChildReceipts = false;
        TransactionGetReceiptQuery.create = function create(properties) {
          return new TransactionGetReceiptQuery(properties);
        };
        TransactionGetReceiptQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.transactionID != null && Object.hasOwnProperty.call(m6, "transactionID")) $root.proto.TransactionID.encode(m6.transactionID, w5.uint32(18).fork()).ldelim();
          if (m6.includeDuplicates != null && Object.hasOwnProperty.call(m6, "includeDuplicates")) w5.uint32(24).bool(m6.includeDuplicates);
          if (m6.includeChildReceipts != null && Object.hasOwnProperty.call(m6, "includeChildReceipts")) w5.uint32(32).bool(m6.includeChildReceipts);
          return w5;
        };
        TransactionGetReceiptQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionGetReceiptQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.transactionID = $root.proto.TransactionID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.includeDuplicates = r41.bool();
                break;
              }
              case 4: {
                m6.includeChildReceipts = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionGetReceiptQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionGetReceiptQuery";
        };
        return TransactionGetReceiptQuery;
      })();
      proto37.TransactionGetReceiptResponse = (function() {
        function TransactionGetReceiptResponse(p3) {
          this.duplicateTransactionReceipts = [];
          this.childTransactionReceipts = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionGetReceiptResponse.prototype.header = null;
        TransactionGetReceiptResponse.prototype.receipt = null;
        TransactionGetReceiptResponse.prototype.duplicateTransactionReceipts = $util.emptyArray;
        TransactionGetReceiptResponse.prototype.childTransactionReceipts = $util.emptyArray;
        TransactionGetReceiptResponse.create = function create(properties) {
          return new TransactionGetReceiptResponse(properties);
        };
        TransactionGetReceiptResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.receipt != null && Object.hasOwnProperty.call(m6, "receipt")) $root.proto.TransactionReceipt.encode(m6.receipt, w5.uint32(18).fork()).ldelim();
          if (m6.duplicateTransactionReceipts != null && m6.duplicateTransactionReceipts.length) {
            for (var i17 = 0; i17 < m6.duplicateTransactionReceipts.length; ++i17) $root.proto.TransactionReceipt.encode(m6.duplicateTransactionReceipts[i17], w5.uint32(34).fork()).ldelim();
          }
          if (m6.childTransactionReceipts != null && m6.childTransactionReceipts.length) {
            for (var i17 = 0; i17 < m6.childTransactionReceipts.length; ++i17) $root.proto.TransactionReceipt.encode(m6.childTransactionReceipts[i17], w5.uint32(42).fork()).ldelim();
          }
          return w5;
        };
        TransactionGetReceiptResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionGetReceiptResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.receipt = $root.proto.TransactionReceipt.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                if (!(m6.duplicateTransactionReceipts && m6.duplicateTransactionReceipts.length)) m6.duplicateTransactionReceipts = [];
                m6.duplicateTransactionReceipts.push($root.proto.TransactionReceipt.decode(r41, r41.uint32()));
                break;
              }
              case 5: {
                if (!(m6.childTransactionReceipts && m6.childTransactionReceipts.length)) m6.childTransactionReceipts = [];
                m6.childTransactionReceipts.push($root.proto.TransactionReceipt.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionGetReceiptResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionGetReceiptResponse";
        };
        return TransactionGetReceiptResponse;
      })();
      proto37.TransactionGetRecordQuery = (function() {
        function TransactionGetRecordQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionGetRecordQuery.prototype.header = null;
        TransactionGetRecordQuery.prototype.transactionID = null;
        TransactionGetRecordQuery.prototype.includeDuplicates = false;
        TransactionGetRecordQuery.prototype.includeChildRecords = false;
        TransactionGetRecordQuery.create = function create(properties) {
          return new TransactionGetRecordQuery(properties);
        };
        TransactionGetRecordQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.transactionID != null && Object.hasOwnProperty.call(m6, "transactionID")) $root.proto.TransactionID.encode(m6.transactionID, w5.uint32(18).fork()).ldelim();
          if (m6.includeDuplicates != null && Object.hasOwnProperty.call(m6, "includeDuplicates")) w5.uint32(24).bool(m6.includeDuplicates);
          if (m6.includeChildRecords != null && Object.hasOwnProperty.call(m6, "includeChildRecords")) w5.uint32(32).bool(m6.includeChildRecords);
          return w5;
        };
        TransactionGetRecordQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionGetRecordQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.transactionID = $root.proto.TransactionID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.includeDuplicates = r41.bool();
                break;
              }
              case 4: {
                m6.includeChildRecords = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionGetRecordQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionGetRecordQuery";
        };
        return TransactionGetRecordQuery;
      })();
      proto37.TransactionGetRecordResponse = (function() {
        function TransactionGetRecordResponse(p3) {
          this.duplicateTransactionRecords = [];
          this.childTransactionRecords = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionGetRecordResponse.prototype.header = null;
        TransactionGetRecordResponse.prototype.transactionRecord = null;
        TransactionGetRecordResponse.prototype.duplicateTransactionRecords = $util.emptyArray;
        TransactionGetRecordResponse.prototype.childTransactionRecords = $util.emptyArray;
        TransactionGetRecordResponse.create = function create(properties) {
          return new TransactionGetRecordResponse(properties);
        };
        TransactionGetRecordResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.transactionRecord != null && Object.hasOwnProperty.call(m6, "transactionRecord")) $root.proto.TransactionRecord.encode(m6.transactionRecord, w5.uint32(26).fork()).ldelim();
          if (m6.duplicateTransactionRecords != null && m6.duplicateTransactionRecords.length) {
            for (var i17 = 0; i17 < m6.duplicateTransactionRecords.length; ++i17) $root.proto.TransactionRecord.encode(m6.duplicateTransactionRecords[i17], w5.uint32(34).fork()).ldelim();
          }
          if (m6.childTransactionRecords != null && m6.childTransactionRecords.length) {
            for (var i17 = 0; i17 < m6.childTransactionRecords.length; ++i17) $root.proto.TransactionRecord.encode(m6.childTransactionRecords[i17], w5.uint32(42).fork()).ldelim();
          }
          return w5;
        };
        TransactionGetRecordResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionGetRecordResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.transactionRecord = $root.proto.TransactionRecord.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                if (!(m6.duplicateTransactionRecords && m6.duplicateTransactionRecords.length)) m6.duplicateTransactionRecords = [];
                m6.duplicateTransactionRecords.push($root.proto.TransactionRecord.decode(r41, r41.uint32()));
                break;
              }
              case 5: {
                if (!(m6.childTransactionRecords && m6.childTransactionRecords.length)) m6.childTransactionRecords = [];
                m6.childTransactionRecords.push($root.proto.TransactionRecord.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionGetRecordResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionGetRecordResponse";
        };
        return TransactionGetRecordResponse;
      })();
      proto37.TransactionGetFastRecordQuery = (function() {
        function TransactionGetFastRecordQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionGetFastRecordQuery.prototype.header = null;
        TransactionGetFastRecordQuery.prototype.transactionID = null;
        TransactionGetFastRecordQuery.create = function create(properties) {
          return new TransactionGetFastRecordQuery(properties);
        };
        TransactionGetFastRecordQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.transactionID != null && Object.hasOwnProperty.call(m6, "transactionID")) $root.proto.TransactionID.encode(m6.transactionID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TransactionGetFastRecordQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionGetFastRecordQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.transactionID = $root.proto.TransactionID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionGetFastRecordQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionGetFastRecordQuery";
        };
        return TransactionGetFastRecordQuery;
      })();
      proto37.TransactionGetFastRecordResponse = (function() {
        function TransactionGetFastRecordResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionGetFastRecordResponse.prototype.header = null;
        TransactionGetFastRecordResponse.prototype.transactionRecord = null;
        TransactionGetFastRecordResponse.create = function create(properties) {
          return new TransactionGetFastRecordResponse(properties);
        };
        TransactionGetFastRecordResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.transactionRecord != null && Object.hasOwnProperty.call(m6, "transactionRecord")) $root.proto.TransactionRecord.encode(m6.transactionRecord, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TransactionGetFastRecordResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionGetFastRecordResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.transactionRecord = $root.proto.TransactionRecord.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionGetFastRecordResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionGetFastRecordResponse";
        };
        return TransactionGetFastRecordResponse;
      })();
      proto37.NetworkGetVersionInfoQuery = (function() {
        function NetworkGetVersionInfoQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NetworkGetVersionInfoQuery.prototype.header = null;
        NetworkGetVersionInfoQuery.create = function create(properties) {
          return new NetworkGetVersionInfoQuery(properties);
        };
        NetworkGetVersionInfoQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          return w5;
        };
        NetworkGetVersionInfoQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NetworkGetVersionInfoQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NetworkGetVersionInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NetworkGetVersionInfoQuery";
        };
        return NetworkGetVersionInfoQuery;
      })();
      proto37.NetworkGetVersionInfoResponse = (function() {
        function NetworkGetVersionInfoResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NetworkGetVersionInfoResponse.prototype.header = null;
        NetworkGetVersionInfoResponse.prototype.hapiProtoVersion = null;
        NetworkGetVersionInfoResponse.prototype.hederaServicesVersion = null;
        NetworkGetVersionInfoResponse.create = function create(properties) {
          return new NetworkGetVersionInfoResponse(properties);
        };
        NetworkGetVersionInfoResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.hapiProtoVersion != null && Object.hasOwnProperty.call(m6, "hapiProtoVersion")) $root.proto.SemanticVersion.encode(m6.hapiProtoVersion, w5.uint32(18).fork()).ldelim();
          if (m6.hederaServicesVersion != null && Object.hasOwnProperty.call(m6, "hederaServicesVersion")) $root.proto.SemanticVersion.encode(m6.hederaServicesVersion, w5.uint32(26).fork()).ldelim();
          return w5;
        };
        NetworkGetVersionInfoResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NetworkGetVersionInfoResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.hapiProtoVersion = $root.proto.SemanticVersion.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.hederaServicesVersion = $root.proto.SemanticVersion.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NetworkGetVersionInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NetworkGetVersionInfoResponse";
        };
        return NetworkGetVersionInfoResponse;
      })();
      proto37.NetworkGetExecutionTimeQuery = (function() {
        function NetworkGetExecutionTimeQuery(p3) {
          this.transactionIds = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NetworkGetExecutionTimeQuery.prototype.header = null;
        NetworkGetExecutionTimeQuery.prototype.transactionIds = $util.emptyArray;
        NetworkGetExecutionTimeQuery.create = function create(properties) {
          return new NetworkGetExecutionTimeQuery(properties);
        };
        NetworkGetExecutionTimeQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.transactionIds != null && m6.transactionIds.length) {
            for (var i17 = 0; i17 < m6.transactionIds.length; ++i17) $root.proto.TransactionID.encode(m6.transactionIds[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        NetworkGetExecutionTimeQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NetworkGetExecutionTimeQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.transactionIds && m6.transactionIds.length)) m6.transactionIds = [];
                m6.transactionIds.push($root.proto.TransactionID.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NetworkGetExecutionTimeQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NetworkGetExecutionTimeQuery";
        };
        return NetworkGetExecutionTimeQuery;
      })();
      proto37.NetworkGetExecutionTimeResponse = (function() {
        function NetworkGetExecutionTimeResponse(p3) {
          this.executionTimes = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        NetworkGetExecutionTimeResponse.prototype.header = null;
        NetworkGetExecutionTimeResponse.prototype.executionTimes = $util.emptyArray;
        NetworkGetExecutionTimeResponse.create = function create(properties) {
          return new NetworkGetExecutionTimeResponse(properties);
        };
        NetworkGetExecutionTimeResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.executionTimes != null && m6.executionTimes.length) {
            w5.uint32(18).fork();
            for (var i17 = 0; i17 < m6.executionTimes.length; ++i17) w5.uint64(m6.executionTimes[i17]);
            w5.ldelim();
          }
          return w5;
        };
        NetworkGetExecutionTimeResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.NetworkGetExecutionTimeResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.executionTimes && m6.executionTimes.length)) m6.executionTimes = [];
                if ((t35 & 7) === 2) {
                  var c22 = r41.uint32() + r41.pos;
                  while (r41.pos < c22) m6.executionTimes.push(r41.uint64());
                } else m6.executionTimes.push(r41.uint64());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        NetworkGetExecutionTimeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.NetworkGetExecutionTimeResponse";
        };
        return NetworkGetExecutionTimeResponse;
      })();
      proto37.TokenGetInfoQuery = (function() {
        function TokenGetInfoQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenGetInfoQuery.prototype.header = null;
        TokenGetInfoQuery.prototype.token = null;
        TokenGetInfoQuery.create = function create(properties) {
          return new TokenGetInfoQuery(properties);
        };
        TokenGetInfoQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.token != null && Object.hasOwnProperty.call(m6, "token")) $root.proto.TokenID.encode(m6.token, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenGetInfoQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenGetInfoQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.token = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenGetInfoQuery";
        };
        return TokenGetInfoQuery;
      })();
      proto37.TokenInfo = (function() {
        function TokenInfo(p3) {
          this.customFees = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenInfo.prototype.tokenId = null;
        TokenInfo.prototype.name = "";
        TokenInfo.prototype.symbol = "";
        TokenInfo.prototype.decimals = 0;
        TokenInfo.prototype.totalSupply = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TokenInfo.prototype.treasury = null;
        TokenInfo.prototype.adminKey = null;
        TokenInfo.prototype.kycKey = null;
        TokenInfo.prototype.freezeKey = null;
        TokenInfo.prototype.wipeKey = null;
        TokenInfo.prototype.supplyKey = null;
        TokenInfo.prototype.defaultFreezeStatus = 0;
        TokenInfo.prototype.defaultKycStatus = 0;
        TokenInfo.prototype.deleted = false;
        TokenInfo.prototype.autoRenewAccount = null;
        TokenInfo.prototype.autoRenewPeriod = null;
        TokenInfo.prototype.expiry = null;
        TokenInfo.prototype.memo = "";
        TokenInfo.prototype.tokenType = 0;
        TokenInfo.prototype.supplyType = 0;
        TokenInfo.prototype.maxSupply = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenInfo.prototype.feeScheduleKey = null;
        TokenInfo.prototype.customFees = $util.emptyArray;
        TokenInfo.prototype.pauseKey = null;
        TokenInfo.prototype.pauseStatus = 0;
        TokenInfo.prototype.ledgerId = $util.newBuffer([]);
        TokenInfo.prototype.metadata = $util.newBuffer([]);
        TokenInfo.prototype.metadataKey = null;
        TokenInfo.create = function create(properties) {
          return new TokenInfo(properties);
        };
        TokenInfo.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.name != null && Object.hasOwnProperty.call(m6, "name")) w5.uint32(18).string(m6.name);
          if (m6.symbol != null && Object.hasOwnProperty.call(m6, "symbol")) w5.uint32(26).string(m6.symbol);
          if (m6.decimals != null && Object.hasOwnProperty.call(m6, "decimals")) w5.uint32(32).uint32(m6.decimals);
          if (m6.totalSupply != null && Object.hasOwnProperty.call(m6, "totalSupply")) w5.uint32(40).uint64(m6.totalSupply);
          if (m6.treasury != null && Object.hasOwnProperty.call(m6, "treasury")) $root.proto.AccountID.encode(m6.treasury, w5.uint32(50).fork()).ldelim();
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(58).fork()).ldelim();
          if (m6.kycKey != null && Object.hasOwnProperty.call(m6, "kycKey")) $root.proto.Key.encode(m6.kycKey, w5.uint32(66).fork()).ldelim();
          if (m6.freezeKey != null && Object.hasOwnProperty.call(m6, "freezeKey")) $root.proto.Key.encode(m6.freezeKey, w5.uint32(74).fork()).ldelim();
          if (m6.wipeKey != null && Object.hasOwnProperty.call(m6, "wipeKey")) $root.proto.Key.encode(m6.wipeKey, w5.uint32(82).fork()).ldelim();
          if (m6.supplyKey != null && Object.hasOwnProperty.call(m6, "supplyKey")) $root.proto.Key.encode(m6.supplyKey, w5.uint32(90).fork()).ldelim();
          if (m6.defaultFreezeStatus != null && Object.hasOwnProperty.call(m6, "defaultFreezeStatus")) w5.uint32(96).int32(m6.defaultFreezeStatus);
          if (m6.defaultKycStatus != null && Object.hasOwnProperty.call(m6, "defaultKycStatus")) w5.uint32(104).int32(m6.defaultKycStatus);
          if (m6.deleted != null && Object.hasOwnProperty.call(m6, "deleted")) w5.uint32(112).bool(m6.deleted);
          if (m6.autoRenewAccount != null && Object.hasOwnProperty.call(m6, "autoRenewAccount")) $root.proto.AccountID.encode(m6.autoRenewAccount, w5.uint32(122).fork()).ldelim();
          if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(130).fork()).ldelim();
          if (m6.expiry != null && Object.hasOwnProperty.call(m6, "expiry")) $root.proto.Timestamp.encode(m6.expiry, w5.uint32(138).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(146).string(m6.memo);
          if (m6.tokenType != null && Object.hasOwnProperty.call(m6, "tokenType")) w5.uint32(152).int32(m6.tokenType);
          if (m6.supplyType != null && Object.hasOwnProperty.call(m6, "supplyType")) w5.uint32(160).int32(m6.supplyType);
          if (m6.maxSupply != null && Object.hasOwnProperty.call(m6, "maxSupply")) w5.uint32(168).int64(m6.maxSupply);
          if (m6.feeScheduleKey != null && Object.hasOwnProperty.call(m6, "feeScheduleKey")) $root.proto.Key.encode(m6.feeScheduleKey, w5.uint32(178).fork()).ldelim();
          if (m6.customFees != null && m6.customFees.length) {
            for (var i17 = 0; i17 < m6.customFees.length; ++i17) $root.proto.CustomFee.encode(m6.customFees[i17], w5.uint32(186).fork()).ldelim();
          }
          if (m6.pauseKey != null && Object.hasOwnProperty.call(m6, "pauseKey")) $root.proto.Key.encode(m6.pauseKey, w5.uint32(194).fork()).ldelim();
          if (m6.pauseStatus != null && Object.hasOwnProperty.call(m6, "pauseStatus")) w5.uint32(200).int32(m6.pauseStatus);
          if (m6.ledgerId != null && Object.hasOwnProperty.call(m6, "ledgerId")) w5.uint32(210).bytes(m6.ledgerId);
          if (m6.metadata != null && Object.hasOwnProperty.call(m6, "metadata")) w5.uint32(218).bytes(m6.metadata);
          if (m6.metadataKey != null && Object.hasOwnProperty.call(m6, "metadataKey")) $root.proto.Key.encode(m6.metadataKey, w5.uint32(226).fork()).ldelim();
          return w5;
        };
        TokenInfo.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenInfo();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.name = r41.string();
                break;
              }
              case 3: {
                m6.symbol = r41.string();
                break;
              }
              case 4: {
                m6.decimals = r41.uint32();
                break;
              }
              case 5: {
                m6.totalSupply = r41.uint64();
                break;
              }
              case 6: {
                m6.treasury = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.kycKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.freezeKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.wipeKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.supplyKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.defaultFreezeStatus = r41.int32();
                break;
              }
              case 13: {
                m6.defaultKycStatus = r41.int32();
                break;
              }
              case 14: {
                m6.deleted = r41.bool();
                break;
              }
              case 15: {
                m6.autoRenewAccount = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                break;
              }
              case 17: {
                m6.expiry = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 18: {
                m6.memo = r41.string();
                break;
              }
              case 19: {
                m6.tokenType = r41.int32();
                break;
              }
              case 20: {
                m6.supplyType = r41.int32();
                break;
              }
              case 21: {
                m6.maxSupply = r41.int64();
                break;
              }
              case 22: {
                m6.feeScheduleKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 23: {
                if (!(m6.customFees && m6.customFees.length)) m6.customFees = [];
                m6.customFees.push($root.proto.CustomFee.decode(r41, r41.uint32()));
                break;
              }
              case 24: {
                m6.pauseKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 25: {
                m6.pauseStatus = r41.int32();
                break;
              }
              case 26: {
                m6.ledgerId = r41.bytes();
                break;
              }
              case 27: {
                m6.metadata = r41.bytes();
                break;
              }
              case 28: {
                m6.metadataKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenInfo";
        };
        return TokenInfo;
      })();
      proto37.TokenGetInfoResponse = (function() {
        function TokenGetInfoResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenGetInfoResponse.prototype.header = null;
        TokenGetInfoResponse.prototype.tokenInfo = null;
        TokenGetInfoResponse.create = function create(properties) {
          return new TokenGetInfoResponse(properties);
        };
        TokenGetInfoResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.tokenInfo != null && Object.hasOwnProperty.call(m6, "tokenInfo")) $root.proto.TokenInfo.encode(m6.tokenInfo, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenGetInfoResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenGetInfoResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.tokenInfo = $root.proto.TokenInfo.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenGetInfoResponse";
        };
        return TokenGetInfoResponse;
      })();
      proto37.ScheduleGetInfoQuery = (function() {
        function ScheduleGetInfoQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ScheduleGetInfoQuery.prototype.header = null;
        ScheduleGetInfoQuery.prototype.scheduleID = null;
        ScheduleGetInfoQuery.create = function create(properties) {
          return new ScheduleGetInfoQuery(properties);
        };
        ScheduleGetInfoQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.scheduleID != null && Object.hasOwnProperty.call(m6, "scheduleID")) $root.proto.ScheduleID.encode(m6.scheduleID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ScheduleGetInfoQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ScheduleGetInfoQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.scheduleID = $root.proto.ScheduleID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ScheduleGetInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ScheduleGetInfoQuery";
        };
        return ScheduleGetInfoQuery;
      })();
      proto37.ScheduleInfo = (function() {
        function ScheduleInfo(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ScheduleInfo.prototype.scheduleID = null;
        ScheduleInfo.prototype.deletionTime = null;
        ScheduleInfo.prototype.executionTime = null;
        ScheduleInfo.prototype.expirationTime = null;
        ScheduleInfo.prototype.scheduledTransactionBody = null;
        ScheduleInfo.prototype.memo = "";
        ScheduleInfo.prototype.adminKey = null;
        ScheduleInfo.prototype.signers = null;
        ScheduleInfo.prototype.creatorAccountID = null;
        ScheduleInfo.prototype.payerAccountID = null;
        ScheduleInfo.prototype.scheduledTransactionID = null;
        ScheduleInfo.prototype.ledgerId = $util.newBuffer([]);
        ScheduleInfo.prototype.waitForExpiry = false;
        let $oneOfFields;
        Object.defineProperty(ScheduleInfo.prototype, "data", { get: $util.oneOfGetter($oneOfFields = ["deletionTime", "executionTime"]), set: $util.oneOfSetter($oneOfFields) });
        ScheduleInfo.create = function create(properties) {
          return new ScheduleInfo(properties);
        };
        ScheduleInfo.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.scheduleID != null && Object.hasOwnProperty.call(m6, "scheduleID")) $root.proto.ScheduleID.encode(m6.scheduleID, w5.uint32(10).fork()).ldelim();
          if (m6.deletionTime != null && Object.hasOwnProperty.call(m6, "deletionTime")) $root.proto.Timestamp.encode(m6.deletionTime, w5.uint32(18).fork()).ldelim();
          if (m6.executionTime != null && Object.hasOwnProperty.call(m6, "executionTime")) $root.proto.Timestamp.encode(m6.executionTime, w5.uint32(26).fork()).ldelim();
          if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(34).fork()).ldelim();
          if (m6.scheduledTransactionBody != null && Object.hasOwnProperty.call(m6, "scheduledTransactionBody")) $root.proto.SchedulableTransactionBody.encode(m6.scheduledTransactionBody, w5.uint32(42).fork()).ldelim();
          if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(50).string(m6.memo);
          if (m6.adminKey != null && Object.hasOwnProperty.call(m6, "adminKey")) $root.proto.Key.encode(m6.adminKey, w5.uint32(58).fork()).ldelim();
          if (m6.signers != null && Object.hasOwnProperty.call(m6, "signers")) $root.proto.KeyList.encode(m6.signers, w5.uint32(66).fork()).ldelim();
          if (m6.creatorAccountID != null && Object.hasOwnProperty.call(m6, "creatorAccountID")) $root.proto.AccountID.encode(m6.creatorAccountID, w5.uint32(74).fork()).ldelim();
          if (m6.payerAccountID != null && Object.hasOwnProperty.call(m6, "payerAccountID")) $root.proto.AccountID.encode(m6.payerAccountID, w5.uint32(82).fork()).ldelim();
          if (m6.scheduledTransactionID != null && Object.hasOwnProperty.call(m6, "scheduledTransactionID")) $root.proto.TransactionID.encode(m6.scheduledTransactionID, w5.uint32(90).fork()).ldelim();
          if (m6.ledgerId != null && Object.hasOwnProperty.call(m6, "ledgerId")) w5.uint32(98).bytes(m6.ledgerId);
          if (m6.waitForExpiry != null && Object.hasOwnProperty.call(m6, "waitForExpiry")) w5.uint32(104).bool(m6.waitForExpiry);
          return w5;
        };
        ScheduleInfo.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ScheduleInfo();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.scheduleID = $root.proto.ScheduleID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.deletionTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.executionTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.scheduledTransactionBody = $root.proto.SchedulableTransactionBody.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.memo = r41.string();
                break;
              }
              case 7: {
                m6.adminKey = $root.proto.Key.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.signers = $root.proto.KeyList.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.creatorAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.payerAccountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.scheduledTransactionID = $root.proto.TransactionID.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.ledgerId = r41.bytes();
                break;
              }
              case 13: {
                m6.waitForExpiry = r41.bool();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ScheduleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ScheduleInfo";
        };
        return ScheduleInfo;
      })();
      proto37.ScheduleGetInfoResponse = (function() {
        function ScheduleGetInfoResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ScheduleGetInfoResponse.prototype.header = null;
        ScheduleGetInfoResponse.prototype.scheduleInfo = null;
        ScheduleGetInfoResponse.create = function create(properties) {
          return new ScheduleGetInfoResponse(properties);
        };
        ScheduleGetInfoResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.scheduleInfo != null && Object.hasOwnProperty.call(m6, "scheduleInfo")) $root.proto.ScheduleInfo.encode(m6.scheduleInfo, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        ScheduleGetInfoResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ScheduleGetInfoResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.scheduleInfo = $root.proto.ScheduleInfo.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ScheduleGetInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ScheduleGetInfoResponse";
        };
        return ScheduleGetInfoResponse;
      })();
      proto37.TokenGetAccountNftInfosQuery = (function() {
        function TokenGetAccountNftInfosQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenGetAccountNftInfosQuery.prototype.header = null;
        TokenGetAccountNftInfosQuery.prototype.accountID = null;
        TokenGetAccountNftInfosQuery.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenGetAccountNftInfosQuery.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenGetAccountNftInfosQuery.create = function create(properties) {
          return new TokenGetAccountNftInfosQuery(properties);
        };
        TokenGetAccountNftInfosQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          if (m6.start != null && Object.hasOwnProperty.call(m6, "start")) w5.uint32(24).int64(m6.start);
          if (m6.end != null && Object.hasOwnProperty.call(m6, "end")) w5.uint32(32).int64(m6.end);
          return w5;
        };
        TokenGetAccountNftInfosQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenGetAccountNftInfosQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.start = r41.int64();
                break;
              }
              case 4: {
                m6.end = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenGetAccountNftInfosQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenGetAccountNftInfosQuery";
        };
        return TokenGetAccountNftInfosQuery;
      })();
      proto37.TokenGetAccountNftInfosResponse = (function() {
        function TokenGetAccountNftInfosResponse(p3) {
          this.nfts = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenGetAccountNftInfosResponse.prototype.header = null;
        TokenGetAccountNftInfosResponse.prototype.nfts = $util.emptyArray;
        TokenGetAccountNftInfosResponse.create = function create(properties) {
          return new TokenGetAccountNftInfosResponse(properties);
        };
        TokenGetAccountNftInfosResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.nfts != null && m6.nfts.length) {
            for (var i17 = 0; i17 < m6.nfts.length; ++i17) $root.proto.TokenNftInfo.encode(m6.nfts[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        TokenGetAccountNftInfosResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenGetAccountNftInfosResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.nfts && m6.nfts.length)) m6.nfts = [];
                m6.nfts.push($root.proto.TokenNftInfo.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenGetAccountNftInfosResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenGetAccountNftInfosResponse";
        };
        return TokenGetAccountNftInfosResponse;
      })();
      proto37.TokenGetNftInfoQuery = (function() {
        function TokenGetNftInfoQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenGetNftInfoQuery.prototype.header = null;
        TokenGetNftInfoQuery.prototype.nftID = null;
        TokenGetNftInfoQuery.create = function create(properties) {
          return new TokenGetNftInfoQuery(properties);
        };
        TokenGetNftInfoQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.nftID != null && Object.hasOwnProperty.call(m6, "nftID")) $root.proto.NftID.encode(m6.nftID, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenGetNftInfoQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenGetNftInfoQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.nftID = $root.proto.NftID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenGetNftInfoQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenGetNftInfoQuery";
        };
        return TokenGetNftInfoQuery;
      })();
      proto37.TokenNftInfo = (function() {
        function TokenNftInfo(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenNftInfo.prototype.nftID = null;
        TokenNftInfo.prototype.accountID = null;
        TokenNftInfo.prototype.creationTime = null;
        TokenNftInfo.prototype.metadata = $util.newBuffer([]);
        TokenNftInfo.prototype.ledgerId = $util.newBuffer([]);
        TokenNftInfo.prototype.spenderId = null;
        TokenNftInfo.create = function create(properties) {
          return new TokenNftInfo(properties);
        };
        TokenNftInfo.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.nftID != null && Object.hasOwnProperty.call(m6, "nftID")) $root.proto.NftID.encode(m6.nftID, w5.uint32(10).fork()).ldelim();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(18).fork()).ldelim();
          if (m6.creationTime != null && Object.hasOwnProperty.call(m6, "creationTime")) $root.proto.Timestamp.encode(m6.creationTime, w5.uint32(26).fork()).ldelim();
          if (m6.metadata != null && Object.hasOwnProperty.call(m6, "metadata")) w5.uint32(34).bytes(m6.metadata);
          if (m6.ledgerId != null && Object.hasOwnProperty.call(m6, "ledgerId")) w5.uint32(42).bytes(m6.ledgerId);
          if (m6.spenderId != null && Object.hasOwnProperty.call(m6, "spenderId")) $root.proto.AccountID.encode(m6.spenderId, w5.uint32(50).fork()).ldelim();
          return w5;
        };
        TokenNftInfo.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenNftInfo();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.nftID = $root.proto.NftID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.creationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.metadata = r41.bytes();
                break;
              }
              case 5: {
                m6.ledgerId = r41.bytes();
                break;
              }
              case 6: {
                m6.spenderId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenNftInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenNftInfo";
        };
        return TokenNftInfo;
      })();
      proto37.TokenGetNftInfoResponse = (function() {
        function TokenGetNftInfoResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenGetNftInfoResponse.prototype.header = null;
        TokenGetNftInfoResponse.prototype.nft = null;
        TokenGetNftInfoResponse.create = function create(properties) {
          return new TokenGetNftInfoResponse(properties);
        };
        TokenGetNftInfoResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.nft != null && Object.hasOwnProperty.call(m6, "nft")) $root.proto.TokenNftInfo.encode(m6.nft, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        TokenGetNftInfoResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenGetNftInfoResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.nft = $root.proto.TokenNftInfo.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenGetNftInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenGetNftInfoResponse";
        };
        return TokenGetNftInfoResponse;
      })();
      proto37.TokenGetNftInfosQuery = (function() {
        function TokenGetNftInfosQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenGetNftInfosQuery.prototype.header = null;
        TokenGetNftInfosQuery.prototype.tokenID = null;
        TokenGetNftInfosQuery.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenGetNftInfosQuery.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        TokenGetNftInfosQuery.create = function create(properties) {
          return new TokenGetNftInfosQuery(properties);
        };
        TokenGetNftInfosQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.tokenID != null && Object.hasOwnProperty.call(m6, "tokenID")) $root.proto.TokenID.encode(m6.tokenID, w5.uint32(18).fork()).ldelim();
          if (m6.start != null && Object.hasOwnProperty.call(m6, "start")) w5.uint32(24).int64(m6.start);
          if (m6.end != null && Object.hasOwnProperty.call(m6, "end")) w5.uint32(32).int64(m6.end);
          return w5;
        };
        TokenGetNftInfosQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenGetNftInfosQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.tokenID = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.start = r41.int64();
                break;
              }
              case 4: {
                m6.end = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenGetNftInfosQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenGetNftInfosQuery";
        };
        return TokenGetNftInfosQuery;
      })();
      proto37.TokenGetNftInfosResponse = (function() {
        function TokenGetNftInfosResponse(p3) {
          this.nfts = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenGetNftInfosResponse.prototype.header = null;
        TokenGetNftInfosResponse.prototype.tokenID = null;
        TokenGetNftInfosResponse.prototype.nfts = $util.emptyArray;
        TokenGetNftInfosResponse.create = function create(properties) {
          return new TokenGetNftInfosResponse(properties);
        };
        TokenGetNftInfosResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.tokenID != null && Object.hasOwnProperty.call(m6, "tokenID")) $root.proto.TokenID.encode(m6.tokenID, w5.uint32(18).fork()).ldelim();
          if (m6.nfts != null && m6.nfts.length) {
            for (var i17 = 0; i17 < m6.nfts.length; ++i17) $root.proto.TokenNftInfo.encode(m6.nfts[i17], w5.uint32(26).fork()).ldelim();
          }
          return w5;
        };
        TokenGetNftInfosResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenGetNftInfosResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.tokenID = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                if (!(m6.nfts && m6.nfts.length)) m6.nfts = [];
                m6.nfts.push($root.proto.TokenNftInfo.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenGetNftInfosResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenGetNftInfosResponse";
        };
        return TokenGetNftInfosResponse;
      })();
      proto37.GetAccountDetailsQuery = (function() {
        function GetAccountDetailsQuery(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        GetAccountDetailsQuery.prototype.header = null;
        GetAccountDetailsQuery.prototype.accountId = null;
        GetAccountDetailsQuery.create = function create(properties) {
          return new GetAccountDetailsQuery(properties);
        };
        GetAccountDetailsQuery.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.QueryHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountId != null && Object.hasOwnProperty.call(m6, "accountId")) $root.proto.AccountID.encode(m6.accountId, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        GetAccountDetailsQuery.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GetAccountDetailsQuery();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.QueryHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountId = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        GetAccountDetailsQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.GetAccountDetailsQuery";
        };
        return GetAccountDetailsQuery;
      })();
      proto37.GetAccountDetailsResponse = (function() {
        function GetAccountDetailsResponse(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        GetAccountDetailsResponse.prototype.header = null;
        GetAccountDetailsResponse.prototype.accountDetails = null;
        GetAccountDetailsResponse.create = function create(properties) {
          return new GetAccountDetailsResponse(properties);
        };
        GetAccountDetailsResponse.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.header != null && Object.hasOwnProperty.call(m6, "header")) $root.proto.ResponseHeader.encode(m6.header, w5.uint32(10).fork()).ldelim();
          if (m6.accountDetails != null && Object.hasOwnProperty.call(m6, "accountDetails")) $root.proto.GetAccountDetailsResponse.AccountDetails.encode(m6.accountDetails, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        GetAccountDetailsResponse.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GetAccountDetailsResponse();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.header = $root.proto.ResponseHeader.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.accountDetails = $root.proto.GetAccountDetailsResponse.AccountDetails.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        GetAccountDetailsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.GetAccountDetailsResponse";
        };
        GetAccountDetailsResponse.AccountDetails = (function() {
          function AccountDetails(p3) {
            this.tokenRelationships = [];
            this.grantedCryptoAllowances = [];
            this.grantedNftAllowances = [];
            this.grantedTokenAllowances = [];
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          AccountDetails.prototype.accountId = null;
          AccountDetails.prototype.contractAccountId = "";
          AccountDetails.prototype.deleted = false;
          AccountDetails.prototype.proxyAccountId = null;
          AccountDetails.prototype.proxyReceived = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          AccountDetails.prototype.key = null;
          AccountDetails.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          AccountDetails.prototype.receiverSigRequired = false;
          AccountDetails.prototype.expirationTime = null;
          AccountDetails.prototype.autoRenewPeriod = null;
          AccountDetails.prototype.tokenRelationships = $util.emptyArray;
          AccountDetails.prototype.memo = "";
          AccountDetails.prototype.ownedNfts = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          AccountDetails.prototype.maxAutomaticTokenAssociations = 0;
          AccountDetails.prototype.alias = $util.newBuffer([]);
          AccountDetails.prototype.ledgerId = $util.newBuffer([]);
          AccountDetails.prototype.grantedCryptoAllowances = $util.emptyArray;
          AccountDetails.prototype.grantedNftAllowances = $util.emptyArray;
          AccountDetails.prototype.grantedTokenAllowances = $util.emptyArray;
          AccountDetails.create = function create(properties) {
            return new AccountDetails(properties);
          };
          AccountDetails.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.accountId != null && Object.hasOwnProperty.call(m6, "accountId")) $root.proto.AccountID.encode(m6.accountId, w5.uint32(10).fork()).ldelim();
            if (m6.contractAccountId != null && Object.hasOwnProperty.call(m6, "contractAccountId")) w5.uint32(18).string(m6.contractAccountId);
            if (m6.deleted != null && Object.hasOwnProperty.call(m6, "deleted")) w5.uint32(24).bool(m6.deleted);
            if (m6.proxyAccountId != null && Object.hasOwnProperty.call(m6, "proxyAccountId")) $root.proto.AccountID.encode(m6.proxyAccountId, w5.uint32(34).fork()).ldelim();
            if (m6.proxyReceived != null && Object.hasOwnProperty.call(m6, "proxyReceived")) w5.uint32(40).int64(m6.proxyReceived);
            if (m6.key != null && Object.hasOwnProperty.call(m6, "key")) $root.proto.Key.encode(m6.key, w5.uint32(50).fork()).ldelim();
            if (m6.balance != null && Object.hasOwnProperty.call(m6, "balance")) w5.uint32(56).uint64(m6.balance);
            if (m6.receiverSigRequired != null && Object.hasOwnProperty.call(m6, "receiverSigRequired")) w5.uint32(64).bool(m6.receiverSigRequired);
            if (m6.expirationTime != null && Object.hasOwnProperty.call(m6, "expirationTime")) $root.proto.Timestamp.encode(m6.expirationTime, w5.uint32(74).fork()).ldelim();
            if (m6.autoRenewPeriod != null && Object.hasOwnProperty.call(m6, "autoRenewPeriod")) $root.proto.Duration.encode(m6.autoRenewPeriod, w5.uint32(82).fork()).ldelim();
            if (m6.tokenRelationships != null && m6.tokenRelationships.length) {
              for (var i17 = 0; i17 < m6.tokenRelationships.length; ++i17) $root.proto.TokenRelationship.encode(m6.tokenRelationships[i17], w5.uint32(90).fork()).ldelim();
            }
            if (m6.memo != null && Object.hasOwnProperty.call(m6, "memo")) w5.uint32(98).string(m6.memo);
            if (m6.ownedNfts != null && Object.hasOwnProperty.call(m6, "ownedNfts")) w5.uint32(104).int64(m6.ownedNfts);
            if (m6.maxAutomaticTokenAssociations != null && Object.hasOwnProperty.call(m6, "maxAutomaticTokenAssociations")) w5.uint32(112).int32(m6.maxAutomaticTokenAssociations);
            if (m6.alias != null && Object.hasOwnProperty.call(m6, "alias")) w5.uint32(122).bytes(m6.alias);
            if (m6.ledgerId != null && Object.hasOwnProperty.call(m6, "ledgerId")) w5.uint32(130).bytes(m6.ledgerId);
            if (m6.grantedCryptoAllowances != null && m6.grantedCryptoAllowances.length) {
              for (var i17 = 0; i17 < m6.grantedCryptoAllowances.length; ++i17) $root.proto.GrantedCryptoAllowance.encode(m6.grantedCryptoAllowances[i17], w5.uint32(138).fork()).ldelim();
            }
            if (m6.grantedNftAllowances != null && m6.grantedNftAllowances.length) {
              for (var i17 = 0; i17 < m6.grantedNftAllowances.length; ++i17) $root.proto.GrantedNftAllowance.encode(m6.grantedNftAllowances[i17], w5.uint32(146).fork()).ldelim();
            }
            if (m6.grantedTokenAllowances != null && m6.grantedTokenAllowances.length) {
              for (var i17 = 0; i17 < m6.grantedTokenAllowances.length; ++i17) $root.proto.GrantedTokenAllowance.encode(m6.grantedTokenAllowances[i17], w5.uint32(154).fork()).ldelim();
            }
            return w5;
          };
          AccountDetails.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GetAccountDetailsResponse.AccountDetails();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.accountId = $root.proto.AccountID.decode(r41, r41.uint32());
                  break;
                }
                case 2: {
                  m6.contractAccountId = r41.string();
                  break;
                }
                case 3: {
                  m6.deleted = r41.bool();
                  break;
                }
                case 4: {
                  m6.proxyAccountId = $root.proto.AccountID.decode(r41, r41.uint32());
                  break;
                }
                case 5: {
                  m6.proxyReceived = r41.int64();
                  break;
                }
                case 6: {
                  m6.key = $root.proto.Key.decode(r41, r41.uint32());
                  break;
                }
                case 7: {
                  m6.balance = r41.uint64();
                  break;
                }
                case 8: {
                  m6.receiverSigRequired = r41.bool();
                  break;
                }
                case 9: {
                  m6.expirationTime = $root.proto.Timestamp.decode(r41, r41.uint32());
                  break;
                }
                case 10: {
                  m6.autoRenewPeriod = $root.proto.Duration.decode(r41, r41.uint32());
                  break;
                }
                case 11: {
                  if (!(m6.tokenRelationships && m6.tokenRelationships.length)) m6.tokenRelationships = [];
                  m6.tokenRelationships.push($root.proto.TokenRelationship.decode(r41, r41.uint32()));
                  break;
                }
                case 12: {
                  m6.memo = r41.string();
                  break;
                }
                case 13: {
                  m6.ownedNfts = r41.int64();
                  break;
                }
                case 14: {
                  m6.maxAutomaticTokenAssociations = r41.int32();
                  break;
                }
                case 15: {
                  m6.alias = r41.bytes();
                  break;
                }
                case 16: {
                  m6.ledgerId = r41.bytes();
                  break;
                }
                case 17: {
                  if (!(m6.grantedCryptoAllowances && m6.grantedCryptoAllowances.length)) m6.grantedCryptoAllowances = [];
                  m6.grantedCryptoAllowances.push($root.proto.GrantedCryptoAllowance.decode(r41, r41.uint32()));
                  break;
                }
                case 18: {
                  if (!(m6.grantedNftAllowances && m6.grantedNftAllowances.length)) m6.grantedNftAllowances = [];
                  m6.grantedNftAllowances.push($root.proto.GrantedNftAllowance.decode(r41, r41.uint32()));
                  break;
                }
                case 19: {
                  if (!(m6.grantedTokenAllowances && m6.grantedTokenAllowances.length)) m6.grantedTokenAllowances = [];
                  m6.grantedTokenAllowances.push($root.proto.GrantedTokenAllowance.decode(r41, r41.uint32()));
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          AccountDetails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GetAccountDetailsResponse.AccountDetails";
          };
          return AccountDetails;
        })();
        return GetAccountDetailsResponse;
      })();
      proto37.GrantedCryptoAllowance = (function() {
        function GrantedCryptoAllowance(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        GrantedCryptoAllowance.prototype.spender = null;
        GrantedCryptoAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        GrantedCryptoAllowance.create = function create(properties) {
          return new GrantedCryptoAllowance(properties);
        };
        GrantedCryptoAllowance.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.spender != null && Object.hasOwnProperty.call(m6, "spender")) $root.proto.AccountID.encode(m6.spender, w5.uint32(10).fork()).ldelim();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(16).int64(m6.amount);
          return w5;
        };
        GrantedCryptoAllowance.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GrantedCryptoAllowance();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.spender = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.amount = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        GrantedCryptoAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.GrantedCryptoAllowance";
        };
        return GrantedCryptoAllowance;
      })();
      proto37.GrantedNftAllowance = (function() {
        function GrantedNftAllowance(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        GrantedNftAllowance.prototype.tokenId = null;
        GrantedNftAllowance.prototype.spender = null;
        GrantedNftAllowance.create = function create(properties) {
          return new GrantedNftAllowance(properties);
        };
        GrantedNftAllowance.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.spender != null && Object.hasOwnProperty.call(m6, "spender")) $root.proto.AccountID.encode(m6.spender, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        GrantedNftAllowance.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GrantedNftAllowance();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.spender = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        GrantedNftAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.GrantedNftAllowance";
        };
        return GrantedNftAllowance;
      })();
      proto37.GrantedTokenAllowance = (function() {
        function GrantedTokenAllowance(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        GrantedTokenAllowance.prototype.tokenId = null;
        GrantedTokenAllowance.prototype.spender = null;
        GrantedTokenAllowance.prototype.amount = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        GrantedTokenAllowance.create = function create(properties) {
          return new GrantedTokenAllowance(properties);
        };
        GrantedTokenAllowance.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.spender != null && Object.hasOwnProperty.call(m6, "spender")) $root.proto.AccountID.encode(m6.spender, w5.uint32(18).fork()).ldelim();
          if (m6.amount != null && Object.hasOwnProperty.call(m6, "amount")) w5.uint32(24).int64(m6.amount);
          return w5;
        };
        GrantedTokenAllowance.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.GrantedTokenAllowance();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.spender = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.amount = r41.int64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        GrantedTokenAllowance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.GrantedTokenAllowance";
        };
        return GrantedTokenAllowance;
      })();
      proto37.Response = (function() {
        function Response(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        Response.prototype.getByKey = null;
        Response.prototype.getBySolidityID = null;
        Response.prototype.contractCallLocal = null;
        Response.prototype.contractGetBytecodeResponse = null;
        Response.prototype.contractGetInfo = null;
        Response.prototype.contractGetRecordsResponse = null;
        Response.prototype.cryptogetAccountBalance = null;
        Response.prototype.cryptoGetAccountRecords = null;
        Response.prototype.cryptoGetInfo = null;
        Response.prototype.cryptoGetLiveHash = null;
        Response.prototype.cryptoGetProxyStakers = null;
        Response.prototype.fileGetContents = null;
        Response.prototype.fileGetInfo = null;
        Response.prototype.transactionGetReceipt = null;
        Response.prototype.transactionGetRecord = null;
        Response.prototype.transactionGetFastRecord = null;
        Response.prototype.consensusGetTopicInfo = null;
        Response.prototype.networkGetVersionInfo = null;
        Response.prototype.tokenGetInfo = null;
        Response.prototype.scheduleGetInfo = null;
        Response.prototype.tokenGetAccountNftInfos = null;
        Response.prototype.tokenGetNftInfo = null;
        Response.prototype.tokenGetNftInfos = null;
        Response.prototype.networkGetExecutionTime = null;
        Response.prototype.accountDetails = null;
        let $oneOfFields;
        Object.defineProperty(Response.prototype, "response", { get: $util.oneOfGetter($oneOfFields = ["getByKey", "getBySolidityID", "contractCallLocal", "contractGetBytecodeResponse", "contractGetInfo", "contractGetRecordsResponse", "cryptogetAccountBalance", "cryptoGetAccountRecords", "cryptoGetInfo", "cryptoGetLiveHash", "cryptoGetProxyStakers", "fileGetContents", "fileGetInfo", "transactionGetReceipt", "transactionGetRecord", "transactionGetFastRecord", "consensusGetTopicInfo", "networkGetVersionInfo", "tokenGetInfo", "scheduleGetInfo", "tokenGetAccountNftInfos", "tokenGetNftInfo", "tokenGetNftInfos", "networkGetExecutionTime", "accountDetails"]), set: $util.oneOfSetter($oneOfFields) });
        Response.create = function create(properties) {
          return new Response(properties);
        };
        Response.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.getByKey != null && Object.hasOwnProperty.call(m6, "getByKey")) $root.proto.GetByKeyResponse.encode(m6.getByKey, w5.uint32(10).fork()).ldelim();
          if (m6.getBySolidityID != null && Object.hasOwnProperty.call(m6, "getBySolidityID")) $root.proto.GetBySolidityIDResponse.encode(m6.getBySolidityID, w5.uint32(18).fork()).ldelim();
          if (m6.contractCallLocal != null && Object.hasOwnProperty.call(m6, "contractCallLocal")) $root.proto.ContractCallLocalResponse.encode(m6.contractCallLocal, w5.uint32(26).fork()).ldelim();
          if (m6.contractGetInfo != null && Object.hasOwnProperty.call(m6, "contractGetInfo")) $root.proto.ContractGetInfoResponse.encode(m6.contractGetInfo, w5.uint32(34).fork()).ldelim();
          if (m6.contractGetBytecodeResponse != null && Object.hasOwnProperty.call(m6, "contractGetBytecodeResponse")) $root.proto.ContractGetBytecodeResponse.encode(m6.contractGetBytecodeResponse, w5.uint32(42).fork()).ldelim();
          if (m6.contractGetRecordsResponse != null && Object.hasOwnProperty.call(m6, "contractGetRecordsResponse")) $root.proto.ContractGetRecordsResponse.encode(m6.contractGetRecordsResponse, w5.uint32(50).fork()).ldelim();
          if (m6.cryptogetAccountBalance != null && Object.hasOwnProperty.call(m6, "cryptogetAccountBalance")) $root.proto.CryptoGetAccountBalanceResponse.encode(m6.cryptogetAccountBalance, w5.uint32(58).fork()).ldelim();
          if (m6.cryptoGetAccountRecords != null && Object.hasOwnProperty.call(m6, "cryptoGetAccountRecords")) $root.proto.CryptoGetAccountRecordsResponse.encode(m6.cryptoGetAccountRecords, w5.uint32(66).fork()).ldelim();
          if (m6.cryptoGetInfo != null && Object.hasOwnProperty.call(m6, "cryptoGetInfo")) $root.proto.CryptoGetInfoResponse.encode(m6.cryptoGetInfo, w5.uint32(74).fork()).ldelim();
          if (m6.cryptoGetLiveHash != null && Object.hasOwnProperty.call(m6, "cryptoGetLiveHash")) $root.proto.CryptoGetLiveHashResponse.encode(m6.cryptoGetLiveHash, w5.uint32(82).fork()).ldelim();
          if (m6.cryptoGetProxyStakers != null && Object.hasOwnProperty.call(m6, "cryptoGetProxyStakers")) $root.proto.CryptoGetStakersResponse.encode(m6.cryptoGetProxyStakers, w5.uint32(90).fork()).ldelim();
          if (m6.fileGetContents != null && Object.hasOwnProperty.call(m6, "fileGetContents")) $root.proto.FileGetContentsResponse.encode(m6.fileGetContents, w5.uint32(98).fork()).ldelim();
          if (m6.fileGetInfo != null && Object.hasOwnProperty.call(m6, "fileGetInfo")) $root.proto.FileGetInfoResponse.encode(m6.fileGetInfo, w5.uint32(106).fork()).ldelim();
          if (m6.transactionGetReceipt != null && Object.hasOwnProperty.call(m6, "transactionGetReceipt")) $root.proto.TransactionGetReceiptResponse.encode(m6.transactionGetReceipt, w5.uint32(114).fork()).ldelim();
          if (m6.transactionGetRecord != null && Object.hasOwnProperty.call(m6, "transactionGetRecord")) $root.proto.TransactionGetRecordResponse.encode(m6.transactionGetRecord, w5.uint32(122).fork()).ldelim();
          if (m6.transactionGetFastRecord != null && Object.hasOwnProperty.call(m6, "transactionGetFastRecord")) $root.proto.TransactionGetFastRecordResponse.encode(m6.transactionGetFastRecord, w5.uint32(130).fork()).ldelim();
          if (m6.consensusGetTopicInfo != null && Object.hasOwnProperty.call(m6, "consensusGetTopicInfo")) $root.proto.ConsensusGetTopicInfoResponse.encode(m6.consensusGetTopicInfo, w5.uint32(1202).fork()).ldelim();
          if (m6.networkGetVersionInfo != null && Object.hasOwnProperty.call(m6, "networkGetVersionInfo")) $root.proto.NetworkGetVersionInfoResponse.encode(m6.networkGetVersionInfo, w5.uint32(1210).fork()).ldelim();
          if (m6.tokenGetInfo != null && Object.hasOwnProperty.call(m6, "tokenGetInfo")) $root.proto.TokenGetInfoResponse.encode(m6.tokenGetInfo, w5.uint32(1218).fork()).ldelim();
          if (m6.scheduleGetInfo != null && Object.hasOwnProperty.call(m6, "scheduleGetInfo")) $root.proto.ScheduleGetInfoResponse.encode(m6.scheduleGetInfo, w5.uint32(1226).fork()).ldelim();
          if (m6.tokenGetAccountNftInfos != null && Object.hasOwnProperty.call(m6, "tokenGetAccountNftInfos")) $root.proto.TokenGetAccountNftInfosResponse.encode(m6.tokenGetAccountNftInfos, w5.uint32(1234).fork()).ldelim();
          if (m6.tokenGetNftInfo != null && Object.hasOwnProperty.call(m6, "tokenGetNftInfo")) $root.proto.TokenGetNftInfoResponse.encode(m6.tokenGetNftInfo, w5.uint32(1242).fork()).ldelim();
          if (m6.tokenGetNftInfos != null && Object.hasOwnProperty.call(m6, "tokenGetNftInfos")) $root.proto.TokenGetNftInfosResponse.encode(m6.tokenGetNftInfos, w5.uint32(1250).fork()).ldelim();
          if (m6.networkGetExecutionTime != null && Object.hasOwnProperty.call(m6, "networkGetExecutionTime")) $root.proto.NetworkGetExecutionTimeResponse.encode(m6.networkGetExecutionTime, w5.uint32(1258).fork()).ldelim();
          if (m6.accountDetails != null && Object.hasOwnProperty.call(m6, "accountDetails")) $root.proto.GetAccountDetailsResponse.encode(m6.accountDetails, w5.uint32(1266).fork()).ldelim();
          return w5;
        };
        Response.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.Response();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.getByKey = $root.proto.GetByKeyResponse.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.getBySolidityID = $root.proto.GetBySolidityIDResponse.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.contractCallLocal = $root.proto.ContractCallLocalResponse.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.contractGetBytecodeResponse = $root.proto.ContractGetBytecodeResponse.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.contractGetInfo = $root.proto.ContractGetInfoResponse.decode(r41, r41.uint32());
                break;
              }
              case 6: {
                m6.contractGetRecordsResponse = $root.proto.ContractGetRecordsResponse.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.cryptogetAccountBalance = $root.proto.CryptoGetAccountBalanceResponse.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.cryptoGetAccountRecords = $root.proto.CryptoGetAccountRecordsResponse.decode(r41, r41.uint32());
                break;
              }
              case 9: {
                m6.cryptoGetInfo = $root.proto.CryptoGetInfoResponse.decode(r41, r41.uint32());
                break;
              }
              case 10: {
                m6.cryptoGetLiveHash = $root.proto.CryptoGetLiveHashResponse.decode(r41, r41.uint32());
                break;
              }
              case 11: {
                m6.cryptoGetProxyStakers = $root.proto.CryptoGetStakersResponse.decode(r41, r41.uint32());
                break;
              }
              case 12: {
                m6.fileGetContents = $root.proto.FileGetContentsResponse.decode(r41, r41.uint32());
                break;
              }
              case 13: {
                m6.fileGetInfo = $root.proto.FileGetInfoResponse.decode(r41, r41.uint32());
                break;
              }
              case 14: {
                m6.transactionGetReceipt = $root.proto.TransactionGetReceiptResponse.decode(r41, r41.uint32());
                break;
              }
              case 15: {
                m6.transactionGetRecord = $root.proto.TransactionGetRecordResponse.decode(r41, r41.uint32());
                break;
              }
              case 16: {
                m6.transactionGetFastRecord = $root.proto.TransactionGetFastRecordResponse.decode(r41, r41.uint32());
                break;
              }
              case 150: {
                m6.consensusGetTopicInfo = $root.proto.ConsensusGetTopicInfoResponse.decode(r41, r41.uint32());
                break;
              }
              case 151: {
                m6.networkGetVersionInfo = $root.proto.NetworkGetVersionInfoResponse.decode(r41, r41.uint32());
                break;
              }
              case 152: {
                m6.tokenGetInfo = $root.proto.TokenGetInfoResponse.decode(r41, r41.uint32());
                break;
              }
              case 153: {
                m6.scheduleGetInfo = $root.proto.ScheduleGetInfoResponse.decode(r41, r41.uint32());
                break;
              }
              case 154: {
                m6.tokenGetAccountNftInfos = $root.proto.TokenGetAccountNftInfosResponse.decode(r41, r41.uint32());
                break;
              }
              case 155: {
                m6.tokenGetNftInfo = $root.proto.TokenGetNftInfoResponse.decode(r41, r41.uint32());
                break;
              }
              case 156: {
                m6.tokenGetNftInfos = $root.proto.TokenGetNftInfosResponse.decode(r41, r41.uint32());
                break;
              }
              case 157: {
                m6.networkGetExecutionTime = $root.proto.NetworkGetExecutionTimeResponse.decode(r41, r41.uint32());
                break;
              }
              case 158: {
                m6.accountDetails = $root.proto.GetAccountDetailsResponse.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.Response";
        };
        return Response;
      })();
      proto37.CryptoService = (function() {
        function CryptoService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (CryptoService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CryptoService;
        CryptoService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(CryptoService.prototype.createAccount = function createAccount(request, callback) {
          return this.rpcCall(createAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createAccount" });
        Object.defineProperty(CryptoService.prototype.updateAccount = function updateAccount(request, callback) {
          return this.rpcCall(updateAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateAccount" });
        Object.defineProperty(CryptoService.prototype.cryptoTransfer = function cryptoTransfer(request, callback) {
          return this.rpcCall(cryptoTransfer, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "cryptoTransfer" });
        Object.defineProperty(CryptoService.prototype.cryptoDelete = function cryptoDelete(request, callback) {
          return this.rpcCall(cryptoDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "cryptoDelete" });
        Object.defineProperty(CryptoService.prototype.approveAllowances = function approveAllowances(request, callback) {
          return this.rpcCall(approveAllowances, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "approveAllowances" });
        Object.defineProperty(CryptoService.prototype.deleteAllowances = function deleteAllowances(request, callback) {
          return this.rpcCall(deleteAllowances, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteAllowances" });
        Object.defineProperty(CryptoService.prototype.addLiveHash = function addLiveHash(request, callback) {
          return this.rpcCall(addLiveHash, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "addLiveHash" });
        Object.defineProperty(CryptoService.prototype.deleteLiveHash = function deleteLiveHash(request, callback) {
          return this.rpcCall(deleteLiveHash, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteLiveHash" });
        Object.defineProperty(CryptoService.prototype.getLiveHash = function getLiveHash(request, callback) {
          return this.rpcCall(getLiveHash, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getLiveHash" });
        Object.defineProperty(CryptoService.prototype.getAccountRecords = function getAccountRecords(request, callback) {
          return this.rpcCall(getAccountRecords, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getAccountRecords" });
        Object.defineProperty(CryptoService.prototype.cryptoGetBalance = function cryptoGetBalance(request, callback) {
          return this.rpcCall(cryptoGetBalance, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "cryptoGetBalance" });
        Object.defineProperty(CryptoService.prototype.getAccountInfo = function getAccountInfo(request, callback) {
          return this.rpcCall(getAccountInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getAccountInfo" });
        Object.defineProperty(CryptoService.prototype.getTransactionReceipts = function getTransactionReceipts(request, callback) {
          return this.rpcCall(getTransactionReceipts, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTransactionReceipts" });
        Object.defineProperty(CryptoService.prototype.getTxRecordByTxID = function getTxRecordByTxID(request, callback) {
          return this.rpcCall(getTxRecordByTxID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTxRecordByTxID" });
        return CryptoService;
      })();
      proto37.FileService = (function() {
        function FileService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (FileService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FileService;
        FileService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(FileService.prototype.createFile = function createFile(request, callback) {
          return this.rpcCall(createFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createFile" });
        Object.defineProperty(FileService.prototype.updateFile = function updateFile(request, callback) {
          return this.rpcCall(updateFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateFile" });
        Object.defineProperty(FileService.prototype.deleteFile = function deleteFile(request, callback) {
          return this.rpcCall(deleteFile, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteFile" });
        Object.defineProperty(FileService.prototype.appendContent = function appendContent(request, callback) {
          return this.rpcCall(appendContent, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "appendContent" });
        Object.defineProperty(FileService.prototype.getFileContent = function getFileContent(request, callback) {
          return this.rpcCall(getFileContent, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getFileContent" });
        Object.defineProperty(FileService.prototype.getFileInfo = function getFileInfo(request, callback) {
          return this.rpcCall(getFileInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getFileInfo" });
        Object.defineProperty(FileService.prototype.systemDelete = function systemDelete(request, callback) {
          return this.rpcCall(systemDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemDelete" });
        Object.defineProperty(FileService.prototype.systemUndelete = function systemUndelete(request, callback) {
          return this.rpcCall(systemUndelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemUndelete" });
        return FileService;
      })();
      proto37.FreezeService = (function() {
        function FreezeService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (FreezeService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FreezeService;
        FreezeService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(FreezeService.prototype.freeze = function freeze(request, callback) {
          return this.rpcCall(freeze, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "freeze" });
        return FreezeService;
      })();
      proto37.NetworkService = (function() {
        function NetworkService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (NetworkService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = NetworkService;
        NetworkService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(NetworkService.prototype.getVersionInfo = function getVersionInfo(request, callback) {
          return this.rpcCall(getVersionInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getVersionInfo" });
        Object.defineProperty(NetworkService.prototype.getAccountDetails = function getAccountDetails(request, callback) {
          return this.rpcCall(getAccountDetails, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getAccountDetails" });
        Object.defineProperty(NetworkService.prototype.getExecutionTime = function getExecutionTime(request, callback) {
          return this.rpcCall(getExecutionTime, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getExecutionTime" });
        Object.defineProperty(NetworkService.prototype.uncheckedSubmit = function uncheckedSubmit(request, callback) {
          return this.rpcCall(uncheckedSubmit, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "uncheckedSubmit" });
        return NetworkService;
      })();
      proto37.ScheduleService = (function() {
        function ScheduleService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (ScheduleService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ScheduleService;
        ScheduleService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(ScheduleService.prototype.createSchedule = function createSchedule(request, callback) {
          return this.rpcCall(createSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createSchedule" });
        Object.defineProperty(ScheduleService.prototype.signSchedule = function signSchedule(request, callback) {
          return this.rpcCall(signSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "signSchedule" });
        Object.defineProperty(ScheduleService.prototype.deleteSchedule = function deleteSchedule(request, callback) {
          return this.rpcCall(deleteSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteSchedule" });
        Object.defineProperty(ScheduleService.prototype.getScheduleInfo = function getScheduleInfo(request, callback) {
          return this.rpcCall(getScheduleInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getScheduleInfo" });
        return ScheduleService;
      })();
      proto37.SmartContractService = (function() {
        function SmartContractService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (SmartContractService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SmartContractService;
        SmartContractService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(SmartContractService.prototype.createContract = function createContract(request, callback) {
          return this.rpcCall(createContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createContract" });
        Object.defineProperty(SmartContractService.prototype.updateContract = function updateContract(request, callback) {
          return this.rpcCall(updateContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateContract" });
        Object.defineProperty(SmartContractService.prototype.contractCallMethod = function contractCallMethod(request, callback) {
          return this.rpcCall(contractCallMethod, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "contractCallMethod" });
        Object.defineProperty(SmartContractService.prototype.contractCallLocalMethod = function contractCallLocalMethod(request, callback) {
          return this.rpcCall(contractCallLocalMethod, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "contractCallLocalMethod" });
        Object.defineProperty(SmartContractService.prototype.getContractInfo = function getContractInfo(request, callback) {
          return this.rpcCall(getContractInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getContractInfo" });
        Object.defineProperty(SmartContractService.prototype.contractGetBytecode = function contractGetBytecode(request, callback) {
          return this.rpcCall(contractGetBytecode, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "ContractGetBytecode" });
        Object.defineProperty(SmartContractService.prototype.getBySolidityID = function getBySolidityID(request, callback) {
          return this.rpcCall(getBySolidityID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getBySolidityID" });
        Object.defineProperty(SmartContractService.prototype.getTxRecordByContractID = function getTxRecordByContractID(request, callback) {
          return this.rpcCall(getTxRecordByContractID, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTxRecordByContractID" });
        Object.defineProperty(SmartContractService.prototype.deleteContract = function deleteContract(request, callback) {
          return this.rpcCall(deleteContract, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteContract" });
        Object.defineProperty(SmartContractService.prototype.systemDelete = function systemDelete(request, callback) {
          return this.rpcCall(systemDelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemDelete" });
        Object.defineProperty(SmartContractService.prototype.systemUndelete = function systemUndelete(request, callback) {
          return this.rpcCall(systemUndelete, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "systemUndelete" });
        Object.defineProperty(SmartContractService.prototype.callEthereum = function callEthereum(request, callback) {
          return this.rpcCall(callEthereum, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "callEthereum" });
        return SmartContractService;
      })();
      proto37.ThrottleGroup = (function() {
        function ThrottleGroup(p3) {
          this.operations = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ThrottleGroup.prototype.operations = $util.emptyArray;
        ThrottleGroup.prototype.milliOpsPerSec = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        ThrottleGroup.create = function create(properties) {
          return new ThrottleGroup(properties);
        };
        ThrottleGroup.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.operations != null && m6.operations.length) {
            w5.uint32(10).fork();
            for (var i17 = 0; i17 < m6.operations.length; ++i17) w5.int32(m6.operations[i17]);
            w5.ldelim();
          }
          if (m6.milliOpsPerSec != null && Object.hasOwnProperty.call(m6, "milliOpsPerSec")) w5.uint32(16).uint64(m6.milliOpsPerSec);
          return w5;
        };
        ThrottleGroup.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ThrottleGroup();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.operations && m6.operations.length)) m6.operations = [];
                if ((t35 & 7) === 2) {
                  var c22 = r41.uint32() + r41.pos;
                  while (r41.pos < c22) m6.operations.push(r41.int32());
                } else m6.operations.push(r41.int32());
                break;
              }
              case 2: {
                m6.milliOpsPerSec = r41.uint64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ThrottleGroup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ThrottleGroup";
        };
        return ThrottleGroup;
      })();
      proto37.ThrottleBucket = (function() {
        function ThrottleBucket(p3) {
          this.throttleGroups = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ThrottleBucket.prototype.name = "";
        ThrottleBucket.prototype.burstPeriodMs = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        ThrottleBucket.prototype.throttleGroups = $util.emptyArray;
        ThrottleBucket.create = function create(properties) {
          return new ThrottleBucket(properties);
        };
        ThrottleBucket.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.name != null && Object.hasOwnProperty.call(m6, "name")) w5.uint32(10).string(m6.name);
          if (m6.burstPeriodMs != null && Object.hasOwnProperty.call(m6, "burstPeriodMs")) w5.uint32(16).uint64(m6.burstPeriodMs);
          if (m6.throttleGroups != null && m6.throttleGroups.length) {
            for (var i17 = 0; i17 < m6.throttleGroups.length; ++i17) $root.proto.ThrottleGroup.encode(m6.throttleGroups[i17], w5.uint32(26).fork()).ldelim();
          }
          return w5;
        };
        ThrottleBucket.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ThrottleBucket();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.name = r41.string();
                break;
              }
              case 2: {
                m6.burstPeriodMs = r41.uint64();
                break;
              }
              case 3: {
                if (!(m6.throttleGroups && m6.throttleGroups.length)) m6.throttleGroups = [];
                m6.throttleGroups.push($root.proto.ThrottleGroup.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ThrottleBucket.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ThrottleBucket";
        };
        return ThrottleBucket;
      })();
      proto37.ThrottleDefinitions = (function() {
        function ThrottleDefinitions(p3) {
          this.throttleBuckets = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ThrottleDefinitions.prototype.throttleBuckets = $util.emptyArray;
        ThrottleDefinitions.create = function create(properties) {
          return new ThrottleDefinitions(properties);
        };
        ThrottleDefinitions.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.throttleBuckets != null && m6.throttleBuckets.length) {
            for (var i17 = 0; i17 < m6.throttleBuckets.length; ++i17) $root.proto.ThrottleBucket.encode(m6.throttleBuckets[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        ThrottleDefinitions.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ThrottleDefinitions();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.throttleBuckets && m6.throttleBuckets.length)) m6.throttleBuckets = [];
                m6.throttleBuckets.push($root.proto.ThrottleBucket.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ThrottleDefinitions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ThrottleDefinitions";
        };
        return ThrottleDefinitions;
      })();
      proto37.TokenService = (function() {
        function TokenService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (TokenService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TokenService;
        TokenService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(TokenService.prototype.createToken = function createToken(request, callback) {
          return this.rpcCall(createToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "createToken" });
        Object.defineProperty(TokenService.prototype.updateToken = function updateToken(request, callback) {
          return this.rpcCall(updateToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateToken" });
        Object.defineProperty(TokenService.prototype.mintToken = function mintToken(request, callback) {
          return this.rpcCall(mintToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "mintToken" });
        Object.defineProperty(TokenService.prototype.burnToken = function burnToken(request, callback) {
          return this.rpcCall(burnToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "burnToken" });
        Object.defineProperty(TokenService.prototype.deleteToken = function deleteToken(request, callback) {
          return this.rpcCall(deleteToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "deleteToken" });
        Object.defineProperty(TokenService.prototype.wipeTokenAccount = function wipeTokenAccount(request, callback) {
          return this.rpcCall(wipeTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "wipeTokenAccount" });
        Object.defineProperty(TokenService.prototype.freezeTokenAccount = function freezeTokenAccount(request, callback) {
          return this.rpcCall(freezeTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "freezeTokenAccount" });
        Object.defineProperty(TokenService.prototype.unfreezeTokenAccount = function unfreezeTokenAccount(request, callback) {
          return this.rpcCall(unfreezeTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "unfreezeTokenAccount" });
        Object.defineProperty(TokenService.prototype.grantKycToTokenAccount = function grantKycToTokenAccount(request, callback) {
          return this.rpcCall(grantKycToTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "grantKycToTokenAccount" });
        Object.defineProperty(TokenService.prototype.revokeKycFromTokenAccount = function revokeKycFromTokenAccount(request, callback) {
          return this.rpcCall(revokeKycFromTokenAccount, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "revokeKycFromTokenAccount" });
        Object.defineProperty(TokenService.prototype.associateTokens = function associateTokens(request, callback) {
          return this.rpcCall(associateTokens, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "associateTokens" });
        Object.defineProperty(TokenService.prototype.dissociateTokens = function dissociateTokens(request, callback) {
          return this.rpcCall(dissociateTokens, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "dissociateTokens" });
        Object.defineProperty(TokenService.prototype.updateTokenFeeSchedule = function updateTokenFeeSchedule(request, callback) {
          return this.rpcCall(updateTokenFeeSchedule, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateTokenFeeSchedule" });
        Object.defineProperty(TokenService.prototype.getTokenInfo = function getTokenInfo(request, callback) {
          return this.rpcCall(getTokenInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTokenInfo" });
        Object.defineProperty(TokenService.prototype.getTokenNftInfo = function getTokenNftInfo(request, callback) {
          return this.rpcCall(getTokenNftInfo, $root.proto.Query, $root.proto.Response, request, callback);
        }, "name", { value: "getTokenNftInfo" });
        Object.defineProperty(TokenService.prototype.pauseToken = function pauseToken(request, callback) {
          return this.rpcCall(pauseToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "pauseToken" });
        Object.defineProperty(TokenService.prototype.unpauseToken = function unpauseToken(request, callback) {
          return this.rpcCall(unpauseToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "unpauseToken" });
        Object.defineProperty(TokenService.prototype.updateNfts = function updateNfts(request, callback) {
          return this.rpcCall(updateNfts, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "updateNfts" });
        Object.defineProperty(TokenService.prototype.rejectToken = function rejectToken(request, callback) {
          return this.rpcCall(rejectToken, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "rejectToken" });
        Object.defineProperty(TokenService.prototype.airdropTokens = function airdropTokens(request, callback) {
          return this.rpcCall(airdropTokens, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "airdropTokens" });
        Object.defineProperty(TokenService.prototype.cancelAirdrop = function cancelAirdrop(request, callback) {
          return this.rpcCall(cancelAirdrop, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "cancelAirdrop" });
        Object.defineProperty(TokenService.prototype.claimAirdrop = function claimAirdrop(request, callback) {
          return this.rpcCall(claimAirdrop, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "claimAirdrop" });
        return TokenService;
      })();
      proto37.SignedTransaction = (function() {
        function SignedTransaction(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SignedTransaction.prototype.bodyBytes = $util.newBuffer([]);
        SignedTransaction.prototype.sigMap = null;
        SignedTransaction.create = function create(properties) {
          return new SignedTransaction(properties);
        };
        SignedTransaction.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.bodyBytes != null && Object.hasOwnProperty.call(m6, "bodyBytes")) w5.uint32(10).bytes(m6.bodyBytes);
          if (m6.sigMap != null && Object.hasOwnProperty.call(m6, "sigMap")) $root.proto.SignatureMap.encode(m6.sigMap, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        SignedTransaction.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SignedTransaction();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.bodyBytes = r41.bytes();
                break;
              }
              case 2: {
                m6.sigMap = $root.proto.SignatureMap.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SignedTransaction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SignedTransaction";
        };
        return SignedTransaction;
      })();
      proto37.UtilService = (function() {
        function UtilService(rpcImpl, requestDelimited, responseDelimited) {
          $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }
        (UtilService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = UtilService;
        UtilService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
          return new this(rpcImpl, requestDelimited, responseDelimited);
        };
        Object.defineProperty(UtilService.prototype.prng = function prng(request, callback) {
          return this.rpcCall(prng, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "prng" });
        Object.defineProperty(UtilService.prototype.atomicBatch = function atomicBatch(request, callback) {
          return this.rpcCall(atomicBatch, $root.proto.Transaction, $root.proto.TransactionResponse, request, callback);
        }, "name", { value: "atomicBatch" });
        return UtilService;
      })();
      proto37.TokenUnitBalance = (function() {
        function TokenUnitBalance(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TokenUnitBalance.prototype.tokenId = null;
        TokenUnitBalance.prototype.balance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TokenUnitBalance.create = function create(properties) {
          return new TokenUnitBalance(properties);
        };
        TokenUnitBalance.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.tokenId != null && Object.hasOwnProperty.call(m6, "tokenId")) $root.proto.TokenID.encode(m6.tokenId, w5.uint32(10).fork()).ldelim();
          if (m6.balance != null && Object.hasOwnProperty.call(m6, "balance")) w5.uint32(16).uint64(m6.balance);
          return w5;
        };
        TokenUnitBalance.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TokenUnitBalance();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.tokenId = $root.proto.TokenID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.balance = r41.uint64();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TokenUnitBalance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TokenUnitBalance";
        };
        return TokenUnitBalance;
      })();
      proto37.SingleAccountBalances = (function() {
        function SingleAccountBalances(p3) {
          this.tokenUnitBalances = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SingleAccountBalances.prototype.accountID = null;
        SingleAccountBalances.prototype.hbarBalance = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        SingleAccountBalances.prototype.tokenUnitBalances = $util.emptyArray;
        SingleAccountBalances.create = function create(properties) {
          return new SingleAccountBalances(properties);
        };
        SingleAccountBalances.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.accountID != null && Object.hasOwnProperty.call(m6, "accountID")) $root.proto.AccountID.encode(m6.accountID, w5.uint32(10).fork()).ldelim();
          if (m6.hbarBalance != null && Object.hasOwnProperty.call(m6, "hbarBalance")) w5.uint32(16).uint64(m6.hbarBalance);
          if (m6.tokenUnitBalances != null && m6.tokenUnitBalances.length) {
            for (var i17 = 0; i17 < m6.tokenUnitBalances.length; ++i17) $root.proto.TokenUnitBalance.encode(m6.tokenUnitBalances[i17], w5.uint32(26).fork()).ldelim();
          }
          return w5;
        };
        SingleAccountBalances.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SingleAccountBalances();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.accountID = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.hbarBalance = r41.uint64();
                break;
              }
              case 3: {
                if (!(m6.tokenUnitBalances && m6.tokenUnitBalances.length)) m6.tokenUnitBalances = [];
                m6.tokenUnitBalances.push($root.proto.TokenUnitBalance.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SingleAccountBalances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SingleAccountBalances";
        };
        return SingleAccountBalances;
      })();
      proto37.AllAccountBalances = (function() {
        function AllAccountBalances(p3) {
          this.allAccounts = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        AllAccountBalances.prototype.consensusTimestamp = null;
        AllAccountBalances.prototype.allAccounts = $util.emptyArray;
        AllAccountBalances.create = function create(properties) {
          return new AllAccountBalances(properties);
        };
        AllAccountBalances.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.consensusTimestamp != null && Object.hasOwnProperty.call(m6, "consensusTimestamp")) $root.proto.Timestamp.encode(m6.consensusTimestamp, w5.uint32(10).fork()).ldelim();
          if (m6.allAccounts != null && m6.allAccounts.length) {
            for (var i17 = 0; i17 < m6.allAccounts.length; ++i17) $root.proto.SingleAccountBalances.encode(m6.allAccounts[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        AllAccountBalances.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.AllAccountBalances();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.consensusTimestamp = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.allAccounts && m6.allAccounts.length)) m6.allAccounts = [];
                m6.allAccounts.push($root.proto.SingleAccountBalances.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        AllAccountBalances.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.AllAccountBalances";
        };
        return AllAccountBalances;
      })();
      proto37.ContractActions = (function() {
        function ContractActions(p3) {
          this.contractActions = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractActions.prototype.contractActions = $util.emptyArray;
        ContractActions.create = function create(properties) {
          return new ContractActions(properties);
        };
        ContractActions.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractActions != null && m6.contractActions.length) {
            for (var i17 = 0; i17 < m6.contractActions.length; ++i17) $root.proto.ContractAction.encode(m6.contractActions[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        ContractActions.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractActions();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.contractActions && m6.contractActions.length)) m6.contractActions = [];
                m6.contractActions.push($root.proto.ContractAction.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractActions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractActions";
        };
        return ContractActions;
      })();
      proto37.ContractActionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_ACTION"] = 0;
        values[valuesById[1] = "CALL"] = 1;
        values[valuesById[2] = "CREATE"] = 2;
        values[valuesById[3] = "PRECOMPILE"] = 3;
        values[valuesById[4] = "SYSTEM"] = 4;
        return values;
      })();
      proto37.CallOperationType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OP_UNKNOWN"] = 0;
        values[valuesById[1] = "OP_CALL"] = 1;
        values[valuesById[2] = "OP_CALLCODE"] = 2;
        values[valuesById[3] = "OP_DELEGATECALL"] = 3;
        values[valuesById[4] = "OP_STATICCALL"] = 4;
        values[valuesById[5] = "OP_CREATE"] = 5;
        values[valuesById[6] = "OP_CREATE2"] = 6;
        return values;
      })();
      proto37.ContractAction = (function() {
        function ContractAction(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractAction.prototype.callType = 0;
        ContractAction.prototype.callingAccount = null;
        ContractAction.prototype.callingContract = null;
        ContractAction.prototype.gas = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractAction.prototype.input = $util.newBuffer([]);
        ContractAction.prototype.recipientAccount = null;
        ContractAction.prototype.recipientContract = null;
        ContractAction.prototype.targetedAddress = null;
        ContractAction.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractAction.prototype.gasUsed = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ContractAction.prototype.output = null;
        ContractAction.prototype.revertReason = null;
        ContractAction.prototype.error = null;
        ContractAction.prototype.callDepth = 0;
        ContractAction.prototype.callOperationType = 0;
        let $oneOfFields;
        Object.defineProperty(ContractAction.prototype, "caller", { get: $util.oneOfGetter($oneOfFields = ["callingAccount", "callingContract"]), set: $util.oneOfSetter($oneOfFields) });
        Object.defineProperty(ContractAction.prototype, "recipient", { get: $util.oneOfGetter($oneOfFields = ["recipientAccount", "recipientContract", "targetedAddress"]), set: $util.oneOfSetter($oneOfFields) });
        Object.defineProperty(ContractAction.prototype, "resultData", { get: $util.oneOfGetter($oneOfFields = ["output", "revertReason", "error"]), set: $util.oneOfSetter($oneOfFields) });
        ContractAction.create = function create(properties) {
          return new ContractAction(properties);
        };
        ContractAction.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.callType != null && Object.hasOwnProperty.call(m6, "callType")) w5.uint32(8).int32(m6.callType);
          if (m6.callingAccount != null && Object.hasOwnProperty.call(m6, "callingAccount")) $root.proto.AccountID.encode(m6.callingAccount, w5.uint32(18).fork()).ldelim();
          if (m6.callingContract != null && Object.hasOwnProperty.call(m6, "callingContract")) $root.proto.ContractID.encode(m6.callingContract, w5.uint32(26).fork()).ldelim();
          if (m6.gas != null && Object.hasOwnProperty.call(m6, "gas")) w5.uint32(32).int64(m6.gas);
          if (m6.input != null && Object.hasOwnProperty.call(m6, "input")) w5.uint32(42).bytes(m6.input);
          if (m6.recipientAccount != null && Object.hasOwnProperty.call(m6, "recipientAccount")) $root.proto.AccountID.encode(m6.recipientAccount, w5.uint32(50).fork()).ldelim();
          if (m6.recipientContract != null && Object.hasOwnProperty.call(m6, "recipientContract")) $root.proto.ContractID.encode(m6.recipientContract, w5.uint32(58).fork()).ldelim();
          if (m6.targetedAddress != null && Object.hasOwnProperty.call(m6, "targetedAddress")) w5.uint32(66).bytes(m6.targetedAddress);
          if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(72).int64(m6.value);
          if (m6.gasUsed != null && Object.hasOwnProperty.call(m6, "gasUsed")) w5.uint32(80).int64(m6.gasUsed);
          if (m6.output != null && Object.hasOwnProperty.call(m6, "output")) w5.uint32(90).bytes(m6.output);
          if (m6.revertReason != null && Object.hasOwnProperty.call(m6, "revertReason")) w5.uint32(98).bytes(m6.revertReason);
          if (m6.error != null && Object.hasOwnProperty.call(m6, "error")) w5.uint32(106).bytes(m6.error);
          if (m6.callDepth != null && Object.hasOwnProperty.call(m6, "callDepth")) w5.uint32(112).int32(m6.callDepth);
          if (m6.callOperationType != null && Object.hasOwnProperty.call(m6, "callOperationType")) w5.uint32(120).int32(m6.callOperationType);
          return w5;
        };
        ContractAction.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractAction();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.callType = r41.int32();
                break;
              }
              case 2: {
                m6.callingAccount = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                m6.callingContract = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.gas = r41.int64();
                break;
              }
              case 5: {
                m6.input = r41.bytes();
                break;
              }
              case 6: {
                m6.recipientAccount = $root.proto.AccountID.decode(r41, r41.uint32());
                break;
              }
              case 7: {
                m6.recipientContract = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 8: {
                m6.targetedAddress = r41.bytes();
                break;
              }
              case 9: {
                m6.value = r41.int64();
                break;
              }
              case 10: {
                m6.gasUsed = r41.int64();
                break;
              }
              case 11: {
                m6.output = r41.bytes();
                break;
              }
              case 12: {
                m6.revertReason = r41.bytes();
                break;
              }
              case 13: {
                m6.error = r41.bytes();
                break;
              }
              case 14: {
                m6.callDepth = r41.int32();
                break;
              }
              case 15: {
                m6.callOperationType = r41.int32();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractAction";
        };
        return ContractAction;
      })();
      proto37.ContractBytecode = (function() {
        function ContractBytecode(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractBytecode.prototype.contractId = null;
        ContractBytecode.prototype.initcode = $util.newBuffer([]);
        ContractBytecode.prototype.runtimeBytecode = $util.newBuffer([]);
        ContractBytecode.create = function create(properties) {
          return new ContractBytecode(properties);
        };
        ContractBytecode.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractId != null && Object.hasOwnProperty.call(m6, "contractId")) $root.proto.ContractID.encode(m6.contractId, w5.uint32(10).fork()).ldelim();
          if (m6.initcode != null && Object.hasOwnProperty.call(m6, "initcode")) w5.uint32(18).bytes(m6.initcode);
          if (m6.runtimeBytecode != null && Object.hasOwnProperty.call(m6, "runtimeBytecode")) w5.uint32(26).bytes(m6.runtimeBytecode);
          return w5;
        };
        ContractBytecode.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractBytecode();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contractId = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.initcode = r41.bytes();
                break;
              }
              case 3: {
                m6.runtimeBytecode = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractBytecode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractBytecode";
        };
        return ContractBytecode;
      })();
      proto37.ContractStateChanges = (function() {
        function ContractStateChanges(p3) {
          this.contractStateChanges = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractStateChanges.prototype.contractStateChanges = $util.emptyArray;
        ContractStateChanges.create = function create(properties) {
          return new ContractStateChanges(properties);
        };
        ContractStateChanges.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractStateChanges != null && m6.contractStateChanges.length) {
            for (var i17 = 0; i17 < m6.contractStateChanges.length; ++i17) $root.proto.ContractStateChange.encode(m6.contractStateChanges[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        ContractStateChanges.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractStateChanges();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.contractStateChanges && m6.contractStateChanges.length)) m6.contractStateChanges = [];
                m6.contractStateChanges.push($root.proto.ContractStateChange.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractStateChanges.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractStateChanges";
        };
        return ContractStateChanges;
      })();
      proto37.ContractStateChange = (function() {
        function ContractStateChange(p3) {
          this.storageChanges = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        ContractStateChange.prototype.contractId = null;
        ContractStateChange.prototype.storageChanges = $util.emptyArray;
        ContractStateChange.create = function create(properties) {
          return new ContractStateChange(properties);
        };
        ContractStateChange.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.contractId != null && Object.hasOwnProperty.call(m6, "contractId")) $root.proto.ContractID.encode(m6.contractId, w5.uint32(10).fork()).ldelim();
          if (m6.storageChanges != null && m6.storageChanges.length) {
            for (var i17 = 0; i17 < m6.storageChanges.length; ++i17) $root.proto.StorageChange.encode(m6.storageChanges[i17], w5.uint32(18).fork()).ldelim();
          }
          return w5;
        };
        ContractStateChange.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.ContractStateChange();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.contractId = $root.proto.ContractID.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                if (!(m6.storageChanges && m6.storageChanges.length)) m6.storageChanges = [];
                m6.storageChanges.push($root.proto.StorageChange.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        ContractStateChange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.ContractStateChange";
        };
        return ContractStateChange;
      })();
      proto37.StorageChange = (function() {
        function StorageChange(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        StorageChange.prototype.slot = $util.newBuffer([]);
        StorageChange.prototype.valueRead = $util.newBuffer([]);
        StorageChange.prototype.valueWritten = null;
        StorageChange.create = function create(properties) {
          return new StorageChange(properties);
        };
        StorageChange.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.slot != null && Object.hasOwnProperty.call(m6, "slot")) w5.uint32(10).bytes(m6.slot);
          if (m6.valueRead != null && Object.hasOwnProperty.call(m6, "valueRead")) w5.uint32(18).bytes(m6.valueRead);
          if (m6.valueWritten != null && Object.hasOwnProperty.call(m6, "valueWritten")) $root.google.protobuf.BytesValue.encode(m6.valueWritten, w5.uint32(26).fork()).ldelim();
          return w5;
        };
        StorageChange.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.StorageChange();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.slot = r41.bytes();
                break;
              }
              case 2: {
                m6.valueRead = r41.bytes();
                break;
              }
              case 3: {
                m6.valueWritten = $root.google.protobuf.BytesValue.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        StorageChange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.StorageChange";
        };
        return StorageChange;
      })();
      proto37.HashAlgorithm = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "HASH_ALGORITHM_UNKNOWN"] = 0;
        values[valuesById[1] = "SHA_384"] = 1;
        return values;
      })();
      proto37.HashObject = (function() {
        function HashObject(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        HashObject.prototype.algorithm = 0;
        HashObject.prototype.length = 0;
        HashObject.prototype.hash = $util.newBuffer([]);
        HashObject.create = function create(properties) {
          return new HashObject(properties);
        };
        HashObject.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.algorithm != null && Object.hasOwnProperty.call(m6, "algorithm")) w5.uint32(8).int32(m6.algorithm);
          if (m6.length != null && Object.hasOwnProperty.call(m6, "length")) w5.uint32(16).int32(m6.length);
          if (m6.hash != null && Object.hasOwnProperty.call(m6, "hash")) w5.uint32(26).bytes(m6.hash);
          return w5;
        };
        HashObject.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.HashObject();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.algorithm = r41.int32();
                break;
              }
              case 2: {
                m6.length = r41.int32();
                break;
              }
              case 3: {
                m6.hash = r41.bytes();
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        HashObject.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.HashObject";
        };
        return HashObject;
      })();
      proto37.RecordStreamFile = (function() {
        function RecordStreamFile(p3) {
          this.recordStreamItems = [];
          this.sidecars = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        RecordStreamFile.prototype.hapiProtoVersion = null;
        RecordStreamFile.prototype.startObjectRunningHash = null;
        RecordStreamFile.prototype.recordStreamItems = $util.emptyArray;
        RecordStreamFile.prototype.endObjectRunningHash = null;
        RecordStreamFile.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        RecordStreamFile.prototype.sidecars = $util.emptyArray;
        RecordStreamFile.create = function create(properties) {
          return new RecordStreamFile(properties);
        };
        RecordStreamFile.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.hapiProtoVersion != null && Object.hasOwnProperty.call(m6, "hapiProtoVersion")) $root.proto.SemanticVersion.encode(m6.hapiProtoVersion, w5.uint32(10).fork()).ldelim();
          if (m6.startObjectRunningHash != null && Object.hasOwnProperty.call(m6, "startObjectRunningHash")) $root.proto.HashObject.encode(m6.startObjectRunningHash, w5.uint32(18).fork()).ldelim();
          if (m6.recordStreamItems != null && m6.recordStreamItems.length) {
            for (var i17 = 0; i17 < m6.recordStreamItems.length; ++i17) $root.proto.RecordStreamItem.encode(m6.recordStreamItems[i17], w5.uint32(26).fork()).ldelim();
          }
          if (m6.endObjectRunningHash != null && Object.hasOwnProperty.call(m6, "endObjectRunningHash")) $root.proto.HashObject.encode(m6.endObjectRunningHash, w5.uint32(34).fork()).ldelim();
          if (m6.blockNumber != null && Object.hasOwnProperty.call(m6, "blockNumber")) w5.uint32(40).int64(m6.blockNumber);
          if (m6.sidecars != null && m6.sidecars.length) {
            for (var i17 = 0; i17 < m6.sidecars.length; ++i17) $root.proto.SidecarMetadata.encode(m6.sidecars[i17], w5.uint32(50).fork()).ldelim();
          }
          return w5;
        };
        RecordStreamFile.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.RecordStreamFile();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.hapiProtoVersion = $root.proto.SemanticVersion.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.startObjectRunningHash = $root.proto.HashObject.decode(r41, r41.uint32());
                break;
              }
              case 3: {
                if (!(m6.recordStreamItems && m6.recordStreamItems.length)) m6.recordStreamItems = [];
                m6.recordStreamItems.push($root.proto.RecordStreamItem.decode(r41, r41.uint32()));
                break;
              }
              case 4: {
                m6.endObjectRunningHash = $root.proto.HashObject.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.blockNumber = r41.int64();
                break;
              }
              case 6: {
                if (!(m6.sidecars && m6.sidecars.length)) m6.sidecars = [];
                m6.sidecars.push($root.proto.SidecarMetadata.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        RecordStreamFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.RecordStreamFile";
        };
        return RecordStreamFile;
      })();
      proto37.RecordStreamItem = (function() {
        function RecordStreamItem(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        RecordStreamItem.prototype.transaction = null;
        RecordStreamItem.prototype.record = null;
        RecordStreamItem.create = function create(properties) {
          return new RecordStreamItem(properties);
        };
        RecordStreamItem.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.transaction != null && Object.hasOwnProperty.call(m6, "transaction")) $root.proto.Transaction.encode(m6.transaction, w5.uint32(10).fork()).ldelim();
          if (m6.record != null && Object.hasOwnProperty.call(m6, "record")) $root.proto.TransactionRecord.encode(m6.record, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        RecordStreamItem.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.RecordStreamItem();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.transaction = $root.proto.Transaction.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.record = $root.proto.TransactionRecord.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        RecordStreamItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.RecordStreamItem";
        };
        return RecordStreamItem;
      })();
      proto37.SidecarMetadata = (function() {
        function SidecarMetadata(p3) {
          this.types = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SidecarMetadata.prototype.hash = null;
        SidecarMetadata.prototype.id = 0;
        SidecarMetadata.prototype.types = $util.emptyArray;
        SidecarMetadata.create = function create(properties) {
          return new SidecarMetadata(properties);
        };
        SidecarMetadata.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.hash != null && Object.hasOwnProperty.call(m6, "hash")) $root.proto.HashObject.encode(m6.hash, w5.uint32(10).fork()).ldelim();
          if (m6.id != null && Object.hasOwnProperty.call(m6, "id")) w5.uint32(16).int32(m6.id);
          if (m6.types != null && m6.types.length) {
            w5.uint32(26).fork();
            for (var i17 = 0; i17 < m6.types.length; ++i17) w5.int32(m6.types[i17]);
            w5.ldelim();
          }
          return w5;
        };
        SidecarMetadata.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SidecarMetadata();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.hash = $root.proto.HashObject.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.id = r41.int32();
                break;
              }
              case 3: {
                if (!(m6.types && m6.types.length)) m6.types = [];
                if ((t35 & 7) === 2) {
                  var c22 = r41.uint32() + r41.pos;
                  while (r41.pos < c22) m6.types.push(r41.int32());
                } else m6.types.push(r41.int32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SidecarMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SidecarMetadata";
        };
        return SidecarMetadata;
      })();
      proto37.SidecarType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIDECAR_TYPE_UNKNOWN"] = 0;
        values[valuesById[1] = "CONTRACT_STATE_CHANGE"] = 1;
        values[valuesById[2] = "CONTRACT_ACTION"] = 2;
        values[valuesById[3] = "CONTRACT_BYTECODE"] = 3;
        return values;
      })();
      proto37.SidecarFile = (function() {
        function SidecarFile(p3) {
          this.sidecarRecords = [];
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SidecarFile.prototype.sidecarRecords = $util.emptyArray;
        SidecarFile.create = function create(properties) {
          return new SidecarFile(properties);
        };
        SidecarFile.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.sidecarRecords != null && m6.sidecarRecords.length) {
            for (var i17 = 0; i17 < m6.sidecarRecords.length; ++i17) $root.proto.TransactionSidecarRecord.encode(m6.sidecarRecords[i17], w5.uint32(10).fork()).ldelim();
          }
          return w5;
        };
        SidecarFile.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SidecarFile();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                if (!(m6.sidecarRecords && m6.sidecarRecords.length)) m6.sidecarRecords = [];
                m6.sidecarRecords.push($root.proto.TransactionSidecarRecord.decode(r41, r41.uint32()));
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SidecarFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SidecarFile";
        };
        return SidecarFile;
      })();
      proto37.TransactionSidecarRecord = (function() {
        function TransactionSidecarRecord(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        TransactionSidecarRecord.prototype.consensusTimestamp = null;
        TransactionSidecarRecord.prototype.migration = false;
        TransactionSidecarRecord.prototype.stateChanges = null;
        TransactionSidecarRecord.prototype.actions = null;
        TransactionSidecarRecord.prototype.bytecode = null;
        let $oneOfFields;
        Object.defineProperty(TransactionSidecarRecord.prototype, "sidecarRecords", { get: $util.oneOfGetter($oneOfFields = ["stateChanges", "actions", "bytecode"]), set: $util.oneOfSetter($oneOfFields) });
        TransactionSidecarRecord.create = function create(properties) {
          return new TransactionSidecarRecord(properties);
        };
        TransactionSidecarRecord.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.consensusTimestamp != null && Object.hasOwnProperty.call(m6, "consensusTimestamp")) $root.proto.Timestamp.encode(m6.consensusTimestamp, w5.uint32(10).fork()).ldelim();
          if (m6.migration != null && Object.hasOwnProperty.call(m6, "migration")) w5.uint32(16).bool(m6.migration);
          if (m6.stateChanges != null && Object.hasOwnProperty.call(m6, "stateChanges")) $root.proto.ContractStateChanges.encode(m6.stateChanges, w5.uint32(26).fork()).ldelim();
          if (m6.actions != null && Object.hasOwnProperty.call(m6, "actions")) $root.proto.ContractActions.encode(m6.actions, w5.uint32(34).fork()).ldelim();
          if (m6.bytecode != null && Object.hasOwnProperty.call(m6, "bytecode")) $root.proto.ContractBytecode.encode(m6.bytecode, w5.uint32(42).fork()).ldelim();
          return w5;
        };
        TransactionSidecarRecord.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.TransactionSidecarRecord();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.consensusTimestamp = $root.proto.Timestamp.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.migration = r41.bool();
                break;
              }
              case 3: {
                m6.stateChanges = $root.proto.ContractStateChanges.decode(r41, r41.uint32());
                break;
              }
              case 4: {
                m6.actions = $root.proto.ContractActions.decode(r41, r41.uint32());
                break;
              }
              case 5: {
                m6.bytecode = $root.proto.ContractBytecode.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        TransactionSidecarRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.TransactionSidecarRecord";
        };
        return TransactionSidecarRecord;
      })();
      proto37.SignatureFile = (function() {
        function SignatureFile(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SignatureFile.prototype.fileSignature = null;
        SignatureFile.prototype.metadataSignature = null;
        SignatureFile.create = function create(properties) {
          return new SignatureFile(properties);
        };
        SignatureFile.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.fileSignature != null && Object.hasOwnProperty.call(m6, "fileSignature")) $root.proto.SignatureObject.encode(m6.fileSignature, w5.uint32(10).fork()).ldelim();
          if (m6.metadataSignature != null && Object.hasOwnProperty.call(m6, "metadataSignature")) $root.proto.SignatureObject.encode(m6.metadataSignature, w5.uint32(18).fork()).ldelim();
          return w5;
        };
        SignatureFile.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SignatureFile();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.fileSignature = $root.proto.SignatureObject.decode(r41, r41.uint32());
                break;
              }
              case 2: {
                m6.metadataSignature = $root.proto.SignatureObject.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SignatureFile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SignatureFile";
        };
        return SignatureFile;
      })();
      proto37.SignatureObject = (function() {
        function SignatureObject(p3) {
          if (p3) {
            for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
          }
        }
        SignatureObject.prototype.type = 0;
        SignatureObject.prototype.length = 0;
        SignatureObject.prototype.checksum = 0;
        SignatureObject.prototype.signature = $util.newBuffer([]);
        SignatureObject.prototype.hashObject = null;
        SignatureObject.create = function create(properties) {
          return new SignatureObject(properties);
        };
        SignatureObject.encode = function encode5(m6, w5) {
          if (!w5) w5 = $Writer.create();
          if (m6.type != null && Object.hasOwnProperty.call(m6, "type")) w5.uint32(8).int32(m6.type);
          if (m6.length != null && Object.hasOwnProperty.call(m6, "length")) w5.uint32(16).int32(m6.length);
          if (m6.checksum != null && Object.hasOwnProperty.call(m6, "checksum")) w5.uint32(24).int32(m6.checksum);
          if (m6.signature != null && Object.hasOwnProperty.call(m6, "signature")) w5.uint32(34).bytes(m6.signature);
          if (m6.hashObject != null && Object.hasOwnProperty.call(m6, "hashObject")) $root.proto.HashObject.encode(m6.hashObject, w5.uint32(42).fork()).ldelim();
          return w5;
        };
        SignatureObject.decode = function decode7(r41, l19) {
          if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
          var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.proto.SignatureObject();
          while (r41.pos < c17) {
            var t35 = r41.uint32();
            switch (t35 >>> 3) {
              case 1: {
                m6.type = r41.int32();
                break;
              }
              case 2: {
                m6.length = r41.int32();
                break;
              }
              case 3: {
                m6.checksum = r41.int32();
                break;
              }
              case 4: {
                m6.signature = r41.bytes();
                break;
              }
              case 5: {
                m6.hashObject = $root.proto.HashObject.decode(r41, r41.uint32());
                break;
              }
              default:
                r41.skipType(t35 & 7);
                break;
            }
          }
          return m6;
        };
        SignatureObject.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/proto.SignatureObject";
        };
        return SignatureObject;
      })();
      proto37.SignatureType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIGNATURE_TYPE_UNKNOWN"] = 0;
        values[valuesById[1] = "SHA_384_WITH_RSA"] = 1;
        return values;
      })();
      return proto37;
    })();
    exports2.proto = proto36;
    var google = $root.google = (() => {
      const google2 = {};
      google2.protobuf = (function() {
        const protobuf = {};
        protobuf.DoubleValue = (function() {
          function DoubleValue(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          DoubleValue.prototype.value = 0;
          DoubleValue.create = function create(properties) {
            return new DoubleValue(properties);
          };
          DoubleValue.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(9).double(m6.value);
            return w5;
          };
          DoubleValue.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.google.protobuf.DoubleValue();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.value = r41.double();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          DoubleValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.DoubleValue";
          };
          return DoubleValue;
        })();
        protobuf.FloatValue = (function() {
          function FloatValue(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          FloatValue.prototype.value = 0;
          FloatValue.create = function create(properties) {
            return new FloatValue(properties);
          };
          FloatValue.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(13).float(m6.value);
            return w5;
          };
          FloatValue.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.google.protobuf.FloatValue();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.value = r41.float();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          FloatValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.FloatValue";
          };
          return FloatValue;
        })();
        protobuf.Int64Value = (function() {
          function Int64Value(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Int64Value.create = function create(properties) {
            return new Int64Value(properties);
          };
          Int64Value.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(8).int64(m6.value);
            return w5;
          };
          Int64Value.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.google.protobuf.Int64Value();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.value = r41.int64();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          Int64Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.Int64Value";
          };
          return Int64Value;
        })();
        protobuf.UInt64Value = (function() {
          function UInt64Value(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          UInt64Value.create = function create(properties) {
            return new UInt64Value(properties);
          };
          UInt64Value.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(8).uint64(m6.value);
            return w5;
          };
          UInt64Value.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.google.protobuf.UInt64Value();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.value = r41.uint64();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          UInt64Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.UInt64Value";
          };
          return UInt64Value;
        })();
        protobuf.Int32Value = (function() {
          function Int32Value(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          Int32Value.prototype.value = 0;
          Int32Value.create = function create(properties) {
            return new Int32Value(properties);
          };
          Int32Value.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(8).int32(m6.value);
            return w5;
          };
          Int32Value.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.google.protobuf.Int32Value();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.value = r41.int32();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          Int32Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.Int32Value";
          };
          return Int32Value;
        })();
        protobuf.UInt32Value = (function() {
          function UInt32Value(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          UInt32Value.prototype.value = 0;
          UInt32Value.create = function create(properties) {
            return new UInt32Value(properties);
          };
          UInt32Value.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(8).uint32(m6.value);
            return w5;
          };
          UInt32Value.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.google.protobuf.UInt32Value();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.value = r41.uint32();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          UInt32Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.UInt32Value";
          };
          return UInt32Value;
        })();
        protobuf.BoolValue = (function() {
          function BoolValue(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          BoolValue.prototype.value = false;
          BoolValue.create = function create(properties) {
            return new BoolValue(properties);
          };
          BoolValue.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(8).bool(m6.value);
            return w5;
          };
          BoolValue.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.google.protobuf.BoolValue();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.value = r41.bool();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          BoolValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.BoolValue";
          };
          return BoolValue;
        })();
        protobuf.StringValue = (function() {
          function StringValue(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          StringValue.prototype.value = "";
          StringValue.create = function create(properties) {
            return new StringValue(properties);
          };
          StringValue.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(10).string(m6.value);
            return w5;
          };
          StringValue.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.google.protobuf.StringValue();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.value = r41.string();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          StringValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.StringValue";
          };
          return StringValue;
        })();
        protobuf.BytesValue = (function() {
          function BytesValue(p3) {
            if (p3) {
              for (var ks = Object.keys(p3), i17 = 0; i17 < ks.length; ++i17) if (p3[ks[i17]] != null) this[ks[i17]] = p3[ks[i17]];
            }
          }
          BytesValue.prototype.value = $util.newBuffer([]);
          BytesValue.create = function create(properties) {
            return new BytesValue(properties);
          };
          BytesValue.encode = function encode5(m6, w5) {
            if (!w5) w5 = $Writer.create();
            if (m6.value != null && Object.hasOwnProperty.call(m6, "value")) w5.uint32(10).bytes(m6.value);
            return w5;
          };
          BytesValue.decode = function decode7(r41, l19) {
            if (!(r41 instanceof $Reader)) r41 = $Reader.create(r41);
            var c17 = l19 === void 0 ? r41.len : r41.pos + l19, m6 = new $root.google.protobuf.BytesValue();
            while (r41.pos < c17) {
              var t35 = r41.uint32();
              switch (t35 >>> 3) {
                case 1: {
                  m6.value = r41.bytes();
                  break;
                }
                default:
                  r41.skipType(t35 & 7);
                  break;
              }
            }
            return m6;
          };
          BytesValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/google.protobuf.BytesValue";
          };
          return BytesValue;
        })();
        return protobuf;
      })();
      return google2;
    })();
    exports2.google = google;
  }
});

// node_modules/@hashgraph/proto/lib/index.js
var require_lib = __commonJS({
  "node_modules/@hashgraph/proto/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.proto = exports2.google = exports2.com = exports2.Writer = exports2.Reader = void 0;
    var $protobuf = _interopRequireWildcard(require_minimal2());
    var _long = _interopRequireDefault(require_umd());
    var $proto = _interopRequireWildcard(require_proto());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(e39) {
      if ("function" != typeof WeakMap) return null;
      var r41 = /* @__PURE__ */ new WeakMap(), t35 = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e40) {
        return e40 ? t35 : r41;
      })(e39);
    }
    function _interopRequireWildcard(e39, r41) {
      if (!r41 && e39 && e39.__esModule) return e39;
      if (null === e39 || "object" != typeof e39 && "function" != typeof e39) return { default: e39 };
      var t35 = _getRequireWildcardCache(r41);
      if (t35 && t35.has(e39)) return t35.get(e39);
      var n31 = { __proto__: null }, a23 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u22 in e39) if ("default" !== u22 && Object.prototype.hasOwnProperty.call(e39, u22)) {
        var i17 = a23 ? Object.getOwnPropertyDescriptor(e39, u22) : null;
        i17 && (i17.get || i17.set) ? Object.defineProperty(n31, u22, i17) : n31[u22] = e39[u22];
      }
      return n31.default = e39, t35 && t35.set(e39, n31), n31;
    }
    (() => {
      var $util = $protobuf.util;
      if ($util.Long == null) {
        console.log(`Patching Protobuf Long.js instance...`);
        $util.Long = _long.default;
        if ($protobuf.Reader._configure != null) {
          $protobuf.Reader._configure($protobuf.BufferReader);
        }
      }
    })();
    var Reader2 = $protobuf.Reader;
    exports2.Reader = Reader2;
    var Writer2 = $protobuf.Writer;
    exports2.Writer = Writer2;
    var proto36 = $proto.proto;
    exports2.proto = proto36;
    var com2 = $proto.com;
    exports2.com = com2;
    var google = $proto.google;
    exports2.google = google;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_4, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    (function(nacl5) {
      "use strict";
      var gf = function(init) {
        var i17, r41 = new Float64Array(16);
        if (init) for (i17 = 0; i17 < init.length; i17++) r41[i17] = init[i17];
        return r41;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I3 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x2, i17, h8, l19) {
        x2[i17] = h8 >> 24 & 255;
        x2[i17 + 1] = h8 >> 16 & 255;
        x2[i17 + 2] = h8 >> 8 & 255;
        x2[i17 + 3] = h8 & 255;
        x2[i17 + 4] = l19 >> 24 & 255;
        x2[i17 + 5] = l19 >> 16 & 255;
        x2[i17 + 6] = l19 >> 8 & 255;
        x2[i17 + 7] = l19 & 255;
      }
      function vn(x2, xi, y5, yi, n31) {
        var i17, d18 = 0;
        for (i17 = 0; i17 < n31; i17++) d18 |= x2[xi + i17] ^ y5[yi + i17];
        return (1 & d18 - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x2, xi, y5, yi) {
        return vn(x2, xi, y5, yi, 16);
      }
      function crypto_verify_32(x2, xi, y5, yi) {
        return vn(x2, xi, y5, yi, 32);
      }
      function core_salsa20(o32, p3, k3, c17) {
        var j0 = c17[0] & 255 | (c17[1] & 255) << 8 | (c17[2] & 255) << 16 | (c17[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j2 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j3 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c17[4] & 255 | (c17[5] & 255) << 8 | (c17[6] & 255) << 16 | (c17[7] & 255) << 24, j6 = p3[0] & 255 | (p3[1] & 255) << 8 | (p3[2] & 255) << 16 | (p3[3] & 255) << 24, j7 = p3[4] & 255 | (p3[5] & 255) << 8 | (p3[6] & 255) << 16 | (p3[7] & 255) << 24, j8 = p3[8] & 255 | (p3[9] & 255) << 8 | (p3[10] & 255) << 16 | (p3[11] & 255) << 24, j9 = p3[12] & 255 | (p3[13] & 255) << 8 | (p3[14] & 255) << 16 | (p3[15] & 255) << 24, j10 = c17[8] & 255 | (c17[9] & 255) << 8 | (c17[10] & 255) << 16 | (c17[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c17[12] & 255 | (c17[13] & 255) << 8 | (c17[14] & 255) << 16 | (c17[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u22;
        for (var i17 = 0; i17 < 20; i17 += 2) {
          u22 = x0 + x12 | 0;
          x4 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x4 + x0 | 0;
          x8 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x8 + x4 | 0;
          x12 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x12 + x8 | 0;
          x0 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x5 + x1 | 0;
          x9 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x9 + x5 | 0;
          x13 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x13 + x9 | 0;
          x1 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x1 + x13 | 0;
          x5 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x10 + x6 | 0;
          x14 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x14 + x10 | 0;
          x2 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x2 + x14 | 0;
          x6 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x6 + x2 | 0;
          x10 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x15 + x11 | 0;
          x3 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x3 + x15 | 0;
          x7 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x7 + x3 | 0;
          x11 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x11 + x7 | 0;
          x15 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x0 + x3 | 0;
          x1 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x1 + x0 | 0;
          x2 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x2 + x1 | 0;
          x3 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x3 + x2 | 0;
          x0 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x5 + x4 | 0;
          x6 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x6 + x5 | 0;
          x7 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x7 + x6 | 0;
          x4 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x4 + x7 | 0;
          x5 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x10 + x9 | 0;
          x11 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x11 + x10 | 0;
          x8 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x8 + x11 | 0;
          x9 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x9 + x8 | 0;
          x10 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x15 + x14 | 0;
          x12 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x12 + x15 | 0;
          x13 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x13 + x12 | 0;
          x14 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x14 + x13 | 0;
          x15 ^= u22 << 18 | u22 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o32[0] = x0 >>> 0 & 255;
        o32[1] = x0 >>> 8 & 255;
        o32[2] = x0 >>> 16 & 255;
        o32[3] = x0 >>> 24 & 255;
        o32[4] = x1 >>> 0 & 255;
        o32[5] = x1 >>> 8 & 255;
        o32[6] = x1 >>> 16 & 255;
        o32[7] = x1 >>> 24 & 255;
        o32[8] = x2 >>> 0 & 255;
        o32[9] = x2 >>> 8 & 255;
        o32[10] = x2 >>> 16 & 255;
        o32[11] = x2 >>> 24 & 255;
        o32[12] = x3 >>> 0 & 255;
        o32[13] = x3 >>> 8 & 255;
        o32[14] = x3 >>> 16 & 255;
        o32[15] = x3 >>> 24 & 255;
        o32[16] = x4 >>> 0 & 255;
        o32[17] = x4 >>> 8 & 255;
        o32[18] = x4 >>> 16 & 255;
        o32[19] = x4 >>> 24 & 255;
        o32[20] = x5 >>> 0 & 255;
        o32[21] = x5 >>> 8 & 255;
        o32[22] = x5 >>> 16 & 255;
        o32[23] = x5 >>> 24 & 255;
        o32[24] = x6 >>> 0 & 255;
        o32[25] = x6 >>> 8 & 255;
        o32[26] = x6 >>> 16 & 255;
        o32[27] = x6 >>> 24 & 255;
        o32[28] = x7 >>> 0 & 255;
        o32[29] = x7 >>> 8 & 255;
        o32[30] = x7 >>> 16 & 255;
        o32[31] = x7 >>> 24 & 255;
        o32[32] = x8 >>> 0 & 255;
        o32[33] = x8 >>> 8 & 255;
        o32[34] = x8 >>> 16 & 255;
        o32[35] = x8 >>> 24 & 255;
        o32[36] = x9 >>> 0 & 255;
        o32[37] = x9 >>> 8 & 255;
        o32[38] = x9 >>> 16 & 255;
        o32[39] = x9 >>> 24 & 255;
        o32[40] = x10 >>> 0 & 255;
        o32[41] = x10 >>> 8 & 255;
        o32[42] = x10 >>> 16 & 255;
        o32[43] = x10 >>> 24 & 255;
        o32[44] = x11 >>> 0 & 255;
        o32[45] = x11 >>> 8 & 255;
        o32[46] = x11 >>> 16 & 255;
        o32[47] = x11 >>> 24 & 255;
        o32[48] = x12 >>> 0 & 255;
        o32[49] = x12 >>> 8 & 255;
        o32[50] = x12 >>> 16 & 255;
        o32[51] = x12 >>> 24 & 255;
        o32[52] = x13 >>> 0 & 255;
        o32[53] = x13 >>> 8 & 255;
        o32[54] = x13 >>> 16 & 255;
        o32[55] = x13 >>> 24 & 255;
        o32[56] = x14 >>> 0 & 255;
        o32[57] = x14 >>> 8 & 255;
        o32[58] = x14 >>> 16 & 255;
        o32[59] = x14 >>> 24 & 255;
        o32[60] = x15 >>> 0 & 255;
        o32[61] = x15 >>> 8 & 255;
        o32[62] = x15 >>> 16 & 255;
        o32[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o32, p3, k3, c17) {
        var j0 = c17[0] & 255 | (c17[1] & 255) << 8 | (c17[2] & 255) << 16 | (c17[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j2 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j3 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c17[4] & 255 | (c17[5] & 255) << 8 | (c17[6] & 255) << 16 | (c17[7] & 255) << 24, j6 = p3[0] & 255 | (p3[1] & 255) << 8 | (p3[2] & 255) << 16 | (p3[3] & 255) << 24, j7 = p3[4] & 255 | (p3[5] & 255) << 8 | (p3[6] & 255) << 16 | (p3[7] & 255) << 24, j8 = p3[8] & 255 | (p3[9] & 255) << 8 | (p3[10] & 255) << 16 | (p3[11] & 255) << 24, j9 = p3[12] & 255 | (p3[13] & 255) << 8 | (p3[14] & 255) << 16 | (p3[15] & 255) << 24, j10 = c17[8] & 255 | (c17[9] & 255) << 8 | (c17[10] & 255) << 16 | (c17[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c17[12] & 255 | (c17[13] & 255) << 8 | (c17[14] & 255) << 16 | (c17[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u22;
        for (var i17 = 0; i17 < 20; i17 += 2) {
          u22 = x0 + x12 | 0;
          x4 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x4 + x0 | 0;
          x8 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x8 + x4 | 0;
          x12 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x12 + x8 | 0;
          x0 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x5 + x1 | 0;
          x9 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x9 + x5 | 0;
          x13 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x13 + x9 | 0;
          x1 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x1 + x13 | 0;
          x5 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x10 + x6 | 0;
          x14 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x14 + x10 | 0;
          x2 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x2 + x14 | 0;
          x6 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x6 + x2 | 0;
          x10 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x15 + x11 | 0;
          x3 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x3 + x15 | 0;
          x7 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x7 + x3 | 0;
          x11 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x11 + x7 | 0;
          x15 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x0 + x3 | 0;
          x1 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x1 + x0 | 0;
          x2 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x2 + x1 | 0;
          x3 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x3 + x2 | 0;
          x0 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x5 + x4 | 0;
          x6 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x6 + x5 | 0;
          x7 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x7 + x6 | 0;
          x4 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x4 + x7 | 0;
          x5 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x10 + x9 | 0;
          x11 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x11 + x10 | 0;
          x8 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x8 + x11 | 0;
          x9 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x9 + x8 | 0;
          x10 ^= u22 << 18 | u22 >>> 32 - 18;
          u22 = x15 + x14 | 0;
          x12 ^= u22 << 7 | u22 >>> 32 - 7;
          u22 = x12 + x15 | 0;
          x13 ^= u22 << 9 | u22 >>> 32 - 9;
          u22 = x13 + x12 | 0;
          x14 ^= u22 << 13 | u22 >>> 32 - 13;
          u22 = x14 + x13 | 0;
          x15 ^= u22 << 18 | u22 >>> 32 - 18;
        }
        o32[0] = x0 >>> 0 & 255;
        o32[1] = x0 >>> 8 & 255;
        o32[2] = x0 >>> 16 & 255;
        o32[3] = x0 >>> 24 & 255;
        o32[4] = x5 >>> 0 & 255;
        o32[5] = x5 >>> 8 & 255;
        o32[6] = x5 >>> 16 & 255;
        o32[7] = x5 >>> 24 & 255;
        o32[8] = x10 >>> 0 & 255;
        o32[9] = x10 >>> 8 & 255;
        o32[10] = x10 >>> 16 & 255;
        o32[11] = x10 >>> 24 & 255;
        o32[12] = x15 >>> 0 & 255;
        o32[13] = x15 >>> 8 & 255;
        o32[14] = x15 >>> 16 & 255;
        o32[15] = x15 >>> 24 & 255;
        o32[16] = x6 >>> 0 & 255;
        o32[17] = x6 >>> 8 & 255;
        o32[18] = x6 >>> 16 & 255;
        o32[19] = x6 >>> 24 & 255;
        o32[20] = x7 >>> 0 & 255;
        o32[21] = x7 >>> 8 & 255;
        o32[22] = x7 >>> 16 & 255;
        o32[23] = x7 >>> 24 & 255;
        o32[24] = x8 >>> 0 & 255;
        o32[25] = x8 >>> 8 & 255;
        o32[26] = x8 >>> 16 & 255;
        o32[27] = x8 >>> 24 & 255;
        o32[28] = x9 >>> 0 & 255;
        o32[29] = x9 >>> 8 & 255;
        o32[30] = x9 >>> 16 & 255;
        o32[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k3, c17) {
        core_salsa20(out, inp, k3, c17);
      }
      function crypto_core_hsalsa20(out, inp, k3, c17) {
        core_hsalsa20(out, inp, k3, c17);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c17, cpos, m6, mpos, b5, n31, k3) {
        var z = new Uint8Array(16), x2 = new Uint8Array(64);
        var u22, i17;
        for (i17 = 0; i17 < 16; i17++) z[i17] = 0;
        for (i17 = 0; i17 < 8; i17++) z[i17] = n31[i17];
        while (b5 >= 64) {
          crypto_core_salsa20(x2, z, k3, sigma);
          for (i17 = 0; i17 < 64; i17++) c17[cpos + i17] = m6[mpos + i17] ^ x2[i17];
          u22 = 1;
          for (i17 = 8; i17 < 16; i17++) {
            u22 = u22 + (z[i17] & 255) | 0;
            z[i17] = u22 & 255;
            u22 >>>= 8;
          }
          b5 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b5 > 0) {
          crypto_core_salsa20(x2, z, k3, sigma);
          for (i17 = 0; i17 < b5; i17++) c17[cpos + i17] = m6[mpos + i17] ^ x2[i17];
        }
        return 0;
      }
      function crypto_stream_salsa20(c17, cpos, b5, n31, k3) {
        var z = new Uint8Array(16), x2 = new Uint8Array(64);
        var u22, i17;
        for (i17 = 0; i17 < 16; i17++) z[i17] = 0;
        for (i17 = 0; i17 < 8; i17++) z[i17] = n31[i17];
        while (b5 >= 64) {
          crypto_core_salsa20(x2, z, k3, sigma);
          for (i17 = 0; i17 < 64; i17++) c17[cpos + i17] = x2[i17];
          u22 = 1;
          for (i17 = 8; i17 < 16; i17++) {
            u22 = u22 + (z[i17] & 255) | 0;
            z[i17] = u22 & 255;
            u22 >>>= 8;
          }
          b5 -= 64;
          cpos += 64;
        }
        if (b5 > 0) {
          crypto_core_salsa20(x2, z, k3, sigma);
          for (i17 = 0; i17 < b5; i17++) c17[cpos + i17] = x2[i17];
        }
        return 0;
      }
      function crypto_stream(c17, cpos, d18, n31, k3) {
        var s26 = new Uint8Array(32);
        crypto_core_hsalsa20(s26, n31, k3, sigma);
        var sn = new Uint8Array(8);
        for (var i17 = 0; i17 < 8; i17++) sn[i17] = n31[i17 + 16];
        return crypto_stream_salsa20(c17, cpos, d18, sn, s26);
      }
      function crypto_stream_xor(c17, cpos, m6, mpos, d18, n31, k3) {
        var s26 = new Uint8Array(32);
        crypto_core_hsalsa20(s26, n31, k3, sigma);
        var sn = new Uint8Array(8);
        for (var i17 = 0; i17 < 8; i17++) sn[i17] = n31[i17 + 16];
        return crypto_stream_salsa20_xor(c17, cpos, m6, mpos, d18, sn, s26);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t210, t35, t42, t52, t62, t72;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t210 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t210 << 6) & 7939;
        t35 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t210 >>> 7 | t35 << 9) & 8191;
        t42 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t35 >>> 4 | t42 << 12) & 255;
        this.r[5] = t42 >>> 1 & 8190;
        t52 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t42 >>> 14 | t52 << 2) & 8191;
        t62 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t52 >>> 11 | t62 << 5) & 8065;
        t72 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t62 >>> 8 | t72 << 8) & 8191;
        this.r[9] = t72 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m6, mpos, bytes3) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t210, t35, t42, t52, t62, t72, c17;
        var d0, d1, d22, d32, d42, d52, d62, d72, d82, d92;
        var h0 = this.h[0], h1 = this.h[1], h22 = this.h[2], h32 = this.h[3], h42 = this.h[4], h52 = this.h[5], h62 = this.h[6], h72 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r210 = this.r[2], r310 = this.r[3], r42 = this.r[4], r52 = this.r[5], r62 = this.r[6], r72 = this.r[7], r82 = this.r[8], r92 = this.r[9];
        while (bytes3 >= 16) {
          t0 = m6[mpos + 0] & 255 | (m6[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m6[mpos + 2] & 255 | (m6[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t210 = m6[mpos + 4] & 255 | (m6[mpos + 5] & 255) << 8;
          h22 += (t1 >>> 10 | t210 << 6) & 8191;
          t35 = m6[mpos + 6] & 255 | (m6[mpos + 7] & 255) << 8;
          h32 += (t210 >>> 7 | t35 << 9) & 8191;
          t42 = m6[mpos + 8] & 255 | (m6[mpos + 9] & 255) << 8;
          h42 += (t35 >>> 4 | t42 << 12) & 8191;
          h52 += t42 >>> 1 & 8191;
          t52 = m6[mpos + 10] & 255 | (m6[mpos + 11] & 255) << 8;
          h62 += (t42 >>> 14 | t52 << 2) & 8191;
          t62 = m6[mpos + 12] & 255 | (m6[mpos + 13] & 255) << 8;
          h72 += (t52 >>> 11 | t62 << 5) & 8191;
          t72 = m6[mpos + 14] & 255 | (m6[mpos + 15] & 255) << 8;
          h8 += (t62 >>> 8 | t72 << 8) & 8191;
          h9 += t72 >>> 5 | hibit;
          c17 = 0;
          d0 = c17;
          d0 += h0 * r0;
          d0 += h1 * (5 * r92);
          d0 += h22 * (5 * r82);
          d0 += h32 * (5 * r72);
          d0 += h42 * (5 * r62);
          c17 = d0 >>> 13;
          d0 &= 8191;
          d0 += h52 * (5 * r52);
          d0 += h62 * (5 * r42);
          d0 += h72 * (5 * r310);
          d0 += h8 * (5 * r210);
          d0 += h9 * (5 * r1);
          c17 += d0 >>> 13;
          d0 &= 8191;
          d1 = c17;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h22 * (5 * r92);
          d1 += h32 * (5 * r82);
          d1 += h42 * (5 * r72);
          c17 = d1 >>> 13;
          d1 &= 8191;
          d1 += h52 * (5 * r62);
          d1 += h62 * (5 * r52);
          d1 += h72 * (5 * r42);
          d1 += h8 * (5 * r310);
          d1 += h9 * (5 * r210);
          c17 += d1 >>> 13;
          d1 &= 8191;
          d22 = c17;
          d22 += h0 * r210;
          d22 += h1 * r1;
          d22 += h22 * r0;
          d22 += h32 * (5 * r92);
          d22 += h42 * (5 * r82);
          c17 = d22 >>> 13;
          d22 &= 8191;
          d22 += h52 * (5 * r72);
          d22 += h62 * (5 * r62);
          d22 += h72 * (5 * r52);
          d22 += h8 * (5 * r42);
          d22 += h9 * (5 * r310);
          c17 += d22 >>> 13;
          d22 &= 8191;
          d32 = c17;
          d32 += h0 * r310;
          d32 += h1 * r210;
          d32 += h22 * r1;
          d32 += h32 * r0;
          d32 += h42 * (5 * r92);
          c17 = d32 >>> 13;
          d32 &= 8191;
          d32 += h52 * (5 * r82);
          d32 += h62 * (5 * r72);
          d32 += h72 * (5 * r62);
          d32 += h8 * (5 * r52);
          d32 += h9 * (5 * r42);
          c17 += d32 >>> 13;
          d32 &= 8191;
          d42 = c17;
          d42 += h0 * r42;
          d42 += h1 * r310;
          d42 += h22 * r210;
          d42 += h32 * r1;
          d42 += h42 * r0;
          c17 = d42 >>> 13;
          d42 &= 8191;
          d42 += h52 * (5 * r92);
          d42 += h62 * (5 * r82);
          d42 += h72 * (5 * r72);
          d42 += h8 * (5 * r62);
          d42 += h9 * (5 * r52);
          c17 += d42 >>> 13;
          d42 &= 8191;
          d52 = c17;
          d52 += h0 * r52;
          d52 += h1 * r42;
          d52 += h22 * r310;
          d52 += h32 * r210;
          d52 += h42 * r1;
          c17 = d52 >>> 13;
          d52 &= 8191;
          d52 += h52 * r0;
          d52 += h62 * (5 * r92);
          d52 += h72 * (5 * r82);
          d52 += h8 * (5 * r72);
          d52 += h9 * (5 * r62);
          c17 += d52 >>> 13;
          d52 &= 8191;
          d62 = c17;
          d62 += h0 * r62;
          d62 += h1 * r52;
          d62 += h22 * r42;
          d62 += h32 * r310;
          d62 += h42 * r210;
          c17 = d62 >>> 13;
          d62 &= 8191;
          d62 += h52 * r1;
          d62 += h62 * r0;
          d62 += h72 * (5 * r92);
          d62 += h8 * (5 * r82);
          d62 += h9 * (5 * r72);
          c17 += d62 >>> 13;
          d62 &= 8191;
          d72 = c17;
          d72 += h0 * r72;
          d72 += h1 * r62;
          d72 += h22 * r52;
          d72 += h32 * r42;
          d72 += h42 * r310;
          c17 = d72 >>> 13;
          d72 &= 8191;
          d72 += h52 * r210;
          d72 += h62 * r1;
          d72 += h72 * r0;
          d72 += h8 * (5 * r92);
          d72 += h9 * (5 * r82);
          c17 += d72 >>> 13;
          d72 &= 8191;
          d82 = c17;
          d82 += h0 * r82;
          d82 += h1 * r72;
          d82 += h22 * r62;
          d82 += h32 * r52;
          d82 += h42 * r42;
          c17 = d82 >>> 13;
          d82 &= 8191;
          d82 += h52 * r310;
          d82 += h62 * r210;
          d82 += h72 * r1;
          d82 += h8 * r0;
          d82 += h9 * (5 * r92);
          c17 += d82 >>> 13;
          d82 &= 8191;
          d92 = c17;
          d92 += h0 * r92;
          d92 += h1 * r82;
          d92 += h22 * r72;
          d92 += h32 * r62;
          d92 += h42 * r52;
          c17 = d92 >>> 13;
          d92 &= 8191;
          d92 += h52 * r42;
          d92 += h62 * r310;
          d92 += h72 * r210;
          d92 += h8 * r1;
          d92 += h9 * r0;
          c17 += d92 >>> 13;
          d92 &= 8191;
          c17 = (c17 << 2) + c17 | 0;
          c17 = c17 + d0 | 0;
          d0 = c17 & 8191;
          c17 = c17 >>> 13;
          d1 += c17;
          h0 = d0;
          h1 = d1;
          h22 = d22;
          h32 = d32;
          h42 = d42;
          h52 = d52;
          h62 = d62;
          h72 = d72;
          h8 = d82;
          h9 = d92;
          mpos += 16;
          bytes3 -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h22;
        this.h[3] = h32;
        this.h[4] = h42;
        this.h[5] = h52;
        this.h[6] = h62;
        this.h[7] = h72;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g5 = new Uint16Array(10);
        var c17, mask, f4, i17;
        if (this.leftover) {
          i17 = this.leftover;
          this.buffer[i17++] = 1;
          for (; i17 < 16; i17++) this.buffer[i17] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c17 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i17 = 2; i17 < 10; i17++) {
          this.h[i17] += c17;
          c17 = this.h[i17] >>> 13;
          this.h[i17] &= 8191;
        }
        this.h[0] += c17 * 5;
        c17 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c17;
        c17 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c17;
        g5[0] = this.h[0] + 5;
        c17 = g5[0] >>> 13;
        g5[0] &= 8191;
        for (i17 = 1; i17 < 10; i17++) {
          g5[i17] = this.h[i17] + c17;
          c17 = g5[i17] >>> 13;
          g5[i17] &= 8191;
        }
        g5[9] -= 1 << 13;
        mask = (c17 ^ 1) - 1;
        for (i17 = 0; i17 < 10; i17++) g5[i17] &= mask;
        mask = ~mask;
        for (i17 = 0; i17 < 10; i17++) this.h[i17] = this.h[i17] & mask | g5[i17];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f4 = this.h[0] + this.pad[0];
        this.h[0] = f4 & 65535;
        for (i17 = 1; i17 < 8; i17++) {
          f4 = (this.h[i17] + this.pad[i17] | 0) + (f4 >>> 16) | 0;
          this.h[i17] = f4 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m6, mpos, bytes3) {
        var i17, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes3)
            want = bytes3;
          for (i17 = 0; i17 < want; i17++)
            this.buffer[this.leftover + i17] = m6[mpos + i17];
          bytes3 -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes3 >= 16) {
          want = bytes3 - bytes3 % 16;
          this.blocks(m6, mpos, want);
          mpos += want;
          bytes3 -= want;
        }
        if (bytes3) {
          for (i17 = 0; i17 < bytes3; i17++)
            this.buffer[this.leftover + i17] = m6[mpos + i17];
          this.leftover += bytes3;
        }
      };
      function crypto_onetimeauth(out, outpos, m6, mpos, n31, k3) {
        var s26 = new poly1305(k3);
        s26.update(m6, mpos, n31);
        s26.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h8, hpos, m6, mpos, n31, k3) {
        var x2 = new Uint8Array(16);
        crypto_onetimeauth(x2, 0, m6, mpos, n31, k3);
        return crypto_verify_16(h8, hpos, x2, 0);
      }
      function crypto_secretbox(c17, m6, d18, n31, k3) {
        var i17;
        if (d18 < 32) return -1;
        crypto_stream_xor(c17, 0, m6, 0, d18, n31, k3);
        crypto_onetimeauth(c17, 16, c17, 32, d18 - 32, c17);
        for (i17 = 0; i17 < 16; i17++) c17[i17] = 0;
        return 0;
      }
      function crypto_secretbox_open(m6, c17, d18, n31, k3) {
        var i17;
        var x2 = new Uint8Array(32);
        if (d18 < 32) return -1;
        crypto_stream(x2, 0, 32, n31, k3);
        if (crypto_onetimeauth_verify(c17, 16, c17, 32, d18 - 32, x2) !== 0) return -1;
        crypto_stream_xor(m6, 0, c17, 0, d18, n31, k3);
        for (i17 = 0; i17 < 32; i17++) m6[i17] = 0;
        return 0;
      }
      function set25519(r41, a23) {
        var i17;
        for (i17 = 0; i17 < 16; i17++) r41[i17] = a23[i17] | 0;
      }
      function car25519(o32) {
        var i17, v3, c17 = 1;
        for (i17 = 0; i17 < 16; i17++) {
          v3 = o32[i17] + c17 + 65535;
          c17 = Math.floor(v3 / 65536);
          o32[i17] = v3 - c17 * 65536;
        }
        o32[0] += c17 - 1 + 37 * (c17 - 1);
      }
      function sel25519(p3, q, b5) {
        var t35, c17 = ~(b5 - 1);
        for (var i17 = 0; i17 < 16; i17++) {
          t35 = c17 & (p3[i17] ^ q[i17]);
          p3[i17] ^= t35;
          q[i17] ^= t35;
        }
      }
      function pack25519(o32, n31) {
        var i17, j2, b5;
        var m6 = gf(), t35 = gf();
        for (i17 = 0; i17 < 16; i17++) t35[i17] = n31[i17];
        car25519(t35);
        car25519(t35);
        car25519(t35);
        for (j2 = 0; j2 < 2; j2++) {
          m6[0] = t35[0] - 65517;
          for (i17 = 1; i17 < 15; i17++) {
            m6[i17] = t35[i17] - 65535 - (m6[i17 - 1] >> 16 & 1);
            m6[i17 - 1] &= 65535;
          }
          m6[15] = t35[15] - 32767 - (m6[14] >> 16 & 1);
          b5 = m6[15] >> 16 & 1;
          m6[14] &= 65535;
          sel25519(t35, m6, 1 - b5);
        }
        for (i17 = 0; i17 < 16; i17++) {
          o32[2 * i17] = t35[i17] & 255;
          o32[2 * i17 + 1] = t35[i17] >> 8;
        }
      }
      function neq25519(a23, b5) {
        var c17 = new Uint8Array(32), d18 = new Uint8Array(32);
        pack25519(c17, a23);
        pack25519(d18, b5);
        return crypto_verify_32(c17, 0, d18, 0);
      }
      function par25519(a23) {
        var d18 = new Uint8Array(32);
        pack25519(d18, a23);
        return d18[0] & 1;
      }
      function unpack25519(o32, n31) {
        var i17;
        for (i17 = 0; i17 < 16; i17++) o32[i17] = n31[2 * i17] + (n31[2 * i17 + 1] << 8);
        o32[15] &= 32767;
      }
      function A3(o32, a23, b5) {
        for (var i17 = 0; i17 < 16; i17++) o32[i17] = a23[i17] + b5[i17];
      }
      function Z(o32, a23, b5) {
        for (var i17 = 0; i17 < 16; i17++) o32[i17] = a23[i17] - b5[i17];
      }
      function M(o32, a23, b5) {
        var v3, c17, t0 = 0, t1 = 0, t210 = 0, t35 = 0, t42 = 0, t52 = 0, t62 = 0, t72 = 0, t82 = 0, t92 = 0, t102 = 0, t112 = 0, t122 = 0, t132 = 0, t142 = 0, t152 = 0, t162 = 0, t172 = 0, t182 = 0, t192 = 0, t202 = 0, t212 = 0, t222 = 0, t232 = 0, t242 = 0, t252 = 0, t262 = 0, t272 = 0, t282 = 0, t292 = 0, t302 = 0, b0 = b5[0], b1 = b5[1], b22 = b5[2], b32 = b5[3], b42 = b5[4], b52 = b5[5], b6 = b5[6], b7 = b5[7], b8 = b5[8], b9 = b5[9], b10 = b5[10], b11 = b5[11], b12 = b5[12], b13 = b5[13], b14 = b5[14], b15 = b5[15];
        v3 = a23[0];
        t0 += v3 * b0;
        t1 += v3 * b1;
        t210 += v3 * b22;
        t35 += v3 * b32;
        t42 += v3 * b42;
        t52 += v3 * b52;
        t62 += v3 * b6;
        t72 += v3 * b7;
        t82 += v3 * b8;
        t92 += v3 * b9;
        t102 += v3 * b10;
        t112 += v3 * b11;
        t122 += v3 * b12;
        t132 += v3 * b13;
        t142 += v3 * b14;
        t152 += v3 * b15;
        v3 = a23[1];
        t1 += v3 * b0;
        t210 += v3 * b1;
        t35 += v3 * b22;
        t42 += v3 * b32;
        t52 += v3 * b42;
        t62 += v3 * b52;
        t72 += v3 * b6;
        t82 += v3 * b7;
        t92 += v3 * b8;
        t102 += v3 * b9;
        t112 += v3 * b10;
        t122 += v3 * b11;
        t132 += v3 * b12;
        t142 += v3 * b13;
        t152 += v3 * b14;
        t162 += v3 * b15;
        v3 = a23[2];
        t210 += v3 * b0;
        t35 += v3 * b1;
        t42 += v3 * b22;
        t52 += v3 * b32;
        t62 += v3 * b42;
        t72 += v3 * b52;
        t82 += v3 * b6;
        t92 += v3 * b7;
        t102 += v3 * b8;
        t112 += v3 * b9;
        t122 += v3 * b10;
        t132 += v3 * b11;
        t142 += v3 * b12;
        t152 += v3 * b13;
        t162 += v3 * b14;
        t172 += v3 * b15;
        v3 = a23[3];
        t35 += v3 * b0;
        t42 += v3 * b1;
        t52 += v3 * b22;
        t62 += v3 * b32;
        t72 += v3 * b42;
        t82 += v3 * b52;
        t92 += v3 * b6;
        t102 += v3 * b7;
        t112 += v3 * b8;
        t122 += v3 * b9;
        t132 += v3 * b10;
        t142 += v3 * b11;
        t152 += v3 * b12;
        t162 += v3 * b13;
        t172 += v3 * b14;
        t182 += v3 * b15;
        v3 = a23[4];
        t42 += v3 * b0;
        t52 += v3 * b1;
        t62 += v3 * b22;
        t72 += v3 * b32;
        t82 += v3 * b42;
        t92 += v3 * b52;
        t102 += v3 * b6;
        t112 += v3 * b7;
        t122 += v3 * b8;
        t132 += v3 * b9;
        t142 += v3 * b10;
        t152 += v3 * b11;
        t162 += v3 * b12;
        t172 += v3 * b13;
        t182 += v3 * b14;
        t192 += v3 * b15;
        v3 = a23[5];
        t52 += v3 * b0;
        t62 += v3 * b1;
        t72 += v3 * b22;
        t82 += v3 * b32;
        t92 += v3 * b42;
        t102 += v3 * b52;
        t112 += v3 * b6;
        t122 += v3 * b7;
        t132 += v3 * b8;
        t142 += v3 * b9;
        t152 += v3 * b10;
        t162 += v3 * b11;
        t172 += v3 * b12;
        t182 += v3 * b13;
        t192 += v3 * b14;
        t202 += v3 * b15;
        v3 = a23[6];
        t62 += v3 * b0;
        t72 += v3 * b1;
        t82 += v3 * b22;
        t92 += v3 * b32;
        t102 += v3 * b42;
        t112 += v3 * b52;
        t122 += v3 * b6;
        t132 += v3 * b7;
        t142 += v3 * b8;
        t152 += v3 * b9;
        t162 += v3 * b10;
        t172 += v3 * b11;
        t182 += v3 * b12;
        t192 += v3 * b13;
        t202 += v3 * b14;
        t212 += v3 * b15;
        v3 = a23[7];
        t72 += v3 * b0;
        t82 += v3 * b1;
        t92 += v3 * b22;
        t102 += v3 * b32;
        t112 += v3 * b42;
        t122 += v3 * b52;
        t132 += v3 * b6;
        t142 += v3 * b7;
        t152 += v3 * b8;
        t162 += v3 * b9;
        t172 += v3 * b10;
        t182 += v3 * b11;
        t192 += v3 * b12;
        t202 += v3 * b13;
        t212 += v3 * b14;
        t222 += v3 * b15;
        v3 = a23[8];
        t82 += v3 * b0;
        t92 += v3 * b1;
        t102 += v3 * b22;
        t112 += v3 * b32;
        t122 += v3 * b42;
        t132 += v3 * b52;
        t142 += v3 * b6;
        t152 += v3 * b7;
        t162 += v3 * b8;
        t172 += v3 * b9;
        t182 += v3 * b10;
        t192 += v3 * b11;
        t202 += v3 * b12;
        t212 += v3 * b13;
        t222 += v3 * b14;
        t232 += v3 * b15;
        v3 = a23[9];
        t92 += v3 * b0;
        t102 += v3 * b1;
        t112 += v3 * b22;
        t122 += v3 * b32;
        t132 += v3 * b42;
        t142 += v3 * b52;
        t152 += v3 * b6;
        t162 += v3 * b7;
        t172 += v3 * b8;
        t182 += v3 * b9;
        t192 += v3 * b10;
        t202 += v3 * b11;
        t212 += v3 * b12;
        t222 += v3 * b13;
        t232 += v3 * b14;
        t242 += v3 * b15;
        v3 = a23[10];
        t102 += v3 * b0;
        t112 += v3 * b1;
        t122 += v3 * b22;
        t132 += v3 * b32;
        t142 += v3 * b42;
        t152 += v3 * b52;
        t162 += v3 * b6;
        t172 += v3 * b7;
        t182 += v3 * b8;
        t192 += v3 * b9;
        t202 += v3 * b10;
        t212 += v3 * b11;
        t222 += v3 * b12;
        t232 += v3 * b13;
        t242 += v3 * b14;
        t252 += v3 * b15;
        v3 = a23[11];
        t112 += v3 * b0;
        t122 += v3 * b1;
        t132 += v3 * b22;
        t142 += v3 * b32;
        t152 += v3 * b42;
        t162 += v3 * b52;
        t172 += v3 * b6;
        t182 += v3 * b7;
        t192 += v3 * b8;
        t202 += v3 * b9;
        t212 += v3 * b10;
        t222 += v3 * b11;
        t232 += v3 * b12;
        t242 += v3 * b13;
        t252 += v3 * b14;
        t262 += v3 * b15;
        v3 = a23[12];
        t122 += v3 * b0;
        t132 += v3 * b1;
        t142 += v3 * b22;
        t152 += v3 * b32;
        t162 += v3 * b42;
        t172 += v3 * b52;
        t182 += v3 * b6;
        t192 += v3 * b7;
        t202 += v3 * b8;
        t212 += v3 * b9;
        t222 += v3 * b10;
        t232 += v3 * b11;
        t242 += v3 * b12;
        t252 += v3 * b13;
        t262 += v3 * b14;
        t272 += v3 * b15;
        v3 = a23[13];
        t132 += v3 * b0;
        t142 += v3 * b1;
        t152 += v3 * b22;
        t162 += v3 * b32;
        t172 += v3 * b42;
        t182 += v3 * b52;
        t192 += v3 * b6;
        t202 += v3 * b7;
        t212 += v3 * b8;
        t222 += v3 * b9;
        t232 += v3 * b10;
        t242 += v3 * b11;
        t252 += v3 * b12;
        t262 += v3 * b13;
        t272 += v3 * b14;
        t282 += v3 * b15;
        v3 = a23[14];
        t142 += v3 * b0;
        t152 += v3 * b1;
        t162 += v3 * b22;
        t172 += v3 * b32;
        t182 += v3 * b42;
        t192 += v3 * b52;
        t202 += v3 * b6;
        t212 += v3 * b7;
        t222 += v3 * b8;
        t232 += v3 * b9;
        t242 += v3 * b10;
        t252 += v3 * b11;
        t262 += v3 * b12;
        t272 += v3 * b13;
        t282 += v3 * b14;
        t292 += v3 * b15;
        v3 = a23[15];
        t152 += v3 * b0;
        t162 += v3 * b1;
        t172 += v3 * b22;
        t182 += v3 * b32;
        t192 += v3 * b42;
        t202 += v3 * b52;
        t212 += v3 * b6;
        t222 += v3 * b7;
        t232 += v3 * b8;
        t242 += v3 * b9;
        t252 += v3 * b10;
        t262 += v3 * b11;
        t272 += v3 * b12;
        t282 += v3 * b13;
        t292 += v3 * b14;
        t302 += v3 * b15;
        t0 += 38 * t162;
        t1 += 38 * t172;
        t210 += 38 * t182;
        t35 += 38 * t192;
        t42 += 38 * t202;
        t52 += 38 * t212;
        t62 += 38 * t222;
        t72 += 38 * t232;
        t82 += 38 * t242;
        t92 += 38 * t252;
        t102 += 38 * t262;
        t112 += 38 * t272;
        t122 += 38 * t282;
        t132 += 38 * t292;
        t142 += 38 * t302;
        c17 = 1;
        v3 = t0 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t0 = v3 - c17 * 65536;
        v3 = t1 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t1 = v3 - c17 * 65536;
        v3 = t210 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t210 = v3 - c17 * 65536;
        v3 = t35 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t35 = v3 - c17 * 65536;
        v3 = t42 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t42 = v3 - c17 * 65536;
        v3 = t52 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t52 = v3 - c17 * 65536;
        v3 = t62 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t62 = v3 - c17 * 65536;
        v3 = t72 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t72 = v3 - c17 * 65536;
        v3 = t82 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t82 = v3 - c17 * 65536;
        v3 = t92 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t92 = v3 - c17 * 65536;
        v3 = t102 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t102 = v3 - c17 * 65536;
        v3 = t112 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t112 = v3 - c17 * 65536;
        v3 = t122 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t122 = v3 - c17 * 65536;
        v3 = t132 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t132 = v3 - c17 * 65536;
        v3 = t142 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t142 = v3 - c17 * 65536;
        v3 = t152 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t152 = v3 - c17 * 65536;
        t0 += c17 - 1 + 37 * (c17 - 1);
        c17 = 1;
        v3 = t0 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t0 = v3 - c17 * 65536;
        v3 = t1 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t1 = v3 - c17 * 65536;
        v3 = t210 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t210 = v3 - c17 * 65536;
        v3 = t35 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t35 = v3 - c17 * 65536;
        v3 = t42 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t42 = v3 - c17 * 65536;
        v3 = t52 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t52 = v3 - c17 * 65536;
        v3 = t62 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t62 = v3 - c17 * 65536;
        v3 = t72 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t72 = v3 - c17 * 65536;
        v3 = t82 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t82 = v3 - c17 * 65536;
        v3 = t92 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t92 = v3 - c17 * 65536;
        v3 = t102 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t102 = v3 - c17 * 65536;
        v3 = t112 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t112 = v3 - c17 * 65536;
        v3 = t122 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t122 = v3 - c17 * 65536;
        v3 = t132 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t132 = v3 - c17 * 65536;
        v3 = t142 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t142 = v3 - c17 * 65536;
        v3 = t152 + c17 + 65535;
        c17 = Math.floor(v3 / 65536);
        t152 = v3 - c17 * 65536;
        t0 += c17 - 1 + 37 * (c17 - 1);
        o32[0] = t0;
        o32[1] = t1;
        o32[2] = t210;
        o32[3] = t35;
        o32[4] = t42;
        o32[5] = t52;
        o32[6] = t62;
        o32[7] = t72;
        o32[8] = t82;
        o32[9] = t92;
        o32[10] = t102;
        o32[11] = t112;
        o32[12] = t122;
        o32[13] = t132;
        o32[14] = t142;
        o32[15] = t152;
      }
      function S3(o32, a23) {
        M(o32, a23, a23);
      }
      function inv25519(o32, i17) {
        var c17 = gf();
        var a23;
        for (a23 = 0; a23 < 16; a23++) c17[a23] = i17[a23];
        for (a23 = 253; a23 >= 0; a23--) {
          S3(c17, c17);
          if (a23 !== 2 && a23 !== 4) M(c17, c17, i17);
        }
        for (a23 = 0; a23 < 16; a23++) o32[a23] = c17[a23];
      }
      function pow2523(o32, i17) {
        var c17 = gf();
        var a23;
        for (a23 = 0; a23 < 16; a23++) c17[a23] = i17[a23];
        for (a23 = 250; a23 >= 0; a23--) {
          S3(c17, c17);
          if (a23 !== 1) M(c17, c17, i17);
        }
        for (a23 = 0; a23 < 16; a23++) o32[a23] = c17[a23];
      }
      function crypto_scalarmult(q, n31, p3) {
        var z = new Uint8Array(32);
        var x2 = new Float64Array(80), r41, i17;
        var a23 = gf(), b5 = gf(), c17 = gf(), d18 = gf(), e39 = gf(), f4 = gf();
        for (i17 = 0; i17 < 31; i17++) z[i17] = n31[i17];
        z[31] = n31[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x2, p3);
        for (i17 = 0; i17 < 16; i17++) {
          b5[i17] = x2[i17];
          d18[i17] = a23[i17] = c17[i17] = 0;
        }
        a23[0] = d18[0] = 1;
        for (i17 = 254; i17 >= 0; --i17) {
          r41 = z[i17 >>> 3] >>> (i17 & 7) & 1;
          sel25519(a23, b5, r41);
          sel25519(c17, d18, r41);
          A3(e39, a23, c17);
          Z(a23, a23, c17);
          A3(c17, b5, d18);
          Z(b5, b5, d18);
          S3(d18, e39);
          S3(f4, a23);
          M(a23, c17, a23);
          M(c17, b5, e39);
          A3(e39, a23, c17);
          Z(a23, a23, c17);
          S3(b5, a23);
          Z(c17, d18, f4);
          M(a23, c17, _121665);
          A3(a23, a23, d18);
          M(c17, c17, a23);
          M(a23, d18, f4);
          M(d18, b5, x2);
          S3(b5, e39);
          sel25519(a23, b5, r41);
          sel25519(c17, d18, r41);
        }
        for (i17 = 0; i17 < 16; i17++) {
          x2[i17 + 16] = a23[i17];
          x2[i17 + 32] = c17[i17];
          x2[i17 + 48] = b5[i17];
          x2[i17 + 64] = d18[i17];
        }
        var x32 = x2.subarray(32);
        var x16 = x2.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n31) {
        return crypto_scalarmult(q, n31, _9);
      }
      function crypto_box_keypair(y5, x2) {
        randombytes(x2, 32);
        return crypto_scalarmult_base(y5, x2);
      }
      function crypto_box_beforenm(k3, y5, x2) {
        var s26 = new Uint8Array(32);
        crypto_scalarmult(s26, x2, y5);
        return crypto_core_hsalsa20(k3, _0, s26, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c17, m6, d18, n31, y5, x2) {
        var k3 = new Uint8Array(32);
        crypto_box_beforenm(k3, y5, x2);
        return crypto_box_afternm(c17, m6, d18, n31, k3);
      }
      function crypto_box_open(m6, c17, d18, n31, y5, x2) {
        var k3 = new Uint8Array(32);
        crypto_box_beforenm(k3, y5, x2);
        return crypto_box_open_afternm(m6, c17, d18, n31, k3);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m6, n31) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i17, j2, h8, l19, a23, b5, c17, d18;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n31 >= 128) {
          for (i17 = 0; i17 < 16; i17++) {
            j2 = 8 * i17 + pos;
            wh[i17] = m6[j2 + 0] << 24 | m6[j2 + 1] << 16 | m6[j2 + 2] << 8 | m6[j2 + 3];
            wl[i17] = m6[j2 + 4] << 24 | m6[j2 + 5] << 16 | m6[j2 + 6] << 8 | m6[j2 + 7];
          }
          for (i17 = 0; i17 < 80; i17++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h8 = ah7;
            l19 = al7;
            a23 = l19 & 65535;
            b5 = l19 >>> 16;
            c17 = h8 & 65535;
            d18 = h8 >>> 16;
            h8 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l19 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a23 += l19 & 65535;
            b5 += l19 >>> 16;
            c17 += h8 & 65535;
            d18 += h8 >>> 16;
            h8 = ah4 & ah5 ^ ~ah4 & ah6;
            l19 = al4 & al5 ^ ~al4 & al6;
            a23 += l19 & 65535;
            b5 += l19 >>> 16;
            c17 += h8 & 65535;
            d18 += h8 >>> 16;
            h8 = K[i17 * 2];
            l19 = K[i17 * 2 + 1];
            a23 += l19 & 65535;
            b5 += l19 >>> 16;
            c17 += h8 & 65535;
            d18 += h8 >>> 16;
            h8 = wh[i17 % 16];
            l19 = wl[i17 % 16];
            a23 += l19 & 65535;
            b5 += l19 >>> 16;
            c17 += h8 & 65535;
            d18 += h8 >>> 16;
            b5 += a23 >>> 16;
            c17 += b5 >>> 16;
            d18 += c17 >>> 16;
            th = c17 & 65535 | d18 << 16;
            tl = a23 & 65535 | b5 << 16;
            h8 = th;
            l19 = tl;
            a23 = l19 & 65535;
            b5 = l19 >>> 16;
            c17 = h8 & 65535;
            d18 = h8 >>> 16;
            h8 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l19 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a23 += l19 & 65535;
            b5 += l19 >>> 16;
            c17 += h8 & 65535;
            d18 += h8 >>> 16;
            h8 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l19 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a23 += l19 & 65535;
            b5 += l19 >>> 16;
            c17 += h8 & 65535;
            d18 += h8 >>> 16;
            b5 += a23 >>> 16;
            c17 += b5 >>> 16;
            d18 += c17 >>> 16;
            bh7 = c17 & 65535 | d18 << 16;
            bl7 = a23 & 65535 | b5 << 16;
            h8 = bh3;
            l19 = bl3;
            a23 = l19 & 65535;
            b5 = l19 >>> 16;
            c17 = h8 & 65535;
            d18 = h8 >>> 16;
            h8 = th;
            l19 = tl;
            a23 += l19 & 65535;
            b5 += l19 >>> 16;
            c17 += h8 & 65535;
            d18 += h8 >>> 16;
            b5 += a23 >>> 16;
            c17 += b5 >>> 16;
            d18 += c17 >>> 16;
            bh3 = c17 & 65535 | d18 << 16;
            bl3 = a23 & 65535 | b5 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i17 % 16 === 15) {
              for (j2 = 0; j2 < 16; j2++) {
                h8 = wh[j2];
                l19 = wl[j2];
                a23 = l19 & 65535;
                b5 = l19 >>> 16;
                c17 = h8 & 65535;
                d18 = h8 >>> 16;
                h8 = wh[(j2 + 9) % 16];
                l19 = wl[(j2 + 9) % 16];
                a23 += l19 & 65535;
                b5 += l19 >>> 16;
                c17 += h8 & 65535;
                d18 += h8 >>> 16;
                th = wh[(j2 + 1) % 16];
                tl = wl[(j2 + 1) % 16];
                h8 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l19 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a23 += l19 & 65535;
                b5 += l19 >>> 16;
                c17 += h8 & 65535;
                d18 += h8 >>> 16;
                th = wh[(j2 + 14) % 16];
                tl = wl[(j2 + 14) % 16];
                h8 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l19 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a23 += l19 & 65535;
                b5 += l19 >>> 16;
                c17 += h8 & 65535;
                d18 += h8 >>> 16;
                b5 += a23 >>> 16;
                c17 += b5 >>> 16;
                d18 += c17 >>> 16;
                wh[j2] = c17 & 65535 | d18 << 16;
                wl[j2] = a23 & 65535 | b5 << 16;
              }
            }
          }
          h8 = ah0;
          l19 = al0;
          a23 = l19 & 65535;
          b5 = l19 >>> 16;
          c17 = h8 & 65535;
          d18 = h8 >>> 16;
          h8 = hh[0];
          l19 = hl[0];
          a23 += l19 & 65535;
          b5 += l19 >>> 16;
          c17 += h8 & 65535;
          d18 += h8 >>> 16;
          b5 += a23 >>> 16;
          c17 += b5 >>> 16;
          d18 += c17 >>> 16;
          hh[0] = ah0 = c17 & 65535 | d18 << 16;
          hl[0] = al0 = a23 & 65535 | b5 << 16;
          h8 = ah1;
          l19 = al1;
          a23 = l19 & 65535;
          b5 = l19 >>> 16;
          c17 = h8 & 65535;
          d18 = h8 >>> 16;
          h8 = hh[1];
          l19 = hl[1];
          a23 += l19 & 65535;
          b5 += l19 >>> 16;
          c17 += h8 & 65535;
          d18 += h8 >>> 16;
          b5 += a23 >>> 16;
          c17 += b5 >>> 16;
          d18 += c17 >>> 16;
          hh[1] = ah1 = c17 & 65535 | d18 << 16;
          hl[1] = al1 = a23 & 65535 | b5 << 16;
          h8 = ah2;
          l19 = al2;
          a23 = l19 & 65535;
          b5 = l19 >>> 16;
          c17 = h8 & 65535;
          d18 = h8 >>> 16;
          h8 = hh[2];
          l19 = hl[2];
          a23 += l19 & 65535;
          b5 += l19 >>> 16;
          c17 += h8 & 65535;
          d18 += h8 >>> 16;
          b5 += a23 >>> 16;
          c17 += b5 >>> 16;
          d18 += c17 >>> 16;
          hh[2] = ah2 = c17 & 65535 | d18 << 16;
          hl[2] = al2 = a23 & 65535 | b5 << 16;
          h8 = ah3;
          l19 = al3;
          a23 = l19 & 65535;
          b5 = l19 >>> 16;
          c17 = h8 & 65535;
          d18 = h8 >>> 16;
          h8 = hh[3];
          l19 = hl[3];
          a23 += l19 & 65535;
          b5 += l19 >>> 16;
          c17 += h8 & 65535;
          d18 += h8 >>> 16;
          b5 += a23 >>> 16;
          c17 += b5 >>> 16;
          d18 += c17 >>> 16;
          hh[3] = ah3 = c17 & 65535 | d18 << 16;
          hl[3] = al3 = a23 & 65535 | b5 << 16;
          h8 = ah4;
          l19 = al4;
          a23 = l19 & 65535;
          b5 = l19 >>> 16;
          c17 = h8 & 65535;
          d18 = h8 >>> 16;
          h8 = hh[4];
          l19 = hl[4];
          a23 += l19 & 65535;
          b5 += l19 >>> 16;
          c17 += h8 & 65535;
          d18 += h8 >>> 16;
          b5 += a23 >>> 16;
          c17 += b5 >>> 16;
          d18 += c17 >>> 16;
          hh[4] = ah4 = c17 & 65535 | d18 << 16;
          hl[4] = al4 = a23 & 65535 | b5 << 16;
          h8 = ah5;
          l19 = al5;
          a23 = l19 & 65535;
          b5 = l19 >>> 16;
          c17 = h8 & 65535;
          d18 = h8 >>> 16;
          h8 = hh[5];
          l19 = hl[5];
          a23 += l19 & 65535;
          b5 += l19 >>> 16;
          c17 += h8 & 65535;
          d18 += h8 >>> 16;
          b5 += a23 >>> 16;
          c17 += b5 >>> 16;
          d18 += c17 >>> 16;
          hh[5] = ah5 = c17 & 65535 | d18 << 16;
          hl[5] = al5 = a23 & 65535 | b5 << 16;
          h8 = ah6;
          l19 = al6;
          a23 = l19 & 65535;
          b5 = l19 >>> 16;
          c17 = h8 & 65535;
          d18 = h8 >>> 16;
          h8 = hh[6];
          l19 = hl[6];
          a23 += l19 & 65535;
          b5 += l19 >>> 16;
          c17 += h8 & 65535;
          d18 += h8 >>> 16;
          b5 += a23 >>> 16;
          c17 += b5 >>> 16;
          d18 += c17 >>> 16;
          hh[6] = ah6 = c17 & 65535 | d18 << 16;
          hl[6] = al6 = a23 & 65535 | b5 << 16;
          h8 = ah7;
          l19 = al7;
          a23 = l19 & 65535;
          b5 = l19 >>> 16;
          c17 = h8 & 65535;
          d18 = h8 >>> 16;
          h8 = hh[7];
          l19 = hl[7];
          a23 += l19 & 65535;
          b5 += l19 >>> 16;
          c17 += h8 & 65535;
          d18 += h8 >>> 16;
          b5 += a23 >>> 16;
          c17 += b5 >>> 16;
          d18 += c17 >>> 16;
          hh[7] = ah7 = c17 & 65535 | d18 << 16;
          hl[7] = al7 = a23 & 65535 | b5 << 16;
          pos += 128;
          n31 -= 128;
        }
        return n31;
      }
      function crypto_hash(out, m6, n31) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i17, b5 = n31;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m6, n31);
        n31 %= 128;
        for (i17 = 0; i17 < n31; i17++) x2[i17] = m6[b5 - n31 + i17];
        x2[n31] = 128;
        n31 = 256 - 128 * (n31 < 112 ? 1 : 0);
        x2[n31 - 9] = 0;
        ts64(x2, n31 - 8, b5 / 536870912 | 0, b5 << 3);
        crypto_hashblocks_hl(hh, hl, x2, n31);
        for (i17 = 0; i17 < 8; i17++) ts64(out, 8 * i17, hh[i17], hl[i17]);
        return 0;
      }
      function add3(p3, q) {
        var a23 = gf(), b5 = gf(), c17 = gf(), d18 = gf(), e39 = gf(), f4 = gf(), g5 = gf(), h8 = gf(), t35 = gf();
        Z(a23, p3[1], p3[0]);
        Z(t35, q[1], q[0]);
        M(a23, a23, t35);
        A3(b5, p3[0], p3[1]);
        A3(t35, q[0], q[1]);
        M(b5, b5, t35);
        M(c17, p3[3], q[3]);
        M(c17, c17, D2);
        M(d18, p3[2], q[2]);
        A3(d18, d18, d18);
        Z(e39, b5, a23);
        Z(f4, d18, c17);
        A3(g5, d18, c17);
        A3(h8, b5, a23);
        M(p3[0], e39, f4);
        M(p3[1], h8, g5);
        M(p3[2], g5, f4);
        M(p3[3], e39, h8);
      }
      function cswap(p3, q, b5) {
        var i17;
        for (i17 = 0; i17 < 4; i17++) {
          sel25519(p3[i17], q[i17], b5);
        }
      }
      function pack2(r41, p3) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p3[2]);
        M(tx, p3[0], zi);
        M(ty, p3[1], zi);
        pack25519(r41, ty);
        r41[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p3, q, s26) {
        var b5, i17;
        set25519(p3[0], gf0);
        set25519(p3[1], gf1);
        set25519(p3[2], gf1);
        set25519(p3[3], gf0);
        for (i17 = 255; i17 >= 0; --i17) {
          b5 = s26[i17 / 8 | 0] >> (i17 & 7) & 1;
          cswap(p3, q, b5);
          add3(q, p3);
          add3(p3, p3);
          cswap(p3, q, b5);
        }
      }
      function scalarbase(p3, s26) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p3, q, s26);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d18 = new Uint8Array(64);
        var p3 = [gf(), gf(), gf(), gf()];
        var i17;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d18, sk, 32);
        d18[0] &= 248;
        d18[31] &= 127;
        d18[31] |= 64;
        scalarbase(p3, d18);
        pack2(pk, p3);
        for (i17 = 0; i17 < 32; i17++) sk[i17 + 32] = pk[i17];
        return 0;
      }
      var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r41, x2) {
        var carry, i17, j2, k3;
        for (i17 = 63; i17 >= 32; --i17) {
          carry = 0;
          for (j2 = i17 - 32, k3 = i17 - 12; j2 < k3; ++j2) {
            x2[j2] += carry - 16 * x2[i17] * L2[j2 - (i17 - 32)];
            carry = Math.floor((x2[j2] + 128) / 256);
            x2[j2] -= carry * 256;
          }
          x2[j2] += carry;
          x2[i17] = 0;
        }
        carry = 0;
        for (j2 = 0; j2 < 32; j2++) {
          x2[j2] += carry - (x2[31] >> 4) * L2[j2];
          carry = x2[j2] >> 8;
          x2[j2] &= 255;
        }
        for (j2 = 0; j2 < 32; j2++) x2[j2] -= carry * L2[j2];
        for (i17 = 0; i17 < 32; i17++) {
          x2[i17 + 1] += x2[i17] >> 8;
          r41[i17] = x2[i17] & 255;
        }
      }
      function reduce(r41) {
        var x2 = new Float64Array(64), i17;
        for (i17 = 0; i17 < 64; i17++) x2[i17] = r41[i17];
        for (i17 = 0; i17 < 64; i17++) r41[i17] = 0;
        modL(r41, x2);
      }
      function crypto_sign(sm, m6, n31, sk) {
        var d18 = new Uint8Array(64), h8 = new Uint8Array(64), r41 = new Uint8Array(64);
        var i17, j2, x2 = new Float64Array(64);
        var p3 = [gf(), gf(), gf(), gf()];
        crypto_hash(d18, sk, 32);
        d18[0] &= 248;
        d18[31] &= 127;
        d18[31] |= 64;
        var smlen = n31 + 64;
        for (i17 = 0; i17 < n31; i17++) sm[64 + i17] = m6[i17];
        for (i17 = 0; i17 < 32; i17++) sm[32 + i17] = d18[32 + i17];
        crypto_hash(r41, sm.subarray(32), n31 + 32);
        reduce(r41);
        scalarbase(p3, r41);
        pack2(sm, p3);
        for (i17 = 32; i17 < 64; i17++) sm[i17] = sk[i17];
        crypto_hash(h8, sm, n31 + 64);
        reduce(h8);
        for (i17 = 0; i17 < 64; i17++) x2[i17] = 0;
        for (i17 = 0; i17 < 32; i17++) x2[i17] = r41[i17];
        for (i17 = 0; i17 < 32; i17++) {
          for (j2 = 0; j2 < 32; j2++) {
            x2[i17 + j2] += h8[i17] * d18[j2];
          }
        }
        modL(sm.subarray(32), x2);
        return smlen;
      }
      function unpackneg(r41, p3) {
        var t35 = gf(), chk = gf(), num2 = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r41[2], gf1);
        unpack25519(r41[1], p3);
        S3(num2, r41[1]);
        M(den, num2, D);
        Z(num2, num2, r41[2]);
        A3(den, r41[2], den);
        S3(den2, den);
        S3(den4, den2);
        M(den6, den4, den2);
        M(t35, den6, num2);
        M(t35, t35, den);
        pow2523(t35, t35);
        M(t35, t35, num2);
        M(t35, t35, den);
        M(t35, t35, den);
        M(r41[0], t35, den);
        S3(chk, r41[0]);
        M(chk, chk, den);
        if (neq25519(chk, num2)) M(r41[0], r41[0], I3);
        S3(chk, r41[0]);
        M(chk, chk, den);
        if (neq25519(chk, num2)) return -1;
        if (par25519(r41[0]) === p3[31] >> 7) Z(r41[0], gf0, r41[0]);
        M(r41[3], r41[0], r41[1]);
        return 0;
      }
      function crypto_sign_open(m6, sm, n31, pk) {
        var i17;
        var t35 = new Uint8Array(32), h8 = new Uint8Array(64);
        var p3 = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n31 < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i17 = 0; i17 < n31; i17++) m6[i17] = sm[i17];
        for (i17 = 0; i17 < 32; i17++) m6[i17 + 32] = pk[i17];
        crypto_hash(h8, m6, n31);
        reduce(h8);
        scalarmult(p3, q, h8);
        scalarbase(q, sm.subarray(32));
        add3(p3, q);
        pack2(t35, p3);
        n31 -= 64;
        if (crypto_verify_32(sm, 0, t35, 0)) {
          for (i17 = 0; i17 < n31; i17++) m6[i17] = 0;
          return -1;
        }
        for (i17 = 0; i17 < n31; i17++) m6[i17] = sm[i17 + 64];
        return n31;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl5.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L: L2,
        pack25519,
        unpack25519,
        M,
        A: A3,
        S: S3,
        Z,
        pow2523,
        add: add3,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k3, n31) {
        if (k3.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n31.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i17 = 0; i17 < arguments.length; i17++) {
          if (!(arguments[i17] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i17 = 0; i17 < arr.length; i17++) arr[i17] = 0;
      }
      nacl5.randomBytes = function(n31) {
        var b5 = new Uint8Array(n31);
        randombytes(b5, n31);
        return b5;
      };
      nacl5.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m6 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c17 = new Uint8Array(m6.length);
        for (var i17 = 0; i17 < msg.length; i17++) m6[i17 + crypto_secretbox_ZEROBYTES] = msg[i17];
        crypto_secretbox(c17, m6, m6.length, nonce, key);
        return c17.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl5.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c17 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m6 = new Uint8Array(c17.length);
        for (var i17 = 0; i17 < box.length; i17++) c17[i17 + crypto_secretbox_BOXZEROBYTES] = box[i17];
        if (c17.length < 32) return null;
        if (crypto_secretbox_open(m6, c17, c17.length, nonce, key) !== 0) return null;
        return m6.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl5.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl5.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl5.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl5.scalarMult = function(n31, p3) {
        checkArrayTypes(n31, p3);
        if (n31.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p3.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n31, p3);
        return q;
      };
      nacl5.scalarMult.base = function(n31) {
        checkArrayTypes(n31);
        if (n31.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n31);
        return q;
      };
      nacl5.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl5.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl5.box = function(msg, nonce, publicKey, secretKey) {
        var k3 = nacl5.box.before(publicKey, secretKey);
        return nacl5.secretbox(msg, nonce, k3);
      };
      nacl5.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k3 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k3, publicKey, secretKey);
        return k3;
      };
      nacl5.box.after = nacl5.secretbox;
      nacl5.box.open = function(msg, nonce, publicKey, secretKey) {
        var k3 = nacl5.box.before(publicKey, secretKey);
        return nacl5.secretbox.open(msg, nonce, k3);
      };
      nacl5.box.open.after = nacl5.secretbox.open;
      nacl5.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl5.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl5.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl5.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl5.box.nonceLength = crypto_box_NONCEBYTES;
      nacl5.box.overheadLength = nacl5.secretbox.overheadLength;
      nacl5.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl5.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m6 = new Uint8Array(mlen);
        for (var i17 = 0; i17 < m6.length; i17++) m6[i17] = tmp[i17];
        return m6;
      };
      nacl5.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl5.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i17 = 0; i17 < sig.length; i17++) sig[i17] = signedMsg[i17];
        return sig;
      };
      nacl5.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m6 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i17;
        for (i17 = 0; i17 < crypto_sign_BYTES; i17++) sm[i17] = sig[i17];
        for (i17 = 0; i17 < msg.length; i17++) sm[i17 + crypto_sign_BYTES] = msg[i17];
        return crypto_sign_open(m6, sm, sm.length, publicKey) >= 0;
      };
      nacl5.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i17 = 0; i17 < pk.length; i17++) pk[i17] = secretKey[32 + i17];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl5.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i17 = 0; i17 < 32; i17++) sk[i17] = seed[i17];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl5.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl5.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl5.sign.signatureLength = crypto_sign_BYTES;
      nacl5.hash = function(msg) {
        checkArrayTypes(msg);
        var h8 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h8, msg, msg.length);
        return h8;
      };
      nacl5.hash.hashLength = crypto_hash_BYTES;
      nacl5.verify = function(x2, y5) {
        checkArrayTypes(x2, y5);
        if (x2.length === 0 || y5.length === 0) return false;
        if (x2.length !== y5.length) return false;
        return vn(x2, 0, y5, 0, x2.length) === 0 ? true : false;
      };
      nacl5.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto3 && crypto3.getRandomValues) {
          var QUOTA = 65536;
          nacl5.setPRNG(function(x2, n31) {
            var i17, v3 = new Uint8Array(n31);
            for (i17 = 0; i17 < n31; i17 += QUOTA) {
              crypto3.getRandomValues(v3.subarray(i17, i17 + Math.min(n31 - i17, QUOTA)));
            }
            for (i17 = 0; i17 < n31; i17++) x2[i17] = v3[i17];
            cleanup(v3);
          });
        } else if (typeof __require !== "undefined") {
          crypto3 = require_crypto();
          if (crypto3 && crypto3.randomBytes) {
            nacl5.setPRNG(function(x2, n31) {
              var i17, v3 = crypto3.randomBytes(n31);
              for (i17 = 0; i17 < n31; i17++) x2[i17] = v3[i17];
              cleanup(v3);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/spark-md5/spark-md5.js
var require_spark_md5 = __commonJS({
  "node_modules/spark-md5/spark-md5.js"(exports2, module2) {
    (function(factory) {
      if (typeof exports2 === "object") {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        var glob;
        try {
          glob = window;
        } catch (e39) {
          glob = self;
        }
        glob.SparkMD5 = factory();
      }
    })(function(undefined2) {
      "use strict";
      var add32 = function(a23, b5) {
        return a23 + b5 & 4294967295;
      }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      function cmn(q, a23, b5, x2, s26, t35) {
        a23 = add32(add32(a23, q), add32(x2, t35));
        return add32(a23 << s26 | a23 >>> 32 - s26, b5);
      }
      function md5cycle(x2, k3) {
        var a23 = x2[0], b5 = x2[1], c17 = x2[2], d18 = x2[3];
        a23 += (b5 & c17 | ~b5 & d18) + k3[0] - 680876936 | 0;
        a23 = (a23 << 7 | a23 >>> 25) + b5 | 0;
        d18 += (a23 & b5 | ~a23 & c17) + k3[1] - 389564586 | 0;
        d18 = (d18 << 12 | d18 >>> 20) + a23 | 0;
        c17 += (d18 & a23 | ~d18 & b5) + k3[2] + 606105819 | 0;
        c17 = (c17 << 17 | c17 >>> 15) + d18 | 0;
        b5 += (c17 & d18 | ~c17 & a23) + k3[3] - 1044525330 | 0;
        b5 = (b5 << 22 | b5 >>> 10) + c17 | 0;
        a23 += (b5 & c17 | ~b5 & d18) + k3[4] - 176418897 | 0;
        a23 = (a23 << 7 | a23 >>> 25) + b5 | 0;
        d18 += (a23 & b5 | ~a23 & c17) + k3[5] + 1200080426 | 0;
        d18 = (d18 << 12 | d18 >>> 20) + a23 | 0;
        c17 += (d18 & a23 | ~d18 & b5) + k3[6] - 1473231341 | 0;
        c17 = (c17 << 17 | c17 >>> 15) + d18 | 0;
        b5 += (c17 & d18 | ~c17 & a23) + k3[7] - 45705983 | 0;
        b5 = (b5 << 22 | b5 >>> 10) + c17 | 0;
        a23 += (b5 & c17 | ~b5 & d18) + k3[8] + 1770035416 | 0;
        a23 = (a23 << 7 | a23 >>> 25) + b5 | 0;
        d18 += (a23 & b5 | ~a23 & c17) + k3[9] - 1958414417 | 0;
        d18 = (d18 << 12 | d18 >>> 20) + a23 | 0;
        c17 += (d18 & a23 | ~d18 & b5) + k3[10] - 42063 | 0;
        c17 = (c17 << 17 | c17 >>> 15) + d18 | 0;
        b5 += (c17 & d18 | ~c17 & a23) + k3[11] - 1990404162 | 0;
        b5 = (b5 << 22 | b5 >>> 10) + c17 | 0;
        a23 += (b5 & c17 | ~b5 & d18) + k3[12] + 1804603682 | 0;
        a23 = (a23 << 7 | a23 >>> 25) + b5 | 0;
        d18 += (a23 & b5 | ~a23 & c17) + k3[13] - 40341101 | 0;
        d18 = (d18 << 12 | d18 >>> 20) + a23 | 0;
        c17 += (d18 & a23 | ~d18 & b5) + k3[14] - 1502002290 | 0;
        c17 = (c17 << 17 | c17 >>> 15) + d18 | 0;
        b5 += (c17 & d18 | ~c17 & a23) + k3[15] + 1236535329 | 0;
        b5 = (b5 << 22 | b5 >>> 10) + c17 | 0;
        a23 += (b5 & d18 | c17 & ~d18) + k3[1] - 165796510 | 0;
        a23 = (a23 << 5 | a23 >>> 27) + b5 | 0;
        d18 += (a23 & c17 | b5 & ~c17) + k3[6] - 1069501632 | 0;
        d18 = (d18 << 9 | d18 >>> 23) + a23 | 0;
        c17 += (d18 & b5 | a23 & ~b5) + k3[11] + 643717713 | 0;
        c17 = (c17 << 14 | c17 >>> 18) + d18 | 0;
        b5 += (c17 & a23 | d18 & ~a23) + k3[0] - 373897302 | 0;
        b5 = (b5 << 20 | b5 >>> 12) + c17 | 0;
        a23 += (b5 & d18 | c17 & ~d18) + k3[5] - 701558691 | 0;
        a23 = (a23 << 5 | a23 >>> 27) + b5 | 0;
        d18 += (a23 & c17 | b5 & ~c17) + k3[10] + 38016083 | 0;
        d18 = (d18 << 9 | d18 >>> 23) + a23 | 0;
        c17 += (d18 & b5 | a23 & ~b5) + k3[15] - 660478335 | 0;
        c17 = (c17 << 14 | c17 >>> 18) + d18 | 0;
        b5 += (c17 & a23 | d18 & ~a23) + k3[4] - 405537848 | 0;
        b5 = (b5 << 20 | b5 >>> 12) + c17 | 0;
        a23 += (b5 & d18 | c17 & ~d18) + k3[9] + 568446438 | 0;
        a23 = (a23 << 5 | a23 >>> 27) + b5 | 0;
        d18 += (a23 & c17 | b5 & ~c17) + k3[14] - 1019803690 | 0;
        d18 = (d18 << 9 | d18 >>> 23) + a23 | 0;
        c17 += (d18 & b5 | a23 & ~b5) + k3[3] - 187363961 | 0;
        c17 = (c17 << 14 | c17 >>> 18) + d18 | 0;
        b5 += (c17 & a23 | d18 & ~a23) + k3[8] + 1163531501 | 0;
        b5 = (b5 << 20 | b5 >>> 12) + c17 | 0;
        a23 += (b5 & d18 | c17 & ~d18) + k3[13] - 1444681467 | 0;
        a23 = (a23 << 5 | a23 >>> 27) + b5 | 0;
        d18 += (a23 & c17 | b5 & ~c17) + k3[2] - 51403784 | 0;
        d18 = (d18 << 9 | d18 >>> 23) + a23 | 0;
        c17 += (d18 & b5 | a23 & ~b5) + k3[7] + 1735328473 | 0;
        c17 = (c17 << 14 | c17 >>> 18) + d18 | 0;
        b5 += (c17 & a23 | d18 & ~a23) + k3[12] - 1926607734 | 0;
        b5 = (b5 << 20 | b5 >>> 12) + c17 | 0;
        a23 += (b5 ^ c17 ^ d18) + k3[5] - 378558 | 0;
        a23 = (a23 << 4 | a23 >>> 28) + b5 | 0;
        d18 += (a23 ^ b5 ^ c17) + k3[8] - 2022574463 | 0;
        d18 = (d18 << 11 | d18 >>> 21) + a23 | 0;
        c17 += (d18 ^ a23 ^ b5) + k3[11] + 1839030562 | 0;
        c17 = (c17 << 16 | c17 >>> 16) + d18 | 0;
        b5 += (c17 ^ d18 ^ a23) + k3[14] - 35309556 | 0;
        b5 = (b5 << 23 | b5 >>> 9) + c17 | 0;
        a23 += (b5 ^ c17 ^ d18) + k3[1] - 1530992060 | 0;
        a23 = (a23 << 4 | a23 >>> 28) + b5 | 0;
        d18 += (a23 ^ b5 ^ c17) + k3[4] + 1272893353 | 0;
        d18 = (d18 << 11 | d18 >>> 21) + a23 | 0;
        c17 += (d18 ^ a23 ^ b5) + k3[7] - 155497632 | 0;
        c17 = (c17 << 16 | c17 >>> 16) + d18 | 0;
        b5 += (c17 ^ d18 ^ a23) + k3[10] - 1094730640 | 0;
        b5 = (b5 << 23 | b5 >>> 9) + c17 | 0;
        a23 += (b5 ^ c17 ^ d18) + k3[13] + 681279174 | 0;
        a23 = (a23 << 4 | a23 >>> 28) + b5 | 0;
        d18 += (a23 ^ b5 ^ c17) + k3[0] - 358537222 | 0;
        d18 = (d18 << 11 | d18 >>> 21) + a23 | 0;
        c17 += (d18 ^ a23 ^ b5) + k3[3] - 722521979 | 0;
        c17 = (c17 << 16 | c17 >>> 16) + d18 | 0;
        b5 += (c17 ^ d18 ^ a23) + k3[6] + 76029189 | 0;
        b5 = (b5 << 23 | b5 >>> 9) + c17 | 0;
        a23 += (b5 ^ c17 ^ d18) + k3[9] - 640364487 | 0;
        a23 = (a23 << 4 | a23 >>> 28) + b5 | 0;
        d18 += (a23 ^ b5 ^ c17) + k3[12] - 421815835 | 0;
        d18 = (d18 << 11 | d18 >>> 21) + a23 | 0;
        c17 += (d18 ^ a23 ^ b5) + k3[15] + 530742520 | 0;
        c17 = (c17 << 16 | c17 >>> 16) + d18 | 0;
        b5 += (c17 ^ d18 ^ a23) + k3[2] - 995338651 | 0;
        b5 = (b5 << 23 | b5 >>> 9) + c17 | 0;
        a23 += (c17 ^ (b5 | ~d18)) + k3[0] - 198630844 | 0;
        a23 = (a23 << 6 | a23 >>> 26) + b5 | 0;
        d18 += (b5 ^ (a23 | ~c17)) + k3[7] + 1126891415 | 0;
        d18 = (d18 << 10 | d18 >>> 22) + a23 | 0;
        c17 += (a23 ^ (d18 | ~b5)) + k3[14] - 1416354905 | 0;
        c17 = (c17 << 15 | c17 >>> 17) + d18 | 0;
        b5 += (d18 ^ (c17 | ~a23)) + k3[5] - 57434055 | 0;
        b5 = (b5 << 21 | b5 >>> 11) + c17 | 0;
        a23 += (c17 ^ (b5 | ~d18)) + k3[12] + 1700485571 | 0;
        a23 = (a23 << 6 | a23 >>> 26) + b5 | 0;
        d18 += (b5 ^ (a23 | ~c17)) + k3[3] - 1894986606 | 0;
        d18 = (d18 << 10 | d18 >>> 22) + a23 | 0;
        c17 += (a23 ^ (d18 | ~b5)) + k3[10] - 1051523 | 0;
        c17 = (c17 << 15 | c17 >>> 17) + d18 | 0;
        b5 += (d18 ^ (c17 | ~a23)) + k3[1] - 2054922799 | 0;
        b5 = (b5 << 21 | b5 >>> 11) + c17 | 0;
        a23 += (c17 ^ (b5 | ~d18)) + k3[8] + 1873313359 | 0;
        a23 = (a23 << 6 | a23 >>> 26) + b5 | 0;
        d18 += (b5 ^ (a23 | ~c17)) + k3[15] - 30611744 | 0;
        d18 = (d18 << 10 | d18 >>> 22) + a23 | 0;
        c17 += (a23 ^ (d18 | ~b5)) + k3[6] - 1560198380 | 0;
        c17 = (c17 << 15 | c17 >>> 17) + d18 | 0;
        b5 += (d18 ^ (c17 | ~a23)) + k3[13] + 1309151649 | 0;
        b5 = (b5 << 21 | b5 >>> 11) + c17 | 0;
        a23 += (c17 ^ (b5 | ~d18)) + k3[4] - 145523070 | 0;
        a23 = (a23 << 6 | a23 >>> 26) + b5 | 0;
        d18 += (b5 ^ (a23 | ~c17)) + k3[11] - 1120210379 | 0;
        d18 = (d18 << 10 | d18 >>> 22) + a23 | 0;
        c17 += (a23 ^ (d18 | ~b5)) + k3[2] + 718787259 | 0;
        c17 = (c17 << 15 | c17 >>> 17) + d18 | 0;
        b5 += (d18 ^ (c17 | ~a23)) + k3[9] - 343485551 | 0;
        b5 = (b5 << 21 | b5 >>> 11) + c17 | 0;
        x2[0] = a23 + x2[0] | 0;
        x2[1] = b5 + x2[1] | 0;
        x2[2] = c17 + x2[2] | 0;
        x2[3] = d18 + x2[3] | 0;
      }
      function md5blk(s26) {
        var md5blks = [], i17;
        for (i17 = 0; i17 < 64; i17 += 4) {
          md5blks[i17 >> 2] = s26.charCodeAt(i17) + (s26.charCodeAt(i17 + 1) << 8) + (s26.charCodeAt(i17 + 2) << 16) + (s26.charCodeAt(i17 + 3) << 24);
        }
        return md5blks;
      }
      function md5blk_array(a23) {
        var md5blks = [], i17;
        for (i17 = 0; i17 < 64; i17 += 4) {
          md5blks[i17 >> 2] = a23[i17] + (a23[i17 + 1] << 8) + (a23[i17 + 2] << 16) + (a23[i17 + 3] << 24);
        }
        return md5blks;
      }
      function md51(s26) {
        var n31 = s26.length, state = [1732584193, -271733879, -1732584194, 271733878], i17, length, tail, tmp, lo, hi;
        for (i17 = 64; i17 <= n31; i17 += 64) {
          md5cycle(state, md5blk(s26.substring(i17 - 64, i17)));
        }
        s26 = s26.substring(i17 - 64);
        length = s26.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i17 = 0; i17 < length; i17 += 1) {
          tail[i17 >> 2] |= s26.charCodeAt(i17) << (i17 % 4 << 3);
        }
        tail[i17 >> 2] |= 128 << (i17 % 4 << 3);
        if (i17 > 55) {
          md5cycle(state, tail);
          for (i17 = 0; i17 < 16; i17 += 1) {
            tail[i17] = 0;
          }
        }
        tmp = n31 * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function md51_array(a23) {
        var n31 = a23.length, state = [1732584193, -271733879, -1732584194, 271733878], i17, length, tail, tmp, lo, hi;
        for (i17 = 64; i17 <= n31; i17 += 64) {
          md5cycle(state, md5blk_array(a23.subarray(i17 - 64, i17)));
        }
        a23 = i17 - 64 < n31 ? a23.subarray(i17 - 64) : new Uint8Array(0);
        length = a23.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i17 = 0; i17 < length; i17 += 1) {
          tail[i17 >> 2] |= a23[i17] << (i17 % 4 << 3);
        }
        tail[i17 >> 2] |= 128 << (i17 % 4 << 3);
        if (i17 > 55) {
          md5cycle(state, tail);
          for (i17 = 0; i17 < 16; i17 += 1) {
            tail[i17] = 0;
          }
        }
        tmp = n31 * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function rhex(n31) {
        var s26 = "", j2;
        for (j2 = 0; j2 < 4; j2 += 1) {
          s26 += hex_chr[n31 >> j2 * 8 + 4 & 15] + hex_chr[n31 >> j2 * 8 & 15];
        }
        return s26;
      }
      function hex(x2) {
        var i17;
        for (i17 = 0; i17 < x2.length; i17 += 1) {
          x2[i17] = rhex(x2[i17]);
        }
        return x2.join("");
      }
      if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
        add32 = function(x2, y5) {
          var lsw = (x2 & 65535) + (y5 & 65535), msw = (x2 >> 16) + (y5 >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        };
      }
      if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
        (function() {
          function clamp(val, length) {
            val = val | 0 || 0;
            if (val < 0) {
              return Math.max(val + length, 0);
            }
            return Math.min(val, length);
          }
          ArrayBuffer.prototype.slice = function(from, to) {
            var length = this.byteLength, begin = clamp(from, length), end = length, num2, target, targetArray, sourceArray;
            if (to !== undefined2) {
              end = clamp(to, length);
            }
            if (begin > end) {
              return new ArrayBuffer(0);
            }
            num2 = end - begin;
            target = new ArrayBuffer(num2);
            targetArray = new Uint8Array(target);
            sourceArray = new Uint8Array(this, begin, num2);
            targetArray.set(sourceArray);
            return target;
          };
        })();
      }
      function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
          str = unescape(encodeURIComponent(str));
        }
        return str;
      }
      function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i17;
        for (i17 = 0; i17 < length; i17 += 1) {
          arr[i17] = str.charCodeAt(i17);
        }
        return returnUInt8Array ? arr : buff;
      }
      function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
      }
      function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);
        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);
        return returnUInt8Array ? result : result.buffer;
      }
      function hexToBinaryString(hex2) {
        var bytes3 = [], length = hex2.length, x2;
        for (x2 = 0; x2 < length - 1; x2 += 2) {
          bytes3.push(parseInt(hex2.substr(x2, 2), 16));
        }
        return String.fromCharCode.apply(String, bytes3);
      }
      function SparkMD52() {
        this.reset();
      }
      SparkMD52.prototype.append = function(str) {
        this.appendBinary(toUtf8(str));
        return this;
      };
      SparkMD52.prototype.appendBinary = function(contents) {
        this._buff += contents;
        this._length += contents.length;
        var length = this._buff.length, i17;
        for (i17 = 64; i17 <= length; i17 += 64) {
          md5cycle(this._hash, md5blk(this._buff.substring(i17 - 64, i17)));
        }
        this._buff = this._buff.substring(i17 - 64);
        return this;
      };
      SparkMD52.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, i17, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
        for (i17 = 0; i17 < length; i17 += 1) {
          tail[i17 >> 2] |= buff.charCodeAt(i17) << (i17 % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD52.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD52.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      };
      SparkMD52.prototype.setState = function(state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;
        return this;
      };
      SparkMD52.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length;
      };
      SparkMD52.prototype._finish = function(tail, length) {
        var i17 = length, tmp, lo, hi;
        tail[i17 >> 2] |= 128 << (i17 % 4 << 3);
        if (i17 > 55) {
          md5cycle(this._hash, tail);
          for (i17 = 0; i17 < 16; i17 += 1) {
            tail[i17] = 0;
          }
        }
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
      };
      SparkMD52.hash = function(str, raw) {
        return SparkMD52.hashBinary(toUtf8(str), raw);
      };
      SparkMD52.hashBinary = function(content, raw) {
        var hash2 = md51(content), ret = hex(hash2);
        return raw ? hexToBinaryString(ret) : ret;
      };
      SparkMD52.ArrayBuffer = function() {
        this.reset();
      };
      SparkMD52.ArrayBuffer.prototype.append = function(arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i17;
        this._length += arr.byteLength;
        for (i17 = 64; i17 <= length; i17 += 64) {
          md5cycle(this._hash, md5blk_array(buff.subarray(i17 - 64, i17)));
        }
        this._buff = i17 - 64 < length ? new Uint8Array(buff.buffer.slice(i17 - 64)) : new Uint8Array(0);
        return this;
      };
      SparkMD52.ArrayBuffer.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i17, ret;
        for (i17 = 0; i17 < length; i17 += 1) {
          tail[i17 >> 2] |= buff[i17] << (i17 % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD52.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD52.ArrayBuffer.prototype.getState = function() {
        var state = SparkMD52.prototype.getState.call(this);
        state.buff = arrayBuffer2Utf8Str(state.buff);
        return state;
      };
      SparkMD52.ArrayBuffer.prototype.setState = function(state) {
        state.buff = utf8Str2ArrayBuffer(state.buff, true);
        return SparkMD52.prototype.setState.call(this, state);
      };
      SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
      SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
      SparkMD52.ArrayBuffer.hash = function(arr, raw) {
        var hash2 = md51_array(new Uint8Array(arr)), ret = hex(hash2);
        return raw ? hexToBinaryString(ret) : ret;
      };
      return SparkMD52;
    });
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i17 = 0, len = code.length; i17 < len; ++i17) {
      lookup[i17] = code[i17];
      revLookup[code.charCodeAt(i17)] = i17;
    }
    var i17;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i18;
      for (i18 = 0; i18 < len2; i18 += 4) {
        tmp = revLookup[b64.charCodeAt(i18)] << 18 | revLookup[b64.charCodeAt(i18 + 1)] << 12 | revLookup[b64.charCodeAt(i18 + 2)] << 6 | revLookup[b64.charCodeAt(i18 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i18)] << 2 | revLookup[b64.charCodeAt(i18 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i18)] << 10 | revLookup[b64.charCodeAt(i18 + 1)] << 4 | revLookup[b64.charCodeAt(i18 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num2) {
      return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i18 = start; i18 < end; i18 += 3) {
        tmp = (uint8[i18] << 16 & 16711680) + (uint8[i18 + 1] << 8 & 65280) + (uint8[i18 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i18 = 0, len22 = len2 - extraBytes; i18 < len22; i18 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i18, i18 + maxChunkLength > len22 ? len22 : i18 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE2, mLen, nBytes) {
      var e39, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i17 = isLE2 ? nBytes - 1 : 0;
      var d18 = isLE2 ? -1 : 1;
      var s26 = buffer[offset + i17];
      i17 += d18;
      e39 = s26 & (1 << -nBits) - 1;
      s26 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e39 = e39 * 256 + buffer[offset + i17], i17 += d18, nBits -= 8) {
      }
      m6 = e39 & (1 << -nBits) - 1;
      e39 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer[offset + i17], i17 += d18, nBits -= 8) {
      }
      if (e39 === 0) {
        e39 = 1 - eBias;
      } else if (e39 === eMax) {
        return m6 ? NaN : (s26 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e39 = e39 - eBias;
      }
      return (s26 ? -1 : 1) * m6 * Math.pow(2, e39 - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE2, mLen, nBytes) {
      var e39, m6, c17;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i17 = isLE2 ? 0 : nBytes - 1;
      var d18 = isLE2 ? 1 : -1;
      var s26 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m6 = isNaN(value) ? 1 : 0;
        e39 = eMax;
      } else {
        e39 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c17 = Math.pow(2, -e39)) < 1) {
          e39--;
          c17 *= 2;
        }
        if (e39 + eBias >= 1) {
          value += rt / c17;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c17 >= 2) {
          e39++;
          c17 /= 2;
        }
        if (e39 + eBias >= eMax) {
          m6 = 0;
          e39 = eMax;
        } else if (e39 + eBias >= 1) {
          m6 = (value * c17 - 1) * Math.pow(2, mLen);
          e39 = e39 + eBias;
        } else {
          m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e39 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i17] = m6 & 255, i17 += d18, m6 /= 256, mLen -= 8) {
      }
      e39 = e39 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i17] = e39 & 255, i17 += d18, e39 /= 256, eLen -= 8) {
      }
      buffer[offset + i17 - d18] |= s26 * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer5;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer5.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer5.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto36 = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto36, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto36);
        return arr.foo() === 42;
      } catch (e39) {
        return false;
      }
    }
    Object.defineProperty(Buffer5.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer5.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer5.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer5.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer5.prototype);
      return buf;
    }
    function Buffer5(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer5.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString2(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer5.from(valueOf, encodingOrOffset, length);
      }
      const b5 = fromObject(value);
      if (b5) return b5;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer5.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer5.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer5.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer5, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer5.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer5.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer5.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString2(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer5.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i17 = 0; i17 < length; i17 += 1) {
        buf[i17] = array[i17] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer5.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer5.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer5.alloc(+length);
    }
    Buffer5.isBuffer = function isBuffer(b5) {
      return b5 != null && b5._isBuffer === true && b5 !== Buffer5.prototype;
    };
    Buffer5.compare = function compare3(a23, b5) {
      if (isInstance(a23, Uint8Array)) a23 = Buffer5.from(a23, a23.offset, a23.byteLength);
      if (isInstance(b5, Uint8Array)) b5 = Buffer5.from(b5, b5.offset, b5.byteLength);
      if (!Buffer5.isBuffer(a23) || !Buffer5.isBuffer(b5)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a23 === b5) return 0;
      let x2 = a23.length;
      let y5 = b5.length;
      for (let i17 = 0, len = Math.min(x2, y5); i17 < len; ++i17) {
        if (a23[i17] !== b5[i17]) {
          x2 = a23[i17];
          y5 = b5[i17];
          break;
        }
      }
      if (x2 < y5) return -1;
      if (y5 < x2) return 1;
      return 0;
    };
    Buffer5.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer5.concat = function concat3(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer5.alloc(0);
      }
      let i17;
      if (length === void 0) {
        length = 0;
        for (i17 = 0; i17 < list.length; ++i17) {
          length += list[i17].length;
        }
      }
      const buffer = Buffer5.allocUnsafe(length);
      let pos = 0;
      for (i17 = 0; i17 < list.length; ++i17) {
        let buf = list[i17];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer5.isBuffer(buf)) buf = Buffer5.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer5.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer5.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer5.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer5.prototype._isBuffer = true;
    function swap(b5, n31, m6) {
      const i17 = b5[n31];
      b5[n31] = b5[m6];
      b5[m6] = i17;
    }
    Buffer5.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i17 = 0; i17 < len; i17 += 2) {
        swap(this, i17, i17 + 1);
      }
      return this;
    };
    Buffer5.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i17 = 0; i17 < len; i17 += 4) {
        swap(this, i17, i17 + 3);
        swap(this, i17 + 1, i17 + 2);
      }
      return this;
    };
    Buffer5.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i17 = 0; i17 < len; i17 += 8) {
        swap(this, i17, i17 + 7);
        swap(this, i17 + 1, i17 + 6);
        swap(this, i17 + 2, i17 + 5);
        swap(this, i17 + 3, i17 + 4);
      }
      return this;
    };
    Buffer5.prototype.toString = function toString2() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer5.prototype.toLocaleString = Buffer5.prototype.toString;
    Buffer5.prototype.equals = function equals2(b5) {
      if (!Buffer5.isBuffer(b5)) throw new TypeError("Argument must be a Buffer");
      if (this === b5) return true;
      return Buffer5.compare(this, b5) === 0;
    };
    Buffer5.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer5.prototype[customInspectSymbol] = Buffer5.prototype.inspect;
    }
    Buffer5.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer5.from(target, target.offset, target.byteLength);
      }
      if (!Buffer5.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y5 = end - start;
      const len = Math.min(x2, y5);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i17 = 0; i17 < len; ++i17) {
        if (thisCopy[i17] !== targetCopy[i17]) {
          x2 = thisCopy[i17];
          y5 = targetCopy[i17];
          break;
        }
      }
      if (x2 < y5) return -1;
      if (y5 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer5.from(val, encoding);
      }
      if (Buffer5.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i18) {
        if (indexSize === 1) {
          return buf[i18];
        } else {
          return buf.readUInt16BE(i18 * indexSize);
        }
      }
      let i17;
      if (dir) {
        let foundIndex = -1;
        for (i17 = byteOffset; i17 < arrLength; i17++) {
          if (read2(arr, i17) === read2(val, foundIndex === -1 ? 0 : i17 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i17;
            if (i17 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i17 -= i17 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i17 = byteOffset; i17 >= 0; i17--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read2(arr, i17 + j2) !== read2(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i17;
        }
      }
      return -1;
    }
    Buffer5.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer5.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer5.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i17;
      for (i17 = 0; i17 < length; ++i17) {
        const parsed = parseInt(string.substr(i17 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i17;
        buf[offset + i17] = parsed;
      }
      return i17;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes2(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes2(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer5.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer5.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i17 = start;
      while (i17 < end) {
        const firstByte = buf[i17];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i17 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i17 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i17 + 1];
              thirdByte = buf[i17 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i17 + 1];
              thirdByte = buf[i17 + 2];
              fourthByte = buf[i17 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i17 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i17 = 0;
      while (i17 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i17, i17 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i17 = start; i17 < end; ++i17) {
        ret += String.fromCharCode(buf[i17] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i17 = start; i17 < end; ++i17) {
        ret += String.fromCharCode(buf[i17]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i17 = start; i17 < end; ++i17) {
        out += hexSliceLookupTable[buf[i17]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes3 = buf.slice(start, end);
      let res = "";
      for (let i17 = 0; i17 < bytes3.length - 1; i17 += 2) {
        res += String.fromCharCode(bytes3[i17] + bytes3[i17 + 1] * 256);
      }
      return res;
    }
    Buffer5.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer5.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer5.prototype.readUintLE = Buffer5.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i17 = 0;
      while (++i17 < byteLength2 && (mul *= 256)) {
        val += this[offset + i17] * mul;
      }
      return val;
    };
    Buffer5.prototype.readUintBE = Buffer5.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer5.prototype.readUint8 = Buffer5.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer5.prototype.readUint16LE = Buffer5.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer5.prototype.readUint16BE = Buffer5.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer5.prototype.readUint32LE = Buffer5.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer5.prototype.readUint32BE = Buffer5.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer5.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer5.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer5.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i17 = 0;
      while (++i17 < byteLength2 && (mul *= 256)) {
        val += this[offset + i17] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer5.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i17 = byteLength2;
      let mul = 1;
      let val = this[offset + --i17];
      while (i17 > 0 && (mul *= 256)) {
        val += this[offset + --i17] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer5.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer5.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer5.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer5.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer5.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer5.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer5.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer5.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer5.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer5.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer5.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer5.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer5.prototype.writeUintLE = Buffer5.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i17 = 0;
      this[offset] = value & 255;
      while (++i17 < byteLength2 && (mul *= 256)) {
        this[offset + i17] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeUintBE = Buffer5.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i17 = byteLength2 - 1;
      let mul = 1;
      this[offset + i17] = value & 255;
      while (--i17 >= 0 && (mul *= 256)) {
        this[offset + i17] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeUint8 = Buffer5.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer5.prototype.writeUint16LE = Buffer5.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer5.prototype.writeUint16BE = Buffer5.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer5.prototype.writeUint32LE = Buffer5.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer5.prototype.writeUint32BE = Buffer5.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer5.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer5.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer5.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i17 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i17 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i17 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i17] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i17 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i17] = value & 255;
      while (--i17 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i17 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i17] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer5.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer5.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer5.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer5.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer5.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer5.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer5.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer5.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer5.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer5.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer5.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer5.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer5.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer5.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer5.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i17;
      if (typeof val === "number") {
        for (i17 = start; i17 < end; ++i17) {
          this[i17] = val;
        }
      } else {
        const bytes3 = Buffer5.isBuffer(val) ? val : Buffer5.from(val, encoding);
        const len = bytes3.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i17 = 0; i17 < end - start; ++i17) {
          this[i17 + start] = bytes3[i17 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E3(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E3(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E3(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E3(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i17 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i17 >= start + 4; i17 -= 3) {
        res = `_${val.slice(i17 - 3, i17)}${res}`;
      }
      return `${val.slice(0, i17)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n31 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n31} and < 2${n31} ** ${(byteLength2 + 1) * 8}${n31}`;
          } else {
            range = `>= -(2${n31} ** ${(byteLength2 + 1) * 8 - 1}${n31}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n31}`;
          }
        } else {
          range = `>= ${min}${n31} and <= ${max}${n31}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes3 = [];
      for (let i17 = 0; i17 < length; ++i17) {
        codePoint = string.charCodeAt(i17);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes3.push(239, 191, 189);
              continue;
            } else if (i17 + 1 === length) {
              if ((units -= 3) > -1) bytes3.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes3.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes3.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes3.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes3.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes3.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes3.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes3;
    }
    function asciiToBytes2(str) {
      const byteArray = [];
      for (let i17 = 0; i17 < str.length; ++i17) {
        byteArray.push(str.charCodeAt(i17) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c17, hi, lo;
      const byteArray = [];
      for (let i17 = 0; i17 < str.length; ++i17) {
        if ((units -= 2) < 0) break;
        c17 = str.charCodeAt(i17);
        hi = c17 >> 8;
        lo = c17 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i17;
      for (i17 = 0; i17 < length; ++i17) {
        if (i17 + offset >= dst.length || i17 >= src.length) break;
        dst[i17 + offset] = src[i17];
      }
      return i17;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i17 = 0; i17 < 16; ++i17) {
        const i162 = i17 * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i162 + j2] = alphabet[i17] + alphabet[j2];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/forge-light/lib/forge.js
var require_forge = __commonJS({
  "node_modules/forge-light/lib/forge.js"(exports2, module2) {
    module2.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/forge-light/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/forge-light/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i17 = 0;
        var base = alphabet.length;
        var first = alphabet.charAt(0);
        var digits = [0];
        for (i17 = 0; i17 < input.length; ++i17) {
          for (var j2 = 0, carry = input[i17]; j2 < digits.length; ++j2) {
            carry += digits[j2] << 8;
            digits[j2] = carry % base;
            carry = carry / base | 0;
          }
          while (carry > 0) {
            digits.push(carry % base);
            carry = carry / base | 0;
          }
        }
        for (i17 = 0; input[i17] === 0 && i17 < input.length - 1; ++i17) {
          output += first;
        }
        for (i17 = digits.length - 1; i17 >= 0; --i17) {
          output += alphabet[digits[i17]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet];
      if (!table) {
        table = _reverseAlphabets[alphabet] = [];
        for (var i17 = 0; i17 < alphabet.length; ++i17) {
          table[alphabet.charCodeAt(i17)] = i17;
        }
      }
      input = input.replace(/\s/g, "");
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var bytes3 = [0];
      for (var i17 = 0; i17 < input.length; i17++) {
        var value = table[input.charCodeAt(i17)];
        if (value === void 0) {
          return;
        }
        for (var j2 = 0, carry = value; j2 < bytes3.length; ++j2) {
          carry += bytes3[j2] * base;
          bytes3[j2] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes3.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k3 = 0; input[k3] === first && k3 < input.length - 1; ++k3) {
        bytes3.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes3.reverse());
      }
      return new Uint8Array(bytes3.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i17 = 0;
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var digits = [0];
      for (i17 = 0; i17 < input.length(); ++i17) {
        for (var j2 = 0, carry = input.at(i17); j2 < digits.length; ++j2) {
          carry += digits[j2] << 8;
          digits[j2] = carry % base;
          carry = carry / base | 0;
        }
        while (carry > 0) {
          digits.push(carry % base);
          carry = carry / base | 0;
        }
      }
      var output = "";
      for (i17 = 0; input.at(i17) === 0 && i17 < input.length() - 1; ++i17) {
        output += first;
      }
      for (i17 = digits.length - 1; i17 >= 0; --i17) {
        output += alphabet[digits[i17]];
      }
      return output;
    }
  }
});

// node_modules/forge-light/lib/util.js
var require_util = __commonJS({
  "node_modules/forge-light/lib/util.js"(exports2, module2) {
    var forge = require_forge();
    var baseN = require_baseN();
    var util = module2.exports = forge.util = forge.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util.globalScope = (function() {
      if (util.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    })();
    util.isArray = Array.isArray || function(x2) {
      return Object.prototype.toString.call(x2) === "[object Array]";
    };
    util.isArrayBuffer = function(x2) {
      return typeof ArrayBuffer !== "undefined" && x2 instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x2) {
      return x2 && util.isArrayBuffer(x2.buffer) && x2.byteLength !== void 0;
    };
    function _checkBitsParam(n31) {
      if (!(n31 === 8 || n31 === 16 || n31 === 24 || n31 === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n31);
      }
    }
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b5) {
      this.data = "";
      this.read = 0;
      if (typeof b5 === "string") {
        this.data = b5;
      } else if (util.isArrayBuffer(b5) || util.isArrayBufferView(b5)) {
        if (typeof Buffer !== "undefined" && b5 instanceof Buffer) {
          this.data = b5.toString("binary");
        } else {
          var arr = new Uint8Array(b5);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e39) {
            for (var i17 = 0; i17 < arr.length; ++i17) {
              this.putByte(arr[i17]);
            }
          }
        }
      } else if (b5 instanceof ByteStringBuffer || typeof b5 === "object" && typeof b5.data === "string" && typeof b5.read === "number") {
        this.data = b5.data;
        this.read = b5.read;
      }
      this._constructedStringLength = 0;
    }
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x2) {
      this._constructedStringLength += x2;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b5) {
      return this.putBytes(String.fromCharCode(b5));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b5, n31) {
      b5 = String.fromCharCode(b5);
      var d18 = this.data;
      while (n31 > 0) {
        if (n31 & 1) {
          d18 += b5;
        }
        n31 >>>= 1;
        if (n31 > 0) {
          b5 += b5;
        }
      }
      this.data = d18;
      this._optimizeConstructedString(n31);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes3) {
      this.data += bytes3;
      this._optimizeConstructedString(bytes3.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i17) {
      return this.putBytes(
        String.fromCharCode(i17 >> 8 & 255) + String.fromCharCode(i17 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i17) {
      return this.putBytes(
        String.fromCharCode(i17 >> 16 & 255) + String.fromCharCode(i17 >> 8 & 255) + String.fromCharCode(i17 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i17) {
      return this.putBytes(
        String.fromCharCode(i17 >> 24 & 255) + String.fromCharCode(i17 >> 16 & 255) + String.fromCharCode(i17 >> 8 & 255) + String.fromCharCode(i17 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i17) {
      return this.putBytes(
        String.fromCharCode(i17 & 255) + String.fromCharCode(i17 >> 8 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i17) {
      return this.putBytes(
        String.fromCharCode(i17 & 255) + String.fromCharCode(i17 >> 8 & 255) + String.fromCharCode(i17 >> 16 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i17) {
      return this.putBytes(
        String.fromCharCode(i17 & 255) + String.fromCharCode(i17 >> 8 & 255) + String.fromCharCode(i17 >> 16 & 255) + String.fromCharCode(i17 >> 24 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt = function(i17, n31) {
      _checkBitsParam(n31);
      var bytes3 = "";
      do {
        n31 -= 8;
        bytes3 += String.fromCharCode(i17 >> n31 & 255);
      } while (n31 > 0);
      return this.putBytes(bytes3);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i17, n31) {
      if (i17 < 0) {
        i17 += 2 << n31 - 1;
      }
      return this.putInt(i17, n31);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n31) {
      _checkBitsParam(n31);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n31 -= 8;
      } while (n31 > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n31) {
      var x2 = this.getInt(n31);
      var max = 2 << n31 - 2;
      if (x2 >= max) {
        x2 -= max << 1;
      }
      return x2;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.ByteStringBuffer.prototype.at = function(i17) {
      return this.data.charCodeAt(this.read + i17);
    };
    util.ByteStringBuffer.prototype.setAt = function(i17, b5) {
      this.data = this.data.substr(0, this.read + i17) + String.fromCharCode(b5) + this.data.substr(this.read + i17 + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c17 = util.createBuffer(this.data);
      c17.read = this.read;
      return c17;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i17 = this.read; i17 < this.data.length; ++i17) {
        var b5 = this.data.charCodeAt(i17);
        if (b5 < 16) {
          rval += "0";
        }
        rval += b5.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b5, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b5);
      var isArrayBufferView = util.isArrayBufferView(b5);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b5);
        } else {
          this.data = new DataView(b5.buffer, b5.byteOffset, b5.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b5 !== null && b5 !== void 0) {
        this.putBytes(b5);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b5) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b5);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b5, n31) {
      this.accommodate(n31);
      for (var i17 = 0; i17 < n31; ++i17) {
        this.data.setUint8(b5);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes3, encoding) {
      if (util.isArrayBufferView(bytes3)) {
        var src = new Uint8Array(bytes3.buffer, bytes3.byteOffset, bytes3.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes3)) {
        var src = new Uint8Array(bytes3);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
      }
      if (bytes3 instanceof util.DataBuffer || typeof bytes3 === "object" && typeof bytes3.read === "number" && typeof bytes3.write === "number" && util.isArrayBufferView(bytes3.data)) {
        var src = new Uint8Array(bytes3.data.byteLength, bytes3.read, bytes3.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes3.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
      }
      if (bytes3 instanceof util.ByteStringBuffer) {
        bytes3 = bytes3.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes3 === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes3.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes3, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes3.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes3, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes3 = util.encodeUtf8(bytes3);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes3.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes3.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes3);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util.DataBuffer.prototype.putInt16 = function(i17) {
      this.accommodate(2);
      this.data.setInt16(this.write, i17);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i17) {
      this.accommodate(3);
      this.data.setInt16(this.write, i17 >> 8 & 65535);
      this.data.setInt8(this.write, i17 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i17) {
      this.accommodate(4);
      this.data.setInt32(this.write, i17);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i17) {
      this.accommodate(2);
      this.data.setInt16(this.write, i17, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i17) {
      this.accommodate(3);
      this.data.setInt8(this.write, i17 >> 16 & 255);
      this.data.setInt16(this.write, i17 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i17) {
      this.accommodate(4);
      this.data.setInt32(this.write, i17, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i17, n31) {
      _checkBitsParam(n31);
      this.accommodate(n31 / 8);
      do {
        n31 -= 8;
        this.data.setInt8(this.write++, i17 >> n31 & 255);
      } while (n31 > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i17, n31) {
      _checkBitsParam(n31);
      this.accommodate(n31 / 8);
      if (i17 < 0) {
        i17 += 2 << n31 - 1;
      }
      return this.putInt(i17, n31);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n31) {
      _checkBitsParam(n31);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n31 -= 8;
      } while (n31 > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n31) {
      var x2 = this.getInt(n31);
      var max = 2 << n31 - 2;
      if (x2 >= max) {
        x2 -= max << 1;
      }
      return x2;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.DataBuffer.prototype.at = function(i17) {
      return this.data.getUint8(this.read + i17);
    };
    util.DataBuffer.prototype.setAt = function(i17, b5) {
      this.data.setUint8(i17, b5);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i17 = this.read; i17 < this.data.byteLength; ++i17) {
        var b5 = this.data.getUint8(i17);
        if (b5 < 16) {
          rval += "0";
        }
        rval += b5.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c17, n31) {
      var s26 = "";
      while (n31 > 0) {
        if (n31 & 1) {
          s26 += c17;
        }
        n31 >>>= 1;
        if (n31 > 0) {
          c17 += c17;
        }
      }
      return s26;
    };
    util.xorBytes = function(s1, s26, n31) {
      var s32 = "";
      var b5 = "";
      var t35 = "";
      var i17 = 0;
      var c17 = 0;
      for (; n31 > 0; --n31, ++i17) {
        b5 = s1.charCodeAt(i17) ^ s26.charCodeAt(i17);
        if (c17 >= 10) {
          s32 += t35;
          t35 = "";
          c17 = 0;
        }
        t35 += String.fromCharCode(b5);
        ++c17;
      }
      s32 += t35;
      return s32;
    };
    util.hexToBytes = function(hex) {
      var rval = "";
      var i17 = 0;
      if (hex.length & true) {
        i17 = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i17 < hex.length; i17 += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i17, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes3) {
      return util.createBuffer(bytes3).toHex();
    };
    util.int32ToBytes = function(i17) {
      return String.fromCharCode(i17 >> 24 & 255) + String.fromCharCode(i17 >> 16 & 255) + String.fromCharCode(i17 >> 8 & 255) + String.fromCharCode(i17 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i17 = 0;
      while (i17 < input.length) {
        chr1 = input.charCodeAt(i17++);
        chr2 = input.charCodeAt(i17++);
        chr3 = input.charCodeAt(i17++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i17 = 0;
      while (i17 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i17++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i17++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i17++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i17++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util.binary.raw.encode = function(bytes3) {
      return String.fromCharCode.apply(null, bytes3);
    };
    util.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j2 = offset;
      for (var i17 = 0; i17 < str.length; ++i17) {
        out[j2++] = str.charCodeAt(i17);
      }
      return output ? j2 - offset : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i17 = 0, j2 = offset;
      if (hex.length & 1) {
        i17 = 1;
        out[j2++] = parseInt(hex[0], 16);
      }
      for (; i17 < hex.length; i17 += 2) {
        out[j2++] = parseInt(hex.substr(i17, 2), 16);
      }
      return output ? j2 - offset : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i17 = 0;
      while (i17 < input.byteLength) {
        chr1 = input[i17++];
        chr2 = input[i17++];
        chr3 = input[i17++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i17 = 0, j2 = offset;
      while (i17 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i17++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i17++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i17++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i17++) - 43];
        out[j2++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j2++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j2 - offset : out.subarray(0, j2);
    };
    util.binary.base58.encode = function(input, maxline) {
      return util.binary.baseN.encode(input, _base58, maxline);
    };
    util.binary.base58.decode = function(input, maxline) {
      return util.binary.baseN.decode(input, _base58, maxline);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j2 = offset;
      for (var i17 = 0; i17 < str.length; ++i17) {
        out[j2++] = str.charCodeAt(i17);
      }
      return output ? j2 - offset : out;
    };
    util.text.utf8.decode = function(bytes3) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes3));
    };
    util.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j2 = offset;
      var k3 = offset;
      for (var i17 = 0; i17 < str.length; ++i17) {
        view[k3++] = str.charCodeAt(i17);
        j2 += 2;
      }
      return output ? j2 - offset : out;
    };
    util.text.utf16.decode = function(bytes3) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes3.buffer));
    };
    util.deflate = function(api, bytes3, raw) {
      bytes3 = util.decode64(api.deflate(util.encode64(bytes3)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes3.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes3 = bytes3.substring(start, bytes3.length - 4);
      }
      return bytes3;
    };
    util.inflate = function(api, bytes3, raw) {
      var rval = api.inflate(util.encode64(bytes3)).rval;
      return rval === null ? null : util.decode64(rval);
    };
    var _setStorageObject = function(api, id2, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id2);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id2, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id2) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id2);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id2, key, data) {
      var obj = _getStorageObject(api, id2);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id2, obj);
    };
    var _getItem = function(api, id2, key) {
      var rval = _getStorageObject(api, id2);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id2, key) {
      var obj = _getStorageObject(api, id2);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty = true;
        for (var prop in obj) {
          empty = false;
          break;
        }
        if (empty) {
          obj = null;
        }
        _setStorageObject(api, id2, obj);
      }
    };
    var _clearItems = function(api, id2) {
      _setStorageObject(api, id2, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util.setItem = function(api, id2, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util.getItem = function(api, id2, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util.removeItem = function(api, id2, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util.clearItems = function(api, id2, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match = re.exec(format)) {
        part = format.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code = match[0][1];
        switch (code) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          // FIXME: do proper formating for numbers, etc
          //case 'f':
          //case 'd':
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code + "?>");
        }
      }
      parts.push(format.substring(last));
      return parts.join("");
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n31 = number, c17 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d18 = dec_point === void 0 ? "," : dec_point;
      var t35 = thousands_sep === void 0 ? "." : thousands_sep, s26 = n31 < 0 ? "-" : "";
      var i17 = parseInt(n31 = Math.abs(+n31 || 0).toFixed(c17), 10) + "";
      var j2 = i17.length > 3 ? i17.length % 3 : 0;
      return s26 + (j2 ? i17.substr(0, j2) + t35 : "") + i17.substr(j2).replace(/(\d{3})(?=\d)/g, "$1" + t35) + (c17 ? d18 + Math.abs(n31 - i17).toFixed(c17).slice(2) : "");
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b5 = util.createBuffer();
      for (var i17 = 0; i17 < ip.length; ++i17) {
        var num2 = parseInt(ip[i17], 10);
        if (isNaN(num2)) {
          return null;
        }
        b5.putByte(num2);
      }
      return b5.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e39) {
        if (e39.length === 0) ++blanks;
        return true;
      });
      var zeros2 = (8 - ip.length + blanks) * 2;
      var b5 = util.createBuffer();
      for (var i17 = 0; i17 < 8; ++i17) {
        if (!ip[i17] || ip[i17].length === 0) {
          b5.fillWithByte(0, zeros2);
          zeros2 = 0;
          continue;
        }
        var bytes3 = util.hexToBytes(ip[i17]);
        if (bytes3.length < 2) {
          b5.putByte(0);
        }
        b5.putBytes(bytes3);
      }
      return b5.getBytes();
    };
    util.bytesToIP = function(bytes3) {
      if (bytes3.length === 4) {
        return util.bytesToIPv4(bytes3);
      }
      if (bytes3.length === 16) {
        return util.bytesToIPv6(bytes3);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes3) {
      if (bytes3.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i17 = 0; i17 < bytes3.length; ++i17) {
        ip.push(bytes3.charCodeAt(i17));
      }
      return ip.join(".");
    };
    util.bytesToIPv6 = function(bytes3) {
      if (bytes3.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i17 = 0; i17 < bytes3.length; i17 += 2) {
        var hex = util.bytesToHex(bytes3[i17] + bytes3[i17 + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === "undefined") {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === "undefined") {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        (function() {
          self.addEventListener("message", function(e39) {
            var st = Date.now();
            var et = st + 4;
            while (Date.now() < et) ;
            self.postMessage({ st, et });
          });
        }).toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x2) {
            return avg2 + x2;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i17 = 0; i17 < numWorkers; ++i17) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e39) {
            results.push(e39.data);
            if (results.length === numWorkers) {
              for (var i18 = 0; i18 < numWorkers; ++i18) {
                workers[i18].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i17 = 0; i17 < numWorkers; ++i17) {
          workers[i17].postMessage(i17);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n31 = 0; n31 < numWorkers; ++n31) {
          var r1 = results[n31];
          var overlap = overlaps[n31] = [];
          for (var i17 = 0; i17 < numWorkers; ++i17) {
            if (n31 === i17) {
              continue;
            }
            var r210 = results[i17];
            if (r1.st > r210.st && r1.st < r210.et || r210.st > r1.st && r210.st < r1.et) {
              overlap.push(i17);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/forge-light/lib/pem.js
var require_pem = __commonJS({
  "node_modules/forge-light/lib/pem.js"(exports2, module2) {
    var forge = require_forge();
    require_util();
    var pem = module2.exports = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i17 = 0; i17 < msg.headers.length; ++i17) {
          rval += foldHeader(msg.headers[i17]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i17 = 0; i17 < header.values.length; ++i17) {
        values.push(header.values[i17].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length = 0;
      var candidate = -1;
      for (var i17 = 0; i17 < rval.length; ++i17, ++length) {
        if (length > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length = i17 - candidate - 1;
          candidate = -1;
          ++i17;
        } else if (rval[i17] === " " || rval[i17] === "	" || rval[i17] === ",") {
          candidate = i17;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// browser-external:buffer
var require_buffer2 = __commonJS({
  "browser-external:buffer"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_4, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports3.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer5;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer5 = window.Buffer;
        } else {
          Buffer5 = require_buffer2().Buffer;
        }
      } catch (e39) {
      }
      BN2.isBN = function isBN(num2) {
        if (num2 instanceof BN2) {
          return true;
        }
        return num2 !== null && typeof num2 === "object" && num2.constructor.wordSize === BN2.wordSize && Array.isArray(num2.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i17 = 0; i17 < this.length; i17++) {
          this.words[i17] = 0;
        }
        var j2, w5;
        var off = 0;
        if (endian === "be") {
          for (i17 = number.length - 1, j2 = 0; i17 >= 0; i17 -= 3) {
            w5 = number[i17] | number[i17 - 1] << 8 | number[i17 - 2] << 16;
            this.words[j2] |= w5 << off & 67108863;
            this.words[j2 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i17 = 0, j2 = 0; i17 < number.length; i17 += 3) {
            w5 = number[i17] | number[i17 + 1] << 8 | number[i17 + 2] << 16;
            this.words[j2] |= w5 << off & 67108863;
            this.words[j2 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c17 = string.charCodeAt(index);
        if (c17 >= 48 && c17 <= 57) {
          return c17 - 48;
        } else if (c17 >= 65 && c17 <= 70) {
          return c17 - 55;
        } else if (c17 >= 97 && c17 <= 102) {
          return c17 - 87;
        } else {
          assert(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r41 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r41 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r41;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i17 = 0; i17 < this.length; i17++) {
          this.words[i17] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w5;
        if (endian === "be") {
          for (i17 = number.length - 1; i17 >= start; i17 -= 2) {
            w5 = parseHexByte(number, start, i17) << off;
            this.words[j2] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i17 = parseLength % 2 === 0 ? start + 1 : start; i17 < number.length; i17 += 2) {
            w5 = parseHexByte(number, start, i17) << off;
            this.words[j2] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r41 = 0;
        var b5 = 0;
        var len = Math.min(str.length, end);
        for (var i17 = start; i17 < len; i17++) {
          var c17 = str.charCodeAt(i17) - 48;
          r41 *= mul;
          if (c17 >= 49) {
            b5 = c17 - 49 + 10;
          } else if (c17 >= 17) {
            b5 = c17 - 17 + 10;
          } else {
            b5 = c17;
          }
          assert(c17 >= 0 && b5 < mul, "Invalid character");
          r41 += b5;
        }
        return r41;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod3 = total % limbLen;
        var end = Math.min(total, total - mod3) + start;
        var word = 0;
        for (var i17 = start; i17 < end; i17 += limbLen) {
          word = parseBase(number, i17, i17 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod3 !== 0) {
          var pow = 1;
          word = parseBase(number, i17, number.length, base);
          for (i17 = 0; i17 < mod3; i17++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i17 = 0; i17 < this.length; i17++) {
          dest.words[i17] = this.words[i17];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone2() {
        var r41 = new BN2(null);
        this.copy(r41);
        return r41;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e39) {
          BN2.prototype.inspect = inspect;
        }
      } else {
        BN2.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString2(base, padding2) {
        base = base || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i17 = 0; i17 < this.length; i17++) {
            var w5 = this.words[i17];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i17--;
            }
            if (carry !== 0 || i17 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c17 = this.clone();
          c17.negative = 0;
          while (!c17.isZero()) {
            var r41 = c17.modrn(groupBase).toString(base);
            c17 = c17.idivn(groupBase);
            if (!c17.isZero()) {
              out = zeros2[groupSize - r41.length] + r41 + out;
            } else {
              out = r41 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber2() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer5) {
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer5, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i17 = 0, shift = 0; i17 < this.length; i17++) {
          var word = this.words[i17] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i17 = 0, shift = 0; i17 < this.length; i17++) {
          var word = this.words[i17] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w5) {
          var t35 = w5;
          var r41 = 0;
          if (t35 >= 4096) {
            r41 += 13;
            t35 >>>= 13;
          }
          if (t35 >= 64) {
            r41 += 7;
            t35 >>>= 7;
          }
          if (t35 >= 8) {
            r41 += 4;
            t35 >>>= 4;
          }
          if (t35 >= 2) {
            r41 += 2;
            t35 >>>= 2;
          }
          return r41 + t35;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0) return 26;
        var t35 = w5;
        var r41 = 0;
        if ((t35 & 8191) === 0) {
          r41 += 13;
          t35 >>>= 13;
        }
        if ((t35 & 127) === 0) {
          r41 += 7;
          t35 >>>= 7;
        }
        if ((t35 & 15) === 0) {
          r41 += 4;
          t35 >>>= 4;
        }
        if ((t35 & 3) === 0) {
          r41 += 2;
          t35 >>>= 2;
        }
        if ((t35 & 1) === 0) {
          r41++;
        }
        return r41;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi = this._countBits(w5);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num2) {
        var w5 = new Array(num2.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = num2.words[off] >>> wbit & 1;
        }
        return w5;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r41 = 0;
        for (var i17 = 0; i17 < this.length; i17++) {
          var b5 = this._zeroBits(this.words[i17]);
          r41 += b5;
          if (b5 !== 26) break;
        }
        return r41;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num2) {
        while (this.length < num2.length) {
          this.words[this.length++] = 0;
        }
        for (var i17 = 0; i17 < num2.length; i17++) {
          this.words[i17] = this.words[i17] | num2.words[i17];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num2) {
        assert((this.negative | num2.negative) === 0);
        return this.iuor(num2);
      };
      BN2.prototype.or = function or2(num2) {
        if (this.length > num2.length) return this.clone().ior(num2);
        return num2.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num2) {
        if (this.length > num2.length) return this.clone().iuor(num2);
        return num2.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num2) {
        var b5;
        if (this.length > num2.length) {
          b5 = num2;
        } else {
          b5 = this;
        }
        for (var i17 = 0; i17 < b5.length; i17++) {
          this.words[i17] = this.words[i17] & num2.words[i17];
        }
        this.length = b5.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num2) {
        assert((this.negative | num2.negative) === 0);
        return this.iuand(num2);
      };
      BN2.prototype.and = function and2(num2) {
        if (this.length > num2.length) return this.clone().iand(num2);
        return num2.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num2) {
        if (this.length > num2.length) return this.clone().iuand(num2);
        return num2.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num2) {
        var a23;
        var b5;
        if (this.length > num2.length) {
          a23 = this;
          b5 = num2;
        } else {
          a23 = num2;
          b5 = this;
        }
        for (var i17 = 0; i17 < b5.length; i17++) {
          this.words[i17] = a23.words[i17] ^ b5.words[i17];
        }
        if (this !== a23) {
          for (; i17 < a23.length; i17++) {
            this.words[i17] = a23.words[i17];
          }
        }
        this.length = a23.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num2) {
        assert((this.negative | num2.negative) === 0);
        return this.iuxor(num2);
      };
      BN2.prototype.xor = function xor2(num2) {
        if (this.length > num2.length) return this.clone().ixor(num2);
        return num2.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num2) {
        if (this.length > num2.length) return this.clone().iuxor(num2);
        return num2.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i17 = 0; i17 < bytesNeeded; i17++) {
          this.words[i17] = ~this.words[i17] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i17] = ~this.words[i17] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num2) {
        var r41;
        if (this.negative !== 0 && num2.negative === 0) {
          this.negative = 0;
          r41 = this.isub(num2);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num2.negative !== 0) {
          num2.negative = 0;
          r41 = this.isub(num2);
          num2.negative = 1;
          return r41._normSign();
        }
        var a23, b5;
        if (this.length > num2.length) {
          a23 = this;
          b5 = num2;
        } else {
          a23 = num2;
          b5 = this;
        }
        var carry = 0;
        for (var i17 = 0; i17 < b5.length; i17++) {
          r41 = (a23.words[i17] | 0) + (b5.words[i17] | 0) + carry;
          this.words[i17] = r41 & 67108863;
          carry = r41 >>> 26;
        }
        for (; carry !== 0 && i17 < a23.length; i17++) {
          r41 = (a23.words[i17] | 0) + carry;
          this.words[i17] = r41 & 67108863;
          carry = r41 >>> 26;
        }
        this.length = a23.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a23 !== this) {
          for (; i17 < a23.length; i17++) {
            this.words[i17] = a23.words[i17];
          }
        }
        return this;
      };
      BN2.prototype.add = function add3(num2) {
        var res;
        if (num2.negative !== 0 && this.negative === 0) {
          num2.negative = 0;
          res = this.sub(num2);
          num2.negative ^= 1;
          return res;
        } else if (num2.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num2.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num2.length) return this.clone().iadd(num2);
        return num2.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num2) {
        if (num2.negative !== 0) {
          num2.negative = 0;
          var r41 = this.iadd(num2);
          num2.negative = 1;
          return r41._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num2);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num2);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a23, b5;
        if (cmp > 0) {
          a23 = this;
          b5 = num2;
        } else {
          a23 = num2;
          b5 = this;
        }
        var carry = 0;
        for (var i17 = 0; i17 < b5.length; i17++) {
          r41 = (a23.words[i17] | 0) - (b5.words[i17] | 0) + carry;
          carry = r41 >> 26;
          this.words[i17] = r41 & 67108863;
        }
        for (; carry !== 0 && i17 < a23.length; i17++) {
          r41 = (a23.words[i17] | 0) + carry;
          carry = r41 >> 26;
          this.words[i17] = r41 & 67108863;
        }
        if (carry === 0 && i17 < a23.length && a23 !== this) {
          for (; i17 < a23.length; i17++) {
            this.words[i17] = a23.words[i17];
          }
        }
        this.length = Math.max(this.length, i17);
        if (a23 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num2) {
        return this.clone().isub(num2);
      };
      function smallMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        var len = self2.length + num2.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a23 = self2.words[0] | 0;
        var b5 = num2.words[0] | 0;
        var r41 = a23 * b5;
        var lo = r41 & 67108863;
        var carry = r41 / 67108864 | 0;
        out.words[0] = lo;
        for (var k3 = 1; k3 < len; k3++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num2.length - 1);
          for (var j2 = Math.max(0, k3 - self2.length + 1); j2 <= maxJ; j2++) {
            var i17 = k3 - j2 | 0;
            a23 = self2.words[i17] | 0;
            b5 = num2.words[j2] | 0;
            r41 = a23 * b5 + rword;
            ncarry += r41 / 67108864 | 0;
            rword = r41 & 67108863;
          }
          out.words[k3] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k3] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num2, out) {
        var a23 = self2.words;
        var b5 = num2.words;
        var o32 = out.words;
        var c17 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a23[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a23[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a24 = a23[2] | 0;
        var al2 = a24 & 8191;
        var ah2 = a24 >>> 13;
        var a32 = a23[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a23[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a52 = a23[5] | 0;
        var al5 = a52 & 8191;
        var ah5 = a52 >>> 13;
        var a62 = a23[6] | 0;
        var al6 = a62 & 8191;
        var ah6 = a62 >>> 13;
        var a72 = a23[7] | 0;
        var al7 = a72 & 8191;
        var ah7 = a72 >>> 13;
        var a82 = a23[8] | 0;
        var al8 = a82 & 8191;
        var ah8 = a82 >>> 13;
        var a92 = a23[9] | 0;
        var al9 = a92 & 8191;
        var ah9 = a92 >>> 13;
        var b0 = b5[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b5[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b5[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b5[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b5[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b5[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b6 = b5[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b5[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b5[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b5[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num2.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c17 + lo | 0) + ((mid & 8191) << 13) | 0;
        c17 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o32[0] = w0;
        o32[1] = w1;
        o32[2] = w22;
        o32[3] = w32;
        o32[4] = w42;
        o32[5] = w5;
        o32[6] = w6;
        o32[7] = w7;
        o32[8] = w8;
        o32[9] = w9;
        o32[10] = w10;
        o32[11] = w11;
        o32[12] = w12;
        o32[13] = w13;
        o32[14] = w14;
        o32[15] = w15;
        o32[16] = w16;
        o32[17] = w17;
        o32[18] = w18;
        if (c17 !== 0) {
          o32[19] = c17;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num2, out) {
        out.negative = num2.negative ^ self2.negative;
        out.length = self2.length + num2.length;
        var carry = 0;
        var hncarry = 0;
        for (var k3 = 0; k3 < out.length - 1; k3++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k3, num2.length - 1);
          for (var j2 = Math.max(0, k3 - self2.length + 1); j2 <= maxJ; j2++) {
            var i17 = k3 - j2;
            var a23 = self2.words[i17] | 0;
            var b5 = num2.words[j2] | 0;
            var r41 = a23 * b5;
            var lo = r41 & 67108863;
            ncarry = ncarry + (r41 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k3] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k3] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num2, out) {
        return bigMulTo(self2, num2, out);
      }
      BN2.prototype.mulTo = function mulTo(num2, out) {
        var res;
        var len = this.length + num2.length;
        if (this.length === 10 && num2.length === 10) {
          res = comb10MulTo(this, num2, out);
        } else if (len < 63) {
          res = smallMulTo(this, num2, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num2, out);
        } else {
          res = jumboMulTo(this, num2, out);
        }
        return res;
      };
      function FFTM(x2, y5) {
        this.x = x2;
        this.y = y5;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t35 = new Array(N4);
        var l19 = BN2.prototype._countBits(N4) - 1;
        for (var i17 = 0; i17 < N4; i17++) {
          t35[i17] = this.revBin(i17, l19, N4);
        }
        return t35;
      };
      FFTM.prototype.revBin = function revBin(x2, l19, N4) {
        if (x2 === 0 || x2 === N4 - 1) return x2;
        var rb = 0;
        for (var i17 = 0; i17 < l19; i17++) {
          rb |= (x2 & 1) << l19 - i17 - 1;
          x2 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i17 = 0; i17 < N4; i17++) {
          rtws[i17] = rws[rbt[i17]];
          itws[i17] = iws[rbt[i17]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s26 = 1; s26 < N4; s26 <<= 1) {
          var l19 = s26 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l19);
          var itwdf = Math.sin(2 * Math.PI / l19);
          for (var p3 = 0; p3 < N4; p3 += l19) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j2 = 0; j2 < s26; j2++) {
              var re = rtws[p3 + j2];
              var ie = itws[p3 + j2];
              var ro = rtws[p3 + j2 + s26];
              var io = itws[p3 + j2 + s26];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p3 + j2] = re + ro;
              itws[p3 + j2] = ie + io;
              rtws[p3 + j2 + s26] = re - ro;
              itws[p3 + j2 + s26] = ie - io;
              if (j2 !== l19) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n31, m6) {
        var N4 = Math.max(m6, n31) | 1;
        var odd = N4 & 1;
        var i17 = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i17++;
        }
        return 1 << i17 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1) return;
        for (var i17 = 0; i17 < N4 / 2; i17++) {
          var t35 = rws[i17];
          rws[i17] = rws[N4 - i17 - 1];
          rws[N4 - i17 - 1] = t35;
          t35 = iws[i17];
          iws[i17] = -iws[N4 - i17 - 1];
          iws[N4 - i17 - 1] = -t35;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i17 = 0; i17 < N4 / 2; i17++) {
          var w5 = Math.round(ws[2 * i17 + 1] / N4) * 8192 + Math.round(ws[2 * i17] / N4) + carry;
          ws[i17] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i17 = 0; i17 < len; i17++) {
          carry = carry + (ws[i17] | 0);
          rws[2 * i17] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i17 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i17 = 2 * len; i17 < N4; ++i17) {
          rws[i17] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i17 = 0; i17 < N4; i17++) {
          ph[i17] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x2, y5, out) {
        var N4 = 2 * this.guessLen13b(x2.length, y5.length);
        var rbt = this.makeRBT(N4);
        var _4 = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x2.words, x2.length, rws, N4);
        this.convert13b(y5.words, y5.length, nrws, N4);
        this.transform(rws, _4, rwst, iwst, N4, rbt);
        this.transform(nrws, _4, nrwst, niwst, N4, rbt);
        for (var i17 = 0; i17 < N4; i17++) {
          var rx = rwst[i17] * nrwst[i17] - iwst[i17] * niwst[i17];
          iwst[i17] = rwst[i17] * niwst[i17] + iwst[i17] * nrwst[i17];
          rwst[i17] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _4, N4, rbt);
        this.conjugate(rmws, _4, N4);
        this.normalize13b(rmws, N4);
        out.negative = x2.negative ^ y5.negative;
        out.length = x2.length + y5.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num2) {
        var out = new BN2(null);
        out.words = new Array(this.length + num2.length);
        return this.mulTo(num2, out);
      };
      BN2.prototype.mulf = function mulf(num2) {
        var out = new BN2(null);
        out.words = new Array(this.length + num2.length);
        return jumboMulTo(this, num2, out);
      };
      BN2.prototype.imul = function imul(num2) {
        return this.clone().mulTo(num2, this);
      };
      BN2.prototype.imuln = function imuln(num2) {
        var isNegNum = num2 < 0;
        if (isNegNum) num2 = -num2;
        assert(typeof num2 === "number");
        assert(num2 < 67108864);
        var carry = 0;
        for (var i17 = 0; i17 < this.length; i17++) {
          var w5 = (this.words[i17] | 0) * num2;
          var lo = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i17] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i17] = carry;
          this.length++;
        }
        this.length = num2 === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num2) {
        return this.clone().imuln(num2);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num2) {
        var w5 = toBitArray(num2);
        if (w5.length === 0) return new BN2(1);
        var res = this;
        for (var i17 = 0; i17 < w5.length; i17++, res = res.sqr()) {
          if (w5[i17] !== 0) break;
        }
        if (++i17 < w5.length) {
          for (var q = res.sqr(); i17 < w5.length; i17++, q = q.sqr()) {
            if (w5[i17] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r41 = bits % 26;
        var s26 = (bits - r41) / 26;
        var carryMask = 67108863 >>> 26 - r41 << 26 - r41;
        var i17;
        if (r41 !== 0) {
          var carry = 0;
          for (i17 = 0; i17 < this.length; i17++) {
            var newCarry = this.words[i17] & carryMask;
            var c17 = (this.words[i17] | 0) - newCarry << r41;
            this.words[i17] = c17 | carry;
            carry = newCarry >>> 26 - r41;
          }
          if (carry) {
            this.words[i17] = carry;
            this.length++;
          }
        }
        if (s26 !== 0) {
          for (i17 = this.length - 1; i17 >= 0; i17--) {
            this.words[i17 + s26] = this.words[i17];
          }
          for (i17 = 0; i17 < s26; i17++) {
            this.words[i17] = 0;
          }
          this.length += s26;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h8;
        if (hint) {
          h8 = (hint - hint % 26) / 26;
        } else {
          h8 = 0;
        }
        var r41 = bits % 26;
        var s26 = Math.min((bits - r41) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r41 << r41;
        var maskedWords = extended;
        h8 -= s26;
        h8 = Math.max(0, h8);
        if (maskedWords) {
          for (var i17 = 0; i17 < s26; i17++) {
            maskedWords.words[i17] = this.words[i17];
          }
          maskedWords.length = s26;
        }
        if (s26 === 0) {
        } else if (this.length > s26) {
          this.length -= s26;
          for (i17 = 0; i17 < this.length; i17++) {
            this.words[i17] = this.words[i17 + s26];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i17 = this.length - 1; i17 >= 0 && (carry !== 0 || i17 >= h8); i17--) {
          var word = this.words[i17] | 0;
          this.words[i17] = carry << 26 - r41 | word >>> r41;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r41 = bit % 26;
        var s26 = (bit - r41) / 26;
        var q = 1 << r41;
        if (this.length <= s26) return false;
        var w5 = this.words[s26];
        return !!(w5 & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r41 = bits % 26;
        var s26 = (bits - r41) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s26) {
          return this;
        }
        if (r41 !== 0) {
          s26++;
        }
        this.length = Math.min(s26, this.length);
        if (r41 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r41 << r41;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num2) {
        assert(typeof num2 === "number");
        assert(num2 < 67108864);
        if (num2 < 0) return this.isubn(-num2);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num2) {
            this.words[0] = num2 - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num2);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num2);
      };
      BN2.prototype._iaddn = function _iaddn(num2) {
        this.words[0] += num2;
        for (var i17 = 0; i17 < this.length && this.words[i17] >= 67108864; i17++) {
          this.words[i17] -= 67108864;
          if (i17 === this.length - 1) {
            this.words[i17 + 1] = 1;
          } else {
            this.words[i17 + 1]++;
          }
        }
        this.length = Math.max(this.length, i17 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num2) {
        assert(typeof num2 === "number");
        assert(num2 < 67108864);
        if (num2 < 0) return this.iaddn(-num2);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num2);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num2;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i17 = 0; i17 < this.length && this.words[i17] < 0; i17++) {
            this.words[i17] += 67108864;
            this.words[i17 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num2) {
        return this.clone().iaddn(num2);
      };
      BN2.prototype.subn = function subn(num2) {
        return this.clone().isubn(num2);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num2, mul, shift) {
        var len = num2.length + shift;
        var i17;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i17 = 0; i17 < num2.length; i17++) {
          w5 = (this.words[i17 + shift] | 0) + carry;
          var right = (num2.words[i17] | 0) * mul;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i17 + shift] = w5 & 67108863;
        }
        for (; i17 < this.length - shift; i17++) {
          w5 = (this.words[i17 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i17 + shift] = w5 & 67108863;
        }
        if (carry === 0) return this._strip();
        assert(carry === -1);
        carry = 0;
        for (i17 = 0; i17 < this.length; i17++) {
          w5 = -(this.words[i17] | 0) + carry;
          carry = w5 >> 26;
          this.words[i17] = w5 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num2, mode) {
        var shift = this.length - num2.length;
        var a23 = this.clone();
        var b5 = num2;
        var bhi = b5.words[b5.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b5 = b5.ushln(shift);
          a23.iushln(shift);
          bhi = b5.words[b5.length - 1] | 0;
        }
        var m6 = a23.length - b5.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m6 + 1;
          q.words = new Array(q.length);
          for (var i17 = 0; i17 < q.length; i17++) {
            q.words[i17] = 0;
          }
        }
        var diff = a23.clone()._ishlnsubmul(b5, 1, m6);
        if (diff.negative === 0) {
          a23 = diff;
          if (q) {
            q.words[m6] = 1;
          }
        }
        for (var j2 = m6 - 1; j2 >= 0; j2--) {
          var qj = (a23.words[b5.length + j2] | 0) * 67108864 + (a23.words[b5.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a23._ishlnsubmul(b5, qj, j2);
          while (a23.negative !== 0) {
            qj--;
            a23.negative = 0;
            a23._ishlnsubmul(b5, 1, j2);
            if (!a23.isZero()) {
              a23.negative ^= 1;
            }
          }
          if (q) {
            q.words[j2] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a23._strip();
        if (mode !== "div" && shift !== 0) {
          a23.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a23
        };
      };
      BN2.prototype.divmod = function divmod(num2, mode, positive) {
        assert(!num2.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod3, res;
        if (this.negative !== 0 && num2.negative === 0) {
          res = this.neg().divmod(num2, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.iadd(num2);
            }
          }
          return {
            div,
            mod: mod3
          };
        }
        if (this.negative === 0 && num2.negative !== 0) {
          res = this.divmod(num2.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num2.negative) !== 0) {
          res = this.neg().divmod(num2.neg(), mode);
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.isub(num2);
            }
          }
          return {
            div: res.div,
            mod: mod3
          };
        }
        if (num2.length > this.length || this.cmp(num2) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num2.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num2.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num2.words[0]))
            };
          }
          return {
            div: this.divn(num2.words[0]),
            mod: new BN2(this.modrn(num2.words[0]))
          };
        }
        return this._wordDiv(num2, mode);
      };
      BN2.prototype.div = function div(num2) {
        return this.divmod(num2, "div", false).div;
      };
      BN2.prototype.mod = function mod3(num2) {
        return this.divmod(num2, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num2) {
        return this.divmod(num2, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num2) {
        var dm = this.divmod(num2);
        if (dm.mod.isZero()) return dm.div;
        var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num2) : dm.mod;
        var half = num2.ushrn(1);
        var r210 = num2.andln(1);
        var cmp = mod3.cmp(half);
        if (cmp < 0 || r210 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num2) {
        var isNegNum = num2 < 0;
        if (isNegNum) num2 = -num2;
        assert(num2 <= 67108863);
        var p3 = (1 << 26) % num2;
        var acc = 0;
        for (var i17 = this.length - 1; i17 >= 0; i17--) {
          acc = (p3 * acc + (this.words[i17] | 0)) % num2;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num2) {
        return this.modrn(num2);
      };
      BN2.prototype.idivn = function idivn(num2) {
        var isNegNum = num2 < 0;
        if (isNegNum) num2 = -num2;
        assert(num2 <= 67108863);
        var carry = 0;
        for (var i17 = this.length - 1; i17 >= 0; i17--) {
          var w5 = (this.words[i17] | 0) + carry * 67108864;
          this.words[i17] = w5 / num2 | 0;
          carry = w5 % num2;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num2) {
        return this.clone().idivn(num2);
      };
      BN2.prototype.egcd = function egcd(p3) {
        assert(p3.negative === 0);
        assert(!p3.isZero());
        var x2 = this;
        var y5 = p3.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p3);
        } else {
          x2 = x2.clone();
        }
        var A3 = new BN2(1);
        var B2 = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g5 = 0;
        while (x2.isEven() && y5.isEven()) {
          x2.iushrn(1);
          y5.iushrn(1);
          ++g5;
        }
        var yp = y5.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i17 = 0, im = 1; (x2.words[0] & im) === 0 && i17 < 26; ++i17, im <<= 1) ;
          if (i17 > 0) {
            x2.iushrn(i17);
            while (i17-- > 0) {
              if (A3.isOdd() || B2.isOdd()) {
                A3.iadd(yp);
                B2.isub(xp);
              }
              A3.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y5.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            y5.iushrn(j2);
            while (j2-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x2.cmp(y5) >= 0) {
            x2.isub(y5);
            A3.isub(C);
            B2.isub(D);
          } else {
            y5.isub(x2);
            C.isub(A3);
            D.isub(B2);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y5.iushln(g5)
        };
      };
      BN2.prototype._invmp = function _invmp(p3) {
        assert(p3.negative === 0);
        assert(!p3.isZero());
        var a23 = this;
        var b5 = p3.clone();
        if (a23.negative !== 0) {
          a23 = a23.umod(p3);
        } else {
          a23 = a23.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b5.clone();
        while (a23.cmpn(1) > 0 && b5.cmpn(1) > 0) {
          for (var i17 = 0, im = 1; (a23.words[0] & im) === 0 && i17 < 26; ++i17, im <<= 1) ;
          if (i17 > 0) {
            a23.iushrn(i17);
            while (i17-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b5.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            b5.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a23.cmp(b5) >= 0) {
            a23.isub(b5);
            x1.isub(x2);
          } else {
            b5.isub(a23);
            x2.isub(x1);
          }
        }
        var res;
        if (a23.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p3);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num2) {
        if (this.isZero()) return num2.abs();
        if (num2.isZero()) return this.abs();
        var a23 = this.clone();
        var b5 = num2.clone();
        a23.negative = 0;
        b5.negative = 0;
        for (var shift = 0; a23.isEven() && b5.isEven(); shift++) {
          a23.iushrn(1);
          b5.iushrn(1);
        }
        do {
          while (a23.isEven()) {
            a23.iushrn(1);
          }
          while (b5.isEven()) {
            b5.iushrn(1);
          }
          var r41 = a23.cmp(b5);
          if (r41 < 0) {
            var t35 = a23;
            a23 = b5;
            b5 = t35;
          } else if (r41 === 0 || b5.cmpn(1) === 0) {
            break;
          }
          a23.isub(b5);
        } while (true);
        return b5.iushln(shift);
      };
      BN2.prototype.invm = function invm(num2) {
        return this.egcd(num2).a.umod(num2);
      };
      BN2.prototype.isEven = function isEven2() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd3() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num2) {
        return this.words[0] & num2;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r41 = bit % 26;
        var s26 = (bit - r41) / 26;
        var q = 1 << r41;
        if (this.length <= s26) {
          this._expand(s26 + 1);
          this.words[s26] |= q;
          return this;
        }
        var carry = q;
        for (var i17 = s26; carry !== 0 && i17 < this.length; i17++) {
          var w5 = this.words[i17] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i17] = w5;
        }
        if (carry !== 0) {
          this.words[i17] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero2() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num2) {
        var negative = num2 < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num2 = -num2;
          }
          assert(num2 <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num2 ? 0 : w5 < num2 ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num2) {
        if (this.negative !== 0 && num2.negative === 0) return -1;
        if (this.negative === 0 && num2.negative !== 0) return 1;
        var res = this.ucmp(num2);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num2) {
        if (this.length > num2.length) return 1;
        if (this.length < num2.length) return -1;
        var res = 0;
        for (var i17 = this.length - 1; i17 >= 0; i17--) {
          var a23 = this.words[i17] | 0;
          var b5 = num2.words[i17] | 0;
          if (a23 === b5) continue;
          if (a23 < b5) {
            res = -1;
          } else if (a23 > b5) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num2) {
        return this.cmpn(num2) === 1;
      };
      BN2.prototype.gt = function gt(num2) {
        return this.cmp(num2) === 1;
      };
      BN2.prototype.gten = function gten(num2) {
        return this.cmpn(num2) >= 0;
      };
      BN2.prototype.gte = function gte(num2) {
        return this.cmp(num2) >= 0;
      };
      BN2.prototype.ltn = function ltn(num2) {
        return this.cmpn(num2) === -1;
      };
      BN2.prototype.lt = function lt(num2) {
        return this.cmp(num2) === -1;
      };
      BN2.prototype.lten = function lten(num2) {
        return this.cmpn(num2) <= 0;
      };
      BN2.prototype.lte = function lte(num2) {
        return this.cmp(num2) <= 0;
      };
      BN2.prototype.eqn = function eqn(num2) {
        return this.cmpn(num2) === 0;
      };
      BN2.prototype.eq = function eq(num2) {
        return this.cmp(num2) === 0;
      };
      BN2.red = function red(num2) {
        return new Red(num2);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num2) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num2);
      };
      BN2.prototype.redIAdd = function redIAdd(num2) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num2);
      };
      BN2.prototype.redSub = function redSub(num2) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num2);
      };
      BN2.prototype.redISub = function redISub(num2) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num2);
      };
      BN2.prototype.redShl = function redShl(num2) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num2);
      };
      BN2.prototype.redMul = function redMul(num2) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.mul(this, num2);
      };
      BN2.prototype.redIMul = function redIMul(num2) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num2);
        return this.red.imul(this, num2);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num2) {
        assert(this.red && !num2.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num2);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p3) {
        this.name = name;
        this.p = new BN2(p3, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num2) {
        var r41 = num2;
        var rlen;
        do {
          this.split(r41, this.tmp);
          r41 = this.imulK(r41);
          r41 = r41.iadd(this.tmp);
          rlen = r41.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r41.ucmp(this.p);
        if (cmp === 0) {
          r41.words[0] = 0;
          r41.length = 1;
        } else if (cmp > 0) {
          r41.isub(this.p);
        } else {
          if (r41.strip !== void 0) {
            r41.strip();
          } else {
            r41._strip();
          }
        }
        return r41;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num2) {
        return num2.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i17 = 0; i17 < outLen; i17++) {
          output.words[i17] = input.words[i17];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i17 = 10; i17 < input.length; i17++) {
          var next = input.words[i17] | 0;
          input.words[i17 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i17 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num2) {
        num2.words[num2.length] = 0;
        num2.words[num2.length + 1] = 0;
        num2.length += 2;
        var lo = 0;
        for (var i17 = 0; i17 < num2.length; i17++) {
          var w5 = num2.words[i17] | 0;
          lo += w5 * 977;
          num2.words[i17] = lo & 67108863;
          lo = w5 * 64 + (lo / 67108864 | 0);
        }
        if (num2.words[num2.length - 1] === 0) {
          num2.length--;
          if (num2.words[num2.length - 1] === 0) {
            num2.length--;
          }
        }
        return num2;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num2) {
        var carry = 0;
        for (var i17 = 0; i17 < num2.length; i17++) {
          var hi = (num2.words[i17] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num2.words[i17] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num2.words[num2.length++] = carry;
        }
        return num2;
      };
      BN2._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m6) {
        if (typeof m6 === "string") {
          var prime = BN2._prime(m6);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m6.gtn(1), "modulus must be greater than 1");
          this.m = m6;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a23) {
        assert(a23.negative === 0, "red works only with positives");
        assert(a23.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a23, b5) {
        assert((a23.negative | b5.negative) === 0, "red works only with positives");
        assert(
          a23.red && a23.red === b5.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a23) {
        if (this.prime) return this.prime.ireduce(a23)._forceRed(this);
        move(a23, a23.umod(this.m)._forceRed(this));
        return a23;
      };
      Red.prototype.neg = function neg(a23) {
        if (a23.isZero()) {
          return a23.clone();
        }
        return this.m.sub(a23)._forceRed(this);
      };
      Red.prototype.add = function add3(a23, b5) {
        this._verify2(a23, b5);
        var res = a23.add(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a23, b5) {
        this._verify2(a23, b5);
        var res = a23.iadd(b5);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a23, b5) {
        this._verify2(a23, b5);
        var res = a23.sub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a23, b5) {
        this._verify2(a23, b5);
        var res = a23.isub(b5);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a23, num2) {
        this._verify1(a23);
        return this.imod(a23.ushln(num2));
      };
      Red.prototype.imul = function imul(a23, b5) {
        this._verify2(a23, b5);
        return this.imod(a23.imul(b5));
      };
      Red.prototype.mul = function mul(a23, b5) {
        this._verify2(a23, b5);
        return this.imod(a23.mul(b5));
      };
      Red.prototype.isqr = function isqr(a23) {
        return this.imul(a23, a23.clone());
      };
      Red.prototype.sqr = function sqr(a23) {
        return this.mul(a23, a23);
      };
      Red.prototype.sqrt = function sqrt(a23) {
        if (a23.isZero()) return a23.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a23, pow);
        }
        var q = this.m.subn(1);
        var s26 = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s26++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c17 = this.pow(z, q);
        var r41 = this.pow(a23, q.addn(1).iushrn(1));
        var t35 = this.pow(a23, q);
        var m6 = s26;
        while (t35.cmp(one) !== 0) {
          var tmp = t35;
          for (var i17 = 0; tmp.cmp(one) !== 0; i17++) {
            tmp = tmp.redSqr();
          }
          assert(i17 < m6);
          var b5 = this.pow(c17, new BN2(1).iushln(m6 - i17 - 1));
          r41 = r41.redMul(b5);
          c17 = b5.redSqr();
          t35 = t35.redMul(c17);
          m6 = i17;
        }
        return r41;
      };
      Red.prototype.invm = function invm(a23) {
        var inv = a23._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a23, num2) {
        if (num2.isZero()) return new BN2(1).toRed(this);
        if (num2.cmpn(1) === 0) return a23.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a23;
        for (var i17 = 2; i17 < wnd.length; i17++) {
          wnd[i17] = this.mul(wnd[i17 - 1], a23);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num2.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i17 = num2.length - 1; i17 >= 0; i17--) {
          var word = num2.words[i17];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i17 !== 0 || j2 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num2) {
        var r41 = num2.umod(this.m);
        return r41 === num2 ? r41.clone() : r41;
      };
      Red.prototype.convertFrom = function convertFrom(num2) {
        var res = num2.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num2) {
        return new Mont(num2);
      };
      function Mont(m6) {
        Red.call(this, m6);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num2) {
        return this.imod(num2.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num2) {
        var r41 = this.imod(num2.mul(this.rinv));
        r41.red = null;
        return r41;
      };
      Mont.prototype.imul = function imul(a23, b5) {
        if (a23.isZero() || b5.isZero()) {
          a23.words[0] = 0;
          a23.length = 1;
          return a23;
        }
        var t35 = a23.imul(b5);
        var c17 = t35.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u22 = t35.isub(c17).iushrn(this.shift);
        var res = u22;
        if (u22.cmp(this.m) >= 0) {
          res = u22.isub(this.m);
        } else if (u22.cmpn(0) < 0) {
          res = u22.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a23, b5) {
        if (a23.isZero() || b5.isZero()) return new BN2(0)._forceRed(this);
        var t35 = a23.mul(b5);
        var c17 = t35.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u22 = t35.isub(c17).iushrn(this.shift);
        var res = u22;
        if (u22.cmp(this.m) >= 0) {
          res = u22.isub(this.m);
        } else if (u22.cmpn(0) < 0) {
          res = u22.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a23) {
        var res = this.imod(a23._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS2 = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING2 = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT2 = [0, 8, 16, 24];
      var RC2 = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding2, outputType) {
        return function(message) {
          return new Keccak2(bits2, padding2, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak2(bits2, padding2, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits, n31, s26) {
          return methods["cshake" + bits2].update(message, outputBits, n31, s26)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding2, outputType) {
        return function(key, message, outputBits, s26) {
          return methods["kmac" + bits2].update(key, message, outputBits, s26)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding2) {
        for (var i18 = 0; i18 < OUTPUT_TYPES.length; ++i18) {
          var type = OUTPUT_TYPES[i18];
          method[type] = createMethod2(bits2, padding2, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding2) {
        var method = createOutputMethod(bits2, padding2, "hex");
        method.create = function() {
          return new Keccak2(bits2, padding2, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding2);
      };
      var createShakeMethod = function(bits2, padding2) {
        var method = createShakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak2(bits2, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
      };
      var createCshakeMethod = function(bits2, padding2) {
        var w5 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits, n31, s26) {
          if (!n31 && !s26) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak2(bits2, padding2, outputBits).bytepad([n31, s26], w5);
          }
        };
        method.update = function(message, outputBits, n31, s26) {
          return method.create(outputBits, n31, s26).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
      };
      var createKmacMethod = function(bits2, padding2) {
        var w5 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding2, "hex");
        method.create = function(key, outputBits, s26) {
          return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s26], w5).bytepad([key], w5);
        };
        method.update = function(key, message, outputBits, s26) {
          return method.create(key, outputBits, s26).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING2, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i17 = 0; i17 < algorithms.length; ++i17) {
        var algorithm = algorithms[i17];
        var bits = algorithm.bits;
        for (var j2 = 0; j2 < bits.length; ++j2) {
          var methodName = algorithm.name + "_" + bits[j2];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j2];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak2(bits2, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i18 = 0; i18 < 50; ++i18) {
          this.s[i18] = 0;
        }
      }
      Keccak2.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s26 = this.s, i18, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i18 = 1; i18 < blockCount + 1; ++i18) {
              blocks[i18] = 0;
            }
          }
          if (notString) {
            for (i18 = this.start; index < length && i18 < byteCount; ++index) {
              blocks[i18 >> 2] |= message[index] << SHIFT2[i18++ & 3];
            }
          } else {
            for (i18 = this.start; index < length && i18 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i18 >> 2] |= code << SHIFT2[i18++ & 3];
              } else if (code < 2048) {
                blocks[i18 >> 2] |= (192 | code >> 6) << SHIFT2[i18++ & 3];
                blocks[i18 >> 2] |= (128 | code & 63) << SHIFT2[i18++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i18 >> 2] |= (224 | code >> 12) << SHIFT2[i18++ & 3];
                blocks[i18 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i18++ & 3];
                blocks[i18 >> 2] |= (128 | code & 63) << SHIFT2[i18++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i18 >> 2] |= (240 | code >> 18) << SHIFT2[i18++ & 3];
                blocks[i18 >> 2] |= (128 | code >> 12 & 63) << SHIFT2[i18++ & 3];
                blocks[i18 >> 2] |= (128 | code >> 6 & 63) << SHIFT2[i18++ & 3];
                blocks[i18 >> 2] |= (128 | code & 63) << SHIFT2[i18++ & 3];
              }
            }
          }
          this.lastByteIndex = i18;
          if (i18 >= byteCount) {
            this.start = i18 - byteCount;
            this.block = blocks[blockCount];
            for (i18 = 0; i18 < blockCount; ++i18) {
              s26[i18] ^= blocks[i18];
            }
            f4(s26);
            this.reset = true;
          } else {
            this.start = i18;
          }
        }
        return this;
      };
      Keccak2.prototype.encode = function(x2, right) {
        var o32 = x2 & 255, n31 = 1;
        var bytes3 = [o32];
        x2 = x2 >> 8;
        o32 = x2 & 255;
        while (o32 > 0) {
          bytes3.unshift(o32);
          x2 = x2 >> 8;
          o32 = x2 & 255;
          ++n31;
        }
        if (right) {
          bytes3.push(n31);
        } else {
          bytes3.unshift(n31);
        }
        this.update(bytes3);
        return bytes3.length;
      };
      Keccak2.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes3 = 0, length = str.length;
        if (notString) {
          bytes3 = length;
        } else {
          for (var i18 = 0; i18 < str.length; ++i18) {
            var code = str.charCodeAt(i18);
            if (code < 128) {
              bytes3 += 1;
            } else if (code < 2048) {
              bytes3 += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes3 += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i18) & 1023);
              bytes3 += 4;
            }
          }
        }
        bytes3 += this.encode(bytes3 * 8);
        this.update(str);
        return bytes3;
      };
      Keccak2.prototype.bytepad = function(strs, w5) {
        var bytes3 = this.encode(w5);
        for (var i18 = 0; i18 < strs.length; ++i18) {
          bytes3 += this.encodeString(strs[i18]);
        }
        var paddingBytes = w5 - bytes3 % w5;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak2.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i18 = this.lastByteIndex, blockCount = this.blockCount, s26 = this.s;
        blocks[i18 >> 2] |= this.padding[i18 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i18 = 1; i18 < blockCount + 1; ++i18) {
            blocks[i18] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i18 = 0; i18 < blockCount; ++i18) {
          s26[i18] ^= blocks[i18];
        }
        f4(s26);
      };
      Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s26 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i18 = 0, j3 = 0;
        var hex = "", block;
        while (j3 < outputBlocks) {
          for (i18 = 0; i18 < blockCount && j3 < outputBlocks; ++i18, ++j3) {
            block = s26[i18];
            hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15] + HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15] + HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15] + HEX_CHARS2[block >> 28 & 15] + HEX_CHARS2[block >> 24 & 15];
          }
          if (j3 % blockCount === 0) {
            f4(s26);
            i18 = 0;
          }
        }
        if (extraBytes) {
          block = s26[i18];
          hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak2.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s26 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i18 = 0, j3 = 0;
        var bytes3 = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes3);
        }
        var array = new Uint32Array(buffer);
        while (j3 < outputBlocks) {
          for (i18 = 0; i18 < blockCount && j3 < outputBlocks; ++i18, ++j3) {
            array[j3] = s26[i18];
          }
          if (j3 % blockCount === 0) {
            f4(s26);
          }
        }
        if (extraBytes) {
          array[i18] = s26[i18];
          buffer = buffer.slice(0, bytes3);
        }
        return buffer;
      };
      Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
      Keccak2.prototype.digest = Keccak2.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s26 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i18 = 0, j3 = 0;
        var array = [], offset, block;
        while (j3 < outputBlocks) {
          for (i18 = 0; i18 < blockCount && j3 < outputBlocks; ++i18, ++j3) {
            offset = j3 << 2;
            block = s26[i18];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j3 % blockCount === 0) {
            f4(s26);
          }
        }
        if (extraBytes) {
          offset = j3 << 2;
          block = s26[i18];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding2, outputBits) {
        Keccak2.call(this, bits2, padding2, outputBits);
      }
      Kmac.prototype = new Keccak2();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak2.prototype.finalize.call(this);
      };
      var f4 = function(s26) {
        var h8, l19, n31, c0, c1, c22, c32, c42, c52, c62, c72, c82, c92, b0, b1, b22, b32, b42, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b422, b43, b44, b45, b46, b47, b48, b49;
        for (n31 = 0; n31 < 48; n31 += 2) {
          c0 = s26[0] ^ s26[10] ^ s26[20] ^ s26[30] ^ s26[40];
          c1 = s26[1] ^ s26[11] ^ s26[21] ^ s26[31] ^ s26[41];
          c22 = s26[2] ^ s26[12] ^ s26[22] ^ s26[32] ^ s26[42];
          c32 = s26[3] ^ s26[13] ^ s26[23] ^ s26[33] ^ s26[43];
          c42 = s26[4] ^ s26[14] ^ s26[24] ^ s26[34] ^ s26[44];
          c52 = s26[5] ^ s26[15] ^ s26[25] ^ s26[35] ^ s26[45];
          c62 = s26[6] ^ s26[16] ^ s26[26] ^ s26[36] ^ s26[46];
          c72 = s26[7] ^ s26[17] ^ s26[27] ^ s26[37] ^ s26[47];
          c82 = s26[8] ^ s26[18] ^ s26[28] ^ s26[38] ^ s26[48];
          c92 = s26[9] ^ s26[19] ^ s26[29] ^ s26[39] ^ s26[49];
          h8 = c82 ^ (c22 << 1 | c32 >>> 31);
          l19 = c92 ^ (c32 << 1 | c22 >>> 31);
          s26[0] ^= h8;
          s26[1] ^= l19;
          s26[10] ^= h8;
          s26[11] ^= l19;
          s26[20] ^= h8;
          s26[21] ^= l19;
          s26[30] ^= h8;
          s26[31] ^= l19;
          s26[40] ^= h8;
          s26[41] ^= l19;
          h8 = c0 ^ (c42 << 1 | c52 >>> 31);
          l19 = c1 ^ (c52 << 1 | c42 >>> 31);
          s26[2] ^= h8;
          s26[3] ^= l19;
          s26[12] ^= h8;
          s26[13] ^= l19;
          s26[22] ^= h8;
          s26[23] ^= l19;
          s26[32] ^= h8;
          s26[33] ^= l19;
          s26[42] ^= h8;
          s26[43] ^= l19;
          h8 = c22 ^ (c62 << 1 | c72 >>> 31);
          l19 = c32 ^ (c72 << 1 | c62 >>> 31);
          s26[4] ^= h8;
          s26[5] ^= l19;
          s26[14] ^= h8;
          s26[15] ^= l19;
          s26[24] ^= h8;
          s26[25] ^= l19;
          s26[34] ^= h8;
          s26[35] ^= l19;
          s26[44] ^= h8;
          s26[45] ^= l19;
          h8 = c42 ^ (c82 << 1 | c92 >>> 31);
          l19 = c52 ^ (c92 << 1 | c82 >>> 31);
          s26[6] ^= h8;
          s26[7] ^= l19;
          s26[16] ^= h8;
          s26[17] ^= l19;
          s26[26] ^= h8;
          s26[27] ^= l19;
          s26[36] ^= h8;
          s26[37] ^= l19;
          s26[46] ^= h8;
          s26[47] ^= l19;
          h8 = c62 ^ (c0 << 1 | c1 >>> 31);
          l19 = c72 ^ (c1 << 1 | c0 >>> 31);
          s26[8] ^= h8;
          s26[9] ^= l19;
          s26[18] ^= h8;
          s26[19] ^= l19;
          s26[28] ^= h8;
          s26[29] ^= l19;
          s26[38] ^= h8;
          s26[39] ^= l19;
          s26[48] ^= h8;
          s26[49] ^= l19;
          b0 = s26[0];
          b1 = s26[1];
          b322 = s26[11] << 4 | s26[10] >>> 28;
          b33 = s26[10] << 4 | s26[11] >>> 28;
          b14 = s26[20] << 3 | s26[21] >>> 29;
          b15 = s26[21] << 3 | s26[20] >>> 29;
          b46 = s26[31] << 9 | s26[30] >>> 23;
          b47 = s26[30] << 9 | s26[31] >>> 23;
          b28 = s26[40] << 18 | s26[41] >>> 14;
          b29 = s26[41] << 18 | s26[40] >>> 14;
          b20 = s26[2] << 1 | s26[3] >>> 31;
          b21 = s26[3] << 1 | s26[2] >>> 31;
          b22 = s26[13] << 12 | s26[12] >>> 20;
          b32 = s26[12] << 12 | s26[13] >>> 20;
          b34 = s26[22] << 10 | s26[23] >>> 22;
          b35 = s26[23] << 10 | s26[22] >>> 22;
          b16 = s26[33] << 13 | s26[32] >>> 19;
          b17 = s26[32] << 13 | s26[33] >>> 19;
          b48 = s26[42] << 2 | s26[43] >>> 30;
          b49 = s26[43] << 2 | s26[42] >>> 30;
          b40 = s26[5] << 30 | s26[4] >>> 2;
          b41 = s26[4] << 30 | s26[5] >>> 2;
          b222 = s26[14] << 6 | s26[15] >>> 26;
          b23 = s26[15] << 6 | s26[14] >>> 26;
          b42 = s26[25] << 11 | s26[24] >>> 21;
          b5 = s26[24] << 11 | s26[25] >>> 21;
          b36 = s26[34] << 15 | s26[35] >>> 17;
          b37 = s26[35] << 15 | s26[34] >>> 17;
          b18 = s26[45] << 29 | s26[44] >>> 3;
          b19 = s26[44] << 29 | s26[45] >>> 3;
          b10 = s26[6] << 28 | s26[7] >>> 4;
          b11 = s26[7] << 28 | s26[6] >>> 4;
          b422 = s26[17] << 23 | s26[16] >>> 9;
          b43 = s26[16] << 23 | s26[17] >>> 9;
          b24 = s26[26] << 25 | s26[27] >>> 7;
          b25 = s26[27] << 25 | s26[26] >>> 7;
          b6 = s26[36] << 21 | s26[37] >>> 11;
          b7 = s26[37] << 21 | s26[36] >>> 11;
          b38 = s26[47] << 24 | s26[46] >>> 8;
          b39 = s26[46] << 24 | s26[47] >>> 8;
          b30 = s26[8] << 27 | s26[9] >>> 5;
          b31 = s26[9] << 27 | s26[8] >>> 5;
          b12 = s26[18] << 20 | s26[19] >>> 12;
          b13 = s26[19] << 20 | s26[18] >>> 12;
          b44 = s26[29] << 7 | s26[28] >>> 25;
          b45 = s26[28] << 7 | s26[29] >>> 25;
          b26 = s26[38] << 8 | s26[39] >>> 24;
          b27 = s26[39] << 8 | s26[38] >>> 24;
          b8 = s26[48] << 14 | s26[49] >>> 18;
          b9 = s26[49] << 14 | s26[48] >>> 18;
          s26[0] = b0 ^ ~b22 & b42;
          s26[1] = b1 ^ ~b32 & b5;
          s26[10] = b10 ^ ~b12 & b14;
          s26[11] = b11 ^ ~b13 & b15;
          s26[20] = b20 ^ ~b222 & b24;
          s26[21] = b21 ^ ~b23 & b25;
          s26[30] = b30 ^ ~b322 & b34;
          s26[31] = b31 ^ ~b33 & b35;
          s26[40] = b40 ^ ~b422 & b44;
          s26[41] = b41 ^ ~b43 & b45;
          s26[2] = b22 ^ ~b42 & b6;
          s26[3] = b32 ^ ~b5 & b7;
          s26[12] = b12 ^ ~b14 & b16;
          s26[13] = b13 ^ ~b15 & b17;
          s26[22] = b222 ^ ~b24 & b26;
          s26[23] = b23 ^ ~b25 & b27;
          s26[32] = b322 ^ ~b34 & b36;
          s26[33] = b33 ^ ~b35 & b37;
          s26[42] = b422 ^ ~b44 & b46;
          s26[43] = b43 ^ ~b45 & b47;
          s26[4] = b42 ^ ~b6 & b8;
          s26[5] = b5 ^ ~b7 & b9;
          s26[14] = b14 ^ ~b16 & b18;
          s26[15] = b15 ^ ~b17 & b19;
          s26[24] = b24 ^ ~b26 & b28;
          s26[25] = b25 ^ ~b27 & b29;
          s26[34] = b34 ^ ~b36 & b38;
          s26[35] = b35 ^ ~b37 & b39;
          s26[44] = b44 ^ ~b46 & b48;
          s26[45] = b45 ^ ~b47 & b49;
          s26[6] = b6 ^ ~b8 & b0;
          s26[7] = b7 ^ ~b9 & b1;
          s26[16] = b16 ^ ~b18 & b10;
          s26[17] = b17 ^ ~b19 & b11;
          s26[26] = b26 ^ ~b28 & b20;
          s26[27] = b27 ^ ~b29 & b21;
          s26[36] = b36 ^ ~b38 & b30;
          s26[37] = b37 ^ ~b39 & b31;
          s26[46] = b46 ^ ~b48 & b40;
          s26[47] = b47 ^ ~b49 & b41;
          s26[8] = b8 ^ ~b0 & b22;
          s26[9] = b9 ^ ~b1 & b32;
          s26[18] = b18 ^ ~b10 & b12;
          s26[19] = b19 ^ ~b11 & b13;
          s26[28] = b28 ^ ~b20 & b222;
          s26[29] = b29 ^ ~b21 & b23;
          s26[38] = b38 ^ ~b30 & b322;
          s26[39] = b39 ^ ~b31 & b33;
          s26[48] = b48 ^ ~b40 & b422;
          s26[49] = b49 ^ ~b41 & b43;
          s26[0] ^= RC2[n31];
          s26[1] ^= RC2[n31 + 1];
        }
      };
      if (COMMON_JS) {
        module2.exports = methods;
      } else {
        for (i17 = 0; i17 < methodNames.length; ++i17) {
          root[methodNames[i17]] = methods[methodNames[i17]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    function tryStringify(o32) {
      try {
        return JSON.stringify(o32);
      } catch (e39) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f4, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f4 === "object" && f4 !== null) {
        var len = args.length + offset;
        if (len === 1) return f4;
        var objects = new Array(len);
        objects[0] = ss(f4);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f4 !== "string") {
        return f4;
      }
      var argLen = args.length;
      if (argLen === 0) return f4;
      var str = "";
      var a23 = 1 - offset;
      var lastPos = -1;
      var flen = f4 && f4.length || 0;
      for (var i17 = 0; i17 < flen; ) {
        if (f4.charCodeAt(i17) === 37 && i17 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f4.charCodeAt(i17 + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a23 >= argLen)
                break;
              if (args[a23] == null) break;
              if (lastPos < i17)
                str += f4.slice(lastPos, i17);
              str += Number(args[a23]);
              lastPos = i17 + 2;
              i17++;
              break;
            case 105:
              if (a23 >= argLen)
                break;
              if (args[a23] == null) break;
              if (lastPos < i17)
                str += f4.slice(lastPos, i17);
              str += Math.floor(Number(args[a23]));
              lastPos = i17 + 2;
              i17++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a23 >= argLen)
                break;
              if (args[a23] === void 0) break;
              if (lastPos < i17)
                str += f4.slice(lastPos, i17);
              var type = typeof args[a23];
              if (type === "string") {
                str += "'" + args[a23] + "'";
                lastPos = i17 + 2;
                i17++;
                break;
              }
              if (type === "function") {
                str += args[a23].name || "<anonymous>";
                lastPos = i17 + 2;
                i17++;
                break;
              }
              str += ss(args[a23]);
              lastPos = i17 + 2;
              i17++;
              break;
            case 115:
              if (a23 >= argLen)
                break;
              if (lastPos < i17)
                str += f4.slice(lastPos, i17);
              str += String(args[a23]);
              lastPos = i17 + 2;
              i17++;
              break;
            case 37:
              if (lastPos < i17)
                str += f4.slice(lastPos, i17);
              str += "%";
              lastPos = i17 + 2;
              i17++;
              a23--;
              break;
          }
          ++a23;
        }
        ++i17;
      }
      if (lastPos === -1)
        return f4;
      else if (lastPos < flen) {
        str += f4.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/pino/browser.js"(exports2, module2) {
    "use strict";
    var format = require_quick_format_unescaped();
    module2.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue,
      errWithCause: asErrValue
    };
    function levelToValue(level, logger15) {
      return level === "silent" ? Infinity : logger15.levels.values[level];
    }
    var baseLogFunctionSymbol = Symbol("pino.logFuncs");
    var hierarchySymbol = Symbol("pino.hierarchy");
    var logFallbackMap = {
      error: "log",
      fatal: "error",
      warn: "error",
      info: "log",
      debug: "log",
      trace: "log"
    };
    function appendChildLogger(parentLogger, childLogger) {
      const newEntry = {
        logger: childLogger,
        parent: parentLogger[hierarchySymbol]
      };
      childLogger[hierarchySymbol] = newEntry;
    }
    function setupBaseLogFunctions(logger15, levels, proto36) {
      const logFunctions = {};
      levels.forEach((level) => {
        logFunctions[level] = proto36[level] ? proto36[level] : _console[level] || _console[logFallbackMap[level] || "log"] || noop;
      });
      logger15[baseLogFunctionSymbol] = logFunctions;
    }
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k3) {
          return k3 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto36 = opts.browser.write || _console;
      if (opts.browser.write) opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const customLevels = Object.keys(opts.customLevels || {});
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"].concat(customLevels);
      if (typeof proto36 === "function") {
        levels.forEach(function(level2) {
          proto36[level2] = proto36;
        });
      }
      if (opts.enabled === false || opts.browser.disabled) opts.level = "silent";
      const level = opts.level || "info";
      const logger15 = Object.create(proto36);
      if (!logger15.log) logger15.log = noop;
      setupBaseLogFunctions(logger15, levels, proto36);
      appendChildLogger({}, logger15);
      Object.defineProperty(logger15, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger15, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        asObjectBindingsOnly: opts.browser.asObjectBindingsOnly,
        formatters: opts.browser.formatters,
        levels,
        timestamp: getTimeFunction(opts),
        messageKey: opts.messageKey || "msg",
        onChild: opts.onChild || noop
      };
      logger15.levels = getLevels(opts);
      logger15.level = level;
      logger15.isLevelEnabled = function(level2) {
        if (!this.levels.values[level2]) {
          return false;
        }
        return this.levels.values[level2] >= this.levels.values[this.level];
      };
      logger15.setMaxListeners = logger15.getMaxListeners = logger15.emit = logger15.addListener = logger15.on = logger15.prependListener = logger15.once = logger15.prependOnceListener = logger15.removeListener = logger15.removeAllListeners = logger15.listeners = logger15.listenerCount = logger15.eventNames = logger15.write = logger15.flush = noop;
      logger15.serializers = serializers;
      logger15._serialize = serialize;
      logger15._stdErrSerialize = stdErrSerialize;
      logger15.child = function(...args) {
        return child.call(this, setOpts, ...args);
      };
      if (transmit2) logger15._logEvent = createLogEventShape();
      function getLevelVal() {
        return levelToValue(this.level, this);
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set(this, setOpts, logger15, "error");
        set(this, setOpts, logger15, "fatal");
        set(this, setOpts, logger15, "warn");
        set(this, setOpts, logger15, "info");
        set(this, setOpts, logger15, "debug");
        set(this, setOpts, logger15, "trace");
        customLevels.forEach((level3) => {
          set(this, setOpts, logger15, level3);
        });
      }
      function child(setOpts2, bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.bindings = bindings;
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        const newLogger = new Child(this);
        appendChildLogger(this, newLogger);
        newLogger.child = function(...args) {
          return child.call(this, setOpts2, ...args);
        };
        newLogger.level = childOptions.level || this.level;
        setOpts2.onChild(newLogger);
        return newLogger;
      }
      return logger15;
    }
    function getLevels(opts) {
      const customLevels = opts.customLevels || {};
      const values = Object.assign({}, pino.levels.values, customLevels);
      const labels = Object.assign({}, pino.levels.labels, invertObject(customLevels));
      return {
        values,
        labels
      };
    }
    function invertObject(obj) {
      const inverted = {};
      Object.keys(obj).forEach(function(key) {
        inverted[obj[key]] = key;
      });
      return inverted;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function getBindingChain(logger15) {
      const bindings = [];
      if (logger15.bindings) {
        bindings.push(logger15.bindings);
      }
      let hierarchy = logger15[hierarchySymbol];
      while (hierarchy.parent) {
        hierarchy = hierarchy.parent;
        if (hierarchy.logger.bindings) {
          bindings.push(hierarchy.logger.bindings);
        }
      }
      return bindings.reverse();
    }
    function set(self2, opts, rootLogger, level) {
      Object.defineProperty(self2, level, {
        value: levelToValue(self2.level, rootLogger) > levelToValue(level, rootLogger) ? noop : rootLogger[baseLogFunctionSymbol][level],
        writable: true,
        enumerable: true,
        configurable: true
      });
      if (self2[level] === noop) {
        if (!opts.transmit) return;
        const transmitLevel = opts.transmit.level || self2.level;
        const transmitValue = levelToValue(transmitLevel, rootLogger);
        const methodValue = levelToValue(level, rootLogger);
        if (methodValue < transmitValue) return;
      }
      self2[level] = createWrap(self2, opts, rootLogger, level);
      const bindings = getBindingChain(self2);
      if (bindings.length === 0) {
        return;
      }
      self2[level] = prependBindingsInArguments(bindings, self2[level]);
    }
    function prependBindingsInArguments(bindings, logFunc) {
      return function() {
        return logFunc.apply(this, [...bindings, ...arguments]);
      };
    }
    function createWrap(self2, opts, rootLogger, level) {
      return /* @__PURE__ */ (function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto36 = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i17 = 0; i17 < args.length; i17++) args[i17] = arguments[i17];
          var argsIsSerialized = false;
          if (opts.serialize) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
            argsIsSerialized = true;
          }
          if (opts.asObject || opts.formatters) {
            write.call(proto36, ...asObject(this, level, args, ts, opts));
          } else write.apply(proto36, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || self2._level;
            const transmitValue = levelToValue(transmitLevel, rootLogger);
            const methodValue = levelToValue(level, rootLogger);
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: rootLogger.levels.values[opts.transmit.level || self2._level],
              send: opts.transmit.send,
              val: levelToValue(self2._level, rootLogger)
            }, args, argsIsSerialized);
          }
        };
      })(self2[baseLogFunctionSymbol][level]);
    }
    function asObject(logger15, level, args, ts, opts) {
      const {
        level: levelFormatter,
        log: logObjectFormatter = (obj) => obj
      } = opts.formatters || {};
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const logObject = {};
      let lvl = (logger15._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (ts) {
        logObject.time = ts;
      }
      if (levelFormatter) {
        const formattedLevel = levelFormatter(level, logger15.levels.values[level]);
        Object.assign(logObject, formattedLevel);
      } else {
        logObject.level = logger15.levels.values[level];
      }
      if (opts.asObjectBindingsOnly) {
        if (msg !== null && typeof msg === "object") {
          while (lvl-- && typeof argsCloned[0] === "object") {
            Object.assign(logObject, argsCloned.shift());
          }
        }
        const formattedLogObject = logObjectFormatter(logObject);
        return [formattedLogObject, ...argsCloned];
      } else {
        if (msg !== null && typeof msg === "object") {
          while (lvl-- && typeof argsCloned[0] === "object") {
            Object.assign(logObject, argsCloned.shift());
          }
          msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
        } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
        if (msg !== void 0) logObject[opts.messageKey] = msg;
        const formattedLogObject = logObjectFormatter(logObject);
        return [formattedLogObject];
      }
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i17 in args) {
        if (stdErrSerialize && args[i17] instanceof Error) {
          args[i17] = pino.stdSerializers.err(args[i17]);
        } else if (typeof args[i17] === "object" && !Array.isArray(args[i17]) && serialize) {
          for (const k3 in args[i17]) {
            if (serialize.indexOf(k3) > -1 && k3 in serializers) {
              args[i17][k3] = serializers[k3](args[i17][k3]);
            }
          }
        }
      }
    }
    function transmit(logger15, opts, args, argsIsSerialized = false) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger15._logEvent.bindings;
      if (!argsIsSerialized) {
        applySerializers(
          args,
          logger15._serialize || Object.keys(logger15.serializers),
          logger15.serializers,
          logger15._stdErrSerialize === void 0 ? true : logger15._stdErrSerialize
        );
      }
      logger15._logEvent.ts = ts;
      logger15._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger15._logEvent.level.label = methodLevel;
      logger15._logEvent.level.value = methodValue;
      send(methodLevel, logger15._logEvent, val);
      logger15._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a23) {
      return a23;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o32) {
        return typeof o32 !== "undefined" && o32;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e39) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
    module2.exports.default = pino;
    module2.exports.pino = pino;
  }
});

// node_modules/long/index.js
var wasm = null;
try {
  wasm = new WebAssembly.Instance(
    new WebAssembly.Module(
      new Uint8Array([
        // \0asm
        0,
        97,
        115,
        109,
        // version 1
        1,
        0,
        0,
        0,
        // section "type"
        1,
        13,
        2,
        // 0, () => i32
        96,
        0,
        1,
        127,
        // 1, (i32, i32, i32, i32) => i32
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        // section "function"
        3,
        7,
        6,
        // 0, type 0
        0,
        // 1, type 1
        1,
        // 2, type 1
        1,
        // 3, type 1
        1,
        // 4, type 1
        1,
        // 5, type 1
        1,
        // section "global"
        6,
        6,
        1,
        // 0, "high", mutable i32
        127,
        1,
        65,
        0,
        11,
        // section "export"
        7,
        50,
        6,
        // 0, "mul"
        3,
        109,
        117,
        108,
        0,
        1,
        // 1, "div_s"
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        // 2, "div_u"
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        // 3, "rem_s"
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        // 4, "rem_u"
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        // 5, "get_high"
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        // section "code"
        10,
        191,
        1,
        6,
        // 0, "get_high"
        4,
        0,
        35,
        0,
        11,
        // 1, "mul"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 2, "div_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 3, "div_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 4, "rem_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 5, "rem_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])
    ),
    {}
  ).exports;
} catch {
}
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c17 = Math.clz32(value & -value);
  return value ? 31 - c17 : c17;
}
Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache) UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache) INT_CACHE[value] = obj;
    return obj;
  }
}
Long.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value)) return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0) return UZERO;
    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  }
  if (value < 0) return fromNumber(-value, unsigned).neg();
  return fromBits(
    value % TWO_PWR_32_DBL | 0,
    value / TWO_PWR_32_DBL | 0,
    unsigned
  );
}
Long.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0) throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  var p3;
  if ((p3 = str.indexOf("-")) > 0) throw Error("interior hyphen");
  else if (p3 === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i17 = 0; i17 < str.length; i17 += 8) {
    var size = Math.min(8, str.length - i17), value = parseInt(str.substring(i17, i17 + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number") return fromNumber(val, unsigned);
  if (typeof val === "string") return fromString(val, unsigned);
  return fromBits(
    val.low,
    val.high,
    typeof unsigned === "boolean" ? unsigned : val.unsigned
  );
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero()) return digits + result;
    else {
      while (digits.length < 6) digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isSafeInteger = function isSafeInteger() {
  var top11Bits = this.high >> 21;
  if (!top11Bits) return true;
  if (this.unsigned) return false;
  return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
    /* validates */
    other
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
    /* validates */
    other
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
    /* validates */
    other
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.eq(other)) return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) return -1;
  if (!thisNeg && otherNeg) return 1;
  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend)) addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a162 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c162 = 0, c00 = 0;
  c00 += a00 + b00;
  c162 += c00 >>> 16;
  c00 &= 65535;
  c162 += a162 + b16;
  c32 += c162 >>> 16;
  c162 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c162 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero()) return this;
  if (!isLong(multiplier)) multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
    else return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a162 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c162 = 0, c00 = 0;
  c00 += a00 * b00;
  c162 += c00 >>> 16;
  c00 &= 65535;
  c162 += a162 * b00;
  c32 += c162 >>> 16;
  c162 &= 65535;
  c162 += a00 * b16;
  c32 += c162 >>> 16;
  c162 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a162 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a162 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c162 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (divisor.isZero()) throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE)) return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative()) return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned) divisor = divisor.toUnsigned();
    if (divisor.gt(this)) return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero()) approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function and(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low << numBits,
      this.high << numBits | this.low >>> 32 - numBits,
      this.unsigned
    );
  else return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >> numBits,
      this.unsigned
    );
  else
    return fromBits(
      this.high >> numBits - 32,
      this.high >= 0 ? 0 : -1,
      this.unsigned
    );
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >>> numBits,
      this.unsigned
    );
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b5;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b5 = 32 - numBits;
    return fromBits(
      this.low << numBits | this.high >>> b5,
      this.high << numBits | this.low >>> b5,
      this.unsigned
    );
  }
  numBits -= 32;
  b5 = 32 - numBits;
  return fromBits(
    this.high << numBits | this.low >>> b5,
    this.low << numBits | this.high >>> b5,
    this.unsigned
  );
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b5;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b5 = 32 - numBits;
    return fromBits(
      this.high << b5 | this.low >>> numBits,
      this.low << b5 | this.high >>> numBits,
      this.unsigned
    );
  }
  numBits -= 32;
  b5 = 32 - numBits;
  return fromBits(
    this.low << b5 | this.high >>> numBits,
    this.high << b5 | this.low >>> numBits,
    this.unsigned
  );
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned) return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned) return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long.fromBytes = function fromBytes(bytes3, unsigned, le) {
  return le ? Long.fromBytesLE(bytes3, unsigned) : Long.fromBytesBE(bytes3, unsigned);
};
Long.fromBytesLE = function fromBytesLE(bytes3, unsigned) {
  return new Long(
    bytes3[0] | bytes3[1] << 8 | bytes3[2] << 16 | bytes3[3] << 24,
    bytes3[4] | bytes3[5] << 8 | bytes3[6] << 16 | bytes3[7] << 24,
    unsigned
  );
};
Long.fromBytesBE = function fromBytesBE(bytes3, unsigned) {
  return new Long(
    bytes3[4] << 24 | bytes3[5] << 16 | bytes3[6] << 8 | bytes3[7],
    bytes3[0] << 24 | bytes3[1] << 16 | bytes3[2] << 8 | bytes3[3],
    unsigned
  );
};
if (typeof BigInt === "function") {
  Long.fromBigInt = function fromBigInt(value, unsigned) {
    var lowBits = Number(BigInt.asIntN(32, value));
    var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
    return fromBits(lowBits, highBits, unsigned);
  };
  Long.fromValue = function fromValueWithBigInt(value, unsigned) {
    if (typeof value === "bigint") return Long.fromBigInt(value, unsigned);
    return fromValue(value, unsigned);
  };
  LongPrototype.toBigInt = function toBigInt() {
    var lowBigInt = BigInt(this.low >>> 0);
    var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
    return highBigInt << BigInt(32) | lowBigInt;
  };
}
var long_default = Long;

// node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE3 = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber3(v3, b5) {
    var alphabet, c17, caseChanged, e39, i17, isNum, len, str, x2 = this;
    if (!(x2 instanceof BigNumber3)) return new BigNumber3(v3, b5);
    if (b5 == null) {
      if (v3 && v3._isBigNumber === true) {
        x2.s = v3.s;
        if (!v3.c || v3.e > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (v3.e < MIN_EXP) {
          x2.c = [x2.e = 0];
        } else {
          x2.e = v3.e;
          x2.c = v3.c.slice();
        }
        return;
      }
      if ((isNum = typeof v3 == "number") && v3 * 0 == 0) {
        x2.s = 1 / v3 < 0 ? (v3 = -v3, -1) : 1;
        if (v3 === ~~v3) {
          for (e39 = 0, i17 = v3; i17 >= 10; i17 /= 10, e39++) ;
          if (e39 > MAX_EXP) {
            x2.c = x2.e = null;
          } else {
            x2.e = e39;
            x2.c = [v3];
          }
          return;
        }
        str = String(v3);
      } else {
        if (!isNumeric.test(str = String(v3))) return parseNumeric(x2, str, isNum);
        x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e39 = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i17 = str.search(/e/i)) > 0) {
        if (e39 < 0) e39 = i17;
        e39 += +str.slice(i17 + 1);
        str = str.substring(0, i17);
      } else if (e39 < 0) {
        e39 = str.length;
      }
    } else {
      intCheck(b5, 2, ALPHABET.length, "Base");
      if (b5 == 10 && alphabetHasNormalDecimalDigits) {
        x2 = new BigNumber3(v3);
        return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
      }
      str = String(v3);
      if (isNum = typeof v3 == "number") {
        if (v3 * 0 != 0) return parseNumeric(x2, str, isNum, b5);
        x2.s = 1 / v3 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v3);
        }
      } else {
        x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b5);
      e39 = i17 = 0;
      for (len = str.length; i17 < len; i17++) {
        if (alphabet.indexOf(c17 = str.charAt(i17)) < 0) {
          if (c17 == ".") {
            if (i17 > e39) {
              e39 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i17 = -1;
              e39 = 0;
              continue;
            }
          }
          return parseNumeric(x2, String(v3), isNum, b5);
        }
      }
      isNum = false;
      str = convertBase(str, b5, 10, x2.s);
      if ((e39 = str.indexOf(".")) > -1) str = str.replace(".", "");
      else e39 = str.length;
    }
    for (i17 = 0; str.charCodeAt(i17) === 48; i17++) ;
    for (len = str.length; str.charCodeAt(--len) === 48; ) ;
    if (str = str.slice(i17, ++len)) {
      len -= i17;
      if (isNum && BigNumber3.DEBUG && len > 15 && (v3 > MAX_SAFE_INTEGER || v3 !== mathfloor(v3))) {
        throw Error(tooManyDigits + x2.s * v3);
      }
      if ((e39 = e39 - i17 - 1) > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (e39 < MIN_EXP) {
        x2.c = [x2.e = 0];
      } else {
        x2.e = e39;
        x2.c = [];
        i17 = (e39 + 1) % LOG_BASE;
        if (e39 < 0) i17 += LOG_BASE;
        if (i17 < len) {
          if (i17) x2.c.push(+str.slice(0, i17));
          for (len -= LOG_BASE; i17 < len; ) {
            x2.c.push(+str.slice(i17, i17 += LOG_BASE));
          }
          i17 = LOG_BASE - (str = str.slice(i17)).length;
        } else {
          i17 -= len;
        }
        for (; i17--; str += "0") ;
        x2.c.push(+str);
      }
    } else {
      x2.c = [x2.e = 0];
    }
  }
  BigNumber3.clone = clone;
  BigNumber3.ROUND_UP = 0;
  BigNumber3.ROUND_DOWN = 1;
  BigNumber3.ROUND_CEIL = 2;
  BigNumber3.ROUND_FLOOR = 3;
  BigNumber3.ROUND_HALF_UP = 4;
  BigNumber3.ROUND_HALF_DOWN = 5;
  BigNumber3.ROUND_HALF_EVEN = 6;
  BigNumber3.ROUND_HALF_CEIL = 7;
  BigNumber3.ROUND_HALF_FLOOR = 8;
  BigNumber3.EUCLID = 9;
  BigNumber3.config = BigNumber3.set = function(obj) {
    var p3, v3;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p3 = "DECIMAL_PLACES")) {
          v3 = obj[p3];
          intCheck(v3, 0, MAX, p3);
          DECIMAL_PLACES = v3;
        }
        if (obj.hasOwnProperty(p3 = "ROUNDING_MODE")) {
          v3 = obj[p3];
          intCheck(v3, 0, 8, p3);
          ROUNDING_MODE = v3;
        }
        if (obj.hasOwnProperty(p3 = "EXPONENTIAL_AT")) {
          v3 = obj[p3];
          if (v3 && v3.pop) {
            intCheck(v3[0], -MAX, 0, p3);
            intCheck(v3[1], 0, MAX, p3);
            TO_EXP_NEG = v3[0];
            TO_EXP_POS = v3[1];
          } else {
            intCheck(v3, -MAX, MAX, p3);
            TO_EXP_NEG = -(TO_EXP_POS = v3 < 0 ? -v3 : v3);
          }
        }
        if (obj.hasOwnProperty(p3 = "RANGE")) {
          v3 = obj[p3];
          if (v3 && v3.pop) {
            intCheck(v3[0], -MAX, -1, p3);
            intCheck(v3[1], 1, MAX, p3);
            MIN_EXP = v3[0];
            MAX_EXP = v3[1];
          } else {
            intCheck(v3, -MAX, MAX, p3);
            if (v3) {
              MIN_EXP = -(MAX_EXP = v3 < 0 ? -v3 : v3);
            } else {
              throw Error(bignumberError + p3 + " cannot be zero: " + v3);
            }
          }
        }
        if (obj.hasOwnProperty(p3 = "CRYPTO")) {
          v3 = obj[p3];
          if (v3 === !!v3) {
            if (v3) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v3;
              } else {
                CRYPTO = !v3;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v3;
            }
          } else {
            throw Error(bignumberError + p3 + " not true or false: " + v3);
          }
        }
        if (obj.hasOwnProperty(p3 = "MODULO_MODE")) {
          v3 = obj[p3];
          intCheck(v3, 0, 9, p3);
          MODULO_MODE = v3;
        }
        if (obj.hasOwnProperty(p3 = "POW_PRECISION")) {
          v3 = obj[p3];
          intCheck(v3, 0, MAX, p3);
          POW_PRECISION = v3;
        }
        if (obj.hasOwnProperty(p3 = "FORMAT")) {
          v3 = obj[p3];
          if (typeof v3 == "object") FORMAT = v3;
          else throw Error(bignumberError + p3 + " not an object: " + v3);
        }
        if (obj.hasOwnProperty(p3 = "ALPHABET")) {
          v3 = obj[p3];
          if (typeof v3 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v3)) {
            alphabetHasNormalDecimalDigits = v3.slice(0, 10) == "0123456789";
            ALPHABET = v3;
          } else {
            throw Error(bignumberError + p3 + " invalid: " + v3);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber3.isBigNumber = function(v3) {
    if (!v3 || v3._isBigNumber !== true) return false;
    if (!BigNumber3.DEBUG) return true;
    var i17, n31, c17 = v3.c, e39 = v3.e, s26 = v3.s;
    out: if ({}.toString.call(c17) == "[object Array]") {
      if ((s26 === 1 || s26 === -1) && e39 >= -MAX && e39 <= MAX && e39 === mathfloor(e39)) {
        if (c17[0] === 0) {
          if (e39 === 0 && c17.length === 1) return true;
          break out;
        }
        i17 = (e39 + 1) % LOG_BASE;
        if (i17 < 1) i17 += LOG_BASE;
        if (String(c17[0]).length == i17) {
          for (i17 = 0; i17 < c17.length; i17++) {
            n31 = c17[i17];
            if (n31 < 0 || n31 >= BASE || n31 !== mathfloor(n31)) break out;
          }
          if (n31 !== 0) return true;
        }
      }
    } else if (c17 === null && e39 === null && (s26 === null || s26 === 1 || s26 === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v3);
  };
  BigNumber3.maximum = BigNumber3.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber3.minimum = BigNumber3.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber3.random = (function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a23, b5, e39, k3, v3, i17 = 0, c17 = [], rand = new BigNumber3(ONE3);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k3 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a23 = crypto.getRandomValues(new Uint32Array(k3 *= 2));
          for (; i17 < k3; ) {
            v3 = a23[i17] * 131072 + (a23[i17 + 1] >>> 11);
            if (v3 >= 9e15) {
              b5 = crypto.getRandomValues(new Uint32Array(2));
              a23[i17] = b5[0];
              a23[i17 + 1] = b5[1];
            } else {
              c17.push(v3 % 1e14);
              i17 += 2;
            }
          }
          i17 = k3 / 2;
        } else if (crypto.randomBytes) {
          a23 = crypto.randomBytes(k3 *= 7);
          for (; i17 < k3; ) {
            v3 = (a23[i17] & 31) * 281474976710656 + a23[i17 + 1] * 1099511627776 + a23[i17 + 2] * 4294967296 + a23[i17 + 3] * 16777216 + (a23[i17 + 4] << 16) + (a23[i17 + 5] << 8) + a23[i17 + 6];
            if (v3 >= 9e15) {
              crypto.randomBytes(7).copy(a23, i17);
            } else {
              c17.push(v3 % 1e14);
              i17 += 7;
            }
          }
          i17 = k3 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i17 < k3; ) {
          v3 = random53bitInt();
          if (v3 < 9e15) c17[i17++] = v3 % 1e14;
        }
      }
      k3 = c17[--i17];
      dp %= LOG_BASE;
      if (k3 && dp) {
        v3 = POWS_TEN[LOG_BASE - dp];
        c17[i17] = mathfloor(k3 / v3) * v3;
      }
      for (; c17[i17] === 0; c17.pop(), i17--) ;
      if (i17 < 0) {
        c17 = [e39 = 0];
      } else {
        for (e39 = -1; c17[0] === 0; c17.splice(0, 1), e39 -= LOG_BASE) ;
        for (i17 = 1, v3 = c17[0]; v3 >= 10; v3 /= 10, i17++) ;
        if (i17 < LOG_BASE) e39 -= LOG_BASE - i17;
      }
      rand.e = e39;
      rand.c = c17;
      return rand;
    };
  })();
  BigNumber3.sum = function() {
    var i17 = 1, args = arguments, sum = new BigNumber3(args[0]);
    for (; i17 < args.length; ) sum = sum.plus(args[i17++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ (function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j2, arr = [0], arrL, i17 = 0, len = str.length;
      for (; i17 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet.indexOf(str.charAt(i17++));
        for (j2 = 0; j2 < arr.length; j2++) {
          if (arr[j2] > baseOut - 1) {
            if (arr[j2 + 1] == null) arr[j2 + 1] = 0;
            arr[j2 + 1] += arr[j2] / baseOut | 0;
            arr[j2] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet, d18, e39, k3, r41, x2, xc, y5, i17 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i17 >= 0) {
        k3 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y5 = new BigNumber3(baseIn);
        x2 = y5.pow(str.length - i17);
        POW_PRECISION = k3;
        y5.c = toBaseOut(
          toFixedPoint(coeffToString(x2.c), x2.e, "0"),
          10,
          baseOut,
          decimal
        );
        y5.e = y5.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e39 = k3 = xc.length;
      for (; xc[--k3] == 0; xc.pop()) ;
      if (!xc[0]) return alphabet.charAt(0);
      if (i17 < 0) {
        --e39;
      } else {
        x2.c = xc;
        x2.e = e39;
        x2.s = sign2;
        x2 = div(x2, y5, dp, rm, baseOut);
        xc = x2.c;
        r41 = x2.r;
        e39 = x2.e;
      }
      d18 = e39 + dp + 1;
      i17 = xc[d18];
      k3 = baseOut / 2;
      r41 = r41 || d18 < 0 || xc[d18 + 1] != null;
      r41 = rm < 4 ? (i17 != null || r41) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i17 > k3 || i17 == k3 && (rm == 4 || r41 || rm == 6 && xc[d18 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (d18 < 1 || !xc[0]) {
        str = r41 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d18;
        if (r41) {
          for (--baseOut; ++xc[--d18] > baseOut; ) {
            xc[d18] = 0;
            if (!d18) {
              ++e39;
              xc = [1].concat(xc);
            }
          }
        }
        for (k3 = xc.length; !xc[--k3]; ) ;
        for (i17 = 0, str = ""; i17 <= k3; str += alphabet.charAt(xc[i17++])) ;
        str = toFixedPoint(str, e39, alphabet.charAt(0));
      }
      return str;
    };
  })();
  div = /* @__PURE__ */ (function() {
    function multiply2(x2, k3, base) {
      var m6, temp, xlo, xhi, carry = 0, i17 = x2.length, klo = k3 % SQRT_BASE, khi = k3 / SQRT_BASE | 0;
      for (x2 = x2.slice(); i17--; ) {
        xlo = x2[i17] % SQRT_BASE;
        xhi = x2[i17] / SQRT_BASE | 0;
        m6 = khi * xlo + xhi * klo;
        temp = klo * xlo + m6 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m6 / SQRT_BASE | 0) + khi * xhi;
        x2[i17] = temp % base;
      }
      if (carry) x2 = [carry].concat(x2);
      return x2;
    }
    function compare3(a23, b5, aL, bL) {
      var i17, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i17 = cmp = 0; i17 < aL; i17++) {
          if (a23[i17] != b5[i17]) {
            cmp = a23[i17] > b5[i17] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract2(a23, b5, aL, base) {
      var i17 = 0;
      for (; aL--; ) {
        a23[aL] -= i17;
        i17 = a23[aL] < b5[aL] ? 1 : 0;
        a23[aL] = i17 * base + a23[aL] - b5[aL];
      }
      for (; !a23[0] && a23.length > 1; a23.splice(0, 1)) ;
    }
    return function(x2, y5, dp, rm, base) {
      var cmp, e39, i17, more, n31, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s26 = x2.s == y5.s ? 1 : -1, xc = x2.c, yc = y5.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber3(
          // Return NaN if either NaN, or both Infinity or 0.
          !x2.s || !y5.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s26 * 0 : s26 / 0
          )
        );
      }
      q = new BigNumber3(s26);
      qc = q.c = [];
      e39 = x2.e - y5.e;
      s26 = dp + e39 + 1;
      if (!base) {
        base = BASE;
        e39 = bitFloor(x2.e / LOG_BASE) - bitFloor(y5.e / LOG_BASE);
        s26 = s26 / LOG_BASE | 0;
      }
      for (i17 = 0; yc[i17] == (xc[i17] || 0); i17++) ;
      if (yc[i17] > (xc[i17] || 0)) e39--;
      if (s26 < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i17 = 0;
        s26 += 2;
        n31 = mathfloor(base / (yc[0] + 1));
        if (n31 > 1) {
          yc = multiply2(yc, n31, base);
          xc = multiply2(xc, n31, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++;
        do {
          n31 = 0;
          cmp = compare3(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
            n31 = mathfloor(rem0 / yc0);
            if (n31 > 1) {
              if (n31 >= base) n31 = base - 1;
              prod = multiply2(yc, n31, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare3(prod, rem, prodL, remL) == 1) {
                n31--;
                subtract2(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n31 == 0) {
                cmp = n31 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract2(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare3(yc, rem, yL, remL) < 1) {
                n31++;
                subtract2(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n31++;
            rem = [0];
          }
          qc[i17++] = n31;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s26--);
        more = rem[0] != null;
        if (!qc[0]) qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i17 = 1, s26 = qc[0]; s26 >= 10; s26 /= 10, i17++) ;
        round(q, dp + (q.e = i17 + e39 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e39;
        q.r = +more;
      }
      return q;
    };
  })();
  function format(n31, i17, rm, id2) {
    var c0, e39, ne, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n31.c) return n31.toString();
    c0 = n31.c[0];
    ne = n31.e;
    if (i17 == null) {
      str = coeffToString(n31.c);
      str = id2 == 1 || id2 == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n31 = round(new BigNumber3(n31), i17, rm);
      e39 = n31.e;
      str = coeffToString(n31.c);
      len = str.length;
      if (id2 == 1 || id2 == 2 && (i17 <= e39 || e39 <= TO_EXP_NEG)) {
        for (; len < i17; str += "0", len++) ;
        str = toExponential(str, e39);
      } else {
        i17 -= ne + (id2 === 2 && e39 > ne);
        str = toFixedPoint(str, e39, "0");
        if (e39 + 1 > len) {
          if (--i17 > 0) for (str += "."; i17--; str += "0") ;
        } else {
          i17 += e39 - len;
          if (i17 > 0) {
            if (e39 + 1 == len) str += ".";
            for (; i17--; str += "0") ;
          }
        }
      }
    }
    return n31.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n31) {
    var k3, y5, i17 = 1, x2 = new BigNumber3(args[0]);
    for (; i17 < args.length; i17++) {
      y5 = new BigNumber3(args[i17]);
      if (!y5.s || (k3 = compare2(x2, y5)) === n31 || k3 === 0 && x2.s === n31) {
        x2 = y5;
      }
    }
    return x2;
  }
  function normalise(n31, c17, e39) {
    var i17 = 1, j2 = c17.length;
    for (; !c17[--j2]; c17.pop()) ;
    for (j2 = c17[0]; j2 >= 10; j2 /= 10, i17++) ;
    if ((e39 = i17 + e39 * LOG_BASE - 1) > MAX_EXP) {
      n31.c = n31.e = null;
    } else if (e39 < MIN_EXP) {
      n31.c = [n31.e = 0];
    } else {
      n31.e = e39;
      n31.c = c17;
    }
    return n31;
  }
  parseNumeric = /* @__PURE__ */ (function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x2, str, isNum, b5) {
      var base, s26 = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s26)) {
        x2.s = isNaN(s26) ? null : s26 < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s26 = s26.replace(basePrefix, function(m6, p1, p22) {
            base = (p22 = p22.toLowerCase()) == "x" ? 16 : p22 == "b" ? 2 : 8;
            return !b5 || b5 == base ? p1 : m6;
          });
          if (b5) {
            base = b5;
            s26 = s26.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s26) return new BigNumber3(s26, base);
        }
        if (BigNumber3.DEBUG) {
          throw Error(bignumberError + "Not a" + (b5 ? " base " + b5 : "") + " number: " + str);
        }
        x2.s = null;
      }
      x2.c = x2.e = null;
    };
  })();
  function round(x2, sd, rm, r41) {
    var d18, i17, j2, k3, n31, ni, rd, xc = x2.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d18 = 1, k3 = xc[0]; k3 >= 10; k3 /= 10, d18++) ;
        i17 = sd - d18;
        if (i17 < 0) {
          i17 += LOG_BASE;
          j2 = sd;
          n31 = xc[ni = 0];
          rd = mathfloor(n31 / pows10[d18 - j2 - 1] % 10);
        } else {
          ni = mathceil((i17 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r41) {
              for (; xc.length <= ni; xc.push(0)) ;
              n31 = rd = 0;
              d18 = 1;
              i17 %= LOG_BASE;
              j2 = i17 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n31 = k3 = xc[ni];
            for (d18 = 1; k3 >= 10; k3 /= 10, d18++) ;
            i17 %= LOG_BASE;
            j2 = i17 - LOG_BASE + d18;
            rd = j2 < 0 ? 0 : mathfloor(n31 / pows10[d18 - j2 - 1] % 10);
          }
        }
        r41 = r41 || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j2 < 0 ? n31 : n31 % pows10[d18 - j2 - 1]);
        r41 = rm < 4 ? (rd || r41) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r41 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i17 > 0 ? j2 > 0 ? n31 / pows10[d18 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r41) {
            sd -= x2.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x2.e = -sd || 0;
          } else {
            xc[0] = x2.e = 0;
          }
          return x2;
        }
        if (i17 == 0) {
          xc.length = ni;
          k3 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k3 = pows10[LOG_BASE - i17];
          xc[ni] = j2 > 0 ? mathfloor(n31 / pows10[d18 - j2] % pows10[j2]) * k3 : 0;
        }
        if (r41) {
          for (; ; ) {
            if (ni == 0) {
              for (i17 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i17++) ;
              j2 = xc[0] += k3;
              for (k3 = 1; j2 >= 10; j2 /= 10, k3++) ;
              if (i17 != k3) {
                x2.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k3;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k3 = 1;
            }
          }
        }
        for (i17 = xc.length; xc[--i17] === 0; xc.pop()) ;
      }
      if (x2.e > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (x2.e < MIN_EXP) {
        x2.c = [x2.e = 0];
      }
    }
    return x2;
  }
  function valueOf(n31) {
    var str, e39 = n31.e;
    if (e39 === null) return n31.toString();
    str = coeffToString(n31.c);
    str = e39 <= TO_EXP_NEG || e39 >= TO_EXP_POS ? toExponential(str, e39) : toFixedPoint(str, e39, "0");
    return n31.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x2 = new BigNumber3(this);
    if (x2.s < 0) x2.s = 1;
    return x2;
  };
  P2.comparedTo = function(y5, b5) {
    return compare2(this, new BigNumber3(y5, b5));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c17, n31, v3, x2 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber3(x2), dp + x2.e + 1, rm);
    }
    if (!(c17 = x2.c)) return null;
    n31 = ((v3 = c17.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v3 = c17[v3]) for (; v3 % 10 == 0; v3 /= 10, n31--) ;
    if (n31 < 0) n31 = 0;
    return n31;
  };
  P2.dividedBy = P2.div = function(y5, b5) {
    return div(this, new BigNumber3(y5, b5), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y5, b5) {
    return div(this, new BigNumber3(y5, b5), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n31, m6) {
    var half, isModExp, i17, k3, more, nIsBig, nIsNeg, nIsOdd, y5, x2 = this;
    n31 = new BigNumber3(n31);
    if (n31.c && !n31.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n31));
    }
    if (m6 != null) m6 = new BigNumber3(m6);
    nIsBig = n31.e > 14;
    if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n31.c || !n31.c[0]) {
      y5 = new BigNumber3(Math.pow(+valueOf(x2), nIsBig ? n31.s * (2 - isOdd2(n31)) : +valueOf(n31)));
      return m6 ? y5.mod(m6) : y5;
    }
    nIsNeg = n31.s < 0;
    if (m6) {
      if (m6.c ? !m6.c[0] : !m6.s) return new BigNumber3(NaN);
      isModExp = !nIsNeg && x2.isInteger() && m6.isInteger();
      if (isModExp) x2 = x2.mod(m6);
    } else if (n31.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
      k3 = x2.s < 0 && isOdd2(n31) ? -0 : 0;
      if (x2.e > -1) k3 = 1 / k3;
      return new BigNumber3(nIsNeg ? 1 / k3 : k3);
    } else if (POW_PRECISION) {
      k3 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber3(0.5);
      if (nIsNeg) n31.s = 1;
      nIsOdd = isOdd2(n31);
    } else {
      i17 = Math.abs(+valueOf(n31));
      nIsOdd = i17 % 2;
    }
    y5 = new BigNumber3(ONE3);
    for (; ; ) {
      if (nIsOdd) {
        y5 = y5.times(x2);
        if (!y5.c) break;
        if (k3) {
          if (y5.c.length > k3) y5.c.length = k3;
        } else if (isModExp) {
          y5 = y5.mod(m6);
        }
      }
      if (i17) {
        i17 = mathfloor(i17 / 2);
        if (i17 === 0) break;
        nIsOdd = i17 % 2;
      } else {
        n31 = n31.times(half);
        round(n31, n31.e + 1, 1);
        if (n31.e > 14) {
          nIsOdd = isOdd2(n31);
        } else {
          i17 = +valueOf(n31);
          if (i17 === 0) break;
          nIsOdd = i17 % 2;
        }
      }
      x2 = x2.times(x2);
      if (k3) {
        if (x2.c && x2.c.length > k3) x2.c.length = k3;
      } else if (isModExp) {
        x2 = x2.mod(m6);
      }
    }
    if (isModExp) return y5;
    if (nIsNeg) y5 = ONE3.div(y5);
    return m6 ? y5.mod(m6) : k3 ? round(y5, POW_PRECISION, ROUNDING_MODE, more) : y5;
  };
  P2.integerValue = function(rm) {
    var n31 = new BigNumber3(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n31, n31.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y5, b5) {
    return compare2(this, new BigNumber3(y5, b5)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y5, b5) {
    return compare2(this, new BigNumber3(y5, b5)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y5, b5) {
    return (b5 = compare2(this, new BigNumber3(y5, b5))) === 1 || b5 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y5, b5) {
    return compare2(this, new BigNumber3(y5, b5)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y5, b5) {
    return (b5 = compare2(this, new BigNumber3(y5, b5))) === -1 || b5 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y5, b5) {
    var i17, j2, t35, xLTy, x2 = this, a23 = x2.s;
    y5 = new BigNumber3(y5, b5);
    b5 = y5.s;
    if (!a23 || !b5) return new BigNumber3(NaN);
    if (a23 != b5) {
      y5.s = -b5;
      return x2.plus(y5);
    }
    var xe = x2.e / LOG_BASE, ye = y5.e / LOG_BASE, xc = x2.c, yc = y5.c;
    if (!xe || !ye) {
      if (!xc || !yc) return xc ? (y5.s = -b5, y5) : new BigNumber3(yc ? x2 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y5.s = -b5, y5) : new BigNumber3(xc[0] ? x2 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a23 = xe - ye) {
      if (xLTy = a23 < 0) {
        a23 = -a23;
        t35 = xc;
      } else {
        ye = xe;
        t35 = yc;
      }
      t35.reverse();
      for (b5 = a23; b5--; t35.push(0)) ;
      t35.reverse();
    } else {
      j2 = (xLTy = (a23 = xc.length) < (b5 = yc.length)) ? a23 : b5;
      for (a23 = b5 = 0; b5 < j2; b5++) {
        if (xc[b5] != yc[b5]) {
          xLTy = xc[b5] < yc[b5];
          break;
        }
      }
    }
    if (xLTy) {
      t35 = xc;
      xc = yc;
      yc = t35;
      y5.s = -y5.s;
    }
    b5 = (j2 = yc.length) - (i17 = xc.length);
    if (b5 > 0) for (; b5--; xc[i17++] = 0) ;
    b5 = BASE - 1;
    for (; j2 > a23; ) {
      if (xc[--j2] < yc[j2]) {
        for (i17 = j2; i17 && !xc[--i17]; xc[i17] = b5) ;
        --xc[i17];
        xc[j2] += BASE;
      }
      xc[j2] -= yc[j2];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
    if (!xc[0]) {
      y5.s = ROUNDING_MODE == 3 ? -1 : 1;
      y5.c = [y5.e = 0];
      return y5;
    }
    return normalise(y5, xc, ye);
  };
  P2.modulo = P2.mod = function(y5, b5) {
    var q, s26, x2 = this;
    y5 = new BigNumber3(y5, b5);
    if (!x2.c || !y5.s || y5.c && !y5.c[0]) {
      return new BigNumber3(NaN);
    } else if (!y5.c || x2.c && !x2.c[0]) {
      return new BigNumber3(x2);
    }
    if (MODULO_MODE == 9) {
      s26 = y5.s;
      y5.s = 1;
      q = div(x2, y5, 0, 3);
      y5.s = s26;
      q.s *= s26;
    } else {
      q = div(x2, y5, 0, MODULO_MODE);
    }
    y5 = x2.minus(q.times(y5));
    if (!y5.c[0] && MODULO_MODE == 1) y5.s = x2.s;
    return y5;
  };
  P2.multipliedBy = P2.times = function(y5, b5) {
    var c17, e39, i17, j2, k3, m6, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y5 = new BigNumber3(y5, b5)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x2.s || !y5.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y5.c = y5.e = y5.s = null;
      } else {
        y5.s *= x2.s;
        if (!xc || !yc) {
          y5.c = y5.e = null;
        } else {
          y5.c = [0];
          y5.e = 0;
        }
      }
      return y5;
    }
    e39 = bitFloor(x2.e / LOG_BASE) + bitFloor(y5.e / LOG_BASE);
    y5.s *= x2.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i17 = xcL;
      xcL = ycL;
      ycL = i17;
    }
    for (i17 = xcL + ycL, zc = []; i17--; zc.push(0)) ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i17 = ycL; --i17 >= 0; ) {
      c17 = 0;
      ylo = yc[i17] % sqrtBase;
      yhi = yc[i17] / sqrtBase | 0;
      for (k3 = xcL, j2 = i17 + k3; j2 > i17; ) {
        xlo = xc[--k3] % sqrtBase;
        xhi = xc[k3] / sqrtBase | 0;
        m6 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m6 % sqrtBase * sqrtBase + zc[j2] + c17;
        c17 = (xlo / base | 0) + (m6 / sqrtBase | 0) + yhi * xhi;
        zc[j2--] = xlo % base;
      }
      zc[j2] = c17;
    }
    if (c17) {
      ++e39;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y5, zc, e39);
  };
  P2.negated = function() {
    var x2 = new BigNumber3(this);
    x2.s = -x2.s || null;
    return x2;
  };
  P2.plus = function(y5, b5) {
    var t35, x2 = this, a23 = x2.s;
    y5 = new BigNumber3(y5, b5);
    b5 = y5.s;
    if (!a23 || !b5) return new BigNumber3(NaN);
    if (a23 != b5) {
      y5.s = -b5;
      return x2.minus(y5);
    }
    var xe = x2.e / LOG_BASE, ye = y5.e / LOG_BASE, xc = x2.c, yc = y5.c;
    if (!xe || !ye) {
      if (!xc || !yc) return new BigNumber3(a23 / 0);
      if (!xc[0] || !yc[0]) return yc[0] ? y5 : new BigNumber3(xc[0] ? x2 : a23 * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a23 = xe - ye) {
      if (a23 > 0) {
        ye = xe;
        t35 = yc;
      } else {
        a23 = -a23;
        t35 = xc;
      }
      t35.reverse();
      for (; a23--; t35.push(0)) ;
      t35.reverse();
    }
    a23 = xc.length;
    b5 = yc.length;
    if (a23 - b5 < 0) {
      t35 = yc;
      yc = xc;
      xc = t35;
      b5 = a23;
    }
    for (a23 = 0; b5; ) {
      a23 = (xc[--b5] = xc[b5] + yc[b5] + a23) / BASE | 0;
      xc[b5] = BASE === xc[b5] ? 0 : xc[b5] % BASE;
    }
    if (a23) {
      xc = [a23].concat(xc);
      ++ye;
    }
    return normalise(y5, xc, ye);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c17, n31, v3, x2 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber3(x2), sd, rm);
    }
    if (!(c17 = x2.c)) return null;
    v3 = c17.length - 1;
    n31 = v3 * LOG_BASE + 1;
    if (v3 = c17[v3]) {
      for (; v3 % 10 == 0; v3 /= 10, n31--) ;
      for (v3 = c17[0]; v3 >= 10; v3 /= 10, n31++) ;
    }
    if (sd && x2.e + 1 > n31) n31 = x2.e + 1;
    return n31;
  };
  P2.shiftedBy = function(k3) {
    intCheck(k3, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k3);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m6, n31, r41, rep, t35, x2 = this, c17 = x2.c, s26 = x2.s, e39 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
    if (s26 !== 1 || !c17 || !c17[0]) {
      return new BigNumber3(!s26 || s26 < 0 && (!c17 || c17[0]) ? NaN : c17 ? x2 : 1 / 0);
    }
    s26 = Math.sqrt(+valueOf(x2));
    if (s26 == 0 || s26 == 1 / 0) {
      n31 = coeffToString(c17);
      if ((n31.length + e39) % 2 == 0) n31 += "0";
      s26 = Math.sqrt(+n31);
      e39 = bitFloor((e39 + 1) / 2) - (e39 < 0 || e39 % 2);
      if (s26 == 1 / 0) {
        n31 = "5e" + e39;
      } else {
        n31 = s26.toExponential();
        n31 = n31.slice(0, n31.indexOf("e") + 1) + e39;
      }
      r41 = new BigNumber3(n31);
    } else {
      r41 = new BigNumber3(s26 + "");
    }
    if (r41.c[0]) {
      e39 = r41.e;
      s26 = e39 + dp;
      if (s26 < 3) s26 = 0;
      for (; ; ) {
        t35 = r41;
        r41 = half.times(t35.plus(div(x2, t35, dp, 1)));
        if (coeffToString(t35.c).slice(0, s26) === (n31 = coeffToString(r41.c)).slice(0, s26)) {
          if (r41.e < e39) --s26;
          n31 = n31.slice(s26 - 3, s26 + 1);
          if (n31 == "9999" || !rep && n31 == "4999") {
            if (!rep) {
              round(t35, t35.e + DECIMAL_PLACES + 2, 0);
              if (t35.times(t35).eq(x2)) {
                r41 = t35;
                break;
              }
            }
            dp += 4;
            s26 += 4;
            rep = 1;
          } else {
            if (!+n31 || !+n31.slice(1) && n31.charAt(0) == "5") {
              round(r41, r41.e + DECIMAL_PLACES + 2, 1);
              m6 = !r41.times(r41).eq(x2);
            }
            break;
          }
        }
      }
    }
    return round(r41, r41.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m6);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str, x2 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x2.toFixed(dp, rm);
    if (x2.c) {
      var i17, arr = str.split("."), g1 = +format2.groupSize, g22 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g22) {
        i17 = g1;
        g1 = g22;
        g22 = i17;
        len -= i17;
      }
      if (g1 > 0 && len > 0) {
        i17 = len % g1 || g1;
        intPart = intDigits.substr(0, i17);
        for (; i17 < len; i17 += g1) intPart += groupSeparator + intDigits.substr(i17, g1);
        if (g22 > 0) intPart += groupSeparator + intDigits.slice(i17);
        if (isNeg) intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g22 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g22 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P2.toFraction = function(md) {
    var d18, d0, d1, d22, e39, exp, n31, n0, n1, q, r41, s26, x2 = this, xc = x2.c;
    if (md != null) {
      n31 = new BigNumber3(md);
      if (!n31.isInteger() && (n31.c || n31.s !== 1) || n31.lt(ONE3)) {
        throw Error(bignumberError + "Argument " + (n31.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n31));
      }
    }
    if (!xc) return new BigNumber3(x2);
    d18 = new BigNumber3(ONE3);
    n1 = d0 = new BigNumber3(ONE3);
    d1 = n0 = new BigNumber3(ONE3);
    s26 = coeffToString(xc);
    e39 = d18.e = s26.length - x2.e - 1;
    d18.c[0] = POWS_TEN[(exp = e39 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n31.comparedTo(d18) > 0 ? e39 > 0 ? d18 : n1 : n31;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n31 = new BigNumber3(s26);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n31, d18, 0, 1);
      d22 = d0.plus(q.times(d1));
      if (d22.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q.times(d22 = n1));
      n0 = d22;
      d18 = n31.minus(q.times(d22 = d18));
      n31 = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x2.s;
    e39 = e39 * 2;
    r41 = div(n1, d1, e39, ROUNDING_MODE).minus(x2).abs().comparedTo(
      div(n0, d0, e39, ROUNDING_MODE).minus(x2).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r41;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P2.toString = function(b5) {
    var str, n31 = this, s26 = n31.s, e39 = n31.e;
    if (e39 === null) {
      if (s26) {
        str = "Infinity";
        if (s26 < 0) str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b5 == null) {
        str = e39 <= TO_EXP_NEG || e39 >= TO_EXP_POS ? toExponential(coeffToString(n31.c), e39) : toFixedPoint(coeffToString(n31.c), e39, "0");
      } else if (b5 === 10 && alphabetHasNormalDecimalDigits) {
        n31 = round(new BigNumber3(n31), DECIMAL_PLACES + e39 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n31.c), n31.e, "0");
      } else {
        intCheck(b5, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n31.c), e39, "0"), 10, b5, s26, true);
      }
      if (s26 < 0 && n31.c[0]) str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null) BigNumber3.set(configObject);
  return BigNumber3;
}
function bitFloor(n31) {
  var i17 = n31 | 0;
  return n31 > 0 || n31 === i17 ? i17 : i17 - 1;
}
function coeffToString(a23) {
  var s26, z, i17 = 1, j2 = a23.length, r41 = a23[0] + "";
  for (; i17 < j2; ) {
    s26 = a23[i17++] + "";
    z = LOG_BASE - s26.length;
    for (; z--; s26 = "0" + s26) ;
    r41 += s26;
  }
  for (j2 = r41.length; r41.charCodeAt(--j2) === 48; ) ;
  return r41.slice(0, j2 + 1 || 1);
}
function compare2(x2, y5) {
  var a23, b5, xc = x2.c, yc = y5.c, i17 = x2.s, j2 = y5.s, k3 = x2.e, l19 = y5.e;
  if (!i17 || !j2) return null;
  a23 = xc && !xc[0];
  b5 = yc && !yc[0];
  if (a23 || b5) return a23 ? b5 ? 0 : -j2 : i17;
  if (i17 != j2) return i17;
  a23 = i17 < 0;
  b5 = k3 == l19;
  if (!xc || !yc) return b5 ? 0 : !xc ^ a23 ? 1 : -1;
  if (!b5) return k3 > l19 ^ a23 ? 1 : -1;
  j2 = (k3 = xc.length) < (l19 = yc.length) ? k3 : l19;
  for (i17 = 0; i17 < j2; i17++) if (xc[i17] != yc[i17]) return xc[i17] > yc[i17] ^ a23 ? 1 : -1;
  return k3 == l19 ? 0 : k3 > l19 ^ a23 ? 1 : -1;
}
function intCheck(n31, min, max, name) {
  if (n31 < min || n31 > max || n31 !== mathfloor(n31)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n31 == "number" ? n31 < min || n31 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n31));
  }
}
function isOdd2(n31) {
  var k3 = n31.c.length - 1;
  return bitFloor(n31.e / LOG_BASE) == k3 && n31.c[k3] % 2 != 0;
}
function toExponential(str, e39) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e39 < 0 ? "e" : "e+") + e39;
}
function toFixedPoint(str, e39, z) {
  var len, zs;
  if (e39 < 0) {
    for (zs = z + "."; ++e39; zs += z) ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e39 > len) {
      for (zs = z, e39 -= len; --e39; zs += z) ;
      str += zs;
    } else if (e39 < len) {
      str = str.slice(0, e39) + "." + str.slice(e39);
    }
  }
  return str;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// node_modules/rfc4648/lib/rfc4648.js
var base32Encoding = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bits: 5
};
var base32 = {
  parse: function parse(string, opts) {
    if (opts === void 0) {
      opts = {};
    }
    return _parse(opts.loose ? string.toUpperCase().replace(/0/g, "O").replace(/1/g, "L").replace(/8/g, "B") : string, base32Encoding, opts);
  },
  stringify: function stringify(data, opts) {
    return _stringify(data, base32Encoding, opts);
  }
};
function _parse(string, encoding, opts) {
  var _opts$out;
  if (opts === void 0) {
    opts = {};
  }
  if (!encoding.codes) {
    encoding.codes = {};
    for (var i17 = 0; i17 < encoding.chars.length; ++i17) {
      encoding.codes[encoding.chars[i17]] = i17;
    }
  }
  if (!opts.loose && string.length * encoding.bits & 7) {
    throw new SyntaxError("Invalid padding");
  }
  var end = string.length;
  while (string[end - 1] === "=") {
    --end;
    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
      throw new SyntaxError("Invalid padding");
    }
  }
  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0);
  var bits = 0;
  var buffer = 0;
  var written = 0;
  for (var _i = 0; _i < end; ++_i) {
    var value = encoding.codes[string[_i]];
    if (value === void 0) {
      throw new SyntaxError("Invalid character " + string[_i]);
    }
    buffer = buffer << encoding.bits | value;
    bits += encoding.bits;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= encoding.bits || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function _stringify(data, encoding, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var _opts = opts, _opts$pad = _opts.pad, pad = _opts$pad === void 0 ? true : _opts$pad;
  var mask = (1 << encoding.bits) - 1;
  var out = "";
  var bits = 0;
  var buffer = 0;
  for (var i17 = 0; i17 < data.length; ++i17) {
    buffer = buffer << 8 | 255 & data[i17];
    bits += 8;
    while (bits > encoding.bits) {
      bits -= encoding.bits;
      out += encoding.chars[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += encoding.chars[mask & buffer << encoding.bits - bits];
  }
  if (pad) {
    while (out.length * encoding.bits & 7) {
      out += "=";
    }
  }
  return out;
}

// node_modules/@hashgraph/sdk/lib/exports.js
var import_proto5 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/cryptography/src/Key.js
var Key = class {
};

// node_modules/@hashgraph/cryptography/src/BadKeyError.js
var BadKeyError = class extends Error {
  /**
   * @param {Error | string} messageOrCause
   */
  constructor(messageOrCause) {
    super(
      messageOrCause instanceof Error ? messageOrCause.message : messageOrCause
    );
    this.name = "BadKeyError";
    if (messageOrCause instanceof Error) {
      this.cause = messageOrCause;
      this.stack = messageOrCause.stack;
    }
  }
};

// node_modules/@hashgraph/cryptography/src/Ed25519PublicKey.js
var import_tweetnacl = __toESM(require_nacl_fast(), 1);

// node_modules/@hashgraph/cryptography/src/util/array.js
function arrayEqual(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.byteLength !== array2.byteLength) {
    return false;
  }
  const view1 = new DataView(
    array1.buffer,
    array1.byteOffset,
    array1.byteLength
  );
  const view2 = new DataView(
    array2.buffer,
    array2.byteOffset,
    array2.byteLength
  );
  let i17 = array1.byteLength;
  while (i17--) {
    if (view1.getUint8(i17) !== view2.getUint8(i17)) {
      return false;
    }
  }
  return true;
}
function arrayStartsWith(array, arrayPrefix) {
  if (array.byteLength < arrayPrefix.byteLength) {
    return false;
  }
  let i17 = arrayPrefix.byteLength;
  while (i17--) {
    if (array[i17] !== arrayPrefix[i17]) {
      return false;
    }
  }
  return true;
}

// node_modules/@hashgraph/cryptography/src/encoding/hex.browser.js
var byteToHex = [];
for (let n31 = 0; n31 <= 255; n31 += 1) {
  byteToHex.push(n31.toString(16).padStart(2, "0"));
}
function encode(data) {
  let string = "";
  for (const byte of data) {
    string += byteToHex[byte];
  }
  return string;
}
function decode(text) {
  const str = text.startsWith("0x") ? text.substring(2) : text;
  const result = str.match(/.{1,2}/gu);
  return new Uint8Array(
    (result == null ? [] : result).map((byte) => parseInt(byte, 16))
  );
}

// node_modules/@hashgraph/cryptography/src/Ed25519PublicKey.js
var derPrefix = "302a300506032b6570032100";
var derPrefixBytes = decode(derPrefix);
var Ed25519PublicKey = class _Ed25519PublicKey extends Key {
  /**
   * @internal
   * @hideconstructor
   * @param {Uint8Array} keyData
   */
  constructor(keyData) {
    super();
    this._keyData = keyData;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return "ED25519";
  }
  /**
   * @param {Uint8Array} data
   * @returns {Ed25519PublicKey}
   */
  static fromBytes(data) {
    switch (data.length) {
      case 32:
        return _Ed25519PublicKey.fromBytesRaw(data);
      case 44:
        return _Ed25519PublicKey.fromBytesDer(data);
      default:
        throw new BadKeyError(
          `invalid public key length: ${data.length} bytes`
        );
    }
  }
  /**
   * @param {Uint8Array} data
   * @returns {Ed25519PublicKey}
   */
  static fromBytesDer(data) {
    try {
      if (data.length !== 44) {
        throw new Error(`invalid length: ${data.length} bytes`);
      }
      const actualPrefix = data.subarray(0, 12);
      if (!actualPrefix.every((byte, i17) => byte === derPrefixBytes[i17])) {
        throw new Error("invalid DER prefix");
      }
      const publicKey = data.subarray(12);
      return new _Ed25519PublicKey(publicKey);
    } catch (error) {
      throw new BadKeyError(
        `cannot decode ED25519 public key data from DER format: ${error instanceof Error ? error.message : "unknown error"}`
      );
    }
  }
  /**
   * @param {Uint8Array} data
   * @returns {Ed25519PublicKey}
   */
  static fromBytesRaw(data) {
    if (data.length != 32) {
      throw new BadKeyError(
        `invalid public key length: ${data.length} bytes`
      );
    }
    return new _Ed25519PublicKey(data);
  }
  /**
   * Parse a public key from a string of hexadecimal digits.
   *
   * The public key may optionally be prefixed with
   * the DER header.
   * @param {string} text
   * @returns {Ed25519PublicKey}
   */
  static fromString(text) {
    return _Ed25519PublicKey.fromBytes(decode(text));
  }
  /**
   * Verify a signature on a message with this public key.
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {boolean}
   */
  verify(message, signature) {
    return import_tweetnacl.default.sign.detached.verify(message, signature, this._keyData);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    const bytes3 = new Uint8Array(derPrefixBytes.length + 32);
    bytes3.set(derPrefixBytes, 0);
    bytes3.set(this._keyData.subarray(0, 32), derPrefixBytes.length);
    return bytes3;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._keyData.slice();
  }
  /**
   * @param {Ed25519PublicKey} other
   * @returns {boolean}
   */
  equals(other) {
    return arrayEqual(this._keyData, other._keyData);
  }
};

// node_modules/@hashgraph/cryptography/src/Ed25519PrivateKey.js
var import_tweetnacl3 = __toESM(require_nacl_fast(), 1);

// node_modules/@hashgraph/cryptography/src/primitive/random.js
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
function bytes(count) {
  return import_tweetnacl2.default.randomBytes(count);
}
function bytesAsync(count) {
  return Promise.resolve(import_tweetnacl2.default.randomBytes(count));
}

// node_modules/@hashgraph/cryptography/src/encoding/utf8.browser.js
function decode2(data) {
  return new TextDecoder().decode(data);
}
function encode2(text) {
  return new TextEncoder().encode(text);
}

// node_modules/@hashgraph/cryptography/src/primitive/hmac.browser.js
var HashAlgorithm = {
  Sha256: "SHA-256",
  Sha384: "SHA-384",
  Sha512: "SHA-512"
};
async function hash(algorithm, secretKey, data) {
  const key = typeof secretKey === "string" ? encode2(secretKey) : secretKey;
  const value = typeof data === "string" ? encode2(data) : data;
  try {
    const key_ = await window.crypto.subtle.importKey(
      "raw",
      key,
      {
        name: "HMAC",
        hash: algorithm
      },
      false,
      ["sign"]
    );
    return new Uint8Array(
      await window.crypto.subtle.sign("HMAC", key_, value)
    );
  } catch {
    throw new Error("Fallback if SubtleCrypto fails is not implemented");
  }
}

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a23) {
  return a23 instanceof Uint8Array || ArrayBuffer.isView(a23) && a23.constructor.name === "Uint8Array";
}
function anumber(n31) {
  if (!Number.isSafeInteger(n31) || n31 < 0)
    throw new Error("positive integer expected, got " + n31);
}
function abytes(b5, ...lengths) {
  if (!isBytes(b5))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b5.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b5.length);
}
function ahash(h8) {
  if (typeof h8 !== "function" || typeof h8.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h8.outputLen);
  anumber(h8.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i17 = 0; i17 < arrays.length; i17++) {
    arrays[i17].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_4, i17) => i17.toString(16).padStart(2, "0"));
function bytesToHex(bytes3) {
  abytes(bytes3);
  if (hasHexBuiltin)
    return bytes3.toHex();
  let hex = "";
  for (let i17 = 0; i17 < bytes3.length; i17++) {
    hex += hexes[bytes3[i17]];
  }
  return hex;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n210 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n210 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n210;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i17 = 0; i17 < arrays.length; i17++) {
    const a23 = arrays[i17];
    abytes(a23);
    sum += a23.length;
  }
  const res = new Uint8Array(sum);
  for (let i17 = 0, pad = 0; i17 < arrays.length; i17++) {
    const a23 = arrays[i17];
    res.set(a23, pad);
    pad += a23.length;
  }
  return res;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h8 = isLE2 ? 4 : 0;
  const l19 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h8, wh, isLE2);
  view.setUint32(byteOffset + l19, wl, isLE2);
}
function Chi(a23, b5, c17) {
  return a23 & b5 ^ ~a23 & c17;
}
function Maj(a23, b5, c17) {
  return a23 & b5 ^ a23 & c17 ^ b5 & c17;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes2(data);
    abytes(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i17 = pos; i17 < blockLen; i17++)
      buffer[i17] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i17 = 0; i17 < outLen; i17++)
      oview.setUint32(4 * i17, state[i17], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n31, le = false) {
  if (le)
    return { h: Number(n31 & U32_MASK64), l: Number(n31 >> _32n & U32_MASK64) };
  return { h: Number(n31 >> _32n & U32_MASK64) | 0, l: Number(n31 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i17 = 0; i17 < len; i17++) {
    const { h: h8, l: l19 } = fromBig(lst[i17], le);
    [Ah[i17], Al[i17]] = [h8, l19];
  }
  return [Ah, Al];
}
var shrSH = (h8, _l, s26) => h8 >>> s26;
var shrSL = (h8, l19, s26) => h8 << 32 - s26 | l19 >>> s26;
var rotrSH = (h8, l19, s26) => h8 >>> s26 | l19 << 32 - s26;
var rotrSL = (h8, l19, s26) => h8 << 32 - s26 | l19 >>> s26;
var rotrBH = (h8, l19, s26) => h8 << 64 - s26 | l19 >>> s26 - 32;
var rotrBL = (h8, l19, s26) => h8 >>> s26 - 32 | l19 << 64 - s26;
function add2(Ah, Al, Bh, Bl) {
  const l19 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l19 / 2 ** 32 | 0) | 0, l: l19 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// node_modules/@noble/hashes/esm/sha2.js
var SHA256_K = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A3, B: B2, C, D, E: E3, F: F2, G, H } = this;
    return [A3, B2, C, D, E3, F2, G, H];
  }
  // prettier-ignore
  set(A3, B2, C, D, E3, F2, G, H) {
    this.A = A3 | 0;
    this.B = B2 | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E3 | 0;
    this.F = F2 | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i17 = 0; i17 < 16; i17++, offset += 4)
      SHA256_W[i17] = view.getUint32(offset, false);
    for (let i17 = 16; i17 < 64; i17++) {
      const W15 = SHA256_W[i17 - 15];
      const W2 = SHA256_W[i17 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i17] = s1 + SHA256_W[i17 - 7] + s0 + SHA256_W[i17 - 16] | 0;
    }
    let { A: A3, B: B2, C, D, E: E3, F: F2, G, H } = this;
    for (let i17 = 0; i17 < 64; i17++) {
      const sigma1 = rotr(E3, 6) ^ rotr(E3, 11) ^ rotr(E3, 25);
      const T1 = H + sigma1 + Chi(E3, F2, G) + SHA256_K[i17] + SHA256_W[i17] | 0;
      const sigma0 = rotr(A3, 2) ^ rotr(A3, 13) ^ rotr(A3, 22);
      const T22 = sigma0 + Maj(A3, B2, C) | 0;
      H = G;
      G = F2;
      F2 = E3;
      E3 = D + T1 | 0;
      D = C;
      C = B2;
      B2 = A3;
      A3 = T1 + T22 | 0;
    }
    A3 = A3 + this.A | 0;
    B2 = B2 + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E3 = E3 + this.E | 0;
    F2 = F2 + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A3, B2, C, D, E3, F2, G, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super(28);
    this.A = SHA224_IV[0] | 0;
    this.B = SHA224_IV[1] | 0;
    this.C = SHA224_IV[2] | 0;
    this.D = SHA224_IV[3] | 0;
    this.E = SHA224_IV[4] | 0;
    this.F = SHA224_IV[5] | 0;
    this.G = SHA224_IV[6] | 0;
    this.H = SHA224_IV[7] | 0;
  }
};
var K512 = (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n31) => BigInt(n31))))();
var SHA512_Kh = (() => K512[0])();
var SHA512_Kl = (() => K512[1])();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i17 = 0; i17 < 16; i17++, offset += 4) {
      SHA512_W_H[i17] = view.getUint32(offset);
      SHA512_W_L[i17] = view.getUint32(offset += 4);
    }
    for (let i17 = 16; i17 < 80; i17++) {
      const W15h = SHA512_W_H[i17 - 15] | 0;
      const W15l = SHA512_W_L[i17 - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i17 - 2] | 0;
      const W2l = SHA512_W_L[i17 - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i17 - 7], SHA512_W_L[i17 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i17 - 7], SHA512_W_H[i17 - 16]);
      SHA512_W_H[i17] = SUMh | 0;
      SHA512_W_L[i17] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i17 = 0; i17 < 80; i17++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i17], SHA512_W_L[i17]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i17], SHA512_W_H[i17]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add2(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add2(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add2(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add2(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add2(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add2(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add2(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add2(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add2(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV[0] | 0;
    this.Al = SHA384_IV[1] | 0;
    this.Bh = SHA384_IV[2] | 0;
    this.Bl = SHA384_IV[3] | 0;
    this.Ch = SHA384_IV[4] | 0;
    this.Cl = SHA384_IV[5] | 0;
    this.Dh = SHA384_IV[6] | 0;
    this.Dl = SHA384_IV[7] | 0;
    this.Eh = SHA384_IV[8] | 0;
    this.El = SHA384_IV[9] | 0;
    this.Fh = SHA384_IV[10] | 0;
    this.Fl = SHA384_IV[11] | 0;
    this.Gh = SHA384_IV[12] | 0;
    this.Gl = SHA384_IV[13] | 0;
    this.Hh = SHA384_IV[14] | 0;
    this.Hl = SHA384_IV[15] | 0;
  }
};
var T224_IV = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var SHA512_224 = class extends SHA512 {
  constructor() {
    super(28);
    this.Ah = T224_IV[0] | 0;
    this.Al = T224_IV[1] | 0;
    this.Bh = T224_IV[2] | 0;
    this.Bl = T224_IV[3] | 0;
    this.Ch = T224_IV[4] | 0;
    this.Cl = T224_IV[5] | 0;
    this.Dh = T224_IV[6] | 0;
    this.Dl = T224_IV[7] | 0;
    this.Eh = T224_IV[8] | 0;
    this.El = T224_IV[9] | 0;
    this.Fh = T224_IV[10] | 0;
    this.Fl = T224_IV[11] | 0;
    this.Gh = T224_IV[12] | 0;
    this.Gl = T224_IV[13] | 0;
    this.Hh = T224_IV[14] | 0;
    this.Hl = T224_IV[15] | 0;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super(32);
    this.Ah = T256_IV[0] | 0;
    this.Al = T256_IV[1] | 0;
    this.Bh = T256_IV[2] | 0;
    this.Bl = T256_IV[3] | 0;
    this.Ch = T256_IV[4] | 0;
    this.Cl = T256_IV[5] | 0;
    this.Dh = T256_IV[6] | 0;
    this.Dl = T256_IV[7] | 0;
    this.Eh = T256_IV[8] | 0;
    this.El = T256_IV[9] | 0;
    this.Fh = T256_IV[10] | 0;
    this.Fl = T256_IV[11] | 0;
    this.Gh = T256_IV[12] | 0;
    this.Gl = T256_IV[13] | 0;
    this.Hh = T256_IV[14] | 0;
    this.Hl = T256_IV[15] | 0;
  }
};
var sha256 = createHasher(() => new SHA256());
var sha224 = createHasher(() => new SHA224());
var sha512 = createHasher(() => new SHA512());
var sha384 = createHasher(() => new SHA384());
var sha512_256 = createHasher(() => new SHA512_256());
var sha512_224 = createHasher(() => new SHA512_224());

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash2);
    const key = toBytes2(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i17 = 0; i17 < pad.length; i17++)
      pad[i17] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i17 = 0; i17 < pad.length; i17++)
      pad[i17] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@noble/curves/esm/utils.js
var _0n = BigInt(0);
var _1n = BigInt(1);
function _abool2(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}"`;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function _abytes2(value, length, title = "") {
  const bytes3 = isBytes(value);
  const len = value == null ? void 0 : value.length;
  const needsLen = length !== void 0;
  if (!bytes3 || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes3 ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function numberToHexUnpadded(num2) {
  const hex = num2.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex(bytes3));
}
function bytesToNumberLE(bytes3) {
  abytes(bytes3);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n31, len) {
  return hexToBytes(n31.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n31, len) {
  return numberToBytesBE(n31, len).reverse();
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e39) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e39);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
var isPosBig = (n31) => typeof n31 === "bigint" && _0n <= n31;
function inRange(n31, min, max) {
  return isPosBig(n31) && isPosBig(min) && isPosBig(max) && min <= n31 && n31 < max;
}
function aInRange(title, n31, min, max) {
  if (!inRange(n31, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n31);
}
function bitLen(n31) {
  let len;
  for (len = 0; n31 > _0n; n31 >>= _1n, len += 1)
    ;
  return len;
}
var bitMask = (n31) => (_1n << BigInt(n31)) - _1n;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v3 = u8n(hashLen);
  let k3 = u8n(hashLen);
  let i17 = 0;
  const reset = () => {
    v3.fill(1);
    k3.fill(0);
    i17 = 0;
  };
  const h8 = (...b5) => hmacFn(k3, v3, ...b5);
  const reseed = (seed = u8n(0)) => {
    k3 = h8(u8of(0), seed);
    v3 = h8();
    if (seed.length === 0)
      return;
    k3 = h8(u8of(1), seed);
    v3 = h8();
  };
  const gen = () => {
    if (i17++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v3 = h8();
      const sl = v3.slice();
      out.push(sl);
      len += v3.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function isHash(val) {
  return typeof val === "function" && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k3, v3]) => checkField(k3, v3, false));
  Object.entries(optFields).forEach(([k3, v3]) => checkField(k3, v3, true));
}
function memoized(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _7n = BigInt(7);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod2(a23, b5) {
  const result = a23 % b5;
  return result >= _0n2 ? result : b5 + result;
}
function pow2(x2, power, modulo2) {
  let res = x2;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo2;
  }
  return res;
}
function invert(number, modulo2) {
  if (number === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo2 <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo2);
  let a23 = mod2(number, modulo2);
  let b5 = modulo2;
  let x2 = _0n2, y5 = _1n2, u22 = _1n2, v3 = _0n2;
  while (a23 !== _0n2) {
    const q = b5 / a23;
    const r41 = b5 % a23;
    const m6 = x2 - u22 * q;
    const n31 = y5 - v3 * q;
    b5 = a23, a23 = r41, x2 = u22, y5 = v3, u22 = m6, v3 = n31;
  }
  const gcd = b5;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod2(x2, modulo2);
}
function assertIsSquare(Fp, root, n31) {
  if (!Fp.eql(Fp.sqr(root), n31))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp, n31) {
  const p1div4 = (Fp.ORDER + _1n2) / _4n;
  const root = Fp.pow(n31, p1div4);
  assertIsSquare(Fp, root, n31);
  return root;
}
function sqrt5mod8(Fp, n31) {
  const p5div8 = (Fp.ORDER - _5n) / _8n;
  const n210 = Fp.mul(n31, _2n);
  const v3 = Fp.pow(n210, p5div8);
  const nv = Fp.mul(n31, v3);
  const i17 = Fp.mul(Fp.mul(nv, _2n), v3);
  const root = Fp.mul(nv, Fp.sub(i17, Fp.ONE));
  assertIsSquare(Fp, root, n31);
  return root;
}
function sqrt9mod16(P2) {
  const Fp_ = Field(P2);
  const tn = tonelliShanks(P2);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c22 = tn(Fp_, c1);
  const c32 = tn(Fp_, Fp_.neg(c1));
  const c42 = (P2 + _7n) / _16n;
  return (Fp, n31) => {
    let tv1 = Fp.pow(n31, c42);
    let tv2 = Fp.mul(tv1, c1);
    const tv3 = Fp.mul(tv1, c22);
    const tv4 = Fp.mul(tv1, c32);
    const e1 = Fp.eql(Fp.sqr(tv2), n31);
    const e210 = Fp.eql(Fp.sqr(tv3), n31);
    tv1 = Fp.cmov(tv1, tv2, e1);
    tv2 = Fp.cmov(tv4, tv3, e210);
    const e39 = Fp.eql(Fp.sqr(tv2), n31);
    const root = Fp.cmov(tv1, tv2, e39);
    assertIsSquare(Fp, root, n31);
    return root;
  };
}
function tonelliShanks(P2) {
  if (P2 < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P2 - _1n2;
  let S3 = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S3++;
  }
  let Z = _2n;
  const _Fp = Field(P2);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S3 === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp, n31) {
    if (Fp.is0(n31))
      return n31;
    if (FpLegendre(Fp, n31) !== 1)
      throw new Error("Cannot find square root");
    let M = S3;
    let c17 = Fp.mul(Fp.ONE, cc);
    let t35 = Fp.pow(n31, Q);
    let R = Fp.pow(n31, Q1div2);
    while (!Fp.eql(t35, Fp.ONE)) {
      if (Fp.is0(t35))
        return Fp.ZERO;
      let i17 = 1;
      let t_tmp = Fp.sqr(t35);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i17++;
        t_tmp = Fp.sqr(t_tmp);
        if (i17 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i17 - 1);
      const b5 = Fp.pow(c17, exponent);
      M = i17;
      c17 = Fp.sqr(b5);
      t35 = Fp.mul(t35, c17);
      R = Fp.mul(R, b5);
    }
    return R;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n)
    return sqrt3mod4;
  if (P2 % _8n === _5n)
    return sqrt5mod8;
  if (P2 % _16n === _9n)
    return sqrt9mod16(P2);
  return tonelliShanks(P2);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp, num2, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp.ONE;
  if (power === _1n2)
    return num2;
  let p3 = Fp.ONE;
  let d18 = num2;
  while (power > _0n2) {
    if (power & _1n2)
      p3 = Fp.mul(p3, d18);
    d18 = Fp.sqr(d18);
    power >>= _1n2;
  }
  return p3;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num2, i17) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i17] = acc;
    return Fp.mul(acc, num2);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num2, i17) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i17] = Fp.mul(acc, inverted[i17]);
    return Fp.mul(acc, num2);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n31) {
  const p1mod2 = (Fp.ORDER - _1n2) / _2n;
  const powered = Fp.pow(n31, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n31, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n31.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE2 = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  let modFromBytes = false;
  let allowedLengths = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE2)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE2 = _opts.isLE;
    if (typeof _opts.modFromBytes === "boolean")
      modFromBytes = _opts.modFromBytes;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f4 = Object.freeze({
    ORDER,
    isLE: isLE2,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    allowedLengths,
    create: (num2) => mod2(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n2 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n2,
    // is valid and invertible
    isValidNot0: (num2) => !f4.is0(num2) && f4.isValid(num2),
    isOdd: (num2) => (num2 & _1n2) === _1n2,
    neg: (num2) => mod2(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod2(num2 * num2, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow(f4, num2, power),
    div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert(num2, ORDER),
    sqrt: _sqrt || ((n31) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f4, n31);
    }),
    toBytes: (num2) => isLE2 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
    fromBytes: (bytes3, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes3.length) || bytes3.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes3.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes3, isLE2 ? 0 : padded.length - bytes3.length);
        bytes3 = padded;
      }
      if (bytes3.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes3.length);
      let scalar = isLE2 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
      if (modFromBytes)
        scalar = mod2(scalar, ORDER);
      if (!skipValidation) {
        if (!f4.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f4, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a23, b5, c17) => c17 ? b5 : a23
  });
  return Object.freeze(f4);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod2(num2, fieldOrder - _1n2) + _1n2;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c17, points) {
  const invertedZs = FpInvertBatch(c17.Fp, points.map((p3) => p3.Z));
  return points.map((p3, i17) => c17.fromAffine(p3.toAffine(invertedZs[i17])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n31, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n31 & mask);
  let nextN = n31 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero2 = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero: isZero2, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c17) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p3, i17) => {
    if (!(p3 instanceof c17))
      throw new Error("invalid point at index " + i17);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s26, i17) => {
    if (!field.isValid(s26))
      throw new Error("invalid scalar at index " + i17);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P2) {
  return pointWindowSizes.get(P2) || 1;
}
function assert0(n31) {
  if (n31 !== _0n3)
    throw new Error("invalid wNAF");
}
var wNAF = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point, bits) {
    this.BASE = Point.BASE;
    this.ZERO = Point.ZERO;
    this.Fn = Point.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n31, p3 = this.ZERO) {
    let d18 = elm;
    while (n31 > _0n3) {
      if (n31 & _1n3)
        p3 = p3.add(d18);
      d18 = d18.double();
      n31 >>= _1n3;
    }
    return p3;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p3 = point;
    let base = p3;
    for (let window2 = 0; window2 < windows; window2++) {
      base = p3;
      points.push(base);
      for (let i17 = 1; i17 < windowSize; i17++) {
        base = base.add(p3);
        points.push(base);
      }
      p3 = base.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n31) {
    if (!this.Fn.isValid(n31))
      throw new Error("invalid scalar");
    let p3 = this.ZERO;
    let f4 = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero: isZero2, isNeg, isNegF, offsetF } = calcOffsets(n31, window2, wo);
      n31 = nextN;
      if (isZero2) {
        f4 = f4.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p3 = p3.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n31);
    return { p: p3, f: f4 };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n31, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n31 === _0n3)
        break;
      const { nextN, offset, isZero: isZero2, isNeg } = calcOffsets(n31, window2, wo);
      n31 = nextN;
      if (isZero2) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n31);
    return acc;
  }
  getPrecomputes(W, point, transform) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W = getW(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W = getW(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P2, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P2, W);
    pointPrecomputes.delete(P2);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
};
function mulEndoUnsafe(Point, point, k1, k22) {
  let acc = point;
  let p1 = Point.ZERO;
  let p22 = Point.ZERO;
  while (k1 > _0n3 || k22 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k22 & _1n3)
      p22 = p22.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k22 >>= _1n3;
  }
  return { p1, p2: p22 };
}
function pippenger(c17, fieldN, points, scalars) {
  validateMSMPoints(points, c17);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c17.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i17 = lastBits; i17 >= 0; i17 -= windowSize) {
    buckets.fill(zero);
    for (let j2 = 0; j2 < slength; j2++) {
      const scalar = scalars[j2];
      const wbits2 = Number(scalar >> BigInt(i17) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j2]);
    }
    let resI = zero;
    for (let j2 = buckets.length - 1, sumI = zero; j2 > 0; j2--) {
      sumI = sumI.add(buckets[j2]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i17 !== 0)
      for (let j2 = 0; j2 < windowSize; j2++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field, isLE2) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE: isLE2 });
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p3 of ["p", "n", "h"]) {
    const val = CURVE[p3];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p3} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p3 of params) {
    if (!Fp.isValid(CURVE[p3]))
      throw new Error(`CURVE.${p3} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp, Fn };
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
var divNearest = (num2, den) => (num2 + (num2 >= 0 ? den : -den) / _2n2) / den;
function _splitEndoScalar(k3, basis, n31) {
  const [[a1, b1], [a23, b22]] = basis;
  const c1 = divNearest(b22 * k3, n31);
  const c22 = divNearest(-b1 * k3, n31);
  let k1 = k3 - c1 * a1 - c22 * a23;
  let k22 = -c1 * b1 - c22 * b22;
  const k1neg = k1 < _0n4;
  const k2neg = k22 < _0n4;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k22 = -k22;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n31) / 2)) + _1n4;
  if (k1 < _0n4 || k1 >= MAX_NUM || k22 < _0n4 || k22 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k3);
  }
  return { k1neg, k1, k2neg, k2: k22 };
}
function validateSigFormat(format) {
  if (!["compact", "recovered", "der"].includes(format))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  _abool2(optsn.lowS, "lowS");
  _abool2(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
var DERErr = class extends Error {
  constructor(m6 = "") {
    super(m6);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E3 } = DER;
      if (tag < 0 || tag > 256)
        throw new E3("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E3("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E3("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t35 = numberToHexUnpadded(tag);
      return t35 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E3 } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E3("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E3("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong2 = !!(first & 128);
      let length = 0;
      if (!isLong2)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E3("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E3("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E3("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E3("tlv.decode(long): zero leftmost byte");
        for (const b5 of lengthBytes)
          length = length << 8 | b5;
        pos += lenLen;
        if (length < 128)
          throw new E3("tlv.decode(long): not minimal encoding");
      }
      const v3 = data.subarray(pos, pos + length);
      if (v3.length !== length)
        throw new E3("tlv.decode: wrong value length");
      return { v: v3, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const { Err: E3 } = DER;
      if (num2 < _0n4)
        throw new E3("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num2);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E3("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E3 } = DER;
      if (data[0] & 128)
        throw new E3("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E3("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(hex) {
    const { Err: E3, _int: int, _tlv: tlv } = DER;
    const data = ensureBytes("signature", hex);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E3("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E3("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n2 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function _normFnElement(Fn, key) {
  const { BYTES: expected } = Fn;
  let num2;
  if (typeof key === "bigint") {
    num2 = key;
  } else {
    let bytes3 = ensureBytes("private key", key);
    try {
      num2 = Fn.fromBytes(bytes3);
    } catch (error) {
      throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
    }
  }
  if (!Fn.isValidNot0(num2))
    throw new Error("invalid private key: out of range [1..N-1]");
  return num2;
}
function weierstrassN(params, extraOpts = {}) {
  const validated = _createCurveFields("weierstrass", params, extraOpts);
  const { Fp, Fn } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp, Fn);
  function assertCompressionIsSupported() {
    if (!Fp.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes2(_c, point, isCompressed) {
    const { x: x2, y: y5 } = point.toAffine();
    const bx = Fp.toBytes(x2);
    _abool2(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp.isOdd(y5);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp.toBytes(y5));
    }
  }
  function pointFromBytes(bytes3) {
    _abytes2(bytes3, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length = bytes3.length;
    const head = bytes3[0];
    const tail = bytes3.subarray(1);
    if (length === comp && (head === 2 || head === 3)) {
      const x2 = Fp.fromBytes(tail);
      if (!Fp.isValid(x2))
        throw new Error("bad point: is not on curve, wrong x");
      const y22 = weierstrassEquation(x2);
      let y5;
      try {
        y5 = Fp.sqrt(y22);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp.isOdd(y5);
      const isHeadOdd = (head & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y5 = Fp.neg(y5);
      return { x: x2, y: y5 };
    } else if (length === uncomp && head === 4) {
      const L2 = Fp.BYTES;
      const x2 = Fp.fromBytes(tail.subarray(0, L2));
      const y5 = Fp.fromBytes(tail.subarray(L2, L2 * 2));
      if (!isValidXY(x2, y5))
        throw new Error("bad point: is not on curve");
      return { x: x2, y: y5 };
    } else {
      throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes2;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x2) {
    const x22 = Fp.sqr(x2);
    const x3 = Fp.mul(x22, x2);
    return Fp.add(Fp.add(x3, Fp.mul(x2, CURVE.a)), CURVE.b);
  }
  function isValidXY(x2, y5) {
    const left = Fp.sqr(y5);
    const right = weierstrassEquation(x2);
    return Fp.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n2), _4n2);
  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
  if (Fp.is0(Fp.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n31, banZero = false) {
    if (!Fp.isValid(n31) || banZero && Fp.is0(n31))
      throw new Error(`bad point coordinate ${title}`);
    return n31;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  function splitEndoScalarN(k3) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k3, endo.basises, Fn.ORDER);
  }
  const toAffineMemo = memoized((p3, iz) => {
    const { X, Y, Z } = p3;
    if (Fp.eql(Z, Fp.ONE))
      return { x: X, y: Y };
    const is0 = p3.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(Z);
    const x2 = Fp.mul(X, iz);
    const y5 = Fp.mul(Y, iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x: x2, y: y5 };
  });
  const assertValidMemo = memoized((p3) => {
    if (p3.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp.is0(p3.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x2, y: y5 } = p3.toAffine();
    if (!Fp.isValid(x2) || !Fp.isValid(y5))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x2, y5))
      throw new Error("bad point: equation left != right");
    if (!p3.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p3) {
      const { x: x2, y: y5 } = p3 || {};
      if (!p3 || !Fp.isValid(x2) || !Fp.isValid(y5))
        throw new Error("invalid affine point");
      if (p3 instanceof Point)
        throw new Error("projective point not allowed");
      if (Fp.is0(x2) && Fp.is0(y5))
        return Point.ZERO;
      return new Point(x2, y5, Fp.ONE);
    }
    static fromBytes(bytes3) {
      const P2 = Point.fromAffine(decodePoint(_abytes2(bytes3, void 0, "point")));
      P2.assertValidity();
      return P2;
    }
    static fromHex(hex) {
      return Point.fromBytes(ensureBytes("pointHex", hex));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n2);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y5 } = this.toAffine();
      if (!Fp.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp.isOdd(y5);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point(this.X, Fp.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a23, b: b5 } = CURVE;
      const b32 = Fp.mul(b5, _3n2);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t210 = Fp.mul(Z1, Z1);
      let t35 = Fp.mul(X1, Y1);
      t35 = Fp.add(t35, t35);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a23, Z3);
      Y3 = Fp.mul(b32, t210);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t35, X3);
      Z3 = Fp.mul(b32, Z3);
      t210 = Fp.mul(a23, t210);
      t35 = Fp.sub(t0, t210);
      t35 = Fp.mul(a23, t35);
      t35 = Fp.add(t35, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t210);
      t0 = Fp.mul(t0, t35);
      Y3 = Fp.add(Y3, t0);
      t210 = Fp.mul(Y1, Z1);
      t210 = Fp.add(t210, t210);
      t0 = Fp.mul(t210, t35);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t210, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a23 = CURVE.a;
      const b32 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t210 = Fp.mul(Z1, Z2);
      let t35 = Fp.add(X1, Y1);
      let t42 = Fp.add(X2, Y2);
      t35 = Fp.mul(t35, t42);
      t42 = Fp.add(t0, t1);
      t35 = Fp.sub(t35, t42);
      t42 = Fp.add(X1, Z1);
      let t52 = Fp.add(X2, Z2);
      t42 = Fp.mul(t42, t52);
      t52 = Fp.add(t0, t210);
      t42 = Fp.sub(t42, t52);
      t52 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t52 = Fp.mul(t52, X3);
      X3 = Fp.add(t1, t210);
      t52 = Fp.sub(t52, X3);
      Z3 = Fp.mul(a23, t42);
      X3 = Fp.mul(b32, t210);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t210 = Fp.mul(a23, t210);
      t42 = Fp.mul(b32, t42);
      t1 = Fp.add(t1, t210);
      t210 = Fp.sub(t0, t210);
      t210 = Fp.mul(a23, t210);
      t42 = Fp.add(t42, t210);
      t0 = Fp.mul(t1, t42);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t52, t42);
      X3 = Fp.mul(t35, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t35, t1);
      Z3 = Fp.mul(t52, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n31) => wnaf.cached(this, n31, (p3) => normalizeZ(Point, p3));
      if (endo2) {
        const { k1neg, k1, k2neg, k2: k22 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k22);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p: p3, f: f4 } = mul(scalar);
        point = p3;
        fake = f4;
      }
      return normalizeZ(Point, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p3 = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n4 || p3.is0())
        return Point.ZERO;
      if (sc === _1n4)
        return p3;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2: k22 } = splitEndoScalarN(sc);
        const { p1, p2: p22 } = mulEndoUnsafe(Point, p3, k1, k22);
        return finishEndo(endo2.beta, p1, p22, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p3, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a23, b5) {
      const sum = this.multiplyUnsafe(a23).add(Q.multiplyUnsafe(b5));
      return sum.is0() ? void 0 : sum;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      _abool2(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    // TODO: remove
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    static normalizeZ(points) {
      return normalizeZ(Point, points);
    }
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(_normFnElement(Fn, privateKey));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  Point.Fp = Fp;
  Point.Fn = Fn;
  const bits = Fn.BITS;
  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point.BASE.precompute(8);
  return Point;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function SWUFpSqrtRatio(Fp, Z) {
  const q = Fp.ORDER;
  let l19 = _0n4;
  for (let o32 = q - _1n4; o32 % _2n2 === _0n4; o32 /= _2n2)
    l19 += _1n4;
  const c1 = l19;
  const _2n_pow_c1_1 = _2n2 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n2;
  const c22 = (q - _1n4) / _2n_pow_c1;
  const c32 = (c22 - _1n4) / _2n2;
  const c42 = _2n_pow_c1 - _1n4;
  const c52 = _2n_pow_c1_1;
  const c62 = Fp.pow(Z, c22);
  const c72 = Fp.pow(Z, (c22 + _1n4) / _2n2);
  let sqrtRatio = (u22, v3) => {
    let tv1 = c62;
    let tv2 = Fp.pow(v3, c42);
    let tv3 = Fp.sqr(tv2);
    tv3 = Fp.mul(tv3, v3);
    let tv5 = Fp.mul(u22, tv3);
    tv5 = Fp.pow(tv5, c32);
    tv5 = Fp.mul(tv5, tv2);
    tv2 = Fp.mul(tv5, v3);
    tv3 = Fp.mul(tv5, u22);
    let tv4 = Fp.mul(tv3, tv2);
    tv5 = Fp.pow(tv4, c52);
    let isQR = Fp.eql(tv5, Fp.ONE);
    tv2 = Fp.mul(tv3, c72);
    tv5 = Fp.mul(tv4, tv1);
    tv3 = Fp.cmov(tv2, tv3, isQR);
    tv4 = Fp.cmov(tv5, tv4, isQR);
    for (let i17 = c1; i17 > _1n4; i17--) {
      let tv52 = i17 - _2n2;
      tv52 = _2n2 << tv52 - _1n4;
      let tvv5 = Fp.pow(tv4, tv52);
      const e1 = Fp.eql(tvv5, Fp.ONE);
      tv2 = Fp.mul(tv3, tv1);
      tv1 = Fp.mul(tv1, tv1);
      tvv5 = Fp.mul(tv4, tv1);
      tv3 = Fp.cmov(tv2, tv3, e1);
      tv4 = Fp.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp.ORDER % _4n2 === _3n2) {
    const c17 = (Fp.ORDER - _3n2) / _4n2;
    const c23 = Fp.sqrt(Fp.neg(Z));
    sqrtRatio = (u22, v3) => {
      let tv1 = Fp.sqr(v3);
      const tv2 = Fp.mul(u22, v3);
      tv1 = Fp.mul(tv1, tv2);
      let y1 = Fp.pow(tv1, c17);
      y1 = Fp.mul(y1, tv2);
      const y22 = Fp.mul(y1, c23);
      const tv3 = Fp.mul(Fp.sqr(y1), v3);
      const isQR = Fp.eql(tv3, u22);
      let y5 = Fp.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y5 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, opts) {
  validateField(Fp);
  const { A: A3, B: B2, Z } = opts;
  if (!Fp.isValid(A3) || !Fp.isValid(B2) || !Fp.isValid(Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
  if (!Fp.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u22) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x2, y5;
    tv1 = Fp.sqr(u22);
    tv1 = Fp.mul(tv1, Z);
    tv2 = Fp.sqr(tv1);
    tv2 = Fp.add(tv2, tv1);
    tv3 = Fp.add(tv2, Fp.ONE);
    tv3 = Fp.mul(tv3, B2);
    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
    tv4 = Fp.mul(tv4, A3);
    tv2 = Fp.sqr(tv3);
    tv6 = Fp.sqr(tv4);
    tv5 = Fp.mul(tv6, A3);
    tv2 = Fp.add(tv2, tv5);
    tv2 = Fp.mul(tv2, tv3);
    tv6 = Fp.mul(tv6, tv4);
    tv5 = Fp.mul(tv6, B2);
    tv2 = Fp.add(tv2, tv5);
    x2 = Fp.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y5 = Fp.mul(tv1, u22);
    y5 = Fp.mul(y5, value);
    x2 = Fp.cmov(x2, tv3, isValid);
    y5 = Fp.cmov(y5, value, isValid);
    const e1 = Fp.isOdd(u22) === Fp.isOdd(y5);
    y5 = Fp.cmov(Fp.neg(y5), y5, e1);
    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];
    x2 = Fp.mul(x2, tv4_inv);
    return { x: x2, y: y5 };
  };
}
function getWLengths(Fp, Fn) {
  return {
    secretKey: Fn.BYTES,
    publicKey: 1 + Fp.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn.BYTES
  };
}
function ecdh(Point, ecdhOpts = {}) {
  const { Fn } = Point;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      return !!_normFnElement(Fn, secretKey);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l19 = publicKey.length;
      if (isCompressed === true && l19 !== comp)
        return false;
      if (isCompressed === false && l19 !== publicKeyUncompressed)
        return false;
      return !!Point.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField(_abytes2(seed, lengths.seed, "seed"), Fn.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
  }
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point)
      return true;
    const { secretKey, publicKey, publicKeyUncompressed } = lengths;
    if (Fn.allowedLengths || secretKey === publicKey)
      return void 0;
    const l19 = ensureBytes("key", item).length;
    return l19 === publicKey || l19 === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s26 = _normFnElement(Fn, secretKeyA);
    const b5 = Point.fromHex(publicKeyB);
    return b5.multiply(s26).toBytes(isCompressed);
  }
  const utils = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey,
    // TODO: remove
    isValidPrivateKey: isValidSecretKey,
    randomPrivateKey: randomSecretKey,
    normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
    precompute(windowSize = 8, point = Point.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
function ecdsa(Point, hash2, ecdsaOpts = {}) {
  ahash(hash2);
  _validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes2 = ecdsaOpts.randomBytes || randomBytes;
  const hmac2 = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)));
  const { Fp, Fn } = Point;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
  const defaultSigOpts = {
    prehash: false,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
    format: void 0,
    //'compact' as ECDSASigFormat,
    extraEntropy: false
  };
  const defaultSigOpts_format = "compact";
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n4;
    return number > HALF;
  }
  function validateRS(title, num2) {
    if (!Fn.isValidNot0(num2))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num2;
  }
  function validateSigLength(bytes3, format) {
    validateSigFormat(format);
    const size = lengths.signature;
    const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
    return _abytes2(bytes3, sizer, `${format} signature`);
  }
  class Signature {
    constructor(r41, s26, recovery) {
      this.r = validateRS("r", r41);
      this.s = validateRS("s", s26);
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    static fromBytes(bytes3, format = defaultSigOpts_format) {
      validateSigLength(bytes3, format);
      let recid;
      if (format === "der") {
        const { r: r42, s: s27 } = DER.toSig(_abytes2(bytes3));
        return new Signature(r42, s27);
      }
      if (format === "recovered") {
        recid = bytes3[0];
        format = "compact";
        bytes3 = bytes3.subarray(1);
      }
      const L2 = Fn.BYTES;
      const r41 = bytes3.subarray(0, L2);
      const s26 = bytes3.subarray(L2, L2 * 2);
      return new Signature(Fn.fromBytes(r41), Fn.fromBytes(s26), recid);
    }
    static fromHex(hex, format) {
      return this.fromBytes(hexToBytes(hex), format);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const FIELD_ORDER = Fp.ORDER;
      const { r: r41, s: s26, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n2 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r41 + CURVE_ORDER : r41;
      if (!Fp.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x2 = Fp.toBytes(radj);
      const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x2));
      const ir = Fn.inv(radj);
      const h8 = bits2int_modN(ensureBytes("msgHash", messageHash));
      const u1 = Fn.create(-h8 * ir);
      const u22 = Fn.create(s26 * ir);
      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u22));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format = defaultSigOpts_format) {
      validateSigFormat(format);
      if (format === "der")
        return hexToBytes(DER.hexFromSig(this));
      const r41 = Fn.toBytes(this.r);
      const s26 = Fn.toBytes(this.s);
      if (format === "recovered") {
        if (this.recovery == null)
          throw new Error("recovery bit must be present");
        return concatBytes(Uint8Array.of(this.recovery), r41, s26);
      }
      return concatBytes(r41, s26);
    }
    toHex(format) {
      return bytesToHex(this.toBytes(format));
    }
    // TODO: remove
    assertValidity() {
    }
    static fromCompact(hex) {
      return Signature.fromBytes(ensureBytes("sig", hex), "compact");
    }
    static fromDER(hex) {
      return Signature.fromBytes(ensureBytes("sig", hex), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex(this.toBytes("compact"));
    }
  }
  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes3) {
    if (bytes3.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - fnBits;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes3) {
    return Fn.create(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num2) {
    aInRange("num < 2^" + fnBits, num2, _0n4, ORDER_MASK);
    return Fn.toBytes(num2);
  }
  function validateMsgAndHash(message, prehash) {
    _abytes2(message, void 0, "message");
    return prehash ? _abytes2(hash2(message), void 0, "prehashed message") : message;
  }
  function prepSig(message, privateKey, opts) {
    if (["recovered", "canonical"].some((k3) => k3 in opts))
      throw new Error("sign() legacy options not supported");
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    const h1int = bits2int_modN(message);
    const d18 = _normFnElement(Fn, privateKey);
    const seedArgs = [int2octets(d18), int2octets(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e39 = extraEntropy === true ? randomBytes2(lengths.secretKey) : extraEntropy;
      seedArgs.push(ensureBytes("extraEntropy", e39));
    }
    const seed = concatBytes(...seedArgs);
    const m6 = h1int;
    function k2sig(kBytes) {
      const k3 = bits2int(kBytes);
      if (!Fn.isValidNot0(k3))
        return;
      const ik = Fn.inv(k3);
      const q = Point.BASE.multiply(k3).toAffine();
      const r41 = Fn.create(q.x);
      if (r41 === _0n4)
        return;
      const s26 = Fn.create(ik * Fn.create(m6 + r41 * d18));
      if (s26 === _0n4)
        return;
      let recovery = (q.x === r41 ? 0 : 2) | Number(q.y & _1n4);
      let normS = s26;
      if (lowS && isBiggerThanHalfOrder(s26)) {
        normS = Fn.neg(s26);
        recovery ^= 1;
      }
      return new Signature(r41, normS, recovery);
    }
    return { seed, k2sig };
  }
  function sign2(message, secretKey, opts = {}) {
    message = ensureBytes("message", message);
    const { seed, k2sig } = prepSig(message, secretKey, opts);
    const drbg = createHmacDrbg(hash2.outputLen, Fn.BYTES, hmac2);
    const sig = drbg(seed, k2sig);
    return sig;
  }
  function tryParsingSig(sg) {
    let sig = void 0;
    const isHex = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (isObj) {
      sig = new Signature(sg.r, sg.s);
    } else if (isHex) {
      try {
        sig = Signature.fromBytes(ensureBytes("sig", sg), "der");
      } catch (derError) {
        if (!(derError instanceof DER.Err))
          throw derError;
      }
      if (!sig) {
        try {
          sig = Signature.fromBytes(ensureBytes("sig", sg), "compact");
        } catch (error) {
          return false;
        }
      }
    }
    if (!sig)
      return false;
    return sig;
  }
  function verify2(signature, message, publicKey, opts = {}) {
    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
    publicKey = ensureBytes("publicKey", publicKey);
    message = validateMsgAndHash(ensureBytes("message", message), prehash);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes(ensureBytes("sig", signature), format);
    if (sig === false)
      return false;
    try {
      const P2 = Point.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r: r41, s: s26 } = sig;
      const h8 = bits2int_modN(message);
      const is = Fn.inv(s26);
      const u1 = Fn.create(h8 * is);
      const u22 = Fn.create(r41 * is);
      const R = Point.BASE.multiplyUnsafe(u1).add(P2.multiplyUnsafe(u22));
      if (R.is0())
        return false;
      const v3 = Fn.create(R.x);
      return v3 === r41;
    } catch (e39) {
      return false;
    }
  }
  function recoverPublicKey(signature, message, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message = validateMsgAndHash(message, prehash);
    return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils,
    lengths,
    Point,
    sign: sign2,
    verify: verify2,
    recoverPublicKey,
    Signature,
    hash: hash2
  });
}
function _weierstrass_legacy_opts_to_new(c17) {
  const CURVE = {
    a: c17.a,
    b: c17.b,
    p: c17.Fp.ORDER,
    n: c17.n,
    h: c17.h,
    Gx: c17.Gx,
    Gy: c17.Gy
  };
  const Fp = c17.Fp;
  let allowedLengths = c17.allowedPrivateKeyLengths ? Array.from(new Set(c17.allowedPrivateKeyLengths.map((l19) => Math.ceil(l19 / 2)))) : void 0;
  const Fn = Field(CURVE.n, {
    BITS: c17.nBitLength,
    allowedLengths,
    modFromBytes: c17.wrapPrivateKey
  });
  const curveOpts = {
    Fp,
    Fn,
    allowInfinityPoint: c17.allowInfinityPoint,
    endo: c17.endo,
    isTorsionFree: c17.isTorsionFree,
    clearCofactor: c17.clearCofactor,
    fromBytes: c17.fromBytes,
    toBytes: c17.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c17) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c17);
  const ecdsaOpts = {
    hmac: c17.hmac,
    randomBytes: c17.randomBytes,
    lowS: c17.lowS,
    bits2int: c17.bits2int,
    bits2int_modN: c17.bits2int_modN
  };
  return { CURVE, curveOpts, hash: c17.hash, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c17, _ecdsa) {
  const Point = _ecdsa.Point;
  return Object.assign({}, _ecdsa, {
    ProjectivePoint: Point,
    CURVE: Object.assign({}, c17, nLength(Point.Fn.ORDER, Point.Fn.BITS))
  });
}
function weierstrass(c17) {
  const { CURVE, curveOpts, hash: hash2, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c17);
  const Point = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point, hash2, ecdsaOpts);
  return _ecdsa_new_output_to_legacy(c17, signs);
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, hash: hash2 });
  return { ...create(defHash), create };
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i17 = length - 1; i17 >= 0; i17--) {
    res[i17] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a23, b5) {
  const arr = new Uint8Array(a23.length);
  for (let i17 = 0; i17 < a23.length; i17++) {
    arr[i17] = a23[i17] ^ b5[i17];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function normDST(DST) {
  if (!isBytes(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or string");
  return typeof DST === "string" ? utf8ToBytes(DST) : DST;
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255)
    DST = H(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b5 = new Array(ell);
  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b5[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));
  for (let i17 = 1; i17 <= ell; i17++) {
    const args = [strxor(b_0, b5[i17 - 1]), i2osp(i17 + 1, 1), DST_prime];
    b5[i17] = H(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b5);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k3, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k3 / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  _validateObject(options, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p: p3, k: k3, m: m6, hash: hash2, expand, DST } = options;
  if (!isHash(options.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count);
  const log2p = p3.toString(2).length;
  const L2 = Math.ceil((log2p + k3) / 8);
  const len_in_bytes = count * m6 * L2;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k3, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u22 = new Array(count);
  for (let i17 = 0; i17 < count; i17++) {
    const e39 = new Array(m6);
    for (let j2 = 0; j2 < m6; j2++) {
      const elm_offset = L2 * (j2 + i17 * m6);
      const tv = prb.subarray(elm_offset, elm_offset + L2);
      e39[j2] = mod2(os2ip(tv), p3);
    }
    u22[i17] = e39;
  }
  return u22;
}
function isogenyMap(field, map) {
  const coeff = map.map((i17) => Array.from(i17).reverse());
  return (x2, y5) => {
    const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i17) => field.add(field.mul(acc, x2), i17)));
    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);
    x2 = field.mul(xn, xd_inv);
    y5 = field.mul(y5, field.mul(yn, yd_inv));
    return { x: x2, y: y5 };
  };
}
var _DST_scalar = utf8ToBytes("HashToScalar-");
function createHasher2(Point, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map(num2) {
    return Point.fromAffine(mapToCurve(num2));
  }
  function clear(initial) {
    const P2 = initial.clearCofactor();
    if (P2.equals(Point.ZERO))
      return Point.ZERO;
    P2.assertValidity();
    return P2;
  }
  return {
    defaults,
    hashToCurve(msg, options) {
      const opts = Object.assign({}, defaults, options);
      const u22 = hash_to_field(msg, 2, opts);
      const u0 = map(u22[0]);
      const u1 = map(u22[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options);
      const u22 = hash_to_field(msg, 1, opts);
      const u0 = map(u22[0]);
      return clear(u0);
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i17 of scalars)
        if (typeof i17 !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map(scalars));
    },
    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
    hashToScalar(msg, options) {
      const N4 = Point.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N4, m: 1, DST: _DST_scalar }, options);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n3 = BigInt(2);
function sqrtMod(y5) {
  const P2 = secp256k1_CURVE.p;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y5 * y5 * y5 % P2;
  const b32 = b22 * b22 * y5 % P2;
  const b6 = pow2(b32, _3n3, P2) * b32 % P2;
  const b9 = pow2(b6, _3n3, P2) * b32 % P2;
  const b11 = pow2(b9, _2n3, P2) * b22 % P2;
  const b222 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b222, _22n, P2) * b222 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n3, P2) * b32 % P2;
  const t1 = pow2(b223, _23n, P2) * b222 % P2;
  const t210 = pow2(t1, _6n, P2) * b22 % P2;
  const root = pow2(t210, _2n3, P2);
  if (!Fpk1.eql(Fpk1.sqr(root), y5))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(utf8ToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var Pointk1 = (() => secp256k1.Point)();
var hasEven = (y5) => y5 % _2n3 === _0n5;
function schnorrGetExtPubKey(priv) {
  const { Fn, BASE: BASE2 } = Pointk1;
  const d_ = _normFnElement(Fn, priv);
  const p3 = BASE2.multiply(d_);
  const scalar = hasEven(p3.y) ? d_ : Fn.neg(d_);
  return { scalar, bytes: pointToBytes(p3) };
}
function lift_x(x2) {
  const Fp = Fpk1;
  if (!Fp.isValidNot0(x2))
    throw new Error("invalid x: Fail if x  p");
  const xx = Fp.create(x2 * x2);
  const c17 = Fp.create(xx * x2 + BigInt(7));
  let y5 = Fp.sqrt(c17);
  if (!hasEven(y5))
    y5 = Fp.neg(y5);
  const p3 = Pointk1.fromAffine({ x: x2, y: y5 });
  p3.assertValidity();
  return p3;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const { Fn } = Pointk1;
  const m6 = ensureBytes("message", message);
  const { bytes: px, scalar: d18 } = schnorrGetExtPubKey(secretKey);
  const a23 = ensureBytes("auxRand", auxRand, 32);
  const t35 = Fn.toBytes(d18 ^ num(taggedHash("BIP0340/aux", a23)));
  const rand = taggedHash("BIP0340/nonce", t35, px, m6);
  const { bytes: rx, scalar: k3 } = schnorrGetExtPubKey(rand);
  const e39 = challenge(rx, px, m6);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn.toBytes(Fn.create(k3 + e39 * d18)), 32);
  if (!schnorrVerify(sig, m6, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const { Fn, BASE: BASE2 } = Pointk1;
  const sig = ensureBytes("signature", signature, 64);
  const m6 = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P2 = lift_x(num(pub));
    const r41 = num(sig.subarray(0, 32));
    if (!inRange(r41, _1n5, secp256k1_CURVE.p))
      return false;
    const s26 = num(sig.subarray(32, 64));
    if (!inRange(s26, _1n5, secp256k1_CURVE.n))
      return false;
    const e39 = challenge(Fn.toBytes(r41), pointToBytes(P2), m6);
    const R = BASE2.multiplyUnsafe(s26).add(P2.multiplyUnsafe(Fn.neg(e39)));
    const { x: x2, y: y5 } = R.toAffine();
    if (R.is0() || !hasEven(y5) || x2 !== r41)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  secp256k1.utils.randomSecretKey;
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
  }
  return {
    keygen,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      randomPrivateKey: randomSecretKey,
      taggedHash,
      // TODO: remove
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      mod: mod2
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i17) => i17.map((j2) => BigInt(j2)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher2(secp256k1.Point, (scalars) => {
  const { x: x2, y: y5 } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x2, y5);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/@noble/curves/esm/abstract/utils.js
var bytesToNumberBE2 = bytesToNumberBE;
var numberToBytesBE2 = numberToBytesBE;

// node_modules/@hashgraph/cryptography/src/primitive/bip32.js
var N = secp256k1.CURVE.n;
var HARDENED_BIT = 2147483648;
async function derive(parentKey, chainCode, index) {
  const isHardened = isHardenedIndex(index);
  const data = new Uint8Array(37);
  const publicKey = secp256k1.getPublicKey(parentKey, true);
  if (isHardened) {
    data[0] = 0;
    data.set(parentKey, 1);
  } else {
    data.set(publicKey, 0);
  }
  new DataView(data.buffer, data.byteOffset, data.byteLength).setUint32(
    33,
    index,
    false
  );
  const I3 = await hash(HashAlgorithm.Sha512, chainCode, data);
  const IL = I3.subarray(0, 32);
  const IR = I3.subarray(32);
  try {
    const parentKeyBigInt = bytesToNumberBE2(parentKey);
    const ILBigInt = bytesToNumberBE2(IL);
    const ki = (parentKeyBigInt + ILBigInt) % N;
    if (ki === 0n) {
      return derive(parentKey, chainCode, index + 1);
    }
    const keyData = numberToBytesBE2(ki, 32);
    return {
      keyData,
      chainCode: IR
    };
  } catch {
    return derive(parentKey, chainCode, index + 1);
  }
}
async function fromSeed(seed) {
  if (seed.length < 16)
    throw new TypeError("Seed should be at least 128 bits");
  if (seed.length > 64)
    throw new TypeError("Seed should be at most 512 bits");
  const I3 = await hash(HashAlgorithm.Sha512, "Bitcoin seed", seed);
  const IL = I3.subarray(0, 32);
  const IR = I3.subarray(32);
  return { keyData: IL, chainCode: IR };
}
function toHardenedIndex(index) {
  return index | HARDENED_BIT;
}
function isHardenedIndex(index) {
  return (index & HARDENED_BIT) !== 0;
}

// node_modules/@hashgraph/cryptography/src/primitive/slip10.js
async function derive2(parentKey, chainCode, index) {
  if (isHardenedIndex(index)) {
    throw new Error("the index should not be pre-hardened");
  }
  const input = new Uint8Array(37);
  input[0] = 0;
  input.set(parentKey, 1);
  new DataView(input.buffer, input.byteOffset, input.byteLength).setUint32(
    33,
    index,
    false
  );
  input[33] |= 128;
  const digest2 = await hash(HashAlgorithm.Sha512, chainCode, input);
  return { keyData: digest2.subarray(0, 32), chainCode: digest2.subarray(32) };
}
async function fromSeed2(seed) {
  const digest2 = await hash(
    HashAlgorithm.Sha512,
    "ed25519 seed",
    seed
  );
  return { keyData: digest2.subarray(0, 32), chainCode: digest2.subarray(32) };
}

// node_modules/@hashgraph/cryptography/src/Ed25519PrivateKey.js
var derPrefix2 = "302e020100300506032b657004220420";
var derPrefixBytes2 = decode(derPrefix2);
var Ed25519PrivateKey = class _Ed25519PrivateKey {
  /**
   * @hideconstructor
   * @internal
   * @param {nacl.SignKeyPair | Uint8Array} keyPair
   * @param {Uint8Array=} chainCode
   */
  constructor(keyPair, chainCode) {
    this._keyPair = keyPair instanceof Uint8Array ? import_tweetnacl3.default.sign.keyPair.fromSeed(keyPair) : keyPair;
    this._chainCode = chainCode != null ? chainCode : null;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return "ED25519";
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {Ed25519PrivateKey}
   */
  static generate() {
    const entropy = bytes(64);
    return new _Ed25519PrivateKey(
      import_tweetnacl3.default.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
      entropy.subarray(32)
    );
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {Promise<Ed25519PrivateKey>}
   */
  static async generateAsync() {
    const entropy = await bytesAsync(64);
    return new _Ed25519PrivateKey(
      import_tweetnacl3.default.sign.keyPair.fromSeed(entropy.subarray(0, 32)),
      entropy.subarray(32)
    );
  }
  /**
   * Construct a private key from bytes.
   * @param {Uint8Array} data
   * @returns {Ed25519PrivateKey}
   */
  static fromBytes(data) {
    switch (data.length) {
      case 48:
        return _Ed25519PrivateKey.fromBytesDer(data);
      case 32:
      case 64:
        return _Ed25519PrivateKey.fromBytesRaw(data);
      default:
        throw new BadKeyError(
          `invalid private key length: ${data.length} bytes`
        );
    }
  }
  /**
   * Construct a private key from bytes with DER header.
   * @param {Uint8Array} data
   * @returns {Ed25519PrivateKey}
   */
  static fromBytesDer(data) {
    let privateKey;
    try {
      const arr = new Uint8Array(data);
      const header = arr.subarray(0, data.length - 32);
      const isValidED25519 = header.every((byte, index) => {
        return derPrefixBytes2[index] === byte;
      });
      if (!isValidED25519) {
        throw new BadKeyError(
          `invalid DER prefix for ED25519 private key`
        );
      }
      privateKey = arr.slice(data.length - 32);
    } catch (error) {
      const message = (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        error != null && /** @type {Error} */
        error.message != null ? (
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          /** @type {Error} */
          error.message
        ) : ""
      );
      throw new BadKeyError(
        `cannot decode ED25519 private key data from DER format: ${message}`
      );
    }
    const keyPair = import_tweetnacl3.default.sign.keyPair.fromSeed(privateKey);
    return new _Ed25519PrivateKey(keyPair);
  }
  /**
   * Construct a private key from bytes without DER header.
   * @param {Uint8Array} data
   * @returns {Ed25519PrivateKey}
   */
  static fromBytesRaw(data) {
    switch (data.length) {
      case 32:
        return new _Ed25519PrivateKey(import_tweetnacl3.default.sign.keyPair.fromSeed(data));
      case 64:
        return new _Ed25519PrivateKey(
          import_tweetnacl3.default.sign.keyPair.fromSecretKey(data)
        );
      default:
    }
    throw new BadKeyError(
      `invalid private key length: ${data.length} bytes`
    );
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {Ed25519PrivateKey}
   */
  static fromString(text) {
    return _Ed25519PrivateKey.fromBytes(decode(text));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {Ed25519PrivateKey}
   */
  static fromStringDer(text) {
    return _Ed25519PrivateKey.fromBytesDer(decode(text));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {Ed25519PrivateKey}
   */
  static fromStringRaw(text) {
    return _Ed25519PrivateKey.fromBytesRaw(decode(text));
  }
  /**
   * Construct a ED25519 private key from a Uint8Array seed.
   * @param {Uint8Array} seed
   * @returns {Promise<Ed25519PrivateKey>}
   */
  static async fromSeed(seed) {
    const { keyData, chainCode } = await fromSeed2(seed);
    return new _Ed25519PrivateKey(keyData, chainCode);
  }
  /**
   * Get the public key associated with this private key.
   *
   * The public key can be freely given and used by other parties to verify
   * the signatures generated by this private key.
   * @returns {Ed25519PublicKey}
   */
  get publicKey() {
    return new Ed25519PublicKey(this._keyPair.publicKey);
  }
  /**
   * Sign a message with this private key.
   * @param {Uint8Array} bytes
   * @returns {Uint8Array} - The signature bytes without the message
   */
  sign(bytes3) {
    return import_tweetnacl3.default.sign.detached(bytes3, this._keyPair.secretKey);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    const bytes3 = new Uint8Array(derPrefixBytes2.length + 32);
    const privateKey = this._keyPair.secretKey.subarray(0, 32);
    const leadingZeroes = 32 - privateKey.length;
    const privateKeyOffset = derPrefixBytes2.length + leadingZeroes;
    bytes3.set(derPrefixBytes2, 0);
    bytes3.set(privateKey, privateKeyOffset);
    return bytes3;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._keyPair.secretKey.slice(0, 32);
  }
};

// node_modules/@hashgraph/cryptography/src/primitive/keccak.js
var HEX_CHARS = "0123456789abcdef".split("");
var KECCAK_PADDING = [1, 256, 65536, 16777216];
var SHIFT = [0, 8, 16, 24];
var RC = [
  1,
  0,
  32898,
  0,
  32906,
  2147483648,
  2147516416,
  2147483648,
  32907,
  0,
  2147483649,
  0,
  2147516545,
  2147483648,
  32777,
  2147483648,
  138,
  0,
  136,
  0,
  2147516425,
  0,
  2147483658,
  0,
  2147516555,
  0,
  139,
  2147483648,
  32905,
  2147483648,
  32771,
  2147483648,
  32770,
  2147483648,
  128,
  2147483648,
  32778,
  0,
  2147483658,
  2147483648,
  2147516545,
  2147483648,
  32896,
  2147483648,
  2147483649,
  0,
  2147516424,
  2147483648
];
var Keccak = (bits) => ({
  blocks: [],
  reset: true,
  block: 0,
  start: 0,
  blockCount: 1600 - (bits << 1) >> 5,
  outputBlocks: bits >> 5,
  // @ts-ignore
  s: ((s26) => [].concat(s26, s26, s26, s26, s26))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
});
var update = (state, message) => {
  var length = message.length, blocks = state.blocks, byteCount = state.blockCount << 2, blockCount = state.blockCount, outputBlocks = state.outputBlocks, s26 = state.s, index = 0, i17, code;
  while (index < length) {
    if (state.reset) {
      state.reset = false;
      blocks[0] = state.block;
      for (i17 = 1; i17 < blockCount + 1; ++i17) {
        blocks[i17] = 0;
      }
    }
    if (typeof message !== "string") {
      for (i17 = state.start; index < length && i17 < byteCount; ++index) {
        blocks[i17 >> 2] |= message[index] << SHIFT[i17++ & 3];
      }
    } else {
      for (i17 = state.start; index < length && i17 < byteCount; ++index) {
        code = message.charCodeAt(index);
        if (code < 128) {
          blocks[i17 >> 2] |= code << SHIFT[i17++ & 3];
        } else if (code < 2048) {
          blocks[i17 >> 2] |= (192 | code >> 6) << SHIFT[i17++ & 3];
          blocks[i17 >> 2] |= (128 | code & 63) << SHIFT[i17++ & 3];
        } else if (code < 55296 || code >= 57344) {
          blocks[i17 >> 2] |= (224 | code >> 12) << SHIFT[i17++ & 3];
          blocks[i17 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i17++ & 3];
          blocks[i17 >> 2] |= (128 | code & 63) << SHIFT[i17++ & 3];
        } else {
          code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
          blocks[i17 >> 2] |= (240 | code >> 18) << SHIFT[i17++ & 3];
          blocks[i17 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i17++ & 3];
          blocks[i17 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i17++ & 3];
          blocks[i17 >> 2] |= (128 | code & 63) << SHIFT[i17++ & 3];
        }
      }
    }
    state.lastByteIndex = i17;
    if (i17 >= byteCount) {
      state.start = i17 - byteCount;
      state.block = blocks[blockCount];
      for (i17 = 0; i17 < blockCount; ++i17) {
        s26[i17] ^= blocks[i17];
      }
      f(s26);
      state.reset = true;
    } else {
      state.start = i17;
    }
  }
  i17 = state.lastByteIndex;
  blocks[i17 >> 2] |= KECCAK_PADDING[i17 & 3];
  if (state.lastByteIndex === byteCount) {
    blocks[0] = blocks[blockCount];
    for (i17 = 1; i17 < blockCount + 1; ++i17) {
      blocks[i17] = 0;
    }
  }
  blocks[blockCount - 1] |= 2147483648;
  for (i17 = 0; i17 < blockCount; ++i17) {
    s26[i17] ^= blocks[i17];
  }
  f(s26);
  var hex = "";
  var block;
  var j2 = 0;
  i17 = 0;
  while (j2 < outputBlocks) {
    for (i17 = 0; i17 < blockCount && j2 < outputBlocks; ++i17, ++j2) {
      block = s26[i17];
      hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
    }
    if (j2 % blockCount === 0) {
      f(s26);
      i17 = 0;
    }
  }
  return "0x" + hex;
};
var f = (s26) => {
  var h8, l19, n31, c0, c1, c22, c32, c42, c52, c62, c72, c82, c92, b0, b1, b22, b32, b42, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b422, b43, b44, b45, b46, b47, b48, b49;
  for (n31 = 0; n31 < 48; n31 += 2) {
    c0 = s26[0] ^ s26[10] ^ s26[20] ^ s26[30] ^ s26[40];
    c1 = s26[1] ^ s26[11] ^ s26[21] ^ s26[31] ^ s26[41];
    c22 = s26[2] ^ s26[12] ^ s26[22] ^ s26[32] ^ s26[42];
    c32 = s26[3] ^ s26[13] ^ s26[23] ^ s26[33] ^ s26[43];
    c42 = s26[4] ^ s26[14] ^ s26[24] ^ s26[34] ^ s26[44];
    c52 = s26[5] ^ s26[15] ^ s26[25] ^ s26[35] ^ s26[45];
    c62 = s26[6] ^ s26[16] ^ s26[26] ^ s26[36] ^ s26[46];
    c72 = s26[7] ^ s26[17] ^ s26[27] ^ s26[37] ^ s26[47];
    c82 = s26[8] ^ s26[18] ^ s26[28] ^ s26[38] ^ s26[48];
    c92 = s26[9] ^ s26[19] ^ s26[29] ^ s26[39] ^ s26[49];
    h8 = c82 ^ (c22 << 1 | c32 >>> 31);
    l19 = c92 ^ (c32 << 1 | c22 >>> 31);
    s26[0] ^= h8;
    s26[1] ^= l19;
    s26[10] ^= h8;
    s26[11] ^= l19;
    s26[20] ^= h8;
    s26[21] ^= l19;
    s26[30] ^= h8;
    s26[31] ^= l19;
    s26[40] ^= h8;
    s26[41] ^= l19;
    h8 = c0 ^ (c42 << 1 | c52 >>> 31);
    l19 = c1 ^ (c52 << 1 | c42 >>> 31);
    s26[2] ^= h8;
    s26[3] ^= l19;
    s26[12] ^= h8;
    s26[13] ^= l19;
    s26[22] ^= h8;
    s26[23] ^= l19;
    s26[32] ^= h8;
    s26[33] ^= l19;
    s26[42] ^= h8;
    s26[43] ^= l19;
    h8 = c22 ^ (c62 << 1 | c72 >>> 31);
    l19 = c32 ^ (c72 << 1 | c62 >>> 31);
    s26[4] ^= h8;
    s26[5] ^= l19;
    s26[14] ^= h8;
    s26[15] ^= l19;
    s26[24] ^= h8;
    s26[25] ^= l19;
    s26[34] ^= h8;
    s26[35] ^= l19;
    s26[44] ^= h8;
    s26[45] ^= l19;
    h8 = c42 ^ (c82 << 1 | c92 >>> 31);
    l19 = c52 ^ (c92 << 1 | c82 >>> 31);
    s26[6] ^= h8;
    s26[7] ^= l19;
    s26[16] ^= h8;
    s26[17] ^= l19;
    s26[26] ^= h8;
    s26[27] ^= l19;
    s26[36] ^= h8;
    s26[37] ^= l19;
    s26[46] ^= h8;
    s26[47] ^= l19;
    h8 = c62 ^ (c0 << 1 | c1 >>> 31);
    l19 = c72 ^ (c1 << 1 | c0 >>> 31);
    s26[8] ^= h8;
    s26[9] ^= l19;
    s26[18] ^= h8;
    s26[19] ^= l19;
    s26[28] ^= h8;
    s26[29] ^= l19;
    s26[38] ^= h8;
    s26[39] ^= l19;
    s26[48] ^= h8;
    s26[49] ^= l19;
    b0 = s26[0];
    b1 = s26[1];
    b322 = s26[11] << 4 | s26[10] >>> 28;
    b33 = s26[10] << 4 | s26[11] >>> 28;
    b14 = s26[20] << 3 | s26[21] >>> 29;
    b15 = s26[21] << 3 | s26[20] >>> 29;
    b46 = s26[31] << 9 | s26[30] >>> 23;
    b47 = s26[30] << 9 | s26[31] >>> 23;
    b28 = s26[40] << 18 | s26[41] >>> 14;
    b29 = s26[41] << 18 | s26[40] >>> 14;
    b20 = s26[2] << 1 | s26[3] >>> 31;
    b21 = s26[3] << 1 | s26[2] >>> 31;
    b22 = s26[13] << 12 | s26[12] >>> 20;
    b32 = s26[12] << 12 | s26[13] >>> 20;
    b34 = s26[22] << 10 | s26[23] >>> 22;
    b35 = s26[23] << 10 | s26[22] >>> 22;
    b16 = s26[33] << 13 | s26[32] >>> 19;
    b17 = s26[32] << 13 | s26[33] >>> 19;
    b48 = s26[42] << 2 | s26[43] >>> 30;
    b49 = s26[43] << 2 | s26[42] >>> 30;
    b40 = s26[5] << 30 | s26[4] >>> 2;
    b41 = s26[4] << 30 | s26[5] >>> 2;
    b222 = s26[14] << 6 | s26[15] >>> 26;
    b23 = s26[15] << 6 | s26[14] >>> 26;
    b42 = s26[25] << 11 | s26[24] >>> 21;
    b5 = s26[24] << 11 | s26[25] >>> 21;
    b36 = s26[34] << 15 | s26[35] >>> 17;
    b37 = s26[35] << 15 | s26[34] >>> 17;
    b18 = s26[45] << 29 | s26[44] >>> 3;
    b19 = s26[44] << 29 | s26[45] >>> 3;
    b10 = s26[6] << 28 | s26[7] >>> 4;
    b11 = s26[7] << 28 | s26[6] >>> 4;
    b422 = s26[17] << 23 | s26[16] >>> 9;
    b43 = s26[16] << 23 | s26[17] >>> 9;
    b24 = s26[26] << 25 | s26[27] >>> 7;
    b25 = s26[27] << 25 | s26[26] >>> 7;
    b6 = s26[36] << 21 | s26[37] >>> 11;
    b7 = s26[37] << 21 | s26[36] >>> 11;
    b38 = s26[47] << 24 | s26[46] >>> 8;
    b39 = s26[46] << 24 | s26[47] >>> 8;
    b30 = s26[8] << 27 | s26[9] >>> 5;
    b31 = s26[9] << 27 | s26[8] >>> 5;
    b12 = s26[18] << 20 | s26[19] >>> 12;
    b13 = s26[19] << 20 | s26[18] >>> 12;
    b44 = s26[29] << 7 | s26[28] >>> 25;
    b45 = s26[28] << 7 | s26[29] >>> 25;
    b26 = s26[38] << 8 | s26[39] >>> 24;
    b27 = s26[39] << 8 | s26[38] >>> 24;
    b8 = s26[48] << 14 | s26[49] >>> 18;
    b9 = s26[49] << 14 | s26[48] >>> 18;
    s26[0] = b0 ^ ~b22 & b42;
    s26[1] = b1 ^ ~b32 & b5;
    s26[10] = b10 ^ ~b12 & b14;
    s26[11] = b11 ^ ~b13 & b15;
    s26[20] = b20 ^ ~b222 & b24;
    s26[21] = b21 ^ ~b23 & b25;
    s26[30] = b30 ^ ~b322 & b34;
    s26[31] = b31 ^ ~b33 & b35;
    s26[40] = b40 ^ ~b422 & b44;
    s26[41] = b41 ^ ~b43 & b45;
    s26[2] = b22 ^ ~b42 & b6;
    s26[3] = b32 ^ ~b5 & b7;
    s26[12] = b12 ^ ~b14 & b16;
    s26[13] = b13 ^ ~b15 & b17;
    s26[22] = b222 ^ ~b24 & b26;
    s26[23] = b23 ^ ~b25 & b27;
    s26[32] = b322 ^ ~b34 & b36;
    s26[33] = b33 ^ ~b35 & b37;
    s26[42] = b422 ^ ~b44 & b46;
    s26[43] = b43 ^ ~b45 & b47;
    s26[4] = b42 ^ ~b6 & b8;
    s26[5] = b5 ^ ~b7 & b9;
    s26[14] = b14 ^ ~b16 & b18;
    s26[15] = b15 ^ ~b17 & b19;
    s26[24] = b24 ^ ~b26 & b28;
    s26[25] = b25 ^ ~b27 & b29;
    s26[34] = b34 ^ ~b36 & b38;
    s26[35] = b35 ^ ~b37 & b39;
    s26[44] = b44 ^ ~b46 & b48;
    s26[45] = b45 ^ ~b47 & b49;
    s26[6] = b6 ^ ~b8 & b0;
    s26[7] = b7 ^ ~b9 & b1;
    s26[16] = b16 ^ ~b18 & b10;
    s26[17] = b17 ^ ~b19 & b11;
    s26[26] = b26 ^ ~b28 & b20;
    s26[27] = b27 ^ ~b29 & b21;
    s26[36] = b36 ^ ~b38 & b30;
    s26[37] = b37 ^ ~b39 & b31;
    s26[46] = b46 ^ ~b48 & b40;
    s26[47] = b47 ^ ~b49 & b41;
    s26[8] = b8 ^ ~b0 & b22;
    s26[9] = b9 ^ ~b1 & b32;
    s26[18] = b18 ^ ~b10 & b12;
    s26[19] = b19 ^ ~b11 & b13;
    s26[28] = b28 ^ ~b20 & b222;
    s26[29] = b29 ^ ~b21 & b23;
    s26[38] = b38 ^ ~b30 & b322;
    s26[39] = b39 ^ ~b31 & b33;
    s26[48] = b48 ^ ~b40 & b422;
    s26[49] = b49 ^ ~b41 & b43;
    s26[0] ^= RC[n31];
    s26[1] ^= RC[n31 + 1];
  }
};
var keccak = (bits) => (str) => {
  var msg;
  if (str.slice(0, 2) === "0x") {
    msg = [];
    for (var i17 = 2, l19 = str.length; i17 < l19; i17 += 2)
      msg.push(parseInt(str.slice(i17, i17 + 2), 16));
  } else {
    msg = str;
  }
  return update(Keccak(bits), msg);
};
var keccak256 = keccak(256);

// node_modules/@hashgraph/cryptography/src/primitive/utils.js
function equalBytes2(a23, b5) {
  if (a23.length !== b5.length) {
    return false;
  }
  for (let i17 = 0; i17 < a23.length; i17++) {
    if (a23[i17] !== b5[i17]) return false;
  }
  return true;
}

// node_modules/@hashgraph/cryptography/src/primitive/ecdsa.js
function generate() {
  const privateKey = secp256k1.utils.randomPrivateKey();
  const publicKey = secp256k1.getPublicKey(privateKey, true);
  return {
    privateKey,
    publicKey
  };
}
async function generateAsync() {
  return Promise.resolve(generate());
}
function fromBytes2(data) {
  const privateKey = new Uint8Array(data);
  const publicKey = secp256k1.getPublicKey(privateKey, true);
  return {
    privateKey,
    publicKey
  };
}
function sign(keydata, message) {
  const msg = encode(message);
  const data = decode(keccak256(`0x${msg}`));
  const signature = secp256k1.sign(data, keydata);
  return signature.toCompactRawBytes();
}
function verify(keydata, message, signature) {
  const msg = encode(message);
  const data = decode(keccak256(`0x${msg}`));
  const r41 = BigInt("0x" + encode(signature.subarray(0, 32)));
  const s26 = BigInt("0x" + encode(signature.subarray(32, 64)));
  return secp256k1.verify({ r: r41, s: s26 }, data, keydata);
}
function getRecoveryId(privateKey, signature, message) {
  const expectedPubKey = secp256k1.getPublicKey(privateKey, false);
  const hash2 = decode(keccak256(`0x${encode(message)}`));
  for (let recovery = 0; recovery < 4; recovery++) {
    try {
      const sig = secp256k1.Signature.fromCompact(signature).addRecoveryBit(
        recovery
      );
      const recovered = sig.recoverPublicKey(hash2).toRawBytes(false);
      if (equalBytes2(recovered, expectedPubKey)) {
        return recovery;
      }
    } catch {
    }
  }
  throw new Error("Unexpected error: could not construct a recoverable key.");
}

// node_modules/@hashgraph/cryptography/src/EcdsaPublicKey.js
var legacyDerPrefix = "302d300706052b8104000a032200";
var legacyDerPrefixBytes = decode(legacyDerPrefix);
var derPrefix3 = "3036301006072a8648ce3d020106052b8104000a032200";
var derPrefixBytes3 = decode(derPrefix3);
var EcdsaPublicKey = class _EcdsaPublicKey extends Key {
  /**
   * @internal
   * @hideconstructor
   * @param {Uint8Array} keyData
   */
  constructor(keyData) {
    super();
    this._keyData = keyData;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return "secp256k1";
  }
  /**
   * @param {Uint8Array} data
   * @returns {EcdsaPublicKey}
   */
  static fromBytes(data) {
    switch (data.length) {
      case 33:
        return _EcdsaPublicKey.fromBytesRaw(data);
      default:
        return _EcdsaPublicKey.fromBytesDer(data);
    }
  }
  /**
   * @param {Uint8Array} data
   * @returns {EcdsaPublicKey}
   */
  static fromBytesDer(data) {
    let ecdsaPublicKeyBytes;
    switch (data.length) {
      case 47:
        ecdsaPublicKeyBytes = data.subarray(
          legacyDerPrefixBytes.length
        );
        break;
      case 56:
        ecdsaPublicKeyBytes = data.subarray(
          derPrefixBytes3.length,
          derPrefixBytes3.length + 33
        );
        break;
      default:
        try {
          const keyPair = secp256k1.ProjectivePoint.fromHex(
            data.subarray(derPrefixBytes3.length)
          );
          ecdsaPublicKeyBytes = keyPair.toRawBytes(true);
        } catch (error) {
          throw new BadKeyError(
            `cannot decode ECDSA public key from this DER format`
          );
        }
        break;
    }
    if (!ecdsaPublicKeyBytes || ecdsaPublicKeyBytes.length === 0) {
      throw new BadKeyError(
        `cannot decode ECDSA public key from this DER format`
      );
    }
    return new _EcdsaPublicKey(ecdsaPublicKeyBytes);
  }
  /**
   * @param {Uint8Array} data
   * @returns {EcdsaPublicKey}
   */
  static fromBytesRaw(data) {
    if (data.length !== 33) {
      throw new BadKeyError(
        `invalid public key length: ${data.length} bytes`
      );
    }
    return new _EcdsaPublicKey(data);
  }
  /**
   * Parse a public key from a hexadecimal string.
   *
   * The public key may optionally be prefixed with
   * the DER header.
   * @param {string} text
   * @returns {EcdsaPublicKey}
   */
  static fromString(text) {
    return _EcdsaPublicKey.fromBytes(decode(text));
  }
  /**
   * Verify a signature on a message with this public key.
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {boolean}
   */
  verify(message, signature) {
    return verify(this._keyData, message, signature);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    const bytes3 = new Uint8Array(
      legacyDerPrefixBytes.length + this._keyData.length
    );
    bytes3.set(legacyDerPrefixBytes, 0);
    bytes3.set(this._keyData, legacyDerPrefixBytes.length);
    return bytes3;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return new Uint8Array(this._keyData.subarray());
  }
  /**
   * @returns {string}
   */
  toEthereumAddress() {
    const publicKey = secp256k1.ProjectivePoint.fromHex(
      this._keyData
    ).toRawBytes(false);
    const hash2 = decode(
      keccak256(`0x${encode(publicKey.subarray(1))}`)
    );
    return encode(hash2.subarray(12));
  }
  /**
   * @param {EcdsaPublicKey} other
   * @returns {boolean}
   */
  equals(other) {
    return arrayEqual(this._keyData, other._keyData);
  }
};

// node_modules/@hashgraph/cryptography/src/EcdsaPrivateKey.js
var derPrefix4 = "3030020100300706052b8104000a04220420";
var derPrefixBytes4 = decode(derPrefix4);
var derPrefix22 = "30540201010420";
var derPrefixBytes22 = decode(derPrefix22);
var EcdsaPrivateKey = class _EcdsaPrivateKey {
  /**
   * @hideconstructor
   * @internal
   * @param {KeyPair} keyPair
   * @param {(Uint8Array)=} chainCode
   */
  constructor(keyPair, chainCode) {
    this._keyPair = keyPair;
    this._chainCode = chainCode != null ? chainCode : null;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return "secp256k1";
  }
  /**
   * Generate a random ECDSA private key.
   * @returns {EcdsaPrivateKey}
   */
  static generate() {
    return new _EcdsaPrivateKey(generate());
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {Promise<EcdsaPrivateKey>}
   */
  static async generateAsync() {
    return new _EcdsaPrivateKey(await generateAsync());
  }
  /**
   * Construct a private key from bytes.
   * @param {Uint8Array} data
   * @returns {EcdsaPrivateKey}
   */
  static fromBytes(data) {
    switch (data.length) {
      case 32:
        return _EcdsaPrivateKey.fromBytesRaw(data);
      default:
        return _EcdsaPrivateKey.fromBytesDer(data);
    }
  }
  /**
   * Construct a private key from bytes.
   * @param {Uint8Array} data
   * @returns {EcdsaPrivateKey}
   */
  static fromBytesDer(data) {
    let ecdsaPrivateKeyBytes = new Uint8Array();
    if (arrayStartsWith(data, derPrefixBytes4)) {
      ecdsaPrivateKeyBytes = data.subarray(derPrefixBytes4.length);
    } else {
      ecdsaPrivateKeyBytes = data.subarray(
        derPrefixBytes22.length,
        derPrefixBytes22.length + 32
      );
    }
    return new _EcdsaPrivateKey(fromBytes2(ecdsaPrivateKeyBytes));
  }
  /**
   * Construct a private key from bytes.
   * @param {Uint8Array} data
   * @returns {EcdsaPrivateKey}
   */
  static fromBytesRaw(data) {
    return new _EcdsaPrivateKey(fromBytes2(data));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {EcdsaPrivateKey}
   */
  static fromString(text) {
    return _EcdsaPrivateKey.fromBytes(decode(text));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {EcdsaPrivateKey}
   */
  static fromStringDer(text) {
    return _EcdsaPrivateKey.fromBytesDer(decode(text));
  }
  /**
   * Construct a private key from a hex-encoded string.
   * @param {string} text
   * @returns {EcdsaPrivateKey}
   */
  static fromStringRaw(text) {
    return _EcdsaPrivateKey.fromBytesRaw(decode(text));
  }
  /**
   * Construct a ECDSA private key from a Uint8Array seed.
   * @param {Uint8Array} seed
   * @returns {Promise<EcdsaPrivateKey>}
   */
  static async fromSeed(seed) {
    const { keyData, chainCode } = await fromSeed(seed);
    return new _EcdsaPrivateKey(fromBytes2(keyData), chainCode);
  }
  /**
   * Get the public key associated with this private key.
   *
   * The public key can be freely given and used by other parties to verify
   * the signatures generated by this private key.
   * @returns {EcdsaPublicKey}
   */
  get publicKey() {
    return new EcdsaPublicKey(this._keyPair.publicKey);
  }
  /**
   * Sign a message with this private key.
   * @param {Uint8Array} bytes
   * @returns {Uint8Array} - The signature bytes without the message
   */
  sign(bytes3) {
    return sign(this._keyPair.privateKey, bytes3);
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    const bytes3 = new Uint8Array(derPrefixBytes4.length + 32);
    const privateKey = this._keyPair.privateKey.subarray(0, 32);
    const leadingZeroes = 32 - privateKey.length;
    const privateKeyOffset = derPrefixBytes4.length + leadingZeroes;
    bytes3.set(derPrefixBytes4, 0);
    bytes3.set(privateKey, privateKeyOffset);
    return bytes3;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    const privateKey = this._keyPair.privateKey.subarray(-32);
    const leadingZeroes = 32 - privateKey.length;
    const bytes3 = new Uint8Array(32);
    bytes3.set(privateKey, leadingZeroes);
    return bytes3;
  }
  /**
   * Recover the recovery ID used in the signature for the given message.
   * @param {Uint8Array} signature - 64-byte compact signature (r || s)
   * @param {Uint8Array} message - The original (unhashed) message
   * @returns {number} Recovery ID (03), or -1 if not found
   */
  getRecoveryId(signature, message) {
    return getRecoveryId(
      this._keyPair.privateKey,
      signature,
      message
    );
  }
};

// node_modules/@hashgraph/cryptography/src/PublicKey.js
var PublicKey = class _PublicKey extends Key {
  /**
   * @internal
   * @hideconstructor
   * @param {Ed25519PublicKey | EcdsaPublicKey} key
   */
  constructor(key) {
    super();
    this._key = key;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return this._key._type;
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */
  static fromBytes(data) {
    let message;
    try {
      return new _PublicKey(Ed25519PublicKey.fromBytes(data));
    } catch (error) {
      message = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : "";
    }
    try {
      return new _PublicKey(EcdsaPublicKey.fromBytes(data));
    } catch (error) {
      message = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : "";
    }
    throw new BadKeyError(
      `public key cannot be decoded from bytes: ${message}`
    );
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */
  static fromBytesED25519(data) {
    return new _PublicKey(Ed25519PublicKey.fromBytes(data));
  }
  /**
   * @param {Uint8Array} data
   * @returns {PublicKey}
   */
  static fromBytesECDSA(data) {
    return new _PublicKey(EcdsaPublicKey.fromBytes(data));
  }
  /**
   * Parse a public key from a string of hexadecimal digits.
   *
   * The public key may optionally be prefixed with
   * the DER header.
   * @param {string} text
   * @returns {PublicKey}
   */
  static fromString(text) {
    return _PublicKey.fromBytes(decode(text));
  }
  /**
   * @param {string} text
   * @returns {PublicKey}
   */
  static fromStringED25519(text) {
    return _PublicKey.fromBytesED25519(decode(text));
  }
  /**
   * @param {string} text
   * @returns {PublicKey}
   */
  static fromStringECDSA(text) {
    return _PublicKey.fromBytesECDSA(decode(text));
  }
  /**
   * Verify a signature on a message with this public key.
   * @param {Uint8Array} message
   * @param {Uint8Array} signature
   * @returns {boolean}
   */
  verify(message, signature) {
    return this._key.verify(message, signature);
  }
  /**
   * @deprecated - use `@hashgraph/sdk`.PublicKey instead
   * @param {Transaction} transaction
   * @returns {boolean}
   */
  verifyTransaction(transaction) {
    console.log("Deprecated: use `@hashgraph/sdk`.PublicKey instead");
    transaction._requireFrozen();
    if (!transaction.isFrozen()) {
      transaction.freeze();
    }
    for (const signedTransaction of transaction._signedTransactions) {
      if (signedTransaction.sigMap != null && signedTransaction.sigMap.sigPair != null) {
        let found = false;
        for (const sigPair of signedTransaction.sigMap.sigPair) {
          const pubKeyPrefix = (
            /** @type {Uint8Array} */
            sigPair.pubKeyPrefix
          );
          if (arrayEqual(pubKeyPrefix, this.toBytesRaw())) {
            found = true;
            const bodyBytes = (
              /** @type {Uint8Array} */
              signedTransaction.bodyBytes
            );
            const signature = sigPair.ed25519 != null ? sigPair.ed25519 : (
              /** @type {Uint8Array} */
              sigPair.ECDSASecp256k1
            );
            if (!this.verify(bodyBytes, signature)) {
              return false;
            }
          }
        }
        if (!found) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    if (this._key instanceof Ed25519PublicKey) {
      return this.toBytesRaw();
    } else {
      return this.toBytesDer();
    }
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    return this._key.toBytesDer();
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  /**
   * @returns {string}
   */
  toString() {
    return this.toStringDer();
  }
  /**
   * @returns {string}
   */
  toStringDer() {
    return encode(this.toBytesDer());
  }
  /**
   * @returns {string}
   */
  toStringRaw() {
    return encode(this.toBytesRaw());
  }
  /**
   * @returns {string}
   */
  toEthereumAddress() {
    if (this._key instanceof EcdsaPublicKey) {
      return this._key.toEthereumAddress();
    } else {
      throw new Error("unsupported operation on Ed25519PublicKey");
    }
  }
  /**
   * @param {PublicKey} other
   * @returns {boolean}
   */
  equals(other) {
    if (this._key instanceof Ed25519PublicKey && other._key instanceof Ed25519PublicKey) {
      return this._key.equals(other._key);
    } else if (this._key instanceof EcdsaPublicKey && other._key instanceof EcdsaPublicKey) {
      return this._key.equals(other._key);
    } else {
      return false;
    }
  }
};

// node_modules/@hashgraph/cryptography/src/primitive/aes.browser.js
var import_spark_md5 = __toESM(require_spark_md5(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var CipherAlgorithm = {
  Aes128Ctr: "AES-128-CTR",
  Aes128Cbc: "AES-128-CBC"
};
async function createCipheriv(algorithm, key, iv, data) {
  let algorithm_;
  switch (algorithm.toUpperCase()) {
    case CipherAlgorithm.Aes128Ctr:
      algorithm_ = {
        name: "AES-CTR",
        counter: iv,
        length: 128
      };
      break;
    case CipherAlgorithm.Aes128Cbc:
      algorithm_ = {
        name: "AES-CBC",
        iv
      };
      break;
    default:
      throw new Error(
        "(BUG) non-exhaustive switch statement for CipherAlgorithm"
      );
  }
  const key_ = await window.crypto.subtle.importKey(
    "raw",
    key,
    algorithm_.name,
    false,
    ["encrypt"]
  );
  return new Uint8Array(
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
    /** @type {ArrayBuffer} */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    await window.crypto.subtle.encrypt(algorithm_, key_, data)
  );
}
async function createDecipheriv(algorithm, key, iv, data) {
  let algorithm_;
  switch (algorithm.toUpperCase()) {
    case CipherAlgorithm.Aes128Ctr:
      algorithm_ = {
        name: "AES-CTR",
        counter: iv,
        length: 128
      };
      break;
    case CipherAlgorithm.Aes128Cbc:
      algorithm_ = {
        name: "AES-CBC",
        iv
      };
      break;
    default:
      throw new Error(
        "(BUG) non-exhaustive switch statement for CipherAlgorithm"
      );
  }
  const key_ = await window.crypto.subtle.importKey(
    "raw",
    key,
    algorithm_.name,
    false,
    ["decrypt"]
  );
  let decrypted;
  try {
    decrypted = await window.crypto.subtle.decrypt(algorithm_, key_, data);
  } catch (error) {
    const message = (
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : ""
    );
    throw new Error(`Unable to decrypt: ${message}`);
  }
  return new Uint8Array(
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#return_value
    /** @type {ArrayBuffer} */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    decrypted
  );
}
async function messageDigest(passphrase, iv) {
  const pass = encode2(passphrase);
  const sliced = decode(iv).slice(0, 8);
  const result = import_spark_md5.default.ArrayBuffer.hash(
    // @ts-ignore
    import_buffer.Buffer.concat([import_buffer.Buffer.from(pass), import_buffer.Buffer.from(sliced)])
  );
  return Promise.resolve(decode(result));
}

// node_modules/@hashgraph/cryptography/src/primitive/pbkdf2.browser.js
async function deriveKey(algorithm, password, salt, iterations, length) {
  const pass = typeof password === "string" ? (
    // Valid ASCII is also valid UTF-8 so encoding the password as UTF-8
    // should be fine if only valid ASCII characters are used in the password
    encode2(password)
  ) : password;
  const nacl5 = typeof salt === "string" ? encode2(salt) : salt;
  try {
    const key = await window.crypto.subtle.importKey(
      "raw",
      pass,
      {
        name: "PBKDF2",
        hash: algorithm
      },
      false,
      ["deriveBits"]
    );
    return new Uint8Array(
      await window.crypto.subtle.deriveBits(
        {
          name: "PBKDF2",
          hash: algorithm,
          salt: nacl5,
          iterations
        },
        key,
        length << 3
      )
    );
  } catch {
    throw new Error("(BUG) Non-Exhaustive switch statement for algorithms");
  }
}

// node_modules/@hashgraph/cryptography/src/primitive/keystore.js
var HMAC_SHA256 = "hmac-sha256";
async function createKeystore(privateKey, passphrase) {
  const dkLen = 32;
  const c17 = 262144;
  const saltLen = 32;
  const salt = await bytesAsync(saltLen);
  const key = await deriveKey(
    HashAlgorithm.Sha256,
    passphrase,
    salt,
    c17,
    dkLen
  );
  const iv = await bytesAsync(16);
  const cipherText = await createCipheriv(
    CipherAlgorithm.Aes128Ctr,
    key.slice(0, 16),
    iv,
    privateKey
  );
  const mac = await hash(
    HashAlgorithm.Sha384,
    key.slice(16),
    cipherText
  );
  const keystore = {
    version: 1,
    crypto: {
      ciphertext: encode(cipherText),
      cipherparams: { iv: encode(iv) },
      cipher: CipherAlgorithm.Aes128Ctr,
      kdf: "pbkdf2",
      kdfparams: {
        dkLen,
        salt: encode(salt),
        c: c17,
        prf: HMAC_SHA256
      },
      mac: encode(mac)
    }
  };
  return encode2(JSON.stringify(keystore));
}
async function loadKeystore(keystoreBytes, passphrase) {
  const keystore = JSON.parse(decode2(keystoreBytes));
  if (keystore.version !== 1) {
    throw new BadKeyError(
      `unsupported keystore version: ${keystore.version}`
    );
  }
  const {
    ciphertext,
    cipherparams: { iv },
    cipher,
    kdf,
    kdfparams: { dkLen, salt, c: c17, prf },
    mac
  } = keystore.crypto;
  if (kdf !== "pbkdf2") {
    throw new BadKeyError(`unsupported key derivation function:" + ${kdf}`);
  }
  if (prf !== HMAC_SHA256) {
    throw new BadKeyError(
      `unsupported key derivation hash function: ${prf}`
    );
  }
  const saltBytes = decode(salt);
  const ivBytes = decode(iv);
  const cipherBytes = decode(ciphertext);
  const key = await deriveKey(
    HashAlgorithm.Sha256,
    passphrase,
    saltBytes,
    c17,
    dkLen
  );
  const macHex = decode(mac);
  const verifyHmac = await hash(
    HashAlgorithm.Sha384,
    key.slice(16),
    cipherBytes
  );
  if (!macHex.every((b5, i17) => b5 === verifyHmac[i17])) {
    throw new BadKeyError("HMAC mismatch; passphrase is incorrect");
  }
  return createDecipheriv(
    cipher,
    key.slice(0, 16),
    ivBytes,
    cipherBytes
  );
}

// node_modules/@hashgraph/cryptography/src/encoding/der.js
function decode3(data) {
  return decodeIncremental(data)[0];
}
function decodeIncremental(bytes3) {
  const [len, rem] = decodeLength(bytes3.subarray(1));
  const data = rem.subarray(0, len);
  const tail = rem.subarray(len);
  switch (bytes3[0]) {
    case 2:
      return [{ int: decodeInt(data) }, tail];
    case 4:
      return [{ bytes: data }, tail];
    case 5:
      return [{}, tail];
    case 6:
      return [{ ident: decodeObjectIdent(data) }, tail];
    case 48:
      return [{ seq: decodeSeq(data) }, tail];
    default:
      throw new Error(`unsupported DER type tag: ${bytes3[0]}`);
  }
}
function decodeSeq(seqBytes) {
  let data = seqBytes;
  const seq = [];
  while (data.length !== 0) {
    const [decoded, remaining] = decodeIncremental(data);
    seq.push(decoded);
    data = remaining;
  }
  return seq;
}
function decodeObjectIdent(idBytes) {
  const id2 = [
    // first octet is 40 * value1 + value2
    Math.floor(idBytes[0] / 40),
    idBytes[0] % 40
  ];
  let val = 0;
  for (const byte of idBytes.subarray(1)) {
    val *= 128;
    if (byte < 128) {
      val += byte;
      id2.push(val);
      val = 0;
    } else {
      val += byte & 127;
    }
  }
  return id2.join(".");
}
function decodeLength(lenBytes) {
  if (lenBytes[0] < 128) {
    return [lenBytes[0], lenBytes.subarray(1)];
  }
  const numBytes = lenBytes[0] - 128;
  const intBytes = lenBytes.subarray(1, numBytes + 1);
  const rem = lenBytes.subarray(numBytes + 1);
  return [decodeInt(intBytes), rem];
}
function decodeInt(intBytes) {
  const len = intBytes.length;
  if (len === 1) {
    return intBytes[0];
  }
  let view = new DataView(
    intBytes.buffer,
    intBytes.byteOffset,
    intBytes.byteLength
  );
  if (len === 2) return view.getUint16(0, false);
  if (len === 3) {
    const data = Uint8Array.of(0, ...intBytes);
    view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  if (len > 4) {
    throw new Error(`unsupported DER integer length of ${len} bytes`);
  }
  return view.getUint32(0, false);
}

// node_modules/@hashgraph/cryptography/src/primitive/pkcs.js
var AlgorithmIdentifier = class {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length >= 1 && "ident" in asn.seq[0]) {
      this.algIdent = asn.seq[0].ident;
      this.parameters = asn.seq[1];
    } else {
      throw new Error(
        `error parsing AlgorithmIdentifier from ${JSON.stringify(asn)}`
      );
    }
  }
  /**
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this);
  }
};
var PBES2Params = class {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 2) {
      this.kdf = new AlgorithmIdentifier(asn.seq[0]);
      this.encScheme = new AlgorithmIdentifier(asn.seq[1]);
    } else {
      throw new Error(
        `error parsing PBES2Params from ${JSON.stringify(asn)}`
      );
    }
  }
};
var PBKDF2Params = class {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length >= 2 && "bytes" in asn.seq[0] && "int" in asn.seq[1]) {
      this.salt = asn.seq[0].bytes;
      this.iterCount = asn.seq[1]["int"];
      if (asn.seq.length > 2) {
        if ("seq" in asn.seq[2]) {
          this.prf = new AlgorithmIdentifier(asn.seq[2]);
          return;
        } else if ("int" in asn.seq[2]) {
          this.keyLength = asn.seq[2]["int"];
        }
        if (asn.seq.length === 4) {
          this.prf = new AlgorithmIdentifier(asn.seq[3]);
        }
        return;
      }
    }
    throw new Error(
      `error parsing PBKDF2Params from ${JSON.stringify(asn)}`
    );
  }
};
var PrivateKeyInfo = class _PrivateKeyInfo {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 3) {
      if ("int" in asn.seq[0] && asn.seq[0]["int"] === 0) {
        this.version = 0;
      } else {
        throw new Error(
          `expected version = 0, got ${JSON.stringify(asn.seq[0])}`
        );
      }
      this.algId = new AlgorithmIdentifier(asn.seq[1]);
      if ("bytes" in asn.seq[2]) {
        this.privateKey = asn.seq[2].bytes;
      } else {
        throw new Error(
          `expected octet string as 3rd element, got ${JSON.stringify(
            asn.seq[2]
          )}`
        );
      }
      return;
    }
    throw new Error(
      `error parsing PrivateKeyInfo from ${JSON.stringify(asn)}`
    );
  }
  /**
   * @param {Uint8Array} encoded
   * @returns {PrivateKeyInfo}
   */
  static parse(encoded) {
    return new _PrivateKeyInfo(decode3(encoded));
  }
};
var EncryptedPrivateKeyInfo = class _EncryptedPrivateKeyInfo {
  /**
   * @param {import("../encoding/der.js").AsnType} asn
   */
  constructor(asn) {
    if ("seq" in asn && asn.seq.length === 2 && "bytes" in asn.seq[1]) {
      this.algId = new AlgorithmIdentifier(asn.seq[0]);
      this.data = asn.seq[1].bytes;
      return;
    }
    throw new Error(
      `error parsing EncryptedPrivateKeyInfo from ${JSON.stringify(asn)}`
    );
  }
  /**
   * @param {Uint8Array} encoded
   * @returns {EncryptedPrivateKeyInfo}
   */
  static parse(encoded) {
    return new _EncryptedPrivateKeyInfo(decode3(encoded));
  }
  /**
   * @param {string} passphrase
   * @returns {Promise<PrivateKeyInfo>}
   */
  async decrypt(passphrase) {
    if (this.algId.algIdent !== "1.2.840.113549.1.5.13" || !this.algId.parameters) {
      throw new Error(
        `unsupported key encryption algorithm: ${this.algId.toString()}`
      );
    }
    const pbes2Params = new PBES2Params(this.algId.parameters);
    if (pbes2Params.kdf.algIdent !== "1.2.840.113549.1.5.12" || !pbes2Params.kdf.parameters) {
      throw new Error(
        `unsupported key derivation function: ${pbes2Params.kdf.toString()}`
      );
    }
    const pbkdf2Params = new PBKDF2Params(pbes2Params.kdf.parameters);
    if (!pbkdf2Params.prf) {
      throw new Error("unsupported PRF HMAC-SHA-1");
    } else if (pbkdf2Params.prf.algIdent !== "1.2.840.113549.2.9") {
      throw new Error(`unsupported PRF ${pbkdf2Params.prf.toString()}`);
    }
    if (pbes2Params.encScheme.algIdent !== "2.16.840.1.101.3.4.1.2") {
      throw new Error(
        `unsupported encryption scheme: ${pbes2Params.encScheme.toString()}`
      );
    }
    if (!pbes2Params.encScheme.parameters || !("bytes" in pbes2Params.encScheme.parameters)) {
      throw new Error(
        `expected IV as bytes for AES-128-CBC, got: ${JSON.stringify(pbes2Params.encScheme.parameters)}`
      );
    }
    const keyLen = pbkdf2Params.keyLength || 16;
    const iv = pbes2Params.encScheme.parameters.bytes;
    const key = await deriveKey(
      HashAlgorithm.Sha256,
      passphrase,
      pbkdf2Params.salt,
      pbkdf2Params.iterCount,
      keyLen
    );
    const decrypted = await createDecipheriv(
      CipherAlgorithm.Aes128Cbc,
      key,
      iv,
      this.data
    );
    return PrivateKeyInfo.parse(decrypted);
  }
};

// node_modules/@hashgraph/cryptography/src/encoding/base64.browser.js
var import_buffer2 = __toESM(require_buffer(), 1);
function decode4(text) {
  return Uint8Array.from(import_buffer2.Buffer.from(text, "base64"));
}

// node_modules/pvtsutils/build/index.es.js
var ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
var BufferSourceConverter = class _BufferSourceConverter {
  static isArrayBuffer(data) {
    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
  }
  static toArrayBuffer(data) {
    if (this.isArrayBuffer(data)) {
      return data;
    }
    if (data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
  }
  static toUint8Array(data) {
    return this.toView(data, Uint8Array);
  }
  static toView(data, type) {
    if (data.constructor === type) {
      return data;
    }
    if (this.isArrayBuffer(data)) {
      return new type(data);
    }
    if (this.isArrayBufferView(data)) {
      return new type(data.buffer, data.byteOffset, data.byteLength);
    }
    throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
  }
  static isBufferSource(data) {
    return this.isArrayBufferView(data) || this.isArrayBuffer(data);
  }
  static isArrayBufferView(data) {
    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
  }
  static isEqual(a23, b5) {
    const aView = _BufferSourceConverter.toUint8Array(a23);
    const bView = _BufferSourceConverter.toUint8Array(b5);
    if (aView.length !== bView.byteLength) {
      return false;
    }
    for (let i17 = 0; i17 < aView.length; i17++) {
      if (aView[i17] !== bView[i17]) {
        return false;
      }
    }
    return true;
  }
  static concat(...args) {
    let buffers;
    if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
      buffers = args[0];
    } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
      buffers = args[0];
    } else {
      if (args[args.length - 1] instanceof Function) {
        buffers = args.slice(0, args.length - 1);
      } else {
        buffers = args;
      }
    }
    let size = 0;
    for (const buffer of buffers) {
      size += buffer.byteLength;
    }
    const res = new Uint8Array(size);
    let offset = 0;
    for (const buffer of buffers) {
      const view = this.toUint8Array(buffer);
      res.set(view, offset);
      offset += view.length;
    }
    if (args[args.length - 1] instanceof Function) {
      return this.toView(res, args[args.length - 1]);
    }
    return res.buffer;
  }
};
var STRING_TYPE = "string";
var HEX_REGEX = /^[0-9a-f\s]+$/i;
var BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
var BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
var Utf8Converter = class {
  static fromString(text) {
    const s26 = unescape(encodeURIComponent(text));
    const uintArray = new Uint8Array(s26.length);
    for (let i17 = 0; i17 < s26.length; i17++) {
      uintArray[i17] = s26.charCodeAt(i17);
    }
    return uintArray.buffer;
  }
  static toString(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let encodedString = "";
    for (let i17 = 0; i17 < buf.length; i17++) {
      encodedString += String.fromCharCode(buf[i17]);
    }
    const decodedString = decodeURIComponent(escape(encodedString));
    return decodedString;
  }
};
var Utf16Converter = class {
  static toString(buffer, littleEndian = false) {
    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);
    const dataView = new DataView(arrayBuffer);
    let res = "";
    for (let i17 = 0; i17 < arrayBuffer.byteLength; i17 += 2) {
      const code = dataView.getUint16(i17, littleEndian);
      res += String.fromCharCode(code);
    }
    return res;
  }
  static fromString(text, littleEndian = false) {
    const res = new ArrayBuffer(text.length * 2);
    const dataView = new DataView(res);
    for (let i17 = 0; i17 < text.length; i17++) {
      dataView.setUint16(i17 * 2, text.charCodeAt(i17), littleEndian);
    }
    return res;
  }
};
var Convert = class _Convert {
  static isHex(data) {
    return typeof data === STRING_TYPE && HEX_REGEX.test(data);
  }
  static isBase64(data) {
    return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
  }
  static isBase64Url(data) {
    return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
  }
  static ToString(buffer, enc = "utf8") {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.ToUtf8String(buf);
      case "binary":
        return this.ToBinary(buf);
      case "hex":
        return this.ToHex(buf);
      case "base64":
        return this.ToBase64(buf);
      case "base64url":
        return this.ToBase64Url(buf);
      case "utf16le":
        return Utf16Converter.toString(buf, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buf);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static FromString(str, enc = "utf8") {
    if (!str) {
      return new ArrayBuffer(0);
    }
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.FromUtf8String(str);
      case "binary":
        return this.FromBinary(str);
      case "hex":
        return this.FromHex(str);
      case "base64":
        return this.FromBase64(str);
      case "base64url":
        return this.FromBase64Url(str);
      case "utf16le":
        return Utf16Converter.fromString(str, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(str);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static ToBase64(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    if (typeof btoa !== "undefined") {
      const binary = this.ToString(buf, "binary");
      return btoa(binary);
    } else {
      return Buffer.from(buf).toString("base64");
    }
  }
  static FromBase64(base64) {
    const formatted = this.formatString(base64);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isBase64(formatted)) {
      throw new TypeError("Argument 'base64Text' is not Base64 encoded");
    }
    if (typeof atob !== "undefined") {
      return this.FromBinary(atob(formatted));
    } else {
      return new Uint8Array(Buffer.from(formatted, "base64")).buffer;
    }
  }
  static FromBase64Url(base64url) {
    const formatted = this.formatString(base64url);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isBase64Url(formatted)) {
      throw new TypeError("Argument 'base64url' is not Base64Url encoded");
    }
    return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
  }
  static ToBase64Url(data) {
    return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  static FromUtf8String(text, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.FromBinary(text);
      case "utf8":
        return Utf8Converter.fromString(text);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(text);
      case "utf16le":
      case "usc2":
        return Utf16Converter.fromString(text, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static ToUtf8String(buffer, encoding = _Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.ToBinary(buffer);
      case "utf8":
        return Utf8Converter.toString(buffer);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buffer);
      case "utf16le":
      case "usc2":
        return Utf16Converter.toString(buffer, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static FromBinary(text) {
    const stringLength = text.length;
    const resultView = new Uint8Array(stringLength);
    for (let i17 = 0; i17 < stringLength; i17++) {
      resultView[i17] = text.charCodeAt(i17);
    }
    return resultView.buffer;
  }
  static ToBinary(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let res = "";
    for (let i17 = 0; i17 < buf.length; i17++) {
      res += String.fromCharCode(buf[i17]);
    }
    return res;
  }
  static ToHex(buffer) {
    const buf = BufferSourceConverter.toUint8Array(buffer);
    let result = "";
    const len = buf.length;
    for (let i17 = 0; i17 < len; i17++) {
      const byte = buf[i17];
      if (byte < 16) {
        result += "0";
      }
      result += byte.toString(16);
    }
    return result;
  }
  static FromHex(hexString) {
    let formatted = this.formatString(hexString);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!_Convert.isHex(formatted)) {
      throw new TypeError("Argument 'hexString' is not HEX encoded");
    }
    if (formatted.length % 2) {
      formatted = `0${formatted}`;
    }
    const res = new Uint8Array(formatted.length / 2);
    for (let i17 = 0; i17 < formatted.length; i17 = i17 + 2) {
      const c17 = formatted.slice(i17, i17 + 2);
      res[i17 / 2] = parseInt(c17, 16);
    }
    return res.buffer;
  }
  static ToUtf16String(buffer, littleEndian = false) {
    return Utf16Converter.toString(buffer, littleEndian);
  }
  static FromUtf16String(text, littleEndian = false) {
    return Utf16Converter.fromString(text, littleEndian);
  }
  static Base64Padding(base64) {
    const padCount = 4 - base64.length % 4;
    if (padCount < 4) {
      for (let i17 = 0; i17 < padCount; i17++) {
        base64 += "=";
      }
    }
    return base64;
  }
  static formatString(data) {
    return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
  }
};
Convert.DEFAULT_UTF8_ENCODING = "utf8";

// node_modules/pvutils/build/utils.es.js
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i17 = inputBuffer.length - 1; i17 >= 0; i17--) {
    result += inputBuffer[inputBuffer.length - 1 - i17] * Math.pow(2, inputBase * i17);
  }
  return result;
}
function utilToBase(value, base, reserved = -1) {
  const internalReserved = reserved;
  let internalValue = value;
  let result = 0;
  let biggest = Math.pow(2, base);
  for (let i17 = 1; i17 < 8; i17++) {
    if (value < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i17);
        result = i17;
      } else {
        if (internalReserved < i17) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j2 = i17 - 1; j2 >= 0; j2--) {
        const basis = Math.pow(2, j2 * base);
        retView[result - j2 - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j2 - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base);
  }
  return new ArrayBuffer(0);
}
function utilConcatView(...views) {
  let outputLength = 0;
  let prevLength = 0;
  for (const view of views) {
    outputLength += view.length;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const view of views) {
    retView.set(view, prevLength);
    prevLength += view.length;
  }
  return retView;
}
function utilDecodeTC() {
  const buf = new Uint8Array(this.valueHex);
  if (this.valueHex.byteLength >= 2) {
    const condition1 = buf[0] === 255 && buf[1] & 128;
    const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;
    if (condition1 || condition2) {
      this.warnings.push("Needlessly long format");
    }
  }
  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const bigIntView = new Uint8Array(bigIntBuffer);
  for (let i17 = 0; i17 < this.valueHex.byteLength; i17++) {
    bigIntView[i17] = 0;
  }
  bigIntView[0] = buf[0] & 128;
  const bigInt = utilFromBase(bigIntView, 8);
  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const smallIntView = new Uint8Array(smallIntBuffer);
  for (let j2 = 0; j2 < this.valueHex.byteLength; j2++) {
    smallIntView[j2] = buf[j2];
  }
  smallIntView[0] &= 127;
  const smallInt = utilFromBase(smallIntView, 8);
  return smallInt - bigInt;
}
function utilEncodeTC(value) {
  const modValue = value < 0 ? value * -1 : value;
  let bigInt = 128;
  for (let i17 = 1; i17 < 8; i17++) {
    if (modValue <= bigInt) {
      if (value < 0) {
        const smallInt = bigInt - modValue;
        const retBuf2 = utilToBase(smallInt, 8, i17);
        const retView2 = new Uint8Array(retBuf2);
        retView2[0] |= 128;
        return retBuf2;
      }
      let retBuf = utilToBase(modValue, 8, i17);
      let retView = new Uint8Array(retBuf);
      if (retView[0] & 128) {
        const tempBuf = retBuf.slice(0);
        const tempView = new Uint8Array(tempBuf);
        retBuf = new ArrayBuffer(retBuf.byteLength + 1);
        retView = new Uint8Array(retBuf);
        for (let k3 = 0; k3 < tempBuf.byteLength; k3++) {
          retView[k3 + 1] = tempView[k3];
        }
        retView[0] = 0;
      }
      return retBuf;
    }
    bigInt *= Math.pow(2, 8);
  }
  return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i17 = 0; i17 < view1.length; i17++) {
    if (view1[i17] !== view2[i17]) {
      return false;
    }
  }
  return true;
}
function padNumber(inputNumber, fullLength) {
  const str = inputNumber.toString(10);
  if (fullLength < str.length) {
    return "";
  }
  const dif = fullLength - str.length;
  const padding2 = new Array(dif);
  for (let i17 = 0; i17 < dif; i17++) {
    padding2[i17] = "0";
  }
  const paddingString = padding2.join("");
  return paddingString.concat(str);
}
var log2 = Math.log(2);

// node_modules/asn1js/build/index.es.js
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i17 = 0; i17 < buffers.length; i17++) {
    const buffer = buffers[i17];
    outputLength += buffer.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i17 = 0; i17 < buffers.length; i17++) {
    const buffer = buffers[i17];
    retView.set(new Uint8Array(buffer), prevLength);
    prevLength += buffer.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}
var ViewWriter = class {
  constructor() {
    this.items = [];
  }
  write(buf) {
    this.items.push(buf);
  }
  final() {
    return concat(this.items);
  }
};
var powers2 = [new Uint8Array([1])];
var digitsString = "0123456789";
var EMPTY_STRING = "";
var EMPTY_BUFFER = new ArrayBuffer(0);
var EMPTY_VIEW = new Uint8Array(0);
var END_OF_CONTENT_NAME = "EndOfContent";
var OCTET_STRING_NAME = "OCTET STRING";
var BIT_STRING_NAME = "BIT STRING";
function HexBlock(BaseClass) {
  var _a2;
  return _a2 = class Some extends BaseClass {
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    constructor(...args) {
      var _b;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== void 0 ? _b : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a2.NAME = "hexBlock", _a2;
}
var LocalBaseBlock = class {
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
};
LocalBaseBlock.NAME = "baseBlock";
var ValueBlock = class extends LocalBaseBlock {
  fromBER(_inputBuffer, _inputOffset, _inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(_sizeOnly, _writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
};
ValueBlock.NAME = "valueBlock";
var LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {
  constructor({ idBlock = {} } = {}) {
    var _a2, _b, _c, _d;
    super();
    if (idBlock) {
      this.isHexOnly = (_a2 = idBlock.isHexOnly) !== null && _a2 !== void 0 ? _a2 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;
      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;
      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number = this.tagNumber;
        number &= 31;
        firstOctet |= number;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i17 = 0; i17 < size - 1; i17++)
          retView2[i17 + 1] = encodedView[i17] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i17 = 0; i17 < curView.length - 1; i17++)
        retView[i17 + 1] = curView[i17] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count] & 128) {
        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
        count++;
        if (count >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i17 = 0; i17 < intTagNumberBuffer.length; i17++)
            tempBufferView2[i17] = intTagNumberBuffer[i17];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count + 1;
      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;
      const tempBufferView = new Uint8Array(count);
      for (let i17 = 0; i17 < count; i17++)
        tempBufferView[i17] = intTagNumberBuffer[i17];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
};
LocalIdentificationBlock.NAME = "identificationBlock";
var LocalLengthBlock = class extends LocalBaseBlock {
  constructor({ lenBlock = {} } = {}) {
    var _a2, _b, _c;
    super();
    this.isIndefiniteForm = (_a2 = lenBlock.isIndefiniteForm) !== null && _a2 !== void 0 ? _a2 : false;
    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;
    this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count = intBuffer[0] & 127;
    if (count > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);
    if (lengthBufferView[count - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i17 = 0; i17 < encodedBuf.byteLength; i17++)
        retView[i17 + 1] = encodedView[i17];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
};
LocalLengthBlock.NAME = "lengthBlock";
var typeStore = {};
var BaseBlock = class extends LocalBaseBlock {
  constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name;
    this.optional = optional;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock(parameters);
    this.lenBlock = new LocalLengthBlock(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter();
    if (!writer) {
      prepareIndefiniteForm(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer);
      _writer.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer.write(lenBlockBuf);
      _writer.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    const name = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueBeforeDecodeView);
    return `${name} : ${value}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
};
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
  var _a2;
  if (baseBlock instanceof typeStore.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!((_a2 = baseBlock.lenBlock) === null || _a2 === void 0 ? void 0 : _a2.isIndefiniteForm);
}
var BaseStringBlock = class extends BaseBlock {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
};
BaseStringBlock.NAME = "BaseStringBlock";
var LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
};
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
var _a$w;
var Primitive = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock);
    this.idBlock.isConstructed = false;
  }
};
_a$w = Primitive;
(() => {
  typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";
function localChangeType(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType();
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock({}, ValueBlock);
  const baseBlock = new LocalBaseBlock();
  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore.Boolean;
          break;
        case 2:
          newASN1Type = typeStore.Integer;
          break;
        case 3:
          newASN1Type = typeStore.BitString;
          break;
        case 4:
          newASN1Type = typeStore.OctetString;
          break;
        case 5:
          newASN1Type = typeStore.Null;
          break;
        case 6:
          newASN1Type = typeStore.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore.Sequence;
          break;
        case 17:
          newASN1Type = typeStore.Set;
          break;
        case 18:
          newASN1Type = typeStore.NumericString;
          break;
        case 19:
          newASN1Type = typeStore.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore.IA5String;
          break;
        case 23:
          newASN1Type = typeStore.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore.BmpString;
          break;
        case 31:
          newASN1Type = typeStore.DATE;
          break;
        case 32:
          newASN1Type = typeStore.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore.DateTime;
          break;
        case 34:
          newASN1Type = typeStore.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
  }
  returnObject = localChangeType(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock({}, ValueBlock);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length) {
  if (indefiniteLength) {
    return 1;
  }
  return length;
}
var LocalConstructedValueBlock = class extends ValueBlock {
  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer = writer || new ViewWriter();
    for (let i17 = 0; i17 < this.value.length; i17++) {
      this.value[i17].toBER(sizeOnly, _writer);
    }
    if (!writer) {
      return _writer.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
};
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
var _a$v;
var Constructed = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split("\n").map((o32) => `  ${o32}`).join("\n"));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
  }
};
_a$v = Constructed;
(() => {
  typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";
var LocalEndOfContentValueBlock = class extends ValueBlock {
  fromBER(inputBuffer, inputOffset, _inputLength) {
    return inputOffset;
  }
  toBER(_sizeOnly) {
    return EMPTY_BUFFER;
  }
};
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
var _a$u;
var EndOfContent = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
};
_a$u = EndOfContent;
(() => {
  typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;
var _a$t;
var Null = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, ValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
};
_a$t = Null;
(() => {
  typeStore.Null = _a$t;
})();
Null.NAME = "NULL";
var LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
};
LocalBooleanValueBlock.NAME = "BooleanValueBlock";
var _a$s;
var Boolean2 = class extends BaseBlock {
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
};
_a$s = Boolean2;
(() => {
  typeStore.Boolean = _a$s;
})();
Boolean2.NAME = "BOOLEAN";
var LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i17 = 0; i17 < this.value.length; i17++) {
        const currentBlockName = this.value[i17].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
};
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
var _a$r;
var OctetString = class extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch {
      }
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    }
    const name = this.constructor.NAME;
    const value = Convert.ToHex(this.valueBlock.valueHexView);
    return `${name} : ${value}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof _a$r) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
};
_a$r = OctetString;
(() => {
  typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;
var LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf = intBuffer.subarray(1);
      try {
        if (buf.byteLength) {
          const asn = localFromBER(buf, 0, buf.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch {
      }
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
};
LocalBitStringValueBlock.NAME = "BitStringValueBlock";
var _a$q;
var BitString = class extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b, _c;
    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      const name = this.constructor.NAME;
      const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);
      return `${name} : ${value}`;
    }
  }
};
_a$q = BitString;
(() => {
  typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;
var _a$p;
function viewAdd(first, second) {
  const c17 = new Uint8Array([0]);
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i17 = max; i17 >= 0; i17--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c17[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c17[0];
    }
    c17[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c17[0] > 0)
    firstViewCopy = utilConcatView(c17, firstViewCopy);
  return firstViewCopy;
}
function power2(n31) {
  if (n31 >= powers2.length) {
    for (let p3 = powers2.length; p3 <= n31; p3++) {
      const c17 = new Uint8Array([0]);
      let digits = powers2[p3 - 1].slice(0);
      for (let i17 = digits.length - 1; i17 >= 0; i17--) {
        const newValue = new Uint8Array([(digits[i17] << 1) + c17[0]]);
        c17[0] = newValue[0] / 10;
        digits[i17] = newValue[0] % 10;
      }
      if (c17[0] > 0)
        digits = utilConcatView(c17, digits);
      powers2.push(digits);
    }
  }
  return powers2[n31];
}
function viewSub(first, second) {
  let b5 = 0;
  const firstView = new Uint8Array(first);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i17 = secondViewCopyLength; i17 >= 0; i17--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b5;
    switch (true) {
      case value < 0:
        b5 = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b5 = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b5 > 0) {
    for (let i17 = firstViewCopyLength - secondViewCopyLength + 1; i17 >= 0; i17--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b5;
      if (value < 0) {
        b5 = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b5 = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}
var LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value !== void 0) {
      this.valueDec = value;
    }
  }
  set valueDec(v3) {
    this._valueDec = v3;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v3));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i17 = 0; i17 < 8; i17++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub(power2(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd(digits, power2(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i17 = 0; i17 < digits.length; i17++) {
      if (digits[i17])
        flag = true;
      if (flag)
        result += digitsString.charAt(digits[i17]);
    }
    if (flag === false)
      result += digitsString.charAt(0);
    return result;
  }
};
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p.prototype, "valueHex", {
    set: function(v3) {
      this.valueHexView = new Uint8Array(v3);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o;
var Integer = class extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter();
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new _a$o({ valueHex: writer.final() });
    return res;
  }
  convertToDER() {
    const integer = new _a$o({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new _a$o({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
};
_a$o = Integer;
(() => {
  typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";
var _a$n;
var Enumerated = class extends Integer {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
};
_a$n = Enumerated;
(() => {
  typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";
var LocalSidValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i17 = 0; i17 < inputLength; i17++) {
      this.valueHexView[i17] = intBuffer[i17] & 127;
      this.blockLength++;
      if ((intBuffer[i17] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i17 = 0; i17 < this.blockLength; i17++) {
      tempView[i17] = this.valueHexView[i17];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes3 = new Uint8Array(bits.length / 7);
    for (let i17 = 0; i17 < bytes3.length; i17++) {
      bytes3[i17] = parseInt(bits.slice(i17 * 7, i17 * 7 + 7), 2) + (i17 + 1 < bytes3.length ? 128 : 0);
    }
    this.fromBER(bytes3.buffer, 0, bytes3.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i17 = 0; i17 < this.blockLength - 1; i17++)
        retView2[i17] = curView[i17] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i17 = 0; i17 < len; i17++)
        retView[i17] = encodedView[i17] | 128;
      retView[len] = encodedView[len];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
};
LocalSidValueBlock.NAME = "sidBlock";
var LocalObjectIdentifierValueBlock = class extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i17 = 0; i17 < this.value.length; i17++) {
      const valueBuf = this.value[i17].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i17].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock();
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i17 = 0; i17 < this.value.length; i17++) {
      isHexOnly = this.value[i17].isHexOnly;
      let sidStr = this.value[i17].toString();
      if (i17 !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i17].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i17 = 0; i17 < this.value.length; i17++) {
      object.sidArray.push(this.value[i17].toJSON());
    }
    return object;
  }
};
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
var _a$m;
var ObjectIdentifier = class extends BaseBlock {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
};
_a$m = ObjectIdentifier;
(() => {
  typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
var LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i17 = 0; i17 < inputLength; i17++) {
      this.valueHexView[i17] = intBuffer[i17] & 127;
      this.blockLength++;
      if ((intBuffer[i17] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i17 = 0; i17 < this.blockLength; i17++)
      tempView[i17] = this.valueHexView[i17];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i17 = 0; i17 < this.blockLength - 1; i17++)
        retView2[i17] = curView[i17] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len = encodedBuf.byteLength - 1;
      for (let i17 = 0; i17 < len; i17++)
        retView[i17] = encodedView[i17] | 128;
      retView[len] = encodedView[len];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
};
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
var LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, _writer) {
    const retBuffers = [];
    for (let i17 = 0; i17 < this.value.length; i17++) {
      const valueBuf = this.value[i17].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i17].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string.substring(pos1);
      else
        sid = string.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock();
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i17 = 0; i17 < this.value.length; i17++) {
      isHexOnly = this.value[i17].isHexOnly;
      let sidStr = this.value[i17].toString();
      if (i17 !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i17 = 0; i17 < this.value.length; i17++)
      object.sidArray.push(this.value[i17].toJSON());
    return object;
  }
};
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l;
var RelativeObjectIdentifier = class extends BaseBlock {
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
};
_a$l = RelativeObjectIdentifier;
(() => {
  typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
var _a$k;
var Sequence = class extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
};
_a$k = Sequence;
(() => {
  typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";
var _a$j;
var Set2 = class extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
};
_a$j = Set2;
(() => {
  typeStore.Set = _a$j;
})();
Set2.NAME = "SET";
var LocalStringValueBlock = class extends HexBlock(ValueBlock) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
};
LocalStringValueBlock.NAME = "StringValueBlock";
var LocalSimpleStringValueBlock = class extends LocalStringValueBlock {
};
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
var LocalSimpleStringBlock = class extends BaseStringBlock {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i17 = 0; i17 < strLen; i17++)
      view[i17] = inputString.charCodeAt(i17);
    this.valueBlock.value = inputString;
  }
};
LocalSimpleStringBlock.NAME = "SIMPLE STRING";
var LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
};
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
var _a$i;
var Utf8String = class extends LocalUtf8StringValueBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
};
_a$i = Utf8String;
(() => {
  typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";
var LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
};
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
var _a$h;
var BmpString = class extends LocalBmpStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
};
_a$h = BmpString;
(() => {
  typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";
var LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i17 = 0; i17 < valueView.length; i17 += 4) {
      valueView[i17] = valueView[i17 + 3];
      valueView[i17 + 1] = valueView[i17 + 2];
      valueView[i17 + 2] = 0;
      valueView[i17 + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i17 = 0; i17 < strLength; i17++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i17), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j2 = codeView.length - 1; j2 >= 0; j2--)
        valueHexView[i17 * 4 + j2 + dif] = codeView[j2];
    }
    this.valueBlock.value = inputString;
  }
};
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
var _a$g;
var UniversalString = class extends LocalUniversalStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
};
_a$g = UniversalString;
(() => {
  typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";
var _a$f;
var NumericString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
};
_a$f = NumericString;
(() => {
  typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";
var _a$e;
var PrintableString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
};
_a$e = PrintableString;
(() => {
  typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";
var _a$d;
var TeletexString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
};
_a$d = TeletexString;
(() => {
  typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";
var _a$c;
var VideotexString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
};
_a$c = VideotexString;
(() => {
  typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";
var _a$b;
var IA5String = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
};
_a$b = IA5String;
(() => {
  typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";
var _a$a;
var GraphicString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
};
_a$a = GraphicString;
(() => {
  typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";
var _a$9;
var VisibleString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
};
_a$9 = VisibleString;
(() => {
  typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";
var _a$8;
var GeneralString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
};
_a$8 = GeneralString;
(() => {
  typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";
var _a$7;
var CharacterString = class extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
};
_a$7 = CharacterString;
(() => {
  typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";
var _a$6;
var UTCTime = class extends VisibleString {
  constructor({ value, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i17 = 0; i17 < value.length; i17++)
        this.valueBlock.valueHexView[i17] = value.charCodeAt(i17);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer);
    for (let i17 = 0; i17 < str.length; i17++)
      view[i17] = str.charCodeAt(i17);
    return buffer;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2e3 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
};
_a$6 = UTCTime;
(() => {
  typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";
var _a$5;
var GeneralizedTime = class extends UTCTime {
  constructor(parameters = {}) {
    var _b;
    super(parameters);
    (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);
    return new Date(utcDate);
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number = new Number(inputString[inputString.length - 1]);
      if (isNaN(number.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number;
        if (differenceString.length === 4) {
          number = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1e3 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j2 = 1; j2 < parserArray.length; j2++) {
      switch (j2) {
        case 1:
          this.year = parseInt(parserArray[j2], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j2], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j2], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j2], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j2], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j2], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
};
_a$5 = GeneralizedTime;
(() => {
  typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";
var _a$4;
var DATE = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
};
_a$4 = DATE;
(() => {
  typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";
var _a$3;
var TimeOfDay = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
};
_a$3 = TimeOfDay;
(() => {
  typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";
var _a$2;
var DateTime = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
};
_a$2 = DateTime;
(() => {
  typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";
var _a$1;
var Duration = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
};
_a$1 = Duration;
(() => {
  typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";
var _a;
var TIME = class extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
};
_a = TIME;
(() => {
  typeStore.TIME = _a;
})();
TIME.NAME = "TIME";

// node_modules/@hashgraph/cryptography/src/encoding/pem.js
var import_pem = __toESM(require_pem(), 1);
var import_buffer3 = __toESM(require_buffer(), 1);
var ID_ED25519 = "1.3.101.112";
async function readPemED25519(pem, passphrase) {
  const pemKeyData = pem.replace(
    /-----BEGIN (.*)-----|-----END (.*)-----|\n|\r/g,
    ""
  );
  const key = decode4(pemKeyData);
  if (passphrase) {
    let encrypted;
    try {
      encrypted = EncryptedPrivateKeyInfo.parse(key);
    } catch (error) {
      const message = (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        error != null && /** @type {Error} */
        error.message != null ? (
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          /** @type {Error} */
          error.message
        ) : ""
      );
      throw new BadKeyError(
        `failed to parse encrypted private key: ${message}`
      );
    }
    const decrypted = await encrypted.decrypt(passphrase);
    let privateKey = null;
    if (decrypted.algId.algIdent === ID_ED25519) {
      privateKey = Ed25519PrivateKey;
    } else {
      throw new BadKeyError(
        `unknown private key algorithm ${decrypted.algId.toString()}`
      );
    }
    const keyData = decode3(decrypted.privateKey);
    if (!("bytes" in keyData)) {
      throw new BadKeyError(
        `expected ASN bytes, got ${JSON.stringify(keyData)}`
      );
    }
    return privateKey.fromBytes(keyData.bytes);
  }
  return key.subarray(16);
}
async function readPemECDSA(pem, passphrase) {
  const pemKeyData = pem.replace(
    /-----BEGIN (.*)-----|-----END (.*)-----|\n|\r/g,
    ""
  );
  const key = decode4(pemKeyData);
  if (passphrase) {
    const decodedPem = import_pem.default.decode(pem)[0];
    const ivString = decodedPem.dekInfo.parameters;
    const iv = decode(ivString);
    const pemLines = pem.split("\n");
    const key2 = await messageDigest(passphrase, ivString);
    const dataToDecrypt = import_buffer3.Buffer.from(
      pemLines.slice(4, pemLines.length - 1).join(""),
      "base64"
    );
    const keyDerBytes = await createDecipheriv(
      CipherAlgorithm.Aes128Cbc,
      key2,
      iv,
      dataToDecrypt
    );
    return EcdsaPrivateKey.fromBytesDer(keyDerBytes);
  } else {
    const asnData = fromBER(key);
    const parsedKey = asnData.result;
    return parsedKey.valueBlock.value[1].valueBlock.valueHexView;
  }
}
async function read(pem, passphrase) {
  const isEcdsa = pem.includes("BEGIN EC PRIVATE KEY") ? true : false;
  if (isEcdsa) {
    return readPemECDSA(pem, passphrase);
  } else {
    return readPemED25519(pem, passphrase);
  }
}

// node_modules/@hashgraph/cryptography/src/util/derive.js
function legacy(seed, index) {
  const password = new Uint8Array(seed.length + 8);
  password.set(seed, 0);
  const view = new DataView(
    password.buffer,
    password.byteOffset,
    password.byteLength
  );
  if (index === 1099511627775) {
    view.setInt32(seed.length + 0, 255);
    view.setInt32(seed.length + 4, -1);
  } else {
    view.setInt32(seed.length + 0, index < 0 ? -1 : 0);
    view.setInt32(seed.length + 4, index);
  }
  const salt = Uint8Array.from([255]);
  return deriveKey(
    HashAlgorithm.Sha512,
    password,
    salt,
    2048,
    32
  );
}

// node_modules/@hashgraph/cryptography/src/Cache.js
var CACHE = {
  /** @type {((key: Ed25519PrivateKey | EcdsaPrivateKey) => PrivateKey) | null} */
  privateKeyConstructor: null,
  /** @type {((bytes: Uint8Array) => PrivateKey) | null} */
  privateKeyFromBytes: null,
  /** @type {((words: string) => Mnemonic) | null} */
  mnemonicFromString: null
};
var Cache_default = CACHE;

// node_modules/@hashgraph/cryptography/src/PrivateKey.js
var PrivateKey = class _PrivateKey extends Key {
  /**
   * @hideconstructor
   * @internal
   * @param {Ed25519PrivateKey | EcdsaPrivateKey} key
   */
  constructor(key) {
    super();
    this._key = key;
  }
  /**
   * @returns {string}
   */
  get _type() {
    return this._key._type;
  }
  /**
   * @returns {Uint8Array | null}
   */
  get _chainCode() {
    return this._key._chainCode;
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {PrivateKey}
   */
  static generateED25519() {
    return new _PrivateKey(Ed25519PrivateKey.generate());
  }
  /**
   * Generate a random EDSA private key.
   * @returns {PrivateKey}
   */
  static generateECDSA() {
    return new _PrivateKey(EcdsaPrivateKey.generate());
  }
  /**
   * Depredated - Use `generateED25519()` instead
   * Generate a random Ed25519 private key.
   * @returns {PrivateKey}
   */
  static generate() {
    return _PrivateKey.generateED25519();
  }
  /**
   * Depredated - Use `generateED25519Async()` instead
   * Generate a random Ed25519 private key.
   * @returns {Promise<PrivateKey>}
   */
  static async generateAsync() {
    return _PrivateKey.generateED25519Async();
  }
  /**
   * Generate a random Ed25519 private key.
   * @returns {Promise<PrivateKey>}
   */
  static async generateED25519Async() {
    return new _PrivateKey(await Ed25519PrivateKey.generateAsync());
  }
  /**
   * Generate a random ECDSA private key.
   * @returns {Promise<PrivateKey>}
   */
  static async generateECDSAAsync() {
    return new _PrivateKey(await EcdsaPrivateKey.generateAsync());
  }
  /**
   * Construct a private key from bytes. Requires DER header.
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */
  static fromBytes(data) {
    let message;
    if (data.length == 32) {
      console.warn(
        "WARNING: Consider using fromStringECDSA() or fromStringED25519() on a HEX-encoded string and fromStringDer() on a HEX-encoded string with DER prefix instead."
      );
    }
    try {
      return new _PrivateKey(Ed25519PrivateKey.fromBytes(data));
    } catch (error) {
      message = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : "";
    }
    try {
      return new _PrivateKey(EcdsaPrivateKey.fromBytes(data));
    } catch (error) {
      message = // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      error != null && /** @type {Error} */
      error.message != null ? (
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        /** @type {Error} */
        error.message
      ) : "";
    }
    throw new BadKeyError(
      `private key cannot be decoded from bytes: ${message}`
    );
  }
  /**
   * Construct a ECDSA private key from bytes.
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */
  static fromBytesECDSA(data) {
    return new _PrivateKey(EcdsaPrivateKey.fromBytes(data));
  }
  /**
   * Construct a ED25519 private key from bytes.
   * @param {Uint8Array} data
   * @returns {PrivateKey}
   */
  static fromBytesED25519(data) {
    return new _PrivateKey(Ed25519PrivateKey.fromBytes(data));
  }
  /**
   * Construct a private key from a hex-encoded string. Requires DER header.
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromString(text) {
    return _PrivateKey.fromBytes(decode(text));
  }
  /**
   * Construct a ECDSA private key from a hex-encoded string.
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromStringECDSA(text) {
    return _PrivateKey.fromBytesECDSA(decode(text));
  }
  /**
   * Construct a Ed25519 private key from a hex-encoded string.
   * @param {string} text
   * @returns {PrivateKey}
   */
  static fromStringED25519(text) {
    return _PrivateKey.fromBytesED25519(decode(text));
  }
  /**
   * Construct a Ed25519 private key from a Uint8Array seed.
   * @param {Uint8Array} seed
   * @returns {Promise<PrivateKey>}
   */
  static async fromSeedED25519(seed) {
    const ed25519Key = await Ed25519PrivateKey.fromSeed(seed);
    return new _PrivateKey(ed25519Key);
  }
  /**
   * Construct a ECDSA private key from a Uint8Array seed.
   * @param {Uint8Array} seed
   * @returns {Promise<PrivateKey>}
   */
  static async fromSeedECDSAsecp256k1(seed) {
    const ecdsaKey = await EcdsaPrivateKey.fromSeed(seed);
    return new _PrivateKey(ecdsaKey);
  }
  /**
   * @deprecated - Use `Mnemonic.from[Words|String]().toStandard[Ed25519|ECDSAsecp256k1]PrivateKey()` instead
   *
   * Recover a private key from a mnemonic phrase (and optionally a password).
   * @param {Mnemonic | string} mnemonic
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */
  static async fromMnemonic(mnemonic, passphrase = "") {
    if (Cache_default.mnemonicFromString == null) {
      throw new Error("Mnemonic not found in cache");
    }
    return (typeof mnemonic === "string" ? Cache_default.mnemonicFromString(mnemonic) : mnemonic).toEd25519PrivateKey(passphrase);
  }
  /**
   * Recover a private key from a keystore, previously created by `.toKeystore()`.
   *
   * This key will _not_ support child key derivation.
   * @param {Uint8Array} data
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   * @throws {BadKeyError} If the passphrase is incorrect or the hash fails to validate.
   */
  static async fromKeystore(data, passphrase = "") {
    return _PrivateKey.fromBytes(await loadKeystore(data, passphrase));
  }
  /**
   * Recover a private key from a pem string; the private key may be encrypted.
   *
   * This method assumes the .pem file has been converted to a string already.
   *
   * If `passphrase` is not null or empty, this looks for the first `ENCRYPTED PRIVATE KEY`
   * section and uses `passphrase` to decrypt it; otherwise, it looks for the first `PRIVATE KEY`
   * section and decodes that as a DER-encoded  private key.
   * @param {string} data
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */
  static async fromPem(data, passphrase = "") {
    const pem = await read(data, passphrase);
    if (pem instanceof Ed25519PrivateKey || pem instanceof EcdsaPrivateKey) {
      return new _PrivateKey(pem);
    }
    const isEcdsa = data.includes("BEGIN EC PRIVATE KEY") ? true : false;
    if (isEcdsa) {
      return new _PrivateKey(EcdsaPrivateKey.fromBytes(pem));
    } else {
      return new _PrivateKey(Ed25519PrivateKey.fromBytes(pem));
    }
  }
  /**
   * Derive a new private key at the given wallet index.
   *
   * Only currently supported for keys created with from mnemonics; other keys will throw
   * an error.
   *
   * You can check if a key supports derivation with `.supportsDerivation()`
   * @param {number} index
   * @returns {Promise<PrivateKey>}
   * @throws If this key does not support derivation.
   */
  async derive(index) {
    if (this._key._chainCode == null) {
      throw new Error("this private key does not support key derivation");
    }
    if (this._key instanceof Ed25519PrivateKey) {
      const { keyData, chainCode } = await derive2(
        this.toBytesRaw(),
        this._key._chainCode,
        index
      );
      return new _PrivateKey(new Ed25519PrivateKey(keyData, chainCode));
    } else {
      const { keyData, chainCode } = await derive(
        this.toBytesRaw(),
        this._key._chainCode,
        index
      );
      return new _PrivateKey(
        new EcdsaPrivateKey(fromBytes2(keyData), chainCode)
      );
    }
  }
  /**
   * @param {number} index
   * @returns {Promise<PrivateKey>}
   * @throws If this key does not support derivation.
   */
  async legacyDerive(index) {
    const keyBytes = await legacy(
      this.toBytesRaw().subarray(0, 32),
      index
    );
    const constructor = (
      /** @type {any} */
      this._key.constructor
    );
    return new _PrivateKey(new constructor(keyBytes));
  }
  /**
   * Get the public key associated with this private key.
   *
   * The public key can be freely given and used by other parties to verify
   * the signatures generated by this private key.
   * @returns {PublicKey}
   */
  get publicKey() {
    return new PublicKey(this._key.publicKey);
  }
  /**
   * Sign a message with this private key.
   * @param {Uint8Array} bytes
   * @returns {Uint8Array} - The signature bytes without the message
   */
  sign(bytes3) {
    return this._key.sign(bytes3);
  }
  /**
   * @param {Transaction} transaction
   * @returns {Uint8Array}
   */
  signTransaction(transaction) {
    if (!transaction.isFrozen()) {
      transaction.freeze();
    }
    if (transaction._signedTransactions.length != 1) {
      throw new Error(
        "`PrivateKey.signTransaction()` requires `Transaction` to have a single node `AccountId` set"
      );
    }
    const tx = (
      /** @type {ProtoSignedTransaction} */
      transaction._signedTransactions[0]
    );
    const publicKeyHex = encode(this.publicKey.toBytesRaw());
    if (tx.sigMap == null) {
      tx.sigMap = {};
    }
    if (tx.sigMap.sigPair == null) {
      tx.sigMap.sigPair = [];
    }
    for (const sigPair of tx.sigMap.sigPair) {
      if (sigPair.pubKeyPrefix != null && encode(sigPair.pubKeyPrefix) === publicKeyHex) {
        switch (this._type) {
          case "ED25519":
            return (
              /** @type {Uint8Array} */
              sigPair.ed25519
            );
          case "secp256k1":
            return (
              /** @type {Uint8Array} */
              sigPair.ECDSASecp256k1
            );
        }
      }
    }
    const siganture = this.sign(
      tx.bodyBytes != null ? tx.bodyBytes : new Uint8Array()
    );
    const protoSignature = {
      pubKeyPrefix: this.publicKey.toBytesRaw()
    };
    switch (this._type) {
      case "ED25519":
        protoSignature.ed25519 = siganture;
        break;
      case "secp256k1":
        protoSignature.ECDSASecp256k1 = siganture;
        break;
    }
    tx.sigMap.sigPair.push(protoSignature);
    transaction._signerPublicKeys.add(publicKeyHex);
    return siganture;
  }
  /**
   * Check if `derive` can be called on this private key.
   *
   * This is only the case if the key was created from a mnemonic.
   * @returns {boolean}
   */
  isDerivable() {
    return this._key._chainCode != null;
  }
  /**
   * @returns {Uint8Array}
   */
  toBytes() {
    if (this._key instanceof Ed25519PrivateKey) {
      return this.toBytesRaw();
    } else {
      return this.toBytesDer();
    }
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesDer() {
    return this._key.toBytesDer();
  }
  /**
   * @returns {Uint8Array}
   */
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  /**
   * @returns {string}
   */
  toString() {
    return this.toStringDer();
  }
  /**
   * @returns {string}
   */
  toStringDer() {
    return encode(this.toBytesDer());
  }
  /**
   * @returns {string}
   */
  toStringRaw() {
    return encode(this.toBytesRaw());
  }
  /**
   * Create a keystore with a given passphrase.
   *
   * The key can be recovered later with `fromKeystore()`.
   *
   * Note that this will not retain the ancillary data used for
   * deriving child keys, thus `.derive()` on the restored key will
   * throw even if this instance supports derivation.
   * @param {string} [passphrase]
   * @returns {Promise<Uint8Array>}
   */
  toKeystore(passphrase = "") {
    return createKeystore(this.toBytesRaw(), passphrase);
  }
  /**
   * Recover the recovery ID used in the signature for the given message.
   *
   * **Note:** This method only works for ECDSA secp256k1 keys.
   * @param {Uint8Array} r - 32-byte `r` component of the signature
   * @param {Uint8Array} s - 32-byte `s` component of the signature
   * @param {Uint8Array} message - The original (unhashed) message
   * @returns {number} Recovery ID (03), or -1 if not found or not applicable
   */
  getRecoveryId(r41, s26, message) {
    if (!(this._key instanceof EcdsaPrivateKey)) {
      throw new Error("Invalid key type, must be ECDSA secp256k1.");
    }
    if (r41.length !== 32 || s26.length !== 32) {
      throw new Error("Invalid signature components.");
    }
    const signature = new Uint8Array(64);
    signature.set(r41, 0);
    signature.set(s26, 32);
    return this._key.getRecoveryId(signature, message);
  }
};
Cache_default.privateKeyConstructor = (key) => new PrivateKey(key);
Cache_default.privateKeyFromBytes = (bytes3) => PrivateKey.fromBytes(bytes3);

// node_modules/@hashgraph/cryptography/src/BadMnemonicReason.js
var BadMnemonicReason = Object.freeze({
  /**
   * The mnemonic did not have a supported number of words (12 or 24 for regular and 22 for legacy).
   */
  BadLength: "BadLength",
  /**
   * The mnemonic contained words which were not found in the word list.
   */
  UnknownWords: "UnknownWords",
  /**
   * The checksum encoded in the mnemonic did not match the checksum we just calculated for
   * that mnemonic.
   *
   * 24-word mnemonics have an 8-bit checksum that is appended to the 32 bytes of source entropy
   * after being calculated from it, before being encoded into words.
   *
   * This could happen if two or more of the words were entered out of the original order or
   * replaced with another from the standard word list (as this is only returned if all the words
   * exist in the word list).
   */
  ChecksumMismatch: "ChecksumMismatch"
});
var BadMnemonicReason_default = BadMnemonicReason;

// node_modules/@hashgraph/cryptography/src/BadMnemonicError.js
var BadMnemonicError = class _BadMnemonicError extends Error {
  /**
   * @param {Mnemonic} mnemonic
   * @param {string} reason
   * @param {number[]} unknownWordIndices
   * @hideconstructor
   */
  constructor(mnemonic, reason, unknownWordIndices) {
    let reasonMessage;
    switch (reason) {
      case BadMnemonicReason_default.BadLength:
        reasonMessage = "mnemonic is of an unexpected number of words";
        break;
      case BadMnemonicReason_default.ChecksumMismatch:
        reasonMessage = "checksum byte in mnemonic did not match the rest of the mnemonic";
        break;
      case BadMnemonicReason_default.UnknownWords:
        reasonMessage = "mnemonic contained words that are not in the standard word list";
        break;
      default:
        throw new Error(
          `unexpected value ${reason.toString()} for 'reason'`
        );
    }
    super(`invalid mnemonic: ${reasonMessage}`);
    if (typeof Error.captureStackTrace !== "undefined") {
      Error.captureStackTrace(this, _BadMnemonicError);
    }
    this.name = "BadMnemonicError";
    this.reason = reason;
    this.mnemonic = mnemonic;
    this.unknownWordIndices = unknownWordIndices;
  }
};

// node_modules/@hashgraph/cryptography/src/words/legacy.js
var legacy_default = [
  "aback",
  "abbey",
  "abbot",
  "abide",
  "ablaze",
  "able",
  "aboard",
  "abode",
  "abort",
  "abound",
  "about",
  "above",
  "abroad",
  "abrupt",
  "absent",
  "absorb",
  "absurd",
  "abuse",
  "accent",
  "accept",
  "access",
  "accord",
  "accuse",
  "ace",
  "ache",
  "aching",
  "acid",
  "acidic",
  "acorn",
  "acre",
  "across",
  "act",
  "action",
  "active",
  "actor",
  "actual",
  "acute",
  "adam",
  "adapt",
  "add",
  "added",
  "addict",
  "adept",
  "adhere",
  "adjust",
  "admire",
  "admit",
  "adobe",
  "adopt",
  "adrift",
  "adult",
  "adverb",
  "advice",
  "aerial",
  "afar",
  "affair",
  "affect",
  "afford",
  "afghan",
  "afield",
  "afloat",
  "afraid",
  "afresh",
  "after",
  "again",
  "age",
  "agency",
  "agenda",
  "agent",
  "aghast",
  "agile",
  "ago",
  "agony",
  "agree",
  "agreed",
  "ahead",
  "aid",
  "aide",
  "aim",
  "air",
  "airman",
  "airy",
  "akin",
  "alarm",
  "alaska",
  "albeit",
  "album",
  "ale",
  "alert",
  "alibi",
  "alice",
  "alien",
  "alight",
  "align",
  "alike",
  "alive",
  "alkali",
  "all",
  "alley",
  "allied",
  "allow",
  "alloy",
  "ally",
  "almond",
  "almost",
  "aloft",
  "alone",
  "along",
  "aloof",
  "aloud",
  "alpha",
  "alpine",
  "also",
  "altar",
  "alter",
  "always",
  "amaze",
  "amazon",
  "amber",
  "ambush",
  "amen",
  "amend",
  "amid",
  "amidst",
  "amiss",
  "among",
  "amount",
  "ample",
  "amuse",
  "anchor",
  "and",
  "andrew",
  "anew",
  "angel",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "annoy",
  "annual",
  "answer",
  "anthem",
  "any",
  "anyhow",
  "anyway",
  "apart",
  "apathy",
  "apex",
  "apiece",
  "appeal",
  "appear",
  "apple",
  "apply",
  "april",
  "apron",
  "arab",
  "arcade",
  "arcane",
  "arch",
  "arctic",
  "ardent",
  "are",
  "area",
  "argue",
  "arid",
  "arise",
  "ark",
  "arm",
  "armful",
  "army",
  "aroma",
  "around",
  "arouse",
  "array",
  "arrest",
  "arrive",
  "arrow",
  "arson",
  "art",
  "artery",
  "artful",
  "artist",
  "ascent",
  "ash",
  "ashen",
  "ashore",
  "aside",
  "ask",
  "asleep",
  "aspect",
  "assay",
  "assent",
  "assert",
  "assess",
  "asset",
  "assign",
  "assist",
  "assume",
  "assure",
  "asthma",
  "astute",
  "asylum",
  "ate",
  "athens",
  "atlas",
  "atom",
  "atomic",
  "attach",
  "attack",
  "attain",
  "attend",
  "attic",
  "auburn",
  "audio",
  "audit",
  "august",
  "aunt",
  "auntie",
  "aura",
  "austin",
  "author",
  "auto",
  "autumn",
  "avail",
  "avenge",
  "avenue",
  "avert",
  "avid",
  "avoid",
  "await",
  "awake",
  "awaken",
  "award",
  "aware",
  "awash",
  "away",
  "awful",
  "awhile",
  "axe",
  "axes",
  "axiom",
  "axis",
  "axle",
  "aye",
  "babe",
  "baby",
  "bach",
  "back",
  "backup",
  "bacon",
  "bad",
  "badge",
  "badly",
  "bag",
  "baggy",
  "bail",
  "bait",
  "bake",
  "baker",
  "bakery",
  "bald",
  "ball",
  "ballad",
  "ballet",
  "ballot",
  "baltic",
  "bamboo",
  "ban",
  "banal",
  "banana",
  "band",
  "bang",
  "bank",
  "bar",
  "barber",
  "bare",
  "barely",
  "barge",
  "bark",
  "barley",
  "barn",
  "baron",
  "barrel",
  "barren",
  "basalt",
  "base",
  "basic",
  "basil",
  "basin",
  "basis",
  "basket",
  "bass",
  "bat",
  "batch",
  "bath",
  "baton",
  "battle",
  "bay",
  "beach",
  "beacon",
  "beak",
  "beam",
  "bean",
  "bear",
  "beard",
  "beast",
  "beat",
  "beauty",
  "become",
  "bed",
  "beech",
  "beef",
  "beefy",
  "beep",
  "beer",
  "beet",
  "beetle",
  "before",
  "beg",
  "beggar",
  "begin",
  "behalf",
  "behave",
  "behind",
  "beige",
  "being",
  "belief",
  "bell",
  "belly",
  "belong",
  "below",
  "belt",
  "bench",
  "bend",
  "benign",
  "bent",
  "berlin",
  "berry",
  "berth",
  "beset",
  "beside",
  "best",
  "bestow",
  "bet",
  "beta",
  "betray",
  "better",
  "beware",
  "beyond",
  "bias",
  "biceps",
  "bicker",
  "bid",
  "big",
  "bigger",
  "bike",
  "bile",
  "bill",
  "bin",
  "binary",
  "bind",
  "biopsy",
  "birch",
  "bird",
  "birdie",
  "birth",
  "bishop",
  "bit",
  "bitch",
  "bite",
  "bitter",
  "black",
  "blade",
  "blame",
  "bland",
  "blast",
  "blaze",
  "bleak",
  "blend",
  "bless",
  "blew",
  "blind",
  "blink",
  "blip",
  "bliss",
  "blitz",
  "block",
  "blond",
  "blood",
  "bloody",
  "bloom",
  "blot",
  "blouse",
  "blow",
  "blue",
  "bluff",
  "blunt",
  "blur",
  "blush",
  "boar",
  "board",
  "boast",
  "boat",
  "bob",
  "bodily",
  "body",
  "bogus",
  "boil",
  "bold",
  "bolt",
  "bomb",
  "bombay",
  "bond",
  "bone",
  "bonn",
  "bonnet",
  "bonus",
  "bony",
  "book",
  "boom",
  "boost",
  "boot",
  "booth",
  "booze",
  "border",
  "bore",
  "borrow",
  "bosom",
  "boss",
  "boston",
  "both",
  "bother",
  "bottle",
  "bottom",
  "bought",
  "bounce",
  "bound",
  "bounty",
  "bout",
  "bovine",
  "bow",
  "bowel",
  "bowl",
  "box",
  "boy",
  "boyish",
  "brace",
  "brain",
  "brainy",
  "brake",
  "bran",
  "branch",
  "brand",
  "brandy",
  "brass",
  "brave",
  "bravo",
  "brazil",
  "breach",
  "bread",
  "break",
  "breast",
  "breath",
  "bred",
  "breed",
  "breeze",
  "brew",
  "bribe",
  "brick",
  "bride",
  "bridge",
  "brief",
  "bright",
  "brim",
  "brine",
  "bring",
  "brink",
  "brisk",
  "broad",
  "broke",
  "broken",
  "bronze",
  "brook",
  "broom",
  "brown",
  "bruise",
  "brush",
  "brutal",
  "brute",
  "bubble",
  "buck",
  "bucket",
  "buckle",
  "budget",
  "buffet",
  "buggy",
  "build",
  "bulb",
  "bulge",
  "bulk",
  "bulky",
  "bull",
  "bullet",
  "bully",
  "bump",
  "bumpy",
  "bunch",
  "bundle",
  "bunk",
  "bunny",
  "burden",
  "bureau",
  "burial",
  "buried",
  "burly",
  "burn",
  "burnt",
  "burrow",
  "burst",
  "bury",
  "bus",
  "bush",
  "bust",
  "bustle",
  "busy",
  "but",
  "butler",
  "butt",
  "butter",
  "button",
  "buy",
  "buyer",
  "buzz",
  "bye",
  "byte",
  "cab",
  "cabin",
  "cable",
  "cache",
  "cactus",
  "caesar",
  "cage",
  "cairo",
  "cajun",
  "cajole",
  "cake",
  "calf",
  "call",
  "caller",
  "calm",
  "calmly",
  "came",
  "camel",
  "camera",
  "camp",
  "campus",
  "can",
  "canada",
  "canal",
  "canary",
  "cancel",
  "cancer",
  "candid",
  "candle",
  "candy",
  "cane",
  "canine",
  "canoe",
  "canopy",
  "canvas",
  "canyon",
  "cap",
  "cape",
  "car",
  "carbon",
  "card",
  "care",
  "career",
  "caress",
  "cargo",
  "carl",
  "carnal",
  "carol",
  "carp",
  "carpet",
  "carrot",
  "carry",
  "cart",
  "cartel",
  "case",
  "cash",
  "cask",
  "cast",
  "castle",
  "casual",
  "cat",
  "catch",
  "cater",
  "cattle",
  "caught",
  "causal",
  "cause",
  "cave",
  "cease",
  "celery",
  "cell",
  "cellar",
  "celtic",
  "cement",
  "censor",
  "census",
  "cent",
  "cereal",
  "chain",
  "chair",
  "chalk",
  "chalky",
  "champ",
  "chance",
  "change",
  "chant",
  "chaos",
  "chap",
  "chapel",
  "charge",
  "charm",
  "chart",
  "chase",
  "chat",
  "cheap",
  "cheat",
  "check",
  "cheek",
  "cheeky",
  "cheer",
  "cheery",
  "cheese",
  "chef",
  "cheque",
  "cherry",
  "chess",
  "chest",
  "chew",
  "chic",
  "chick",
  "chief",
  "child",
  "chile",
  "chill",
  "chilly",
  "chin",
  "china",
  "chip",
  "choice",
  "choir",
  "choose",
  "chop",
  "choppy",
  "chord",
  "chorus",
  "chose",
  "chosen",
  "chris",
  "chrome",
  "chunk",
  "chunky",
  "church",
  "cider",
  "cigar",
  "cinema",
  "circa",
  "circle",
  "circus",
  "cite",
  "city",
  "civic",
  "civil",
  "clad",
  "claim",
  "clammy",
  "clan",
  "clap",
  "clash",
  "clasp",
  "class",
  "clause",
  "claw",
  "clay",
  "clean",
  "clear",
  "clergy",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climax",
  "climb",
  "clinch",
  "cling",
  "clinic",
  "clip",
  "cloak",
  "clock",
  "clone",
  "close",
  "closer",
  "closet",
  "cloth",
  "cloud",
  "cloudy",
  "clout",
  "clown",
  "club",
  "clue",
  "clumsy",
  "clung",
  "clutch",
  "coach",
  "coal",
  "coarse",
  "coast",
  "coat",
  "coax",
  "cobalt",
  "cobra",
  "coca",
  "cock",
  "cocoa",
  "code",
  "coffee",
  "coffin",
  "cohort",
  "coil",
  "coin",
  "coke",
  "cold",
  "collar",
  "colon",
  "colony",
  "colt",
  "column",
  "comb",
  "combat",
  "come",
  "comedy",
  "comic",
  "commit",
  "common",
  "compel",
  "comply",
  "concur",
  "cone",
  "confer",
  "congo",
  "consul",
  "convex",
  "convey",
  "convoy",
  "cook",
  "cool",
  "cope",
  "copper",
  "copy",
  "coral",
  "cord",
  "core",
  "cork",
  "corn",
  "corner",
  "corps",
  "corpse",
  "corpus",
  "cortex",
  "cosmic",
  "cosmos",
  "cost",
  "costly",
  "cotton",
  "couch",
  "cough",
  "could",
  "count",
  "county",
  "coup",
  "couple",
  "coupon",
  "course",
  "court",
  "cousin",
  "cove",
  "cover",
  "covert",
  "cow",
  "coward",
  "cowboy",
  "cozy",
  "crab",
  "crack",
  "cradle",
  "craft",
  "crafty",
  "crag",
  "crane",
  "crash",
  "crate",
  "crater",
  "crawl",
  "crazy",
  "creak",
  "cream",
  "creamy",
  "create",
  "credit",
  "creed",
  "creek",
  "creep",
  "creepy",
  "crept",
  "crest",
  "crew",
  "cried",
  "crime",
  "crisis",
  "crisp",
  "critic",
  "crook",
  "crop",
  "cross",
  "crow",
  "crowd",
  "crown",
  "crude",
  "cruel",
  "cruise",
  "crunch",
  "crush",
  "crust",
  "crux",
  "cry",
  "crypt",
  "cuba",
  "cube",
  "cubic",
  "cuckoo",
  "cuff",
  "cult",
  "cup",
  "curb",
  "cure",
  "curfew",
  "curl",
  "curry",
  "curse",
  "cursor",
  "curve",
  "cuss",
  "custom",
  "cut",
  "cute",
  "cycle",
  "cyclic",
  "cynic",
  "czech",
  "dad",
  "daddy",
  "dagger",
  "daily",
  "dairy",
  "daisy",
  "dale",
  "dam",
  "damage",
  "damp",
  "dampen",
  "dance",
  "danger",
  "danish",
  "dare",
  "dark",
  "darken",
  "darn",
  "dart",
  "dash",
  "data",
  "date",
  "david",
  "dawn",
  "day",
  "dead",
  "deadly",
  "deaf",
  "deal",
  "dealer",
  "dean",
  "dear",
  "death",
  "debate",
  "debit",
  "debris",
  "debt",
  "debtor",
  "decade",
  "decay",
  "decent",
  "decide",
  "deck",
  "decor",
  "decree",
  "deduce",
  "deed",
  "deep",
  "deeply",
  "deer",
  "defeat",
  "defect",
  "defend",
  "defer",
  "define",
  "defy",
  "degree",
  "deity",
  "delay",
  "delete",
  "delhi",
  "delta",
  "demand",
  "demise",
  "demo",
  "demure",
  "denial",
  "denote",
  "dense",
  "dental",
  "deny",
  "depart",
  "depend",
  "depict",
  "deploy",
  "depot",
  "depth",
  "deputy",
  "derive",
  "desert",
  "design",
  "desire",
  "desist",
  "desk",
  "detail",
  "detect",
  "deter",
  "detest",
  "detour",
  "device",
  "devise",
  "devoid",
  "devote",
  "devour",
  "dial",
  "diana",
  "diary",
  "dice",
  "dictum",
  "did",
  "die",
  "diesel",
  "diet",
  "differ",
  "dig",
  "digest",
  "digit",
  "dine",
  "dinghy",
  "dinner",
  "diode",
  "dip",
  "dire",
  "direct",
  "dirt",
  "dirty",
  "disc",
  "disco",
  "dish",
  "disk",
  "dismal",
  "dispel",
  "ditch",
  "dive",
  "divert",
  "divide",
  "divine",
  "dizzy",
  "docile",
  "dock",
  "doctor",
  "dog",
  "dogma",
  "dole",
  "doll",
  "dollar",
  "dolly",
  "domain",
  "dome",
  "domino",
  "donate",
  "done",
  "donkey",
  "donor",
  "doom",
  "door",
  "dorsal",
  "dose",
  "dot",
  "double",
  "doubt",
  "dough",
  "dour",
  "dove",
  "down",
  "dozen",
  "draft",
  "drag",
  "dragon",
  "drain",
  "drama",
  "drank",
  "draw",
  "drawer",
  "dread",
  "dream",
  "dreary",
  "dress",
  "drew",
  "dried",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "driver",
  "drop",
  "drove",
  "drown",
  "drug",
  "drum",
  "drunk",
  "dry",
  "dual",
  "duck",
  "duct",
  "due",
  "duel",
  "duet",
  "duke",
  "dull",
  "duly",
  "dumb",
  "dummy",
  "dump",
  "dune",
  "dung",
  "duress",
  "during",
  "dusk",
  "dust",
  "dusty",
  "dutch",
  "duty",
  "dwarf",
  "dwell",
  "dyer",
  "dying",
  "dynamo",
  "each",
  "eager",
  "eagle",
  "ear",
  "earl",
  "early",
  "earn",
  "earth",
  "ease",
  "easel",
  "easily",
  "east",
  "easter",
  "easy",
  "eat",
  "eaten",
  "eater",
  "echo",
  "eddy",
  "eden",
  "edge",
  "edible",
  "edict",
  "edit",
  "editor",
  "eel",
  "eerie",
  "eerily",
  "effect",
  "effort",
  "egg",
  "ego",
  "eight",
  "eighth",
  "eighty",
  "either",
  "elbow",
  "elder",
  "eldest",
  "elect",
  "eleven",
  "elicit",
  "elite",
  "else",
  "elude",
  "elves",
  "embark",
  "emblem",
  "embryo",
  "emerge",
  "emit",
  "empire",
  "employ",
  "empty",
  "enable",
  "enamel",
  "end",
  "endure",
  "enemy",
  "energy",
  "engage",
  "engine",
  "enjoy",
  "enlist",
  "enough",
  "ensure",
  "entail",
  "enter",
  "entire",
  "entry",
  "envoy",
  "envy",
  "enzyme",
  "epic",
  "epoch",
  "equal",
  "equate",
  "equip",
  "equity",
  "era",
  "erect",
  "eric",
  "erode",
  "erotic",
  "errant",
  "error",
  "escape",
  "escort",
  "essay",
  "essex",
  "estate",
  "esteem",
  "ethic",
  "ethnic",
  "europe",
  "evade",
  "eve",
  "even",
  "event",
  "ever",
  "every",
  "evict",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "exam",
  "exceed",
  "excel",
  "except",
  "excess",
  "excise",
  "excite",
  "excuse",
  "exempt",
  "exert",
  "exile",
  "exist",
  "exit",
  "exodus",
  "exotic",
  "expand",
  "expect",
  "expert",
  "expire",
  "export",
  "expose",
  "extend",
  "extra",
  "eye",
  "eyed",
  "fabric",
  "face",
  "facial",
  "fact",
  "factor",
  "fade",
  "fail",
  "faint",
  "fair",
  "fairly",
  "fairy",
  "faith",
  "fake",
  "falcon",
  "fall",
  "false",
  "falter",
  "fame",
  "family",
  "famine",
  "famous",
  "fan",
  "fancy",
  "far",
  "farce",
  "fare",
  "farm",
  "farmer",
  "fast",
  "fasten",
  "faster",
  "fat",
  "fatal",
  "fate",
  "father",
  "fatty",
  "fault",
  "faulty",
  "fauna",
  "fear",
  "feast",
  "feat",
  "fed",
  "fee",
  "feeble",
  "feed",
  "feel",
  "feet",
  "fell",
  "fellow",
  "felt",
  "female",
  "fence",
  "fend",
  "ferry",
  "fetal",
  "fetch",
  "feudal",
  "fever",
  "few",
  "fewer",
  "fiasco",
  "fiddle",
  "field",
  "fiend",
  "fierce",
  "fiery",
  "fifth",
  "fifty",
  "fig",
  "fight",
  "figure",
  "file",
  "fill",
  "filled",
  "filler",
  "film",
  "filter",
  "filth",
  "filthy",
  "final",
  "finale",
  "find",
  "fine",
  "finery",
  "finger",
  "finish",
  "finite",
  "fire",
  "firm",
  "firmly",
  "first",
  "fiscal",
  "fish",
  "fisher",
  "fist",
  "fit",
  "fitful",
  "five",
  "fix",
  "flag",
  "flair",
  "flak",
  "flame",
  "flank",
  "flap",
  "flare",
  "flash",
  "flask",
  "flat",
  "flavor",
  "flaw",
  "fled",
  "flee",
  "fleece",
  "fleet",
  "flesh",
  "fleshy",
  "flew",
  "flick",
  "flight",
  "flimsy",
  "flint",
  "flirt",
  "float",
  "flock",
  "flood",
  "floor",
  "floppy",
  "flora",
  "floral",
  "flour",
  "flow",
  "flower",
  "fluent",
  "fluffy",
  "fluid",
  "flung",
  "flurry",
  "flush",
  "flute",
  "flux",
  "fly",
  "flyer",
  "foal",
  "foam",
  "focal",
  "focus",
  "fog",
  "foil",
  "fold",
  "folk",
  "follow",
  "folly",
  "fond",
  "fondly",
  "font",
  "food",
  "fool",
  "foot",
  "for",
  "forbid",
  "force",
  "ford",
  "forest",
  "forge",
  "forget",
  "fork",
  "form",
  "formal",
  "format",
  "former",
  "fort",
  "forth",
  "forty",
  "forum",
  "fossil",
  "foster",
  "foul",
  "found",
  "four",
  "fourth",
  "fox",
  "foyer",
  "frail",
  "frame",
  "franc",
  "france",
  "frank",
  "fraud",
  "fred",
  "free",
  "freed",
  "freely",
  "freeze",
  "french",
  "frenzy",
  "fresh",
  "friar",
  "friday",
  "fridge",
  "fried",
  "friend",
  "fright",
  "fringe",
  "frock",
  "frog",
  "from",
  "front",
  "frost",
  "frosty",
  "frown",
  "frozen",
  "frugal",
  "fruit",
  "fry",
  "fudge",
  "fuel",
  "full",
  "fully",
  "fumes",
  "fun",
  "fund",
  "funny",
  "fur",
  "furry",
  "fury",
  "fuse",
  "fusion",
  "fuss",
  "fussy",
  "futile",
  "future",
  "fuzzy",
  "gadget",
  "gain",
  "gala",
  "galaxy",
  "gale",
  "gall",
  "galley",
  "gallon",
  "gallop",
  "gamble",
  "game",
  "gamma",
  "gandhi",
  "gang",
  "gap",
  "garage",
  "garden",
  "garlic",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaunt",
  "gave",
  "gaze",
  "gear",
  "geese",
  "gem",
  "gemini",
  "gender",
  "gene",
  "geneva",
  "genial",
  "genius",
  "genre",
  "gentle",
  "gently",
  "gentry",
  "genus",
  "george",
  "germ",
  "get",
  "ghetto",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "gill",
  "gilt",
  "ginger",
  "girl",
  "give",
  "given",
  "glad",
  "glade",
  "glance",
  "gland",
  "glare",
  "glass",
  "glassy",
  "gleam",
  "glee",
  "glide",
  "global",
  "globe",
  "gloom",
  "gloomy",
  "gloria",
  "glory",
  "gloss",
  "glossy",
  "glove",
  "glow",
  "glue",
  "gnat",
  "gnu",
  "goal",
  "goat",
  "gold",
  "golden",
  "golf",
  "gone",
  "gong",
  "goo",
  "good",
  "goose",
  "gore",
  "gorge",
  "gory",
  "gosh",
  "gospel",
  "gossip",
  "got",
  "gothic",
  "govern",
  "gown",
  "grab",
  "grace",
  "grade",
  "grail",
  "grain",
  "grand",
  "grant",
  "grape",
  "graph",
  "grasp",
  "grass",
  "grassy",
  "grate",
  "grave",
  "gravel",
  "gravy",
  "grease",
  "greasy",
  "great",
  "greece",
  "greed",
  "greedy",
  "greek",
  "green",
  "greet",
  "grew",
  "grey",
  "grid",
  "grief",
  "grill",
  "grim",
  "grin",
  "grind",
  "grip",
  "grit",
  "gritty",
  "groan",
  "groin",
  "groom",
  "groove",
  "gross",
  "ground",
  "group",
  "grove",
  "grow",
  "grown",
  "growth",
  "grudge",
  "grunt",
  "guard",
  "guess",
  "guest",
  "guide",
  "guild",
  "guilt",
  "guilty",
  "guise",
  "guitar",
  "gulf",
  "gully",
  "gun",
  "gunman",
  "guru",
  "gut",
  "guy",
  "gypsy",
  "habit",
  "hack",
  "had",
  "hail",
  "hair",
  "hairy",
  "haiti",
  "hale",
  "half",
  "hall",
  "halt",
  "hamlet",
  "hammer",
  "hand",
  "handle",
  "handy",
  "hang",
  "hangar",
  "hanoi",
  "happen",
  "happy",
  "harass",
  "harbor",
  "hard",
  "harder",
  "hardly",
  "hare",
  "harem",
  "harm",
  "harp",
  "harry",
  "harsh",
  "has",
  "hash",
  "hassle",
  "haste",
  "hasten",
  "hasty",
  "hat",
  "hatch",
  "hate",
  "haul",
  "haunt",
  "havana",
  "have",
  "haven",
  "havoc",
  "hawaii",
  "hawk",
  "hay",
  "hazard",
  "haze",
  "hazel",
  "hazy",
  "head",
  "heal",
  "health",
  "heap",
  "hear",
  "heard",
  "heart",
  "hearth",
  "hearty",
  "heat",
  "heater",
  "heaven",
  "heavy",
  "hebrew",
  "heck",
  "hectic",
  "hedge",
  "heel",
  "hefty",
  "height",
  "heir",
  "held",
  "helium",
  "helix",
  "hell",
  "hello",
  "helm",
  "helmet",
  "help",
  "hemp",
  "hence",
  "henry",
  "her",
  "herald",
  "herb",
  "herd",
  "here",
  "hereby",
  "hermes",
  "hernia",
  "hero",
  "heroic",
  "heroin",
  "hey",
  "heyday",
  "hick",
  "hidden",
  "hide",
  "high",
  "higher",
  "highly",
  "hill",
  "him",
  "hind",
  "hinder",
  "hint",
  "hippie",
  "hire",
  "his",
  "hiss",
  "hit",
  "hive",
  "hoard",
  "hoarse",
  "hobby",
  "hockey",
  "hold",
  "holder",
  "hole",
  "hollow",
  "holly",
  "holy",
  "home",
  "honest",
  "honey",
  "hood",
  "hook",
  "hope",
  "horn",
  "horrid",
  "horror",
  "horse",
  "hose",
  "host",
  "hot",
  "hotel",
  "hound",
  "hour",
  "house",
  "hover",
  "how",
  "huge",
  "hull",
  "human",
  "humane",
  "humble",
  "humid",
  "hung",
  "hunger",
  "hungry",
  "hunt",
  "hurdle",
  "hurl",
  "hurry",
  "hurt",
  "hush",
  "hut",
  "hybrid",
  "hymn",
  "hyphen",
  "ice",
  "icing",
  "icon",
  "idaho",
  "idea",
  "ideal",
  "idiom",
  "idiot",
  "idle",
  "idly",
  "idol",
  "ignite",
  "ignore",
  "ill",
  "image",
  "immune",
  "impact",
  "imply",
  "import",
  "impose",
  "inca",
  "incest",
  "inch",
  "income",
  "incur",
  "indeed",
  "index",
  "india",
  "indian",
  "indoor",
  "induce",
  "inept",
  "inert",
  "infant",
  "infect",
  "infer",
  "influx",
  "inform",
  "inject",
  "injure",
  "injury",
  "ink",
  "inlaid",
  "inland",
  "inlet",
  "inmate",
  "inn",
  "innate",
  "inner",
  "input",
  "insane",
  "insect",
  "insert",
  "inset",
  "inside",
  "insist",
  "insult",
  "insure",
  "intact",
  "intake",
  "intend",
  "inter",
  "into",
  "invade",
  "invent",
  "invest",
  "invite",
  "invoke",
  "inward",
  "iowa",
  "iran",
  "iraq",
  "irish",
  "iron",
  "ironic",
  "irony",
  "isaac",
  "isabel",
  "island",
  "isle",
  "israel",
  "issue",
  "italy",
  "itch",
  "item",
  "itself",
  "ivan",
  "ivory",
  "jack",
  "jacket",
  "jacob",
  "jade",
  "jaguar",
  "jail",
  "james",
  "jane",
  "japan",
  "jargon",
  "java",
  "jaw",
  "jazz",
  "jeep",
  "jelly",
  "jerky",
  "jest",
  "jet",
  "jewel",
  "jewish",
  "jim",
  "job",
  "jock",
  "jockey",
  "joe",
  "john",
  "join",
  "joint",
  "joke",
  "jolly",
  "jolt",
  "jordan",
  "joseph",
  "joy",
  "joyful",
  "joyous",
  "judge",
  "judy",
  "juice",
  "juicy",
  "july",
  "jumble",
  "jumbo",
  "jump",
  "june",
  "jungle",
  "junior",
  "junk",
  "junta",
  "jury",
  "just",
  "kansas",
  "karate",
  "karl",
  "keel",
  "keen",
  "keep",
  "keeper",
  "kenya",
  "kept",
  "kernel",
  "kettle",
  "key",
  "khaki",
  "kick",
  "kid",
  "kidnap",
  "kidney",
  "kill",
  "killer",
  "kin",
  "kind",
  "kindly",
  "king",
  "kiss",
  "kite",
  "kitten",
  "knack",
  "knee",
  "kneel",
  "knew",
  "knife",
  "knight",
  "knit",
  "knob",
  "knock",
  "knot",
  "know",
  "known",
  "koran",
  "korea",
  "kuwait",
  "label",
  "lace",
  "lack",
  "lad",
  "ladder",
  "laden",
  "lady",
  "lagoon",
  "laity",
  "lake",
  "lamb",
  "lame",
  "lamp",
  "lance",
  "land",
  "lane",
  "lap",
  "lapse",
  "large",
  "larval",
  "laser",
  "last",
  "latch",
  "late",
  "lately",
  "latent",
  "later",
  "latest",
  "latin",
  "latter",
  "laugh",
  "launch",
  "lava",
  "lavish",
  "law",
  "lawful",
  "lawn",
  "lawyer",
  "lay",
  "layer",
  "layman",
  "lazy",
  "lead",
  "leader",
  "leaf",
  "leafy",
  "league",
  "leak",
  "leaky",
  "lean",
  "leap",
  "learn",
  "lease",
  "leash",
  "least",
  "leave",
  "led",
  "ledge",
  "left",
  "leg",
  "legacy",
  "legal",
  "legend",
  "legion",
  "lemon",
  "lend",
  "length",
  "lens",
  "lent",
  "leo",
  "leper",
  "lesion",
  "less",
  "lessen",
  "lesser",
  "lesson",
  "lest",
  "let",
  "lethal",
  "letter",
  "level",
  "lever",
  "levy",
  "lewis",
  "liable",
  "liar",
  "libel",
  "libya",
  "lice",
  "lick",
  "lid",
  "lie",
  "lied",
  "lier",
  "life",
  "lift",
  "light",
  "like",
  "likely",
  "limb",
  "lime",
  "limit",
  "limp",
  "line",
  "linear",
  "linen",
  "linger",
  "link",
  "lint",
  "lion",
  "lip",
  "liquid",
  "liquor",
  "list",
  "listen",
  "lit",
  "live",
  "lively",
  "liver",
  "liz",
  "lizard",
  "load",
  "loaf",
  "loan",
  "lobby",
  "lobe",
  "local",
  "locate",
  "lock",
  "locus",
  "lodge",
  "loft",
  "lofty",
  "log",
  "logic",
  "logo",
  "london",
  "lone",
  "lonely",
  "long",
  "longer",
  "look",
  "loop",
  "loose",
  "loosen",
  "loot",
  "lord",
  "lorry",
  "lose",
  "loss",
  "lost",
  "lot",
  "lotion",
  "lotus",
  "loud",
  "loudly",
  "lounge",
  "lousy",
  "love",
  "lovely",
  "lover",
  "low",
  "lower",
  "lowest",
  "loyal",
  "lucid",
  "luck",
  "lucky",
  "lucy",
  "lull",
  "lump",
  "lumpy",
  "lunacy",
  "lunar",
  "lunch",
  "lung",
  "lure",
  "lurid",
  "lush",
  "lust",
  "lute",
  "luther",
  "luxury",
  "lying",
  "lymph",
  "lynch",
  "lyric",
  "macho",
  "macro",
  "mad",
  "madam",
  "made",
  "mafia",
  "magic",
  "magma",
  "magnet",
  "magnum",
  "magpie",
  "maid",
  "maiden",
  "mail",
  "main",
  "mainly",
  "major",
  "make",
  "maker",
  "male",
  "malice",
  "mall",
  "malt",
  "mammal",
  "manage",
  "mane",
  "mania",
  "manic",
  "manner",
  "manor",
  "mantle",
  "manual",
  "manure",
  "many",
  "map",
  "maple",
  "marble",
  "march",
  "mare",
  "margin",
  "maria",
  "marina",
  "mark",
  "market",
  "marry",
  "mars",
  "marsh",
  "martin",
  "martyr",
  "mary",
  "mask",
  "mason",
  "mass",
  "mast",
  "master",
  "mat",
  "match",
  "mate",
  "matrix",
  "matter",
  "mature",
  "maxim",
  "may",
  "maybe",
  "mayor",
  "maze",
  "mead",
  "meadow",
  "meal",
  "mean",
  "meant",
  "meat",
  "medal",
  "media",
  "median",
  "medic",
  "medium",
  "meet",
  "mellow",
  "melody",
  "melon",
  "melt",
  "member",
  "memo",
  "memory",
  "menace",
  "mend",
  "mental",
  "mentor",
  "menu",
  "mercy",
  "mere",
  "merely",
  "merge",
  "merger",
  "merit",
  "merry",
  "mesh",
  "mess",
  "messy",
  "met",
  "metal",
  "meter",
  "method",
  "methyl",
  "metric",
  "metro",
  "mexico",
  "miami",
  "mickey",
  "mid",
  "midday",
  "middle",
  "midst",
  "midway",
  "might",
  "mighty",
  "mild",
  "mildew",
  "mile",
  "milk",
  "milky",
  "mill",
  "mimic",
  "mince",
  "mind",
  "mine",
  "mini",
  "mink",
  "minor",
  "mint",
  "minus",
  "minute",
  "mire",
  "mirror",
  "mirth",
  "misery",
  "miss",
  "mist",
  "misty",
  "mite",
  "mix",
  "moan",
  "moat",
  "mob",
  "mobile",
  "mock",
  "mode",
  "model",
  "modem",
  "modern",
  "modest",
  "modify",
  "module",
  "moist",
  "molar",
  "mold",
  "mole",
  "molten",
  "moment",
  "monday",
  "money",
  "monk",
  "monkey",
  "month",
  "mood",
  "moody",
  "moon",
  "moor",
  "moral",
  "morale",
  "morbid",
  "more",
  "morgue",
  "mortal",
  "mortar",
  "mosaic",
  "moscow",
  "moses",
  "mosque",
  "moss",
  "most",
  "mostly",
  "moth",
  "mother",
  "motion",
  "motive",
  "motor",
  "mount",
  "mourn",
  "mouse",
  "mouth",
  "move",
  "movie",
  "mrs",
  "much",
  "muck",
  "mucus",
  "mud",
  "muddle",
  "muddy",
  "mule",
  "mummy",
  "munich",
  "murder",
  "murky",
  "murmur",
  "muscle",
  "museum",
  "music",
  "mussel",
  "must",
  "mutant",
  "mute",
  "mutiny",
  "mutter",
  "mutton",
  "mutual",
  "muzzle",
  "myopic",
  "myriad",
  "myself",
  "mystic",
  "myth",
  "nadir",
  "nail",
  "naked",
  "name",
  "namely",
  "nape",
  "napkin",
  "naples",
  "narrow",
  "nasal",
  "nasty",
  "nathan",
  "nation",
  "native",
  "nature",
  "nausea",
  "naval",
  "nave",
  "navy",
  "near",
  "nearer",
  "nearly",
  "neat",
  "neatly",
  "neck",
  "need",
  "needle",
  "needy",
  "negate",
  "neon",
  "nepal",
  "nephew",
  "nerve",
  "nest",
  "net",
  "neural",
  "never",
  "newly",
  "next",
  "nice",
  "nicely",
  "niche",
  "nickel",
  "niece",
  "night",
  "nile",
  "nimble",
  "nine",
  "ninety",
  "ninth",
  "nobel",
  "noble",
  "nobody",
  "node",
  "noise",
  "noisy",
  "none",
  "noon",
  "nor",
  "norm",
  "normal",
  "north",
  "norway",
  "nose",
  "nosy",
  "not",
  "note",
  "notice",
  "notify",
  "notion",
  "noun",
  "novel",
  "novice",
  "now",
  "nozzle",
  "null",
  "numb",
  "number",
  "nurse",
  "nut",
  "nylon",
  "nymph",
  "oak",
  "oar",
  "oasis",
  "oath",
  "obese",
  "obey",
  "object",
  "oblige",
  "oboe",
  "obtain",
  "obtuse",
  "occult",
  "occupy",
  "occur",
  "ocean",
  "octave",
  "odd",
  "off",
  "offend",
  "offer",
  "office",
  "offset",
  "often",
  "ohio",
  "oil",
  "oily",
  "okay",
  "old",
  "older",
  "oldest",
  "olive",
  "omega",
  "omen",
  "omit",
  "once",
  "one",
  "onion",
  "only",
  "onset",
  "onto",
  "onus",
  "onward",
  "opaque",
  "open",
  "openly",
  "opera",
  "opium",
  "oppose",
  "optic",
  "option",
  "oracle",
  "oral",
  "orange",
  "orbit",
  "orchid",
  "ordeal",
  "order",
  "organ",
  "orgasm",
  "orient",
  "origin",
  "ornate",
  "orphan",
  "oscar",
  "other",
  "otter",
  "ought",
  "ounce",
  "our",
  "out",
  "outer",
  "output",
  "outset",
  "oval",
  "oven",
  "over",
  "overt",
  "owe",
  "owing",
  "owl",
  "own",
  "owner",
  "oxford",
  "oxide",
  "oxygen",
  "oyster",
  "ozone",
  "pace",
  "pack",
  "packet",
  "pact",
  "pad",
  "paddle",
  "paddy",
  "pagan",
  "page",
  "paid",
  "pain",
  "paint",
  "pair",
  "palace",
  "pale",
  "palm",
  "pan",
  "panama",
  "panel",
  "panic",
  "papa",
  "papal",
  "paper",
  "parade",
  "parcel",
  "pardon",
  "parent",
  "paris",
  "parish",
  "park",
  "parody",
  "parrot",
  "part",
  "partly",
  "party",
  "pascal",
  "pass",
  "past",
  "paste",
  "pastel",
  "pastor",
  "pastry",
  "pat",
  "patch",
  "patent",
  "path",
  "patio",
  "patrol",
  "patron",
  "paul",
  "pause",
  "pave",
  "paw",
  "pawn",
  "pay",
  "peace",
  "peach",
  "peak",
  "pear",
  "pearl",
  "pedal",
  "peel",
  "peer",
  "peking",
  "pelvic",
  "pelvis",
  "pen",
  "penal",
  "pence",
  "pencil",
  "penny",
  "people",
  "pepper",
  "per",
  "perch",
  "peril",
  "period",
  "perish",
  "permit",
  "person",
  "peru",
  "pest",
  "pet",
  "peter",
  "petite",
  "petrol",
  "petty",
  "phase",
  "philip",
  "phone",
  "photo",
  "phrase",
  "piano",
  "pick",
  "picket",
  "picnic",
  "pie",
  "piece",
  "pier",
  "pierce",
  "piety",
  "pig",
  "pigeon",
  "piggy",
  "pike",
  "pile",
  "pill",
  "pillar",
  "pillow",
  "pilot",
  "pin",
  "pinch",
  "pine",
  "pink",
  "pint",
  "pious",
  "pipe",
  "pirate",
  "piss",
  "pistol",
  "piston",
  "pit",
  "pitch",
  "pity",
  "pivot",
  "pixel",
  "pizza",
  "place",
  "placid",
  "plague",
  "plain",
  "plan",
  "plane",
  "planet",
  "plank",
  "plant",
  "plasma",
  "plate",
  "play",
  "player",
  "plea",
  "plead",
  "please",
  "pledge",
  "plenty",
  "plight",
  "plot",
  "plough",
  "ploy",
  "plug",
  "plum",
  "plump",
  "plunge",
  "plural",
  "plus",
  "plush",
  "pocket",
  "poem",
  "poet",
  "poetic",
  "poetry",
  "point",
  "poison",
  "poland",
  "polar",
  "pole",
  "police",
  "policy",
  "polish",
  "polite",
  "poll",
  "pollen",
  "polo",
  "pond",
  "ponder",
  "pony",
  "pool",
  "poor",
  "poorly",
  "pop",
  "poppy",
  "pore",
  "pork",
  "port",
  "portal",
  "pose",
  "posh",
  "post",
  "postal",
  "pot",
  "potato",
  "potent",
  "pouch",
  "pound",
  "pour",
  "powder",
  "power",
  "praise",
  "pray",
  "prayer",
  "preach",
  "prefer",
  "prefix",
  "press",
  "pretty",
  "price",
  "pride",
  "priest",
  "primal",
  "prime",
  "prince",
  "print",
  "prior",
  "prism",
  "prison",
  "privy",
  "prize",
  "probe",
  "profit",
  "prompt",
  "prone",
  "proof",
  "propel",
  "proper",
  "prose",
  "proton",
  "proud",
  "prove",
  "proven",
  "proxy",
  "prune",
  "pry",
  "psalm",
  "pseudo",
  "psyche",
  "pub",
  "public",
  "puff",
  "pull",
  "pulp",
  "pulpit",
  "pulsar",
  "pulse",
  "pump",
  "punch",
  "punish",
  "punk",
  "pupil",
  "puppet",
  "puppy",
  "pure",
  "purely",
  "purge",
  "purify",
  "purple",
  "purse",
  "pursue",
  "push",
  "pushy",
  "put",
  "putt",
  "puzzle",
  "quaint",
  "quake",
  "quarry",
  "quart",
  "quartz",
  "quebec",
  "queen",
  "queer",
  "query",
  "quest",
  "queue",
  "quick",
  "quid",
  "quiet",
  "quilt",
  "quirk",
  "quit",
  "quite",
  "quiver",
  "quiz",
  "quota",
  "quote",
  "rabbit",
  "race",
  "racial",
  "racism",
  "rack",
  "racket",
  "radar",
  "radio",
  "radish",
  "radius",
  "raffle",
  "raft",
  "rage",
  "raid",
  "rail",
  "rain",
  "rainy",
  "raise",
  "rake",
  "rally",
  "ramp",
  "random",
  "range",
  "rank",
  "ransom",
  "rape",
  "rapid",
  "rare",
  "rarely",
  "rarity",
  "rash",
  "rat",
  "rate",
  "rather",
  "ratify",
  "ratio",
  "rattle",
  "rave",
  "raven",
  "raw",
  "ray",
  "razor",
  "reach",
  "react",
  "read",
  "reader",
  "ready",
  "real",
  "really",
  "realm",
  "reap",
  "rear",
  "reason",
  "rebel",
  "recall",
  "recent",
  "recess",
  "recipe",
  "reckon",
  "record",
  "recoup",
  "rector",
  "red",
  "redeem",
  "redo",
  "reduce",
  "reed",
  "reef",
  "reek",
  "refer",
  "reform",
  "refuge",
  "refuse",
  "regal",
  "regard",
  "regent",
  "regime",
  "region",
  "regret",
  "reign",
  "reject",
  "relate",
  "relax",
  "relay",
  "relic",
  "relief",
  "relish",
  "rely",
  "remain",
  "remark",
  "remedy",
  "remind",
  "remit",
  "remote",
  "remove",
  "renal",
  "render",
  "rent",
  "rental",
  "repair",
  "repeal",
  "repeat",
  "repent",
  "reply",
  "report",
  "rescue",
  "resent",
  "reside",
  "resign",
  "resin",
  "resist",
  "resort",
  "rest",
  "result",
  "resume",
  "retail",
  "retain",
  "retina",
  "retire",
  "return",
  "reveal",
  "review",
  "revise",
  "revive",
  "revolt",
  "reward",
  "rex",
  "rhine",
  "rhino",
  "rhyme",
  "rhythm",
  "ribbon",
  "rice",
  "rich",
  "rick",
  "rid",
  "ride",
  "rider",
  "ridge",
  "rife",
  "rifle",
  "rift",
  "right",
  "rigid",
  "rile",
  "rim",
  "ring",
  "rinse",
  "riot",
  "ripe",
  "ripen",
  "ripple",
  "rise",
  "risk",
  "risky",
  "rite",
  "ritual",
  "ritz",
  "rival",
  "river",
  "road",
  "roar",
  "roast",
  "rob",
  "robe",
  "robert",
  "robin",
  "robot",
  "robust",
  "rock",
  "rocket",
  "rocky",
  "rod",
  "rode",
  "rodent",
  "rogue",
  "role",
  "roll",
  "roman",
  "rome",
  "roof",
  "room",
  "root",
  "rope",
  "rose",
  "rosy",
  "rot",
  "rotate",
  "rotor",
  "rotten",
  "rouge",
  "rough",
  "round",
  "route",
  "rover",
  "row",
  "royal",
  "rub",
  "rubber",
  "rubble",
  "ruby",
  "rudder",
  "rude",
  "rug",
  "rugby",
  "ruin",
  "rule",
  "ruler",
  "rumble",
  "rump",
  "run",
  "rune",
  "rung",
  "runway",
  "rural",
  "rush",
  "russia",
  "rust",
  "rustic",
  "rusty",
  "sack",
  "sacred",
  "sad",
  "saddle",
  "sadism",
  "sadly",
  "safari",
  "safe",
  "safely",
  "safer",
  "safety",
  "saga",
  "sage",
  "sahara",
  "said",
  "sail",
  "sailor",
  "saint",
  "sake",
  "salad",
  "salary",
  "sale",
  "saline",
  "saliva",
  "salmon",
  "saloon",
  "salt",
  "salty",
  "salute",
  "sam",
  "same",
  "sample",
  "sand",
  "sandy",
  "sane",
  "sash",
  "satin",
  "satire",
  "saturn",
  "sauce",
  "saucer",
  "saudi",
  "sauna",
  "savage",
  "save",
  "saw",
  "say",
  "scale",
  "scalp",
  "scan",
  "scant",
  "scar",
  "scarce",
  "scare",
  "scarf",
  "scary",
  "scene",
  "scenic",
  "scent",
  "school",
  "scold",
  "scope",
  "score",
  "scorn",
  "scotch",
  "scott",
  "scout",
  "scrap",
  "scrape",
  "scream",
  "screen",
  "screw",
  "script",
  "scroll",
  "scrub",
  "scum",
  "sea",
  "seal",
  "seam",
  "seaman",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "sect",
  "sector",
  "secure",
  "see",
  "seed",
  "seeing",
  "seek",
  "seem",
  "seize",
  "seldom",
  "select",
  "self",
  "sell",
  "seller",
  "semi",
  "senate",
  "send",
  "senile",
  "senior",
  "sense",
  "sensor",
  "sent",
  "sentry",
  "seoul",
  "sequel",
  "serene",
  "serial",
  "series",
  "sermon",
  "serum",
  "serve",
  "server",
  "set",
  "settle",
  "seven",
  "severe",
  "sew",
  "sewage",
  "shabby",
  "shade",
  "shadow",
  "shady",
  "shaft",
  "shaggy",
  "shah",
  "shake",
  "shaky",
  "shall",
  "sham",
  "shame",
  "shape",
  "share",
  "shark",
  "sharp",
  "shawl",
  "she",
  "shear",
  "sheen",
  "sheep",
  "sheer",
  "sheet",
  "shelf",
  "shell",
  "sherry",
  "shield",
  "shift",
  "shine",
  "shiny",
  "ship",
  "shire",
  "shirk",
  "shirt",
  "shiver",
  "shock",
  "shoe",
  "shook",
  "shoot",
  "shop",
  "shore",
  "short",
  "shot",
  "should",
  "shout",
  "show",
  "shower",
  "shrank",
  "shrewd",
  "shrill",
  "shrimp",
  "shrine",
  "shrink",
  "shrub",
  "shrug",
  "shut",
  "shy",
  "shyly",
  "sick",
  "side",
  "siege",
  "sigh",
  "sight",
  "sigma",
  "sign",
  "signal",
  "silent",
  "silk",
  "silken",
  "silky",
  "sill",
  "silly",
  "silo",
  "silver",
  "simple",
  "simply",
  "since",
  "sinful",
  "sing",
  "singer",
  "single",
  "sink",
  "sir",
  "sire",
  "siren",
  "sister",
  "sit",
  "site",
  "sitter",
  "six",
  "sixth",
  "sixty",
  "size",
  "sketch",
  "skill",
  "skin",
  "skinny",
  "skip",
  "skirt",
  "skull",
  "sky",
  "slab",
  "slack",
  "slain",
  "slam",
  "slang",
  "slap",
  "slat",
  "slate",
  "slave",
  "sleek",
  "sleep",
  "sleepy",
  "sleeve",
  "slice",
  "slick",
  "slid",
  "slide",
  "slight",
  "slim",
  "slimy",
  "sling",
  "slip",
  "slit",
  "slogan",
  "slope",
  "sloppy",
  "slot",
  "slow",
  "slowly",
  "slug",
  "slum",
  "slump",
  "smack",
  "small",
  "smart",
  "smash",
  "smear",
  "smell",
  "smelly",
  "smelt",
  "smile",
  "smite",
  "smoke",
  "smoky",
  "smooth",
  "smug",
  "snack",
  "snail",
  "snake",
  "snap",
  "snatch",
  "sneak",
  "snow",
  "snowy",
  "snug",
  "soak",
  "soap",
  "sober",
  "soccer",
  "social",
  "sock",
  "socket",
  "socks",
  "soda",
  "sodden",
  "sodium",
  "sofa",
  "soft",
  "soften",
  "softly",
  "soggy",
  "soil",
  "solar",
  "sold",
  "sole",
  "solely",
  "solemn",
  "solid",
  "solo",
  "solve",
  "some",
  "son",
  "sonar",
  "sonata",
  "song",
  "sonic",
  "sony",
  "soon",
  "sooner",
  "soot",
  "soothe",
  "sordid",
  "sore",
  "sorrow",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "sour",
  "source",
  "soviet",
  "sow",
  "space",
  "spade",
  "spain",
  "span",
  "spare",
  "spark",
  "sparse",
  "spasm",
  "spat",
  "spate",
  "speak",
  "spear",
  "speech",
  "speed",
  "speedy",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spicy",
  "spider",
  "spiky",
  "spill",
  "spin",
  "spinal",
  "spine",
  "spiral",
  "spirit",
  "spit",
  "spite",
  "splash",
  "split",
  "spoil",
  "spoke",
  "sponge",
  "spoon",
  "sport",
  "spot",
  "spouse",
  "spray",
  "spread",
  "spree",
  "spring",
  "sprint",
  "spur",
  "squad",
  "square",
  "squash",
  "squat",
  "squid",
  "stab",
  "stable",
  "stack",
  "staff",
  "stage",
  "stain",
  "stair",
  "stairs",
  "stake",
  "stale",
  "stall",
  "stamp",
  "stance",
  "stand",
  "staple",
  "star",
  "starch",
  "stare",
  "stark",
  "start",
  "starve",
  "state",
  "static",
  "statue",
  "status",
  "stay",
  "stead",
  "steady",
  "steak",
  "steal",
  "steam",
  "steel",
  "steep",
  "steer",
  "stem",
  "stench",
  "step",
  "stereo",
  "stern",
  "stew",
  "stick",
  "sticky",
  "stiff",
  "stifle",
  "stigma",
  "still",
  "sting",
  "stint",
  "stir",
  "stitch",
  "stock",
  "stocky",
  "stone",
  "stony",
  "stool",
  "stop",
  "store",
  "storm",
  "stormy",
  "story",
  "stout",
  "stove",
  "stow",
  "strain",
  "strait",
  "strand",
  "strap",
  "strata",
  "straw",
  "stray",
  "streak",
  "stream",
  "street",
  "stress",
  "strict",
  "stride",
  "strife",
  "strike",
  "string",
  "strip",
  "stripe",
  "strive",
  "stroke",
  "stroll",
  "strong",
  "stud",
  "studio",
  "study",
  "stuff",
  "stuffy",
  "stunt",
  "stupid",
  "sturdy",
  "style",
  "submit",
  "subtle",
  "subtly",
  "suburb",
  "such",
  "sudden",
  "sue",
  "suez",
  "suffer",
  "sugar",
  "suit",
  "suite",
  "suitor",
  "sullen",
  "sultan",
  "sum",
  "summer",
  "summit",
  "summon",
  "sun",
  "sunday",
  "sunny",
  "sunset",
  "super",
  "superb",
  "supper",
  "supple",
  "supply",
  "sure",
  "surely",
  "surf",
  "surge",
  "survey",
  "suture",
  "swamp",
  "swan",
  "swap",
  "swarm",
  "sway",
  "swear",
  "sweat",
  "sweaty",
  "sweden",
  "sweep",
  "sweet",
  "swell",
  "swift",
  "swim",
  "swine",
  "swing",
  "swirl",
  "swiss",
  "switch",
  "sword",
  "swore",
  "sydney",
  "symbol",
  "synod",
  "syntax",
  "syria",
  "syrup",
  "system",
  "table",
  "tablet",
  "taboo",
  "tacit",
  "tackle",
  "tact",
  "tactic",
  "tail",
  "tailor",
  "taiwan",
  "take",
  "tale",
  "talent",
  "talk",
  "tall",
  "tally",
  "tame",
  "tampa",
  "tan",
  "tandem",
  "tangle",
  "tank",
  "tap",
  "tape",
  "target",
  "tariff",
  "tarp",
  "tart",
  "tarzan",
  "task",
  "taste",
  "tasty",
  "tattoo",
  "taurus",
  "taut",
  "tavern",
  "tax",
  "taxi",
  "tea",
  "teach",
  "teak",
  "team",
  "tear",
  "tease",
  "tech",
  "teeth",
  "tell",
  "temper",
  "temple",
  "tempo",
  "tempt",
  "ten",
  "tenant",
  "tend",
  "tender",
  "tendon",
  "tennis",
  "tenor",
  "tense",
  "tent",
  "tenth",
  "tenure",
  "teresa",
  "term",
  "terror",
  "terse",
  "test",
  "texas",
  "text",
  "thank",
  "thaw",
  "them",
  "theme",
  "thence",
  "theory",
  "there",
  "these",
  "thesis",
  "they",
  "thick",
  "thief",
  "thigh",
  "thin",
  "thing",
  "think",
  "third",
  "thirst",
  "thirty",
  "this",
  "thomas",
  "thorn",
  "those",
  "though",
  "thread",
  "threat",
  "three",
  "thrill",
  "thrive",
  "throat",
  "throne",
  "throng",
  "throw",
  "thrust",
  "thud",
  "thug",
  "thumb",
  "thus",
  "thyme",
  "tibet",
  "tick",
  "ticket",
  "tidal",
  "tide",
  "tidy",
  "tie",
  "tier",
  "tiger",
  "tight",
  "tile",
  "till",
  "tilt",
  "timber",
  "time",
  "timid",
  "tin",
  "tiny",
  "tip",
  "tire",
  "tissue",
  "title",
  "toad",
  "toast",
  "today",
  "toe",
  "toilet",
  "token",
  "tokyo",
  "told",
  "toll",
  "tom",
  "tomato",
  "tomb",
  "tonal",
  "tone",
  "tongue",
  "tonic",
  "too",
  "took",
  "tool",
  "tooth",
  "top",
  "topaz",
  "topic",
  "torch",
  "torque",
  "torso",
  "tort",
  "toss",
  "total",
  "touch",
  "tough",
  "tour",
  "toward",
  "towel",
  "tower",
  "town",
  "toxic",
  "toxin",
  "toy",
  "trace",
  "track",
  "tract",
  "trade",
  "tragic",
  "trail",
  "train",
  "trait",
  "tram",
  "trance",
  "trap",
  "trauma",
  "travel",
  "tray",
  "tread",
  "treat",
  "treaty",
  "treble",
  "tree",
  "trek",
  "tremor",
  "trench",
  "trend",
  "trendy",
  "trial",
  "tribal",
  "tribe",
  "trick",
  "tricky",
  "tried",
  "trifle",
  "trim",
  "trio",
  "trip",
  "triple",
  "troop",
  "trophy",
  "trot",
  "trough",
  "trout",
  "truce",
  "truck",
  "true",
  "truly",
  "trunk",
  "trust",
  "truth",
  "try",
  "tube",
  "tumble",
  "tuna",
  "tundra",
  "tune",
  "tunic",
  "tunnel",
  "turban",
  "turf",
  "turk",
  "turkey",
  "turn",
  "turtle",
  "tutor",
  "tweed",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "tycoon",
  "tying",
  "type",
  "tyrant",
  "ugly",
  "ulcer",
  "ultra",
  "umpire",
  "unable",
  "uncle",
  "under",
  "uneasy",
  "unfair",
  "unify",
  "union",
  "unique",
  "unit",
  "unite",
  "unity",
  "unlike",
  "unrest",
  "unruly",
  "until",
  "update",
  "upheld",
  "uphill",
  "uphold",
  "upon",
  "upper",
  "uproar",
  "upset",
  "upshot",
  "uptake",
  "upturn",
  "upward",
  "urban",
  "urge",
  "urgent",
  "urging",
  "urine",
  "usable",
  "usage",
  "use",
  "useful",
  "user",
  "usual",
  "utmost",
  "utter",
  "vacant",
  "vacuum",
  "vague",
  "vain",
  "valet",
  "valid",
  "valley",
  "value",
  "valve",
  "van",
  "vanish",
  "vanity",
  "vary",
  "vase",
  "vast",
  "vat",
  "vault",
  "vector",
  "veil",
  "vein",
  "velvet",
  "vendor",
  "veneer",
  "venice",
  "venom",
  "vent",
  "venue",
  "venus",
  "verb",
  "verbal",
  "verge",
  "verify",
  "verity",
  "verse",
  "versus",
  "very",
  "vessel",
  "vest",
  "vet",
  "veto",
  "via",
  "viable",
  "vicar",
  "vice",
  "victim",
  "victor",
  "video",
  "vienna",
  "view",
  "vigil",
  "viking",
  "vile",
  "villa",
  "vine",
  "vinyl",
  "viola",
  "violet",
  "violin",
  "viral",
  "virgo",
  "virtue",
  "virus",
  "visa",
  "vision",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "vodka",
  "vogue",
  "voice",
  "void",
  "volley",
  "volume",
  "vote",
  "vowel",
  "voyage",
  "vulgar",
  "wade",
  "wage",
  "waist",
  "wait",
  "waiter",
  "wake",
  "walk",
  "walker",
  "wall",
  "wallet",
  "walnut",
  "wander",
  "want",
  "war",
  "warden",
  "warm",
  "warmth",
  "warn",
  "warp",
  "warsaw",
  "wary",
  "was",
  "wash",
  "wasp",
  "waste",
  "watch",
  "water",
  "watery",
  "wave",
  "wax",
  "way",
  "weak",
  "weaken",
  "wealth",
  "weapon",
  "wear",
  "weary",
  "weave",
  "wedge",
  "wee",
  "weed",
  "week",
  "weekly",
  "weep",
  "weigh",
  "weight",
  "weird",
  "well",
  "were",
  "west",
  "wet",
  "whale",
  "wharf",
  "what",
  "wheat",
  "wheel",
  "when",
  "whence",
  "where",
  "which",
  "whiff",
  "while",
  "whim",
  "whip",
  "whisky",
  "white",
  "who",
  "whole",
  "wholly",
  "whom",
  "whose",
  "why",
  "wicked",
  "wide",
  "widely",
  "widen",
  "wider",
  "widow",
  "width",
  "wife",
  "wig",
  "wild",
  "wildly",
  "will",
  "willow",
  "wily",
  "win",
  "wind",
  "window",
  "windy",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wipe",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "wit",
  "witch",
  "with",
  "within",
  "witty",
  "wizard",
  "woke",
  "wolf",
  "wolves",
  "woman",
  "womb",
  "won",
  "wonder",
  "wood",
  "wooden",
  "woods",
  "woody",
  "wool",
  "word",
  "work",
  "worker",
  "world",
  "worm",
  "worry",
  "worse",
  "worst",
  "worth",
  "worthy",
  "would",
  "wound",
  "wrap",
  "wrath",
  "wreath",
  "wreck",
  "wring",
  "wrist",
  "writ",
  "write",
  "writer",
  "wrong",
  "xerox",
  "yacht",
  "yale",
  "yard",
  "yarn",
  "yeah",
  "year",
  "yeard",
  "yeast",
  "yellow",
  "yet",
  "yield",
  "yogurt",
  "yolk",
  "you",
  "young",
  "your",
  "youth",
  "zaire",
  "zeal",
  "zebra",
  "zenith",
  "zero",
  "zeus",
  "zigzag",
  "zinc",
  "zombie",
  "zone"
];

// node_modules/@hashgraph/cryptography/src/words/bip39.js
var bip39_default = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];

// node_modules/@hashgraph/cryptography/src/Mnemonic.js
var import_tweetnacl4 = __toESM(require_nacl_fast(), 1);

// node_modules/@hashgraph/cryptography/src/primitive/sha256.browser.js
async function digest(data) {
  return new Uint8Array(await crypto.subtle.digest("SHA-256", data));
}

// node_modules/@hashgraph/cryptography/src/primitive/bip39.js
async function toSeed(words, passphrase) {
  const input = words.join(" ");
  const salt = `mnemonic${passphrase}`.normalize("NFKD");
  return deriveKey(HashAlgorithm.Sha512, input, salt, 2048, 64);
}

// node_modules/@hashgraph/cryptography/src/util/entropy.js
function legacy1(words, wordlist) {
  const indicies = words.map((word) => wordlist.indexOf(word.toLowerCase()));
  const data = convertRadix(indicies, wordlist.length, 256, 33);
  const checksum = data[data.length - 1];
  const result = new Uint8Array(data.length - 1);
  for (let i17 = 0; i17 < data.length - 1; i17 += 1) {
    result[i17] = data[i17] ^ checksum;
  }
  return [result, checksum];
}
async function legacy2(words, wordlist) {
  const concatBitsLen = words.length * 11;
  const concatBits = [];
  concatBits.fill(false, 0, concatBitsLen);
  for (const [wordIndex, word] of words.entries()) {
    const index = wordlist.indexOf(word.toLowerCase());
    if (index < 0) {
      throw new Error(`Word not found in wordlist: ${word}`);
    }
    for (let i17 = 0; i17 < 11; i17 += 1) {
      concatBits[wordIndex * 11 + i17] = (index & 1 << 10 - i17) !== 0;
    }
  }
  const checksumBitsLen = concatBitsLen / 33;
  const entropyBitsLen = concatBitsLen - checksumBitsLen;
  const entropy = new Uint8Array(entropyBitsLen / 8);
  for (let i17 = 0; i17 < entropy.length; i17 += 1) {
    for (let j2 = 0; j2 < 8; j2 += 1) {
      if (concatBits[i17 * 8 + j2]) {
        entropy[i17] |= 1 << 7 - j2;
      }
    }
  }
  const hash2 = await digest(entropy);
  const hashBits = bytesToBits(hash2);
  for (let i17 = 0; i17 < checksumBitsLen; i17 += 1) {
    if (concatBits[entropyBitsLen + i17] !== hashBits[i17]) {
      throw new Error("Checksum mismatch");
    }
  }
  return entropy;
}
function crc8(data) {
  let crc = 255;
  for (let i17 = 0; i17 < data.length - 1; i17 += 1) {
    crc ^= data[i17];
    for (let j2 = 0; j2 < 8; j2 += 1) {
      crc = crc >>> 1 ^ ((crc & 1) === 0 ? 0 : 178);
    }
  }
  return crc ^ 255;
}
function convertRadix(nums, fromRadix, toRadix, toLength) {
  let num2 = new bignumber_default(0);
  for (const element of nums) {
    num2 = num2.times(fromRadix);
    num2 = num2.plus(element);
  }
  const result = new Uint8Array(toLength);
  for (let i17 = toLength - 1; i17 >= 0; i17 -= 1) {
    const tem = num2.dividedToIntegerBy(toRadix);
    const rem = num2.modulo(toRadix);
    num2 = tem;
    result[i17] = rem.toNumber();
  }
  return result;
}
function bytesToBits(data) {
  const bits = [];
  bits.fill(false, 0, data.length * 8);
  for (let i17 = 0; i17 < data.length; i17 += 1) {
    for (let j2 = 0; j2 < 8; j2 += 1) {
      bits[i17 * 8 + j2] = (data[i17] & 1 << 7 - j2) !== 0;
    }
  }
  return bits;
}

// node_modules/@hashgraph/cryptography/src/Mnemonic.js
var ED25519_SEED_TEXT = "ed25519 seed";
var ECDSA_SEED_TEXT = "Bitcoin seed";
var HARDENED = 2147483648;
var HEDERA_PATH = [44, 3030, 0, 0];
var SLIP44_ECDSA_HEDERA_PATH = [
  44 | HARDENED,
  3030 | HARDENED,
  0 | HARDENED,
  0
];
var SLIP44_ECDSA_ETH_PATH = [
  44 | HARDENED,
  60 | HARDENED,
  0 | HARDENED,
  0,
  0
];
var Mnemonic = class _Mnemonic {
  /**
   * @param {object} props
   * @param {string[]} props.words
   * @throws {BadMnemonicError}
   * @hideconstructor
   * @private
   */
  constructor({ words }) {
    this.words = words;
  }
  /**
   * Returns a new random 24-word mnemonic from the BIP-39
   * standard English word list.
   * @returns {Promise<Mnemonic>}
   */
  static generate() {
    return _Mnemonic._generate(24);
  }
  /**
   * Returns a new random 12-word mnemonic from the BIP-39
   * standard English word list.
   * @returns {Promise<Mnemonic>}
   */
  static generate12() {
    return _Mnemonic._generate(12);
  }
  /**
   * @param {number} length
   * @returns {Promise<Mnemonic>}
   */
  static async _generate(length) {
    let neededEntropy;
    if (length === 12) neededEntropy = 16;
    else if (length === 24) neededEntropy = 32;
    else {
      throw new Error(
        `unsupported phrase length ${length}, only 12 or 24 are supported`
      );
    }
    const seed = await bytesAsync(neededEntropy);
    const entropyBits = bytesToBinary(Array.from(seed));
    const checksumBits = await deriveChecksumBits(seed);
    const bits = entropyBits + checksumBits;
    const chunks = bits.match(/(.{1,11})/g);
    const words = (chunks != null ? chunks : []).map(
      (binary) => bip39_default[binaryToByte(binary)]
    );
    return new _Mnemonic({ words });
  }
  /**
   * Construct a mnemonic from a list of words. Handles 12, 22 (legacy), and 24 words.
   *
   * An exception of BadMnemonicError will be thrown if the mnemonic
   * contains unknown words or fails the checksum. An invalid mnemonic
   * can still be used to create private keys, the exception will
   * contain the failing mnemonic in case you wish to ignore the
   * validation error and continue.
   * @param {string[]} words
   * @throws {BadMnemonicError}
   * @returns {Promise<Mnemonic>}
   */
  static fromWords(words) {
    return new _Mnemonic({
      words
    })._validate();
  }
  /**
   * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
   * Recover a private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @returns {Promise<PrivateKey>}
   */
  toPrivateKey(passphrase = "") {
    return this.toEd25519PrivateKey(passphrase);
  }
  /**
   * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
   * Recover an Ed25519 private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number[]} [path]
   * @returns {Promise<PrivateKey>}
   */
  async toEd25519PrivateKey(passphrase = "", path = HEDERA_PATH) {
    let { keyData, chainCode } = await this._toKeyData(
      passphrase,
      ED25519_SEED_TEXT
    );
    for (const index of path) {
      ({ keyData, chainCode } = await derive2(
        keyData,
        chainCode,
        index
      ));
    }
    const keyPair = import_tweetnacl4.default.sign.keyPair.fromSeed(keyData);
    if (Cache_default.privateKeyConstructor == null) {
      throw new Error("PrivateKey not found in cache");
    }
    return Cache_default.privateKeyConstructor(
      new Ed25519PrivateKey(keyPair, chainCode)
    );
  }
  /**
   * Recover an Ed25519 private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number} [index]
   * @returns {Promise<PrivateKey>}
   */
  async toStandardEd25519PrivateKey(passphrase = "", index) {
    const seed = await _Mnemonic.toSeed(this.words, passphrase);
    let derivedKey = await PrivateKey.fromSeedED25519(seed);
    index = index == null ? 0 : index;
    for (const currentIndex of [44, 3030, 0, 0, index]) {
      derivedKey = await derivedKey.derive(currentIndex);
    }
    return derivedKey;
  }
  /**
   * @deprecated - Use `toStandardEd25519PrivateKey()` or `toStandardECDSAsecp256k1PrivateKey()` instead
   * Recover an ECDSA private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number[]} [path]
   * @returns {Promise<PrivateKey>}
   */
  async toEcdsaPrivateKey(passphrase = "", path = HEDERA_PATH) {
    let { keyData, chainCode } = await this._toKeyData(
      passphrase,
      ECDSA_SEED_TEXT
    );
    for (const index of path) {
      ({ keyData, chainCode } = await derive(
        keyData,
        chainCode,
        index
      ));
    }
    if (Cache_default.privateKeyConstructor == null) {
      throw new Error("PrivateKey not found in cache");
    }
    return Cache_default.privateKeyConstructor(
      new EcdsaPrivateKey(fromBytes2(keyData), chainCode)
    );
  }
  /**
   * Recover an ECDSA private key from this mnemonic phrase, with an
   * optional passphrase.
   * @param {string} [passphrase]
   * @param {number} [index]
   * @returns {Promise<PrivateKey>}
   */
  async toStandardECDSAsecp256k1PrivateKey(passphrase = "", index) {
    const seed = await _Mnemonic.toSeed(this.words, passphrase);
    let derivedKey = await PrivateKey.fromSeedECDSAsecp256k1(seed);
    index = index == null ? 0 : index;
    for (const currentIndex of [
      toHardenedIndex(44),
      toHardenedIndex(3030),
      toHardenedIndex(0),
      0,
      index
    ]) {
      derivedKey = await derivedKey.derive(currentIndex);
    }
    return derivedKey;
  }
  /**
   * @param {string[]} words
   * @param {string} passphrase
   * @returns {Promise<Uint8Array>}
   */
  static async toSeed(words, passphrase) {
    return await toSeed(words, passphrase);
  }
  /**
   * @param {string} passphrase
   * @param {string} seedText
   * @returns {Promise<{ keyData: Uint8Array; chainCode: Uint8Array }>} seedText
   */
  async _toKeyData(passphrase, seedText) {
    const seed = await toSeed(this.words, passphrase);
    const digest2 = await hash(
      HashAlgorithm.Sha512,
      seedText,
      seed
    );
    return {
      keyData: digest2.subarray(0, 32),
      chainCode: digest2.subarray(32)
    };
  }
  /**
   * Recover a mnemonic phrase from a string, splitting on spaces. Handles 12, 22 (legacy), and 24 words.
   * @param {string} mnemonic
   * @returns {Promise<Mnemonic>}
   */
  static async fromString(mnemonic) {
    return _Mnemonic.fromWords(mnemonic.split(/\s|,/));
  }
  /**
   * @returns {Promise<Mnemonic>}
   * @private
   */
  async _validate() {
    if (this.words.length === 22) {
      const unknownWordIndices = this.words.reduce(
        (unknowns, word, index) => legacy_default.includes(word.toLowerCase()) ? unknowns : [...unknowns, index],
        []
      );
      if (unknownWordIndices.length > 0) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.UnknownWords,
          unknownWordIndices
        );
      }
      const [seed, checksum] = legacy1(this.words, legacy_default);
      const newChecksum = crc8(seed);
      if (checksum !== newChecksum) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.ChecksumMismatch,
          []
        );
      }
    } else {
      if (!(this.words.length === 12 || this.words.length === 24)) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.BadLength,
          []
        );
      }
      const unknownWordIndices = this.words.reduce(
        (unknowns, word, index) => bip39_default.includes(word) ? unknowns : [...unknowns, index],
        []
      );
      if (unknownWordIndices.length > 0) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.UnknownWords,
          unknownWordIndices
        );
      }
      const bits = this.words.map((word) => {
        return bip39_default.indexOf(word).toString(2).padStart(11, "0");
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBitsRegex = entropyBits.match(/(.{1,8})/g);
      const entropyBytes = (
        /** @type {RegExpMatchArray} */
        entropyBitsRegex.map(binaryToByte)
      );
      const newChecksum = await deriveChecksumBits(
        Uint8Array.from(entropyBytes)
      );
      if (newChecksum !== checksumBits) {
        throw new BadMnemonicError(
          this,
          BadMnemonicReason_default.ChecksumMismatch,
          []
        );
      }
    }
    return this;
  }
  /**
   * @returns {Promise<PrivateKey>}
   */
  async toLegacyPrivateKey() {
    let seed;
    if (this.words.length === 22) {
      [seed] = legacy1(this.words, legacy_default);
    } else {
      seed = await legacy2(this.words, bip39_default);
    }
    if (Cache_default.privateKeyFromBytes == null) {
      throw new Error("PrivateKey not found in cache");
    }
    return Cache_default.privateKeyFromBytes(seed);
  }
  /**
   * @returns {string}
   */
  toString() {
    return this.words.join(" ");
  }
};
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function bytesToBinary(bytes3) {
  return bytes3.map((x2) => x2.toString(2).padStart(8, "0")).join("");
}
async function deriveChecksumBits(entropyBuffer) {
  const ENT = entropyBuffer.length * 8;
  const CS = ENT / 32;
  const hash2 = await digest(entropyBuffer);
  return bytesToBinary(Array.from(hash2)).slice(0, CS);
}

// node_modules/@hashgraph/sdk/lib/array.js
function e(e39, t35) {
  if (e39 === t35) return true;
  if (e39.byteLength !== t35.byteLength) return false;
  const n31 = new DataView(e39.buffer, e39.byteOffset, e39.byteLength), f4 = new DataView(t35.buffer, t35.byteOffset, t35.byteLength);
  let r41 = e39.byteLength;
  for (; r41--; ) if (n31.getUint8(r41) !== f4.getUint8(r41)) return false;
  return true;
}

// node_modules/@hashgraph/sdk/lib/Cache.js
var t = new class {
  constructor() {
    this._timeDrift = 0, this._contractId = null, this._keyList = null, this._thresholdKey = null, this._publicKeyED25519 = null, this._publicKeyECDSA = null, this._privateKeyConstructor = null, this._mnemonicFromString = null, this._accountIdConstructor = null, this._delegateContractId = null, this._evmAddress = null, this._ethereumTransactionDataLegacyFromBytes = null, this._ethereumTransactionDataEip1559FromBytes = null, this._ethereumTransactionDataEip2930FromBytes = null, this._transactionReceiptQueryConstructor = null, this._transactionRecordQueryConstructor = null;
  }
  setTimeDrift(t35) {
    this._timeDrift = t35;
  }
  get timeDrift() {
    if (null == this._timeDrift) throw new Error("Cache.timeDrift was used before it was set");
    return this._timeDrift;
  }
  setContractId(t35) {
    this._contractId = t35;
  }
  get contractId() {
    if (null == this._contractId) throw new Error("Cache.contractId was used before it was set");
    return this._contractId;
  }
  setKeyList(t35) {
    this._keyList = t35;
  }
  get keyList() {
    if (null == this._keyList) throw new Error("Cache.keyList was used before it was set");
    return this._keyList;
  }
  setThresholdKey(t35) {
    this._thresholdKey = t35;
  }
  get thresholdKey() {
    if (null == this._thresholdKey) throw new Error("Cache.thresholdKey was used before it was set");
    return this._thresholdKey;
  }
  setPublicKeyED25519(t35) {
    this._publicKeyED25519 = t35;
  }
  get publicKeyED25519() {
    if (null == this._publicKeyED25519) throw new Error("Cache.publicKeyED25519 was used before it was set");
    return this._publicKeyED25519;
  }
  setPublicKeyECDSA(t35) {
    this._publicKeyECDSA = t35;
  }
  get publicKeyECDSA() {
    if (null == this._publicKeyECDSA) throw new Error("Cache.publicKeyECDSA was used before it was set");
    return this._publicKeyECDSA;
  }
  setPrivateKeyConstructor(t35) {
    this._privateKeyConstructor = t35;
  }
  get privateKeyConstructor() {
    if (null == this._privateKeyConstructor) throw new Error("Cache.privateKeyConstructor was used before it was set");
    return this._privateKeyConstructor;
  }
  setMnemonicFromString(t35) {
    this._mnemonicFromString = t35;
  }
  get mnemonicFromString() {
    if (null == this._mnemonicFromString) throw new Error("Cache.mnemonicFromString was used before it was set");
    return this.mnemonicFromString;
  }
  setAccountIdConstructor(t35) {
    this._accountIdConstructor = t35;
  }
  get accountIdConstructor() {
    if (null == this._accountIdConstructor) throw new Error("Cache.accountIdConstructor was used before it was set");
    return this._accountIdConstructor;
  }
  setDelegateContractId(t35) {
    this._delegateContractId = t35;
  }
  get delegateContractId() {
    if (null == this._delegateContractId) throw new Error("Cache.delegateContractId was used before it was set");
    return this._delegateContractId;
  }
  setEvmAddress(t35) {
    this._evmAddress = t35;
  }
  get evmAddress() {
    if (null == this._evmAddress) throw new Error("Cache.evmAddress was used before it was set");
    return this._evmAddress;
  }
  setEthereumTransactionDataLegacyFromBytes(t35) {
    this._ethereumTransactionDataLegacyFromBytes = t35;
  }
  get ethereumTransactionDataLegacyFromBytes() {
    if (null == this._ethereumTransactionDataLegacyFromBytes) throw new Error("Cache.ethereumTransactionDataLegacyFromBytes was used before it was set");
    return this._ethereumTransactionDataLegacyFromBytes;
  }
  setEthereumTransactionDataEip1559FromBytes(t35) {
    this._ethereumTransactionDataEip1559FromBytes = t35;
  }
  get ethereumTransactionDataEip1559FromBytes() {
    if (null == this._ethereumTransactionDataEip1559FromBytes) throw new Error("Cache.ethereumTransactionDataEip1559FromBytes was used before it was set");
    return this._ethereumTransactionDataEip1559FromBytes;
  }
  setEthereumTransactionDataEip2930FromBytes(t35) {
    this._ethereumTransactionDataEip2930FromBytes = t35;
  }
  get ethereumTransactionDataEip2930FromBytes() {
    if (null == this._ethereumTransactionDataEip2930FromBytes) throw new Error("Cache.ethereumTransactionDataEip2930FromBytes was used before it was set");
    return this._ethereumTransactionDataEip2930FromBytes;
  }
  setTransactionReceiptQueryConstructor(t35) {
    this._transactionReceiptQueryConstructor = t35;
  }
  get transactionReceiptQueryConstructor() {
    if (null == this._transactionReceiptQueryConstructor) throw new Error("Cache.transactionReceiptQueryConstructor was used before it was set");
    return this._transactionReceiptQueryConstructor;
  }
  setTransactionRecordQueryConstructor(t35) {
    this._transactionRecordQueryConstructor = t35;
  }
  get transactionRecordQueryConstructor() {
    if (null == this._transactionRecordQueryConstructor) throw new Error("Cache.transactionRecordQueryConstructor was used before it was set");
    return this._transactionRecordQueryConstructor;
  }
}();

// node_modules/@hashgraph/sdk/lib/Key.js
var t2 = class {
  _toProtobufKey() {
    throw new Error("not implemented");
  }
  static _fromProtobufKey(t35) {
    return null != t35.contractID ? t.contractId(t35.contractID) : null != t35.delegatableContractId ? t.delegateContractId(t35.delegatableContractId) : null != t35.ed25519 && t35.ed25519.byteLength > 0 ? t.publicKeyED25519(t35.ed25519) : null != t35.ECDSASecp256k1 && t35.ECDSASecp256k1.byteLength > 0 ? t.publicKeyECDSA(t35.ECDSASecp256k1) : null != t35.thresholdKey && null != t35.thresholdKey.threshold ? t.thresholdKey(t35.thresholdKey) : null != t35.keyList ? t.keyList(t35.keyList) : null;
  }
};

// node_modules/@hashgraph/sdk/lib/PublicKey.js
var i = class _i extends t2 {
  constructor(t35) {
    super(), this._key = t35;
  }
  static fromBytes(e39) {
    return new _i(PublicKey.fromBytes(e39));
  }
  static fromBytesED25519(e39) {
    return new _i(PublicKey.fromBytesED25519(e39));
  }
  static fromBytesECDSA(e39) {
    return new _i(PublicKey.fromBytesECDSA(e39));
  }
  static fromString(e39) {
    return new _i(PublicKey.fromString(e39));
  }
  static fromStringECDSA(e39) {
    return new _i(PublicKey.fromStringECDSA(e39));
  }
  static fromStringED25519(e39) {
    return new _i(PublicKey.fromStringED25519(e39));
  }
  verify(t35, e39) {
    return this._key.verify(t35, e39);
  }
  verifyTransaction(t35) {
    t35._requireFrozen(), t35.isFrozen() || t35.freeze();
    for (const r41 of t35._signedTransactions.list) if (null != r41.sigMap && null != r41.sigMap.sigPair) {
      let t36 = false;
      for (const s26 of r41.sigMap.sigPair) {
        const i17 = s26.pubKeyPrefix;
        if (e(i17, this.toBytesRaw())) {
          t36 = true;
          const e39 = r41.bodyBytes;
          let i18 = null;
          if (null != s26.ed25519 ? i18 = s26.ed25519 : null != s26.ECDSASecp256k1 && (i18 = s26.ECDSASecp256k1), null == i18) continue;
          if (!this.verify(e39, i18)) return false;
        }
      }
      if (!t36) return false;
    }
    return true;
  }
  toBytes() {
    return this._key.toBytes();
  }
  toBytesDer() {
    return this._key.toBytesDer();
  }
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  toEthereumAddress() {
    return this._key.toEthereumAddress();
  }
  toEvmAddress() {
    return this._key.toEthereumAddress();
  }
  toString() {
    return this._key.toString();
  }
  toStringDer() {
    return this._key.toStringDer();
  }
  toStringRaw() {
    return this._key.toStringRaw();
  }
  equals(t35) {
    return this._key.equals(t35._key);
  }
  _toProtobufKey() {
    switch (this._key._type) {
      case "ED25519":
        return { ed25519: this._key.toBytesRaw() };
      case "secp256k1":
        return { ECDSASecp256k1: this._key.toBytesRaw() };
      default:
        throw new Error(`unrecognized key type ${this._key._type}`);
    }
  }
  _toProtobufSignature(t35) {
    switch (this._key._type) {
      case "ED25519":
        return { pubKeyPrefix: this._key.toBytesRaw(), ed25519: t35 };
      case "secp256k1":
        return { pubKeyPrefix: this._key.toBytesRaw(), ECDSASecp256k1: t35 };
      default:
        throw new Error(`unrecognized key type ${this._key._type}`);
    }
  }
  get type() {
    return this._key._type;
  }
  toAccountId(t35, e39) {
    return t.accountIdConstructor(t35, e39, this);
  }
  static unusableKey() {
    return _i.fromStringED25519("0000000000000000000000000000000000000000000000000000000000000000");
  }
};
t.setPublicKeyED25519(((t35) => i.fromBytesED25519(t35))), t.setPublicKeyECDSA(((t35) => i.fromBytesECDSA(t35)));

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version = "logger/5.8.0";

// node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class _Logger {
  constructor(version10) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version10,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(_Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(_Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(_Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = _Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key) => {
      const value = params[key];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i17 = 0; i17 < value.length; i17++) {
            hex += HEX[value[i17] >> 4];
            hex += HEX[value[i17] & 15];
          }
          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key) {
      error[key] = params[key];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, _Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new _Logger(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      _Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version10) {
    return new _Logger(version10);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2 = "bytes/5.8.0";

// node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version2);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes2(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes2(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i17 = 0; i17 < value.length; i17++) {
    const v3 = value[i17];
    if (!isInteger(v3) || v3 < 0 || v3 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i17 = 0; i17 < hex.length; i17 += 2) {
      result.push(parseInt(hex.substring(i17, i17 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes2(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat2(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes2(value)) {
    let result = "0x";
    for (let i17 = 0; i17 < value.length; i17++) {
      let v3 = value[i17];
      result += HexCharacters[(v3 & 240) >> 4] + HexCharacters[v3 & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}

// node_modules/@hashgraph/sdk/lib/PrivateKey.js
var import_proto2 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/lib/Mnemonic.js
var a = class _a2 {
  constructor(t35) {
    this._mnemonic = t35;
  }
  static async generate() {
    return new _a2(await Mnemonic._generate(24));
  }
  static async generate12() {
    return new _a2(await Mnemonic._generate(12));
  }
  static async fromWords(e39) {
    return new _a2(await Mnemonic.fromWords(e39));
  }
  async toPrivateKey(t35 = "") {
    return t.privateKeyConstructor(await this._mnemonic.toPrivateKey(t35));
  }
  async toEd25519PrivateKey(t35 = "", a23) {
    return t.privateKeyConstructor(await this._mnemonic.toEd25519PrivateKey(t35, a23));
  }
  async toStandardEd25519PrivateKey(t35 = "", a23) {
    return t.privateKeyConstructor(await this._mnemonic.toStandardEd25519PrivateKey(t35, a23));
  }
  async toEcdsaPrivateKey(t35 = "", a23) {
    return t.privateKeyConstructor(await this._mnemonic.toEcdsaPrivateKey(t35, a23));
  }
  calculateDerivationPathValues(t35) {
    const e39 = /m\/(\d+'?)\/(\d+'?)\/(\d+'?)\/(\d+'?)\/(\d+'?)/.exec(t35), a23 = new Array(5);
    if (e39) for (let t36 = 1; t36 <= 5; t36++) {
      let r41 = e39[t36];
      r41.endsWith("'") ? (r41 = r41.substring(0, r41.length - 1), a23[t36 - 1] = 2147483648 | parseInt(r41, 10)) : a23[t36 - 1] = parseInt(r41, 10);
    }
    return a23;
  }
  async toStandardECDSAsecp256k1PrivateKeyImpl(t35, e39) {
    return await this.toEcdsaPrivateKey(t35, e39);
  }
  async toStandardECDSAsecp256k1PrivateKey(t35 = "", a23) {
    return t.privateKeyConstructor(await this._mnemonic.toStandardECDSAsecp256k1PrivateKey(t35, a23));
  }
  async toStandardECDSAsecp256k1PrivateKeyCustomDerivationPath(t35 = "", e39) {
    const a23 = this.calculateDerivationPathValues(e39);
    return await this.toStandardECDSAsecp256k1PrivateKeyImpl(t35, a23);
  }
  static async fromString(e39) {
    return new _a2(await Mnemonic.fromString(e39));
  }
  async toLegacyPrivateKey() {
    return t.privateKeyConstructor(await this._mnemonic.toLegacyPrivateKey());
  }
  async toSeed(e39) {
    return await Mnemonic.toSeed(this._mnemonic.words, e39);
  }
  toString() {
    return this._mnemonic.toString();
  }
};

// node_modules/@hashgraph/sdk/lib/ObjectMap.js
var t3 = class {
  constructor(t35) {
    this._map = /* @__PURE__ */ new Map(), this.__map = /* @__PURE__ */ new Map(), this._fromString = t35;
  }
  get(t35) {
    const s26 = "string" == typeof t35 ? t35 : t35.toString(), r41 = this._map.get(s26);
    return null != r41 ? r41 : null;
  }
  _set(t35, s26) {
    const r41 = "string" == typeof t35 ? t35 : t35.toString();
    this._map.set(r41, s26), this.__map.set(t35, s26);
  }
  values() {
    return this._map.values();
  }
  get size() {
    return this._map.size;
  }
  keys() {
    return this.__map.keys();
  }
  [Symbol.iterator]() {
    return this.__map[Symbol.iterator]();
  }
  toString() {
    const t35 = {};
    for (const [s26, r41] of this._map) t35[s26] = r41;
    return JSON.stringify(t35);
  }
  toJSON() {
    const t35 = {};
    return this._map.forEach(((s26, r41) => {
      t35[r41] = s26;
    })), t35;
  }
};

// node_modules/@hashgraph/sdk/lib/EntityIdHelper.js
var EntityIdHelper_exports = {};
__export(EntityIdHelper_exports, {
  _checksum: () => $,
  _parseAddress: () => A,
  aliasToEvmAddress: () => N3,
  aliasToPublicKey: () => I2,
  compare: () => w2,
  constructor: () => g2,
  fromEvmAddress: () => S,
  fromSolidityAddress: () => E2,
  fromString: () => p2,
  fromStringSplitter: () => y2,
  publicKeyToAlias: () => _,
  toEvmAddress: () => k,
  toSolidityAddress: () => x,
  toStringWithChecksum: () => v2,
  validateChecksum: () => b2
});

// node_modules/@hashgraph/sdk/lib/encoding/hex.browser.js
var t4 = [];
for (let n31 = 0; n31 <= 255; n31 += 1) t4.push(n31.toString(16).padStart(2, "0"));
function n(n31) {
  let r41 = "";
  for (const s26 of n31) r41 += t4[s26];
  return r41;
}
function r(t35) {
  const n31 = (t35.startsWith("0x") ? t35.substring(2) : t35).match(/.{1,2}/gu);
  return new Uint8Array((null == n31 ? [] : n31).map(((t36) => parseInt(t36, 16))));
}
function s(t35) {
  if ("string" != typeof t35) return false;
  const n31 = t35.startsWith("0x") ? t35.substring(2) : t35;
  if (0 === n31.length) return false;
  if (n31.length % 2 != 0) return false;
  return /^[0-9a-fA-F]+$/.test(n31);
}

// node_modules/@hashgraph/sdk/lib/BadEntityIdError.js
var t5 = class extends Error {
  constructor(t35, s26, e39, r41, i17) {
    super(`Entity ID ${t35.toString()}.${s26.toString()}.${e39.toString()}-${r41} was incorrect.`), this.name = "BadEntityIdException", this.shard = t35, this.realm = s26, this.num = e39, this.presentChecksum = r41, this.expectedChecksum = i17;
  }
};

// node_modules/@hashgraph/sdk/lib/util.js
var n2 = "This value cannot be null | undefined.";
var r2 = "This value must be a string or Uint8Array.";
var o = "The provided variable must be an Array.";
var i2 = "This value must be a String, Number, or BigNumber to be converted.";
var f2 = "This value must be a String, Number, or BigNumber to be converted.";
var u = "Unable to parse given variable. Returns NaN.";
function a2(e39) {
  return null != e39;
}
function b(e39) {
  return a2(e39) && e39 instanceof Uint8Array;
}
function s2(e39) {
  return a2(e39) && ("number" == typeof e39 || e39 instanceof Number);
}
function c(t35) {
  return a2(t35) && t35 instanceof bignumber_default;
}
function h(e39) {
  return a2(e39) && e39 instanceof long_default;
}
function g(e39) {
  return a2(e39) && "string" == typeof e39;
}
function l(e39) {
  return a2(e39) && (g(e39) || b(e39));
}
function w(e39) {
  for (let t35 = 0; t35 < 12; t35++) if (0 != e39[t35]) return false;
  return true;
}
function y(e39) {
  if (e39.isNegative()) throw new Error("negative value not allowed");
  return e39;
}
function m(e39) {
  if (a2(e39)) return e39;
  throw new Error(n2);
}
function p(e39) {
  if (l(m(e39))) return e39;
  throw new Error(r2);
}
function v(t35) {
  if (m(t35), c(t35) || g(t35) || s2(t35) || h(t35)) return new bignumber_default(t35);
  throw new Error(i2);
}
function N2(e39) {
  if (e39 instanceof Array) return e39.map(v);
  throw new Error(o);
}
function d(e39) {
  if (m(e39), c(e39) || g(e39) || s2(e39) || h(e39)) {
    const t35 = parseInt(e39);
    if (isNaN(t35)) throw new Error(u);
    return t35;
  }
  throw new Error(f2);
}
function E(e39, t35 = 0, n31 = e39.byteLength) {
  if (!(Number.isInteger(t35) && t35 >= 0)) throw new Error("Invalid offset!");
  if (!(Number.isInteger(n31) && n31 >= 0)) throw new Error("Invalid length!");
  return new DataView(e39.buffer, e39.byteOffset + t35, Math.min(n31, e39.byteLength - t35));
}
function L(e39, t35, n31 = /* @__PURE__ */ new Set()) {
  if ("object" == typeof e39 && "object" == typeof t35) {
    const r41 = Object.keys(e39), o32 = Object.keys(t35);
    if (r41.length !== o32.length) return false;
    for (let i17 = 0; i17 < r41.length; i17++) {
      if (r41[i17] !== o32[i17]) return false;
      if (!n31.has(r41[i17]) && !L(e39[r41[i17]], t35[o32[i17]], n31)) return false;
    }
    return true;
  }
  return ("number" == typeof e39 && "number" == typeof t35 || "string" == typeof e39 && "string" == typeof t35 || "boolean" == typeof e39 && "boolean" == typeof t35) && e39 === t35;
}
function T(e39) {
  for (var t35, n31, r41 = e39.length; 0 !== r41; ) n31 = Math.floor(Math.random() * r41), t35 = e39[r41 -= 1], e39[r41] = e39[n31], e39[n31] = t35;
}
function j(e39, t35) {
  if (e39 === t35) return true;
  if (e39.byteLength !== t35.byteLength) return false;
  const n31 = new DataView(e39.buffer, e39.byteOffset, e39.byteLength), r41 = new DataView(t35.buffer, t35.byteOffset, t35.byteLength);
  let o32 = e39.byteLength;
  for (; o32--; ) if (n31.getUint8(o32) !== r41.getUint8(o32)) return false;
  return true;
}
function I(e39) {
  return new Promise(((t35) => setTimeout(t35, e39)));
}

// node_modules/@hashgraph/sdk/lib/base32.js
var o2 = { loose: true };
var a3 = { pad: false };
var r3 = { decode: (a23) => a23 && base32.parse(a23, o2), encode: (o32) => o32 && base32.stringify(o32, a3) };

// node_modules/@hashgraph/sdk/lib/EntityIdHelper.js
var u2 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/lib/EvmAddress.js
var i3 = class _i extends t2 {
  constructor(t35) {
    super(), this._bytes = t35;
  }
  static fromString(t35) {
    if (40 !== (t35 = t35.startsWith("0x") ? t35.slice(2) : t35).length) throw new Error("Input EVM address string is not the correct size");
    return new _i(r(t35));
  }
  static fromBytes(t35) {
    return new _i(t35);
  }
  toBytes() {
    return this._bytes;
  }
  toString() {
    return n(this._bytes);
  }
  equals(t35) {
    return j(this._bytes, t35._bytes);
  }
};

// node_modules/@hashgraph/sdk/lib/EntityIdHelper.js
var h2 = /"^(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))\\.(0|(?:[1-9]\\d*))(?:-([a-z]{5}))?$/;
var d2 = /^(\d+)(?:\.(\d+)\.([a-fA-F0-9]+))?(?:-([a-z]{5}))?$/;
function g2(r41, t35, n31) {
  if (null == t35 && null != n31 || null != t35 && null == n31) throw new Error("invalid entity ID");
  const [o32, l19, i17] = "number" == typeof r41 || long_default.isLong(r41) ? [null != n31 ? long_default.fromValue(r41) : long_default.ZERO, null != t35 ? long_default.fromValue(t35) : long_default.ZERO, null != n31 ? long_default.fromValue(n31) : long_default.fromValue(r41)] : [null != r41.shard ? long_default.fromValue(r41.shard) : long_default.ZERO, null != r41.realm ? long_default.fromValue(r41.realm) : long_default.ZERO, long_default.fromValue(r41.num)];
  if (o32.isNegative() || l19.isNegative() || i17.isNegative()) throw new Error("negative numbers are not allowed in IDs");
  return { shard: o32, realm: l19, num: i17 };
}
function w2(e39, r41) {
  let t35 = e39[0].compare(r41[0]);
  return 0 != t35 ? t35 : (t35 = e39[1].compare(r41[1]), 0 != t35 ? t35 : e39[2].compare(r41[2]));
}
function y2(e39) {
  const r41 = d2.exec(e39);
  if (null == r41) throw new Error(`failed to parse entity id: ${e39}`);
  return null == r41[2] && null == r41[3] ? { shard: "0", realm: "0", numOrHex: r41[1], checksum: r41[4] } : { shard: r41[1], realm: r41[2], numOrHex: r41[3], checksum: r41[4] };
}
function p2(r41) {
  const t35 = y2(r41);
  if (Number.isNaN(t35.shard) || Number.isNaN(t35.realm) || Number.isNaN(t35.numOrHex)) throw new Error("invalid format for entity ID");
  return { shard: null != t35.shard ? long_default.fromString(t35.shard) : long_default.ZERO, realm: null != t35.realm ? long_default.fromString(t35.realm) : long_default.ZERO, num: long_default.fromString(t35.numOrHex), checksum: t35.checksum };
}
function E2(r41) {
  const n31 = r41.startsWith("0x") ? r(r41.slice(2)) : r(r41);
  if (20 !== n31.length) throw new Error(`Invalid hex encoded solidity address length:
                expected length 40, got length ${r41.length}`);
  return [long_default.fromBytesBE([0, 0, 0, 0, ...n31.slice(0, 4)]), long_default.fromBytesBE(Array.from(n31.slice(4, 12))), long_default.fromBytesBE(Array.from(n31.slice(12, 20)))];
}
function S(n31, o32, i17) {
  if (!s(i17)) throw new Error(`Invalid EVM address hex string: ${i17}`);
  const s26 = i17.startsWith("0x") ? r(i17.slice(2)) : r(i17);
  if (20 !== s26.length) throw new Error(`Invalid hex encoded evm address length:
                expected length 20, got length ${i17.length}`);
  let a23 = long_default.ZERO;
  return w(s26) && (a23 = long_default.fromBytesBE(Array.from(s26.slice(12, 20)))), [n31 instanceof long_default ? n31 : long_default.fromNumber(n31), o32 instanceof long_default ? o32 : long_default.fromNumber(o32), a23, a23.isZero() ? i3.fromBytes(s26) : null];
}
function x(e39) {
  const r41 = new Uint8Array(20), t35 = E(r41), [o32, l19, a23] = e39;
  return t35.setUint32(0, d(o32)), t35.setUint32(8, d(l19)), t35.setUint32(16, d(a23)), n(r41);
}
function k(e39) {
  if (e39 instanceof Uint8Array) return n(e39);
  const r41 = e39, t35 = new Uint8Array(20);
  return E(t35).setUint32(16, d(r41)), n(t35);
}
function A(r41, t35) {
  let n31 = h2.exec(t35);
  if (null === n31) {
    return { status: 0 };
  }
  let o32 = [long_default.fromString(n31[1]), long_default.fromString(n31[2]), long_default.fromString(n31[3])], l19 = `${o32[0].toString()}.${o32[1].toString()}.${o32[2].toString()}`, i17 = $(r41, l19);
  return { status: void 0 === n31[4] ? 2 : i17 == n31[4] ? 3 : 1, num1: o32[0], num2: o32[1], num3: o32[2], givenChecksum: n31[4], correctChecksum: i17, noChecksumFormat: l19, withChecksumFormat: `${l19}-${i17}` };
}
function $(e39, r41) {
  let t35 = "", n31 = [], o32 = 0, l19 = 0, i17 = 0, s26 = 0, a23 = 0;
  const u22 = 11881376, c17 = "a".charCodeAt(0);
  let m6 = new Uint8Array(e39.length + 6);
  m6.set(e39, 0), m6.set([0, 0, 0, 0, 0, 0], e39.length);
  for (let e40 = 0; e40 < r41.length; e40++) n31.push("." === r41[e40] ? 10 : parseInt(r41[e40], 10));
  for (let e40 = 0; e40 < n31.length; e40++) i17 = (31 * i17 + n31[e40]) % 17576, e40 % 2 == 0 ? o32 = (o32 + n31[e40]) % 11 : l19 = (l19 + n31[e40]) % 11;
  for (let e40 = 0; e40 < m6.length; e40++) s26 = (31 * s26 + m6[e40]) % u22;
  a23 = (17576 * (11 * (r41.length % 5 * 11 + o32) + l19) + i17 + s26) % u22, a23 = 1000003 * a23 % u22;
  for (let e40 = 0; e40 < 5; e40++) t35 = String.fromCharCode(c17 + a23 % 26) + t35, a23 /= 26;
  return t35;
}
function b2(e39, r41, t35, n31, l19) {
  if (null == l19._network._ledgerId || null == n31) return;
  const i17 = $(l19._network._ledgerId._ledgerId, `${e39.toString()}.${r41.toString()}.${t35.toString()}`);
  if (n31 != i17) throw new t5(e39, r41, t35, n31, i17);
}
function v2(e39, r41) {
  if (null == r41) throw new Error("client cannot be null");
  if (null == r41._network._ledgerId) throw new Error("cannot calculate checksum with a client that does not contain a recognzied ledger ID");
  return `${e39}-${$(r41._network._ledgerId._ledgerId, e39)}`;
}
function I2(e39) {
  const r41 = r3.decode(e39);
  if (!r41) return null;
  let t35;
  try {
    t35 = u2.proto.Key.decode(r41);
  } catch (e40) {
    throw new Error("The alias is created with hollow account. Please use aliasToEvmAddress!");
  }
  return null != t35.ed25519 && t35.ed25519.byteLength > 0 ? i.fromBytes(t35.ed25519) : null != t35.ECDSASecp256k1 && t35.ECDSASecp256k1.byteLength > 0 ? i.fromBytes(t35.ECDSASecp256k1) : null;
}
function N3(e39) {
  const r41 = r3.decode(e39);
  if (!r41) return null;
  try {
    throw u2.proto.Key.decode(r41), new Error("The alias is created with ed25519 or ECDSASecp256k1 account. Please use aliasToPublicKey!");
  } catch (e40) {
    return (function(e41) {
      var r42 = "0x";
      return e41.forEach((function(e42) {
        r42 += ("0" + (255 & e42).toString(16)).slice(-2);
      })), r42;
    })(r41);
  }
}
function _(e39) {
  if ("string" == typeof e39 && (e39.startsWith("0x") && 42 == e39.length || 40 == e39.length)) {
    e39.startsWith("0x") || (e39 = `0x${e39}`);
    const r42 = arrayify(e39);
    return r42 ? r3.encode(r42) : null;
  }
  const r41 = "string" == typeof e39 ? i.fromString(e39) : e39;
  let t35 = r41.toStringRaw(), n31 = "";
  "secp256k1" === r41._key._type && (n31 = "0x3A21"), "ED25519" === r41._key._type && (n31 = "0x1220"), t35.startsWith("0x") || (t35 = `0x${t35}`);
  const o32 = arrayify(n31), l19 = arrayify(t35), i17 = (s26 = o32, u22 = l19, (f4 = new Uint8Array(s26.byteLength + u22.byteLength)).set(new Uint8Array(s26), 0), f4.set(new Uint8Array(u22), s26.byteLength), f4);
  var s26, u22, f4;
  return r3.encode(i17);
}

// node_modules/@hashgraph/sdk/lib/account/AccountId.js
var m2 = __toESM(require_lib(), 1);
var y3 = class _y {
  constructor(t35, e39, r41, i17, n31) {
    const l19 = g2(t35, e39, r41);
    this.shard = l19.shard, this.realm = l19.realm, this.num = l19.num, this.aliasKey = null != i17 ? i17 : null, this.evmAddress = null != n31 ? n31 : null, this._checksum = null;
  }
  static fromString(s26) {
    let r41, i17, n31 = long_default.ZERO, l19 = long_default.ZERO, a23 = long_default.ZERO;
    if (s26.startsWith("0x") && 42 == s26.length || 40 == s26.length) i17 = i3.fromString(s26);
    else {
      const o32 = y2(s26);
      if (Number.isNaN(o32.shard) || Number.isNaN(o32.realm)) throw new Error("invalid format for entity ID");
      null != o32.shard && (n31 = long_default.fromString(o32.shard)), null != o32.realm && (l19 = long_default.fromString(o32.realm)), o32.numOrHex.length < 20 ? a23 = long_default.fromString(o32.numOrHex) : 40 == o32.numOrHex.length ? i17 = i3.fromString(o32.numOrHex) : r41 = i.fromString(o32.numOrHex);
    }
    return new _y(n31, l19, a23, r41, i17);
  }
  static fromEvmAddress(t35, s26, e39) {
    const i17 = "string" == typeof e39 ? i3.fromString(e39) : e39, [n31, l19, a23, o32] = S(t35, s26, i17.toString());
    return new _y(n31, l19, a23, void 0, o32 || void 0);
  }
  static fromEvmPublicAddress(t35) {
    return new _y(0, 0, 0, void 0, t35);
  }
  static _fromProtobuf(t35) {
    let s26, e39;
    return null != t35.alias && (20 === t35.alias.length ? e39 = i3.fromBytes(t35.alias) : s26 = t2._fromProtobufKey(m2.proto.Key.decode(t35.alias))), s26 instanceof i || (s26 = void 0), new _y(null != t35.shardNum ? t35.shardNum : 0, null != t35.realmNum ? t35.realmNum : 0, null != t35.accountNum ? t35.accountNum : 0, s26, e39);
  }
  get checksum() {
    return this._checksum;
  }
  getEvmAddress() {
    return this.evmAddress;
  }
  async populateAccountNum(s26) {
    if (null === this.evmAddress) throw new Error("field `evmAddress` should not be null");
    const e39 = s26.mirrorNetwork[0].slice(0, s26.mirrorNetwork[0].indexOf(":"));
    await new Promise(((t35) => {
      setTimeout(t35, 3e3);
    }));
    const r41 = `https://${e39}/api/v1/accounts/${this.evmAddress.toString()}`, i17 = await fetch(r41), n31 = (await i17.json()).account;
    return this.num = long_default.fromString(n31.slice(n31.lastIndexOf(".") + 1)), this;
  }
  async populateAccountEvmAddress(t35) {
    if (null === this.num) throw new Error("field `num` should not be null");
    const s26 = t35.mirrorNetwork[0].slice(0, t35.mirrorNetwork[0].indexOf(":"));
    await new Promise(((t36) => {
      setTimeout(t36, 3e3);
    }));
    const e39 = `https://${s26}/api/v1/accounts/${this.num.toString()}`, r41 = await fetch(e39), i17 = (await r41.json()).evm_address;
    return this.evmAddress = i3.fromString(i17), this;
  }
  validate(t35) {
    console.warn("Deprecated: Use `validateChecksum` instead"), this.validateChecksum(t35);
  }
  validateChecksum(t35) {
    if (null != this.aliasKey) throw new Error("cannot calculate checksum with an account ID that has a aliasKey");
    b2(this.shard, this.realm, this.num, this._checksum, t35);
  }
  static fromBytes(t35) {
    return _y._fromProtobuf(m2.proto.AccountID.decode(t35));
  }
  static fromSolidityAddress(t35) {
    return w(r(t35)) ? new _y(...E2(t35)) : this.fromEvmAddress(0, 0, t35);
  }
  toSolidityAddress() {
    return null != this.evmAddress ? this.evmAddress.toString() : null != this.aliasKey && "secp256k1" == this.aliasKey._key._type ? this.aliasKey.toEvmAddress() : x([this.shard, this.realm, this.num]);
  }
  toEvmAddress() {
    return null != this.evmAddress ? k(this.evmAddress.toBytes()) : k(this.num);
  }
  _toProtobuf() {
    let s26 = null;
    null != this.aliasKey ? s26 = m2.proto.Key.encode(this.aliasKey._toProtobufKey()).finish() : null != this.evmAddress && (s26 = this.evmAddress._bytes);
    const e39 = this.num.eq(long_default.fromBigInt(0n)) && s26;
    return s26 ? { alias: e39 ? s26 : null, accountNum: e39 ? null : this.num, shardNum: this.shard, realmNum: this.realm } : { alias: null, accountNum: this.num, shardNum: this.shard, realmNum: this.realm };
  }
  toBytes() {
    return m2.proto.AccountID.encode(this._toProtobuf()).finish();
  }
  toString() {
    let t35 = this.num.toString();
    return null != this.aliasKey ? t35 = this.aliasKey.toString() : null != this.evmAddress && (t35 = this.evmAddress.toString()), `${this.shard.toString()}.${this.realm.toString()}.${t35}`;
  }
  toStringWithChecksum(t35) {
    if (null != this.aliasKey) throw new Error("cannot calculate checksum with an account ID that has a aliasKey");
    return v2(this.toString(), t35);
  }
  equals(t35) {
    let s26 = false;
    return null != this.aliasKey && null != t35.aliasKey ? s26 = this.aliasKey.equals(t35.aliasKey) : null != this.evmAddress && null != t35.evmAddress ? s26 = this.evmAddress.equals(t35.evmAddress) : null == this.aliasKey && null == t35.aliasKey && null == this.evmAddress && null == t35.evmAddress && (s26 = this.num.eq(t35.num)), this.shard.eq(t35.shard) && this.realm.eq(t35.realm) && s26;
  }
  clone() {
    const t35 = new _y(this);
    return t35._checksum = this._checksum, t35.aliasKey = this.aliasKey, t35.evmAddress = this.evmAddress, t35;
  }
  compare(t35) {
    let s26 = this.shard.compare(t35.shard);
    if (0 != s26) return s26;
    if (s26 = this.realm.compare(t35.realm), 0 != s26) return s26;
    if (null != this.aliasKey && null != t35.aliasKey) {
      const s27 = this.aliasKey.toString(), e39 = t35.aliasKey.toString();
      return s27 > e39 ? 1 : s27 < e39 ? -1 : 0;
    }
    if (null != this.evmAddress && null != t35.evmAddress) {
      const s27 = this.evmAddress.toString(), e39 = t35.evmAddress.toString();
      return s27 > e39 ? 1 : s27 < e39 ? -1 : 0;
    }
    return null == this.aliasKey && null == t35.aliasKey && null == this.evmAddress && null == t35.evmAddress ? this.num.compare(t35.num) : 1;
  }
};
t.setAccountIdConstructor(((s26, e39, r41) => new y3(s26, e39, long_default.ZERO, r41)));

// node_modules/@hashgraph/sdk/lib/Timestamp.js
var o3 = long_default.fromNumber(1e9);
var n3 = /* @__PURE__ */ new Set();
var s3 = class _s {
  constructor(e39, o32) {
    this.seconds = e39 instanceof long_default ? e39 : long_default.fromNumber(e39), this.nanos = o32 instanceof long_default ? o32 : long_default.fromNumber(o32), Object.freeze(this);
  }
  static generate(t35 = true) {
    let o32;
    o32 = t35 ? Math.floor(5e3 * Math.random()) + 3e3 : 0;
    const r41 = Date.now() - o32, a23 = Math.floor(r41 / 1e3) + t.timeDrift, i17 = 1e6 * Math.floor(r41 % 1e3) + Math.floor(1e6 * Math.random()), c17 = new _s(a23, i17);
    return n3.has(c17.toString()) ? this.generate() : (n3.add(c17.toString()), c17);
  }
  static fromDate(e39) {
    let o32;
    if ("number" == typeof e39) o32 = long_default.fromNumber(e39);
    else if ("string" == typeof e39) o32 = long_default.fromNumber(Date.parse(e39)).mul(1e6);
    else {
      if (!(e39 instanceof Date)) throw new TypeError(`invalid type '${typeof e39}' for 'data', expected 'Date'`);
      o32 = long_default.fromNumber(e39.getTime()).mul(1e6);
    }
    return new _s(0, 0).plusNanos(o32);
  }
  toDate() {
    return new Date(1e3 * this.seconds.toInt() + Math.floor(this.nanos.toInt() / 1e6));
  }
  plusNanos(t35) {
    const e39 = this.nanos.add(t35);
    return new _s(this.seconds.add(e39.div(o3)), e39.mod(o3));
  }
  _toProtobuf() {
    return { seconds: this.seconds, nanos: this.nanos.toInt() };
  }
  static _fromProtobuf(e39) {
    return new _s(e39.seconds instanceof long_default ? e39.seconds.toInt() : null != e39.seconds ? e39.seconds : 0, null != e39.nanos ? e39.nanos : 0);
  }
  toString() {
    const t35 = String(this.nanos).padStart(9, "0");
    return `${this.seconds.toString()}.${t35}`;
  }
  compare(t35) {
    const e39 = this.seconds.compare(t35.seconds);
    return 0 != e39 ? e39 : this.nanos.compare(t35.nanos);
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/TransactionId.js
var r4 = __toESM(require_lib(), 1);
var i4 = class _i {
  constructor(t35, n31, r41 = false, e39 = null) {
    this.accountId = t35, this.validStart = n31, this.scheduled = r41, this.nonce = null, null != e39 && 0 != e39 && this.setNonce(e39), Object.seal(this);
  }
  setNonce(t35) {
    return this.nonce = "number" == typeof t35 ? long_default.fromNumber(t35) : t35, this;
  }
  static withValidStart(t35, n31) {
    return new _i(t35, n31);
  }
  static generate(r41) {
    return new _i("string" == typeof r41 ? y3.fromString(r41) : new y3(r41), s3.generate());
  }
  static fromString(r41) {
    let o32, c17, s26, a23, u22, l19;
    return [o32, l19] = r41.split("@"), [c17, l19] = l19.split("."), l19.includes("?") ? ([s26, l19] = l19.split("?scheduled"), a23 = true, u22 = l19.includes("/") ? l19.replace("/", "") : null) : l19.includes("/") ? ([s26, u22] = l19.split("/"), a23 = false) : s26 = l19, new _i(y3.fromString(o32), new s3(long_default.fromValue(c17), long_default.fromValue(s26)), a23, null != u22 ? long_default.fromString(u22) : null);
  }
  setScheduled(t35) {
    return this.scheduled = t35, this;
  }
  toString() {
    if (null != this.accountId && null != this.validStart) {
      const t35 = String(this.validStart.nanos).padStart(9, "0"), n31 = null != this.nonce ? "/".concat(this.nonce.toString()) : "", r41 = this.scheduled ? "?scheduled" : "";
      return `${this.accountId.toString()}@${this.validStart.seconds.toString()}.${t35}${r41}${n31}`;
    }
    throw new Error("neither `accountId` nor `validStart` are set");
  }
  static _fromProtobuf(r41) {
    if (null != r41.accountID && null != r41.transactionValidStart) return new _i(y3._fromProtobuf(r41.accountID), s3._fromProtobuf(r41.transactionValidStart), null != r41.scheduled ? r41.scheduled : void 0, null != r41.nonce ? r41.nonce : void 0);
    throw new Error("Neither `nonce` or `accountID` and `transactionValidStart` are set");
  }
  _toProtobuf() {
    return { accountID: null != this.accountId ? this.accountId._toProtobuf() : null, transactionValidStart: null != this.validStart ? this.validStart._toProtobuf() : null, scheduled: this.scheduled, nonce: null != this.nonce ? this.nonce.toInt() : null };
  }
  static fromBytes(t35) {
    return _i._fromProtobuf(r4.proto.TransactionID.decode(t35));
  }
  toBytes() {
    return r4.proto.TransactionID.encode(this._toProtobuf()).finish();
  }
  clone() {
    return new _i(this.accountId, this.validStart, this.scheduled, this.nonce);
  }
  compare(t35) {
    const n31 = this.accountId.compare(t35.accountId);
    return 0 != n31 ? n31 : this.validStart.compare(t35.validStart);
  }
  getReceipt(t35) {
    return t.transactionReceiptQueryConstructor().setTransactionId(this).execute(t35);
  }
  async getRecord(t35) {
    return await this.getReceipt(t35), t.transactionRecordQueryConstructor().setTransactionId(this).execute(t35);
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/SignaturePairMap.js
var t6 = class _t extends t3 {
  constructor() {
    super(((e39) => i.fromString(e39)));
  }
  static _fromTransactionSigMap(e39) {
    const s26 = new _t(), i17 = null != e39.sigPair ? e39.sigPair : [];
    for (const e40 of i17) null != e40.pubKeyPrefix && (null != e40.ed25519 ? s26._set(i.fromBytesED25519(e40.pubKeyPrefix), e40.ed25519) : null != e40.ECDSASecp256k1 && s26._set(i.fromBytesECDSA(e40.pubKeyPrefix), e40.ECDSASecp256k1));
    return s26;
  }
  addSignature(e39, r41) {
    return this._set(e39, r41), this;
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/NodeAccountIdSignatureMap.js
var a4 = __toESM(require_lib(), 1);
var n4 = class _n extends t3 {
  constructor() {
    super(((t35) => i4.fromString(t35)));
  }
  static _fromSignedTransactions(t35) {
    const s26 = new _n();
    for (const { bodyBytes: n31, sigMap: i17 } of t35.list) if (null != n31 && null != i17) {
      const t36 = a4.proto.TransactionBody.decode(n31);
      if (null != t36.transactionID) {
        const a23 = i4._fromProtobuf(t36.transactionID);
        s26._set(a23, t6._fromTransactionSigMap(i17));
      }
    }
    return s26;
  }
  addSignature(t35, o32, a23) {
    const n31 = this.get(t35);
    n31 ? n31.addSignature(o32, a23) : this._set(t35, new t6().addSignature(o32, a23));
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/List.js
var t7 = class _t {
  constructor() {
    this.list = [], this.locked = false, this.index = 0;
  }
  setList(t35) {
    if (this.locked) throw new Error("list is locked");
    return this.list = t35, this.index = 0, this;
  }
  push(...t35) {
    if (this.locked) throw new Error("list is locked");
    return this.list.push(...t35), this;
  }
  setLocked() {
    return this.locked = true, this;
  }
  clear() {
    this.list = [], this.index = 0, this.locked = false;
  }
  get(t35) {
    return this.list[t35];
  }
  set(t35, s26) {
    return t35 === this.length ? this.list.push(s26) : this.list[t35] = s26, this;
  }
  setIfAbsent(t35, s26) {
    return t35 != this.length && null != this.list[t35] || this.set(t35, s26()), this;
  }
  get next() {
    return this.get(this.advance());
  }
  get current() {
    return this.get(this.index);
  }
  advance() {
    const t35 = this.index;
    return this.index = (this.index + 1) % this.list.length, t35;
  }
  get isEmpty() {
    return 0 === this.length;
  }
  get length() {
    return this.list.length;
  }
  clone() {
    const s26 = new _t();
    return s26.list = this.list, s26.locked = this.locked, s26;
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/SignatureMap.js
var e2 = class _e extends t3 {
  constructor() {
    super(((t35) => y3.fromString(t35)));
  }
  static _fromTransaction(s26) {
    const n31 = new _e(), r41 = s26._nodeAccountIds.length, i17 = s26._signedTransactions.length / r41;
    for (let e39 = 0; e39 < r41; e39++) {
      const a23 = new t7();
      for (let t35 = 0; t35 < i17; t35++) a23.push(s26._signedTransactions.get(t35 * r41 + e39));
      n31._set(s26._nodeAccountIds.list[e39], n4._fromSignedTransactions(a23));
    }
    return n31;
  }
  addSignature(s26, n31, o32, e39) {
    let r41 = this.get(s26);
    return r41 || (r41 = new n4(), this._set(s26, r41)), r41.addSignature(n31, o32, e39), this._set(s26, r41), this;
  }
  getFlatSignatureList() {
    const t35 = [];
    for (const s26 of this.values()) for (const n31 of s26.values()) t35.push(n31);
    return t35;
  }
};

// node_modules/@hashgraph/sdk/lib/util/ASN1-Decoder.js
var import_proto = __toESM(require_lib(), 1);
var t8 = class {
  constructor(t35) {
    this.data = new Uint8Array(t35), this.pos = 0, this.oids = [], this.oidMap = { "1.3.132.0.10": "ecdsa", "1.3.101.112": "ed25519", "1.2.840.10045.2.1": "pubkey" }, this.isPublicKey = false;
  }
  readLength() {
    let t35 = this.data[this.pos++];
    if (128 & t35) {
      let s26 = 127 & t35;
      t35 = 0;
      for (let e39 = 0; e39 < s26; e39++) t35 = t35 << 8 | this.data[this.pos++];
    }
    return t35;
  }
  readType() {
    return this.data[this.pos++];
  }
  readInteger() {
    const t35 = this.readLength();
    let s26 = 0;
    for (let e39 = 0; e39 < t35; e39++) s26 = s26 << 8 | this.data[this.pos++];
    return { integer: s26 };
  }
  readOctetString() {
    const t35 = this.readLength(), s26 = this.data.slice(this.pos, this.pos + t35);
    return this.pos += t35, { pkey: s26 };
  }
  readBitString() {
    const t35 = this.readLength(), s26 = this.data[this.pos++], e39 = this.data.slice(this.pos, this.pos + t35 - 1);
    return this.pos += t35 - 1, { unusedBits: s26, pubkey: e39 };
  }
  readObjectIdentifier() {
    const t35 = this.readLength(), s26 = this.pos + t35, e39 = [];
    let i17 = 0;
    const r41 = this.data[this.pos++];
    for (e39.push(Math.floor(r41 / 40)), e39.push(r41 % 40); this.pos < s26; ) {
      const t36 = this.data[this.pos++];
      i17 = i17 << 7 | 127 & t36, 128 & t36 || (e39.push(i17), i17 = 0);
    }
    const h8 = e39.join(".");
    return this.oids.push(h8), { oid: h8 };
  }
  getOids() {
    return this.oids;
  }
  getOidKeyTypes() {
    return this.oids.map(((t35) => this.oidMap[t35] || "unknown"));
  }
  readSequence() {
    const t35 = this.readLength(), s26 = this.pos + t35, e39 = [];
    for (; this.pos < s26; ) e39.push(this.read());
    return e39;
  }
  read() {
    const t35 = this.readType();
    switch (t35) {
      case 2:
        return this.readInteger();
      case 3:
        return this.readBitString();
      case 4:
        return this.readOctetString();
      case 6:
        return this.readObjectIdentifier();
      case 48:
      case 160:
      case 161:
        return this.readSequence();
      default:
        throw new Error(`Unsupported type: ${t35}`);
    }
  }
  isPublicKeyType() {
    return this.isPublicKey;
  }
};

// node_modules/@hashgraph/sdk/lib/PrivateKey.js
var g3 = class _g extends t2 {
  constructor(t35) {
    super(), this._key = t35;
  }
  static generateED25519() {
    return new _g(PrivateKey.generateED25519());
  }
  static generateECDSA() {
    return new _g(PrivateKey.generateECDSA());
  }
  static generate() {
    return _g.generateED25519();
  }
  static async generateAsync() {
    return new _g(await PrivateKey.generateAsync());
  }
  static async generateED25519Async() {
    return new _g(await PrivateKey.generateED25519Async());
  }
  static async generateECDSAAsync() {
    return new _g(await PrivateKey.generateECDSAAsync());
  }
  static fromBytes(r41) {
    const n31 = hexlify(r41);
    return _g.isDerKey(n31) ? "ecdsa" === _g.getAlgorithm(n31) ? new _g(PrivateKey.fromBytesECDSA(r41)) : new _g(PrivateKey.fromBytesED25519(r41)) : new _g(PrivateKey.fromBytes(r41));
  }
  static fromBytesECDSA(t35) {
    return new _g(PrivateKey.fromBytesECDSA(t35));
  }
  static fromBytesED25519(t35) {
    return new _g(PrivateKey.fromBytesED25519(t35));
  }
  static fromString(t35) {
    return _g.isDerKey(t35) ? this.fromStringDer(t35) : new _g(PrivateKey.fromString(t35));
  }
  static fromStringDer(t35) {
    return _g.isDerKey(t35) ? "ecdsa" === _g.getAlgorithm(t35) ? this.fromStringECDSA(t35) : this.fromStringED25519(t35) : _g.fromString(t35);
  }
  static fromStringECDSA(t35) {
    return new _g(PrivateKey.fromStringECDSA(t35));
  }
  static fromStringED25519(t35) {
    return new _g(PrivateKey.fromStringED25519(t35));
  }
  static async fromSeedED25519(t35) {
    return new _g(await PrivateKey.fromSeedED25519(t35));
  }
  static async fromSeedECDSAsecp256k1(t35) {
    return new _g(await PrivateKey.fromSeedECDSAsecp256k1(t35));
  }
  static async fromMnemonic(t35, r41 = "") {
    return new _g(t35 instanceof a ? await PrivateKey.fromMnemonic(t35._mnemonic, r41) : await PrivateKey.fromMnemonic(t35, r41));
  }
  static async fromKeystore(t35, r41 = "") {
    return new _g(await PrivateKey.fromKeystore(t35, r41));
  }
  static async fromPem(t35, r41 = "") {
    return new _g(await PrivateKey.fromPem(t35, r41));
  }
  async derive(t35) {
    return new _g(await this._key.derive(t35));
  }
  async legacyDerive(t35) {
    return new _g(await this._key.legacyDerive(t35));
  }
  get publicKey() {
    return new i(this._key.publicKey);
  }
  get chainCode() {
    return this._key._chainCode;
  }
  sign(t35) {
    return this._key.sign(t35);
  }
  signTransaction(t35, e39 = false) {
    if (e39) return this._signTransactionLegacy(t35);
    const n31 = new e2();
    for (const e40 of t35._signedTransactions.list) {
      const t36 = e40.bodyBytes;
      if (!t36) throw new Error("Body bytes are missing");
      const i17 = import_proto2.proto.TransactionBody.decode(t36);
      if (!i17.transactionID || !i17.nodeAccountID) throw new Error("Transaction ID or Node Account ID not found in the signed transaction");
      const o32 = y3._fromProtobuf(i17.nodeAccountID), s26 = i4._fromProtobuf(i17.transactionID), a23 = this._key.sign(t36);
      n31.addSignature(o32, s26, this.publicKey, a23);
    }
    return t35.addSignature(this.publicKey, n31), n31;
  }
  _signTransactionLegacy(t35) {
    const e39 = t35._signedTransactions.list.map(((t36) => {
      const e40 = t36.bodyBytes;
      return e40 ? this._key.sign(e40) : new Uint8Array();
    }));
    return t35.addSignature(this.publicKey, e39), 1 === e39.length ? e39[0] : e39;
  }
  isDerivable() {
    return this._key.isDerivable();
  }
  toBytes() {
    return this._key.toBytes();
  }
  toBytesDer() {
    return this._key.toBytesDer();
  }
  toBytesRaw() {
    return this._key.toBytesRaw();
  }
  toString() {
    return this._key.toStringDer();
  }
  toStringDer() {
    return this._key.toStringDer();
  }
  toStringRaw() {
    return this._key.toStringRaw();
  }
  toKeystore(t35 = "") {
    return this._key.toKeystore(t35);
  }
  _toProtobufKey() {
    return this.publicKey._toProtobufKey();
  }
  toAccountId(t35, e39) {
    return this.publicKey.toAccountId(t35, e39);
  }
  get type() {
    return this._key._type;
  }
  getRecoveryId(t35, e39, r41) {
    return this._key.getRecoveryId(t35, e39, r41);
  }
  static getAlgorithm(t35) {
    if (!_g.isDerKey(t35)) throw new Error("Only der keys are supported");
    const e39 = new t8(Uint8Array.from(r(t35)));
    e39.read();
    return e39.getOidKeyTypes()[0];
  }
  static isDerKey(t35) {
    try {
      const e39 = Uint8Array.from(r(t35));
      return new t8(e39).read(), true;
    } catch (t36) {
      return false;
    }
  }
};
t.setPrivateKeyConstructor(((t35) => new g3(t35)));

// node_modules/@hashgraph/sdk/lib/KeyList.js
var s4 = class _s extends t2 {
  constructor(e39, s26) {
    super(), this._keys = null == e39 ? [] : e39 instanceof t2 ? [e39] : e39, this._threshold = null == s26 ? null : s26;
  }
  static of(...t35) {
    return new _s(t35, null);
  }
  static from(t35, e39, r41) {
    return new _s(null == e39 ? Array.from(t35) : Array.from(t35, e39, r41));
  }
  get threshold() {
    return this._threshold;
  }
  setThreshold(t35) {
    return this._threshold = t35, this;
  }
  push(...t35) {
    return this._keys.push(...t35);
  }
  splice(t35, e39, ...r41) {
    return new _s(this._keys.splice(t35, e39, ...r41), this.threshold);
  }
  slice(t35, e39) {
    return new _s(this._keys.slice(t35, e39), this.threshold);
  }
  [Symbol.iterator]() {
    return this._keys[Symbol.iterator]();
  }
  toArray() {
    return this._keys.slice();
  }
  toString() {
    return JSON.stringify({ threshold: this._threshold, keys: this._keys.toString() });
  }
  _toProtobufKey() {
    const t35 = this._keys.map(((t36) => t36._toProtobufKey()));
    return null == this.threshold ? { keyList: { keys: t35 } } : { thresholdKey: { threshold: this.threshold, keys: { keys: t35 } } };
  }
  static __fromProtobufKeyList(e39) {
    const r41 = (null != e39.keys ? e39.keys : []).map(((e40) => t2._fromProtobufKey(e40)));
    return new _s(r41);
  }
  static __fromProtobufThresoldKey(t35) {
    const e39 = _s.__fromProtobufKeyList(null != t35.keys ? t35.keys : {});
    return e39.setThreshold(null != t35.threshold ? t35.threshold : 0), e39;
  }
};
t.setKeyList(((t35) => s4.__fromProtobufKeyList(t35))), t.setThresholdKey(((t35) => s4.__fromProtobufThresoldKey(t35)));

// node_modules/@hashgraph/sdk/lib/long.js
function i5(i17) {
  return bignumber_default.isBigNumber(i17) ? i17 : new bignumber_default(i17.toString());
}

// node_modules/@hashgraph/sdk/lib/HbarUnit.js
var e3 = class _e {
  constructor(r41, e39, a23) {
    this._name = r41, this._symbol = e39, this._tinybar = a23, Object.freeze(this);
  }
  static fromString(r41) {
    switch (r41) {
      case _e.Hbar._symbol:
        return _e.Hbar;
      case _e.Tinybar._symbol:
        return _e.Tinybar;
      case _e.Microbar._symbol:
        return _e.Microbar;
      case _e.Millibar._symbol:
        return _e.Millibar;
      case _e.Kilobar._symbol:
        return _e.Kilobar;
      case _e.Megabar._symbol:
        return _e.Megabar;
      case _e.Gigabar._symbol:
        return _e.Gigabar;
      default:
        throw new Error("Unknown unit.");
    }
  }
};
e3.Tinybar = new e3("tinybar", "t", new bignumber_default(1)), e3.Microbar = new e3("microbar", "", new bignumber_default(100)), e3.Millibar = new e3("millibar", "m", new bignumber_default(1e5)), e3.Hbar = new e3("hbar", "", new bignumber_default("100000000")), e3.Kilobar = new e3("kilobar", "k", new bignumber_default(1e3).multipliedBy(new bignumber_default("100000000"))), e3.Megabar = new e3("megabar", "M", new bignumber_default(1e6).multipliedBy(new bignumber_default("100000000"))), e3.Gigabar = new e3("gigabar", "G", new bignumber_default("1000000000").multipliedBy(new bignumber_default("100000000")));

// node_modules/@hashgraph/sdk/lib/Hbar.js
var e4 = class _e {
  constructor(e39, a23 = e3.Hbar) {
    if (a23 === e3.Tinybar) this._valueInTinybar = i5(e39);
    else {
      let i17;
      i17 = long_default.isLong(e39) ? new bignumber_default(e39.toString(10)) : bignumber_default.isBigNumber(e39) || "string" == typeof e39 || "number" == typeof e39 ? new bignumber_default(e39) : new bignumber_default(0), this._valueInTinybar = i17.multipliedBy(a23._tinybar);
    }
    if (!this._valueInTinybar.isInteger()) throw new Error("Hbar in tinybars contains decimals");
  }
  static from(r41, i17) {
    return new _e(r41, i17);
  }
  static fromTinybars(r41) {
    return "string" == typeof r41 ? this.fromString(r41, e3.Tinybar) : new _e(r41, e3.Tinybar);
  }
  static fromString(i17, n31 = e3.Hbar) {
    if (/^((?:\+|-)?\d+(?:\.\d+)?)(?: (t||m||k|M|G))?$/.test(i17)) {
      let [a23, s26] = i17.split(" ");
      return null != s26 && (n31 = e3.fromString(s26)), new _e(new bignumber_default(a23), n31);
    }
    throw new Error("invalid argument provided");
  }
  to(r41) {
    return this._valueInTinybar.dividedBy(r41._tinybar);
  }
  toBigNumber() {
    return this.to(e3.Hbar);
  }
  toTinybars() {
    return long_default.fromValue(this._valueInTinybar.toFixed());
  }
  negated() {
    return _e.fromTinybars(this._valueInTinybar.negated());
  }
  isNegative() {
    return this._valueInTinybar.isNegative();
  }
  toString(r41) {
    return null != r41 ? `${this._valueInTinybar.dividedBy(r41._tinybar).toString()} ${r41._symbol}` : this._valueInTinybar.isLessThan(1e4) && this._valueInTinybar.isGreaterThan(-1e4) ? `${this._valueInTinybar.toFixed()} ${e3.Tinybar._symbol}` : `${this.to(e3.Hbar).toString()} ${e3.Hbar._symbol}`;
  }
};

// node_modules/@hashgraph/sdk/lib/StatusError.js
var t9 = class _t extends Error {
  constructor(s26, r41) {
    super(r41), this.name = "StatusError", this.status = s26.status, this.transactionId = s26.transactionId, this.message = r41, void 0 !== Error.captureStackTrace && Error.captureStackTrace(this, _t);
  }
  toJSON() {
    return { name: this.name, status: this.status.toString(), transactionId: this.transactionId.toString(), message: this.message };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  valueOf() {
    return this.toJSON();
  }
};

// node_modules/@hashgraph/sdk/lib/ReceiptStatusError.js
var r6 = class extends t9 {
  constructor(t35) {
    super(t35, `receipt for transaction ${t35.transactionId.toString()} contained error status ${t35.status.toString()}`), this.transactionReceipt = t35.transactionReceipt;
  }
};

// node_modules/@hashgraph/sdk/lib/Status.js
var e5 = class _e {
  constructor(e39) {
    this._code = e39, Object.freeze(this);
  }
  toString() {
    switch (this) {
      case _e.Ok:
        return "OK";
      case _e.InvalidTransaction:
        return "INVALID_TRANSACTION";
      case _e.PayerAccountNotFound:
        return "PAYER_ACCOUNT_NOT_FOUND";
      case _e.InvalidNodeAccount:
        return "INVALID_NODE_ACCOUNT";
      case _e.TransactionExpired:
        return "TRANSACTION_EXPIRED";
      case _e.InvalidTransactionStart:
        return "INVALID_TRANSACTION_START";
      case _e.InvalidTransactionDuration:
        return "INVALID_TRANSACTION_DURATION";
      case _e.InvalidSignature:
        return "INVALID_SIGNATURE";
      case _e.MemoTooLong:
        return "MEMO_TOO_LONG";
      case _e.InsufficientTxFee:
        return "INSUFFICIENT_TX_FEE";
      case _e.InsufficientPayerBalance:
        return "INSUFFICIENT_PAYER_BALANCE";
      case _e.DuplicateTransaction:
        return "DUPLICATE_TRANSACTION";
      case _e.Busy:
        return "BUSY";
      case _e.NotSupported:
        return "NOT_SUPPORTED";
      case _e.InvalidFileId:
        return "INVALID_FILE_ID";
      case _e.InvalidAccountId:
        return "INVALID_ACCOUNT_ID";
      case _e.InvalidContractId:
        return "INVALID_CONTRACT_ID";
      case _e.InvalidTransactionId:
        return "INVALID_TRANSACTION_ID";
      case _e.ReceiptNotFound:
        return "RECEIPT_NOT_FOUND";
      case _e.RecordNotFound:
        return "RECORD_NOT_FOUND";
      case _e.InvalidSolidityId:
        return "INVALID_SOLIDITY_ID";
      case _e.Unknown:
        return "UNKNOWN";
      case _e.Success:
        return "SUCCESS";
      case _e.FailInvalid:
        return "FAIL_INVALID";
      case _e.FailFee:
        return "FAIL_FEE";
      case _e.FailBalance:
        return "FAIL_BALANCE";
      case _e.KeyRequired:
        return "KEY_REQUIRED";
      case _e.BadEncoding:
        return "BAD_ENCODING";
      case _e.InsufficientAccountBalance:
        return "INSUFFICIENT_ACCOUNT_BALANCE";
      case _e.InvalidSolidityAddress:
        return "INVALID_SOLIDITY_ADDRESS";
      case _e.InsufficientGas:
        return "INSUFFICIENT_GAS";
      case _e.ContractSizeLimitExceeded:
        return "CONTRACT_SIZE_LIMIT_EXCEEDED";
      case _e.LocalCallModificationException:
        return "LOCAL_CALL_MODIFICATION_EXCEPTION";
      case _e.ContractRevertExecuted:
        return "CONTRACT_REVERT_EXECUTED";
      case _e.ContractExecutionException:
        return "CONTRACT_EXECUTION_EXCEPTION";
      case _e.InvalidReceivingNodeAccount:
        return "INVALID_RECEIVING_NODE_ACCOUNT";
      case _e.MissingQueryHeader:
        return "MISSING_QUERY_HEADER";
      case _e.AccountUpdateFailed:
        return "ACCOUNT_UPDATE_FAILED";
      case _e.InvalidKeyEncoding:
        return "INVALID_KEY_ENCODING";
      case _e.NullSolidityAddress:
        return "NULL_SOLIDITY_ADDRESS";
      case _e.ContractUpdateFailed:
        return "CONTRACT_UPDATE_FAILED";
      case _e.InvalidQueryHeader:
        return "INVALID_QUERY_HEADER";
      case _e.InvalidFeeSubmitted:
        return "INVALID_FEE_SUBMITTED";
      case _e.InvalidPayerSignature:
        return "INVALID_PAYER_SIGNATURE";
      case _e.KeyNotProvided:
        return "KEY_NOT_PROVIDED";
      case _e.InvalidExpirationTime:
        return "INVALID_EXPIRATION_TIME";
      case _e.NoWaclKey:
        return "NO_WACL_KEY";
      case _e.FileContentEmpty:
        return "FILE_CONTENT_EMPTY";
      case _e.InvalidAccountAmounts:
        return "INVALID_ACCOUNT_AMOUNTS";
      case _e.EmptyTransactionBody:
        return "EMPTY_TRANSACTION_BODY";
      case _e.InvalidTransactionBody:
        return "INVALID_TRANSACTION_BODY";
      case _e.InvalidSignatureTypeMismatchingKey:
        return "INVALID_SIGNATURE_TYPE_MISMATCHING_KEY";
      case _e.InvalidSignatureCountMismatchingKey:
        return "INVALID_SIGNATURE_COUNT_MISMATCHING_KEY";
      case _e.EmptyLiveHashBody:
        return "EMPTY_LIVE_HASH_BODY";
      case _e.EmptyLiveHash:
        return "EMPTY_LIVE_HASH";
      case _e.EmptyLiveHashKeys:
        return "EMPTY_LIVE_HASH_KEYS";
      case _e.InvalidLiveHashSize:
        return "INVALID_LIVE_HASH_SIZE";
      case _e.EmptyQueryBody:
        return "EMPTY_QUERY_BODY";
      case _e.EmptyLiveHashQuery:
        return "EMPTY_LIVE_HASH_QUERY";
      case _e.LiveHashNotFound:
        return "LIVE_HASH_NOT_FOUND";
      case _e.AccountIdDoesNotExist:
        return "ACCOUNT_ID_DOES_NOT_EXIST";
      case _e.LiveHashAlreadyExists:
        return "LIVE_HASH_ALREADY_EXISTS";
      case _e.InvalidFileWacl:
        return "INVALID_FILE_WACL";
      case _e.SerializationFailed:
        return "SERIALIZATION_FAILED";
      case _e.TransactionOversize:
        return "TRANSACTION_OVERSIZE";
      case _e.TransactionTooManyLayers:
        return "TRANSACTION_TOO_MANY_LAYERS";
      case _e.ContractDeleted:
        return "CONTRACT_DELETED";
      case _e.PlatformNotActive:
        return "PLATFORM_NOT_ACTIVE";
      case _e.KeyPrefixMismatch:
        return "KEY_PREFIX_MISMATCH";
      case _e.PlatformTransactionNotCreated:
        return "PLATFORM_TRANSACTION_NOT_CREATED";
      case _e.InvalidRenewalPeriod:
        return "INVALID_RENEWAL_PERIOD";
      case _e.InvalidPayerAccountId:
        return "INVALID_PAYER_ACCOUNT_ID";
      case _e.AccountDeleted:
        return "ACCOUNT_DELETED";
      case _e.FileDeleted:
        return "FILE_DELETED";
      case _e.AccountRepeatedInAccountAmounts:
        return "ACCOUNT_REPEATED_IN_ACCOUNT_AMOUNTS";
      case _e.SettingNegativeAccountBalance:
        return "SETTING_NEGATIVE_ACCOUNT_BALANCE";
      case _e.ObtainerRequired:
        return "OBTAINER_REQUIRED";
      case _e.ObtainerSameContractId:
        return "OBTAINER_SAME_CONTRACT_ID";
      case _e.ObtainerDoesNotExist:
        return "OBTAINER_DOES_NOT_EXIST";
      case _e.ModifyingImmutableContract:
        return "MODIFYING_IMMUTABLE_CONTRACT";
      case _e.FileSystemException:
        return "FILE_SYSTEM_EXCEPTION";
      case _e.AutorenewDurationNotInRange:
        return "AUTORENEW_DURATION_NOT_IN_RANGE";
      case _e.ErrorDecodingBytestring:
        return "ERROR_DECODING_BYTESTRING";
      case _e.ContractFileEmpty:
        return "CONTRACT_FILE_EMPTY";
      case _e.ContractBytecodeEmpty:
        return "CONTRACT_BYTECODE_EMPTY";
      case _e.InvalidInitialBalance:
        return "INVALID_INITIAL_BALANCE";
      case _e.InvalidReceiveRecordThreshold:
        return "INVALID_RECEIVE_RECORD_THRESHOLD";
      case _e.InvalidSendRecordThreshold:
        return "INVALID_SEND_RECORD_THRESHOLD";
      case _e.AccountIsNotGenesisAccount:
        return "ACCOUNT_IS_NOT_GENESIS_ACCOUNT";
      case _e.PayerAccountUnauthorized:
        return "PAYER_ACCOUNT_UNAUTHORIZED";
      case _e.InvalidFreezeTransactionBody:
        return "INVALID_FREEZE_TRANSACTION_BODY";
      case _e.FreezeTransactionBodyNotFound:
        return "FREEZE_TRANSACTION_BODY_NOT_FOUND";
      case _e.TransferListSizeLimitExceeded:
        return "TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
      case _e.ResultSizeLimitExceeded:
        return "RESULT_SIZE_LIMIT_EXCEEDED";
      case _e.NotSpecialAccount:
        return "NOT_SPECIAL_ACCOUNT";
      case _e.ContractNegativeGas:
        return "CONTRACT_NEGATIVE_GAS";
      case _e.ContractNegativeValue:
        return "CONTRACT_NEGATIVE_VALUE";
      case _e.InvalidFeeFile:
        return "INVALID_FEE_FILE";
      case _e.InvalidExchangeRateFile:
        return "INVALID_EXCHANGE_RATE_FILE";
      case _e.InsufficientLocalCallGas:
        return "INSUFFICIENT_LOCAL_CALL_GAS";
      case _e.EntityNotAllowedToDelete:
        return "ENTITY_NOT_ALLOWED_TO_DELETE";
      case _e.AuthorizationFailed:
        return "AUTHORIZATION_FAILED";
      case _e.FileUploadedProtoInvalid:
        return "FILE_UPLOADED_PROTO_INVALID";
      case _e.FileUploadedProtoNotSavedToDisk:
        return "FILE_UPLOADED_PROTO_NOT_SAVED_TO_DISK";
      case _e.FeeScheduleFilePartUploaded:
        return "FEE_SCHEDULE_FILE_PART_UPLOADED";
      case _e.ExchangeRateChangeLimitExceeded:
        return "EXCHANGE_RATE_CHANGE_LIMIT_EXCEEDED";
      case _e.MaxContractStorageExceeded:
        return "MAX_CONTRACT_STORAGE_EXCEEDED";
      case _e.TransferAccountSameAsDeleteAccount:
        return "TRANSFER_ACCOUNT_SAME_AS_DELETE_ACCOUNT";
      case _e.TotalLedgerBalanceInvalid:
        return "TOTAL_LEDGER_BALANCE_INVALID";
      case _e.ExpirationReductionNotAllowed:
        return "EXPIRATION_REDUCTION_NOT_ALLOWED";
      case _e.MaxGasLimitExceeded:
        return "MAX_GAS_LIMIT_EXCEEDED";
      case _e.MaxFileSizeExceeded:
        return "MAX_FILE_SIZE_EXCEEDED";
      case _e.ReceiverSigRequired:
        return "RECEIVER_SIG_REQUIRED";
      case _e.InvalidTopicId:
        return "INVALID_TOPIC_ID";
      case _e.InvalidAdminKey:
        return "INVALID_ADMIN_KEY";
      case _e.InvalidSubmitKey:
        return "INVALID_SUBMIT_KEY";
      case _e.Unauthorized:
        return "UNAUTHORIZED";
      case _e.InvalidTopicMessage:
        return "INVALID_TOPIC_MESSAGE";
      case _e.InvalidAutorenewAccount:
        return "INVALID_AUTORENEW_ACCOUNT";
      case _e.AutorenewAccountNotAllowed:
        return "AUTORENEW_ACCOUNT_NOT_ALLOWED";
      case _e.TopicExpired:
        return "TOPIC_EXPIRED";
      case _e.InvalidChunkNumber:
        return "INVALID_CHUNK_NUMBER";
      case _e.InvalidChunkTransactionId:
        return "INVALID_CHUNK_TRANSACTION_ID";
      case _e.AccountFrozenForToken:
        return "ACCOUNT_FROZEN_FOR_TOKEN";
      case _e.TokensPerAccountLimitExceeded:
        return "TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED";
      case _e.InvalidTokenId:
        return "INVALID_TOKEN_ID";
      case _e.InvalidTokenDecimals:
        return "INVALID_TOKEN_DECIMALS";
      case _e.InvalidTokenInitialSupply:
        return "INVALID_TOKEN_INITIAL_SUPPLY";
      case _e.InvalidTreasuryAccountForToken:
        return "INVALID_TREASURY_ACCOUNT_FOR_TOKEN";
      case _e.InvalidTokenSymbol:
        return "INVALID_TOKEN_SYMBOL";
      case _e.TokenHasNoFreezeKey:
        return "TOKEN_HAS_NO_FREEZE_KEY";
      case _e.TransfersNotZeroSumForToken:
        return "TRANSFERS_NOT_ZERO_SUM_FOR_TOKEN";
      case _e.MissingTokenSymbol:
        return "MISSING_TOKEN_SYMBOL";
      case _e.TokenSymbolTooLong:
        return "TOKEN_SYMBOL_TOO_LONG";
      case _e.AccountKycNotGrantedForToken:
        return "ACCOUNT_KYC_NOT_GRANTED_FOR_TOKEN";
      case _e.TokenHasNoKycKey:
        return "TOKEN_HAS_NO_KYC_KEY";
      case _e.InsufficientTokenBalance:
        return "INSUFFICIENT_TOKEN_BALANCE";
      case _e.TokenWasDeleted:
        return "TOKEN_WAS_DELETED";
      case _e.TokenHasNoSupplyKey:
        return "TOKEN_HAS_NO_SUPPLY_KEY";
      case _e.TokenHasNoWipeKey:
        return "TOKEN_HAS_NO_WIPE_KEY";
      case _e.InvalidTokenMintAmount:
        return "INVALID_TOKEN_MINT_AMOUNT";
      case _e.InvalidTokenBurnAmount:
        return "INVALID_TOKEN_BURN_AMOUNT";
      case _e.TokenNotAssociatedToAccount:
        return "TOKEN_NOT_ASSOCIATED_TO_ACCOUNT";
      case _e.CannotWipeTokenTreasuryAccount:
        return "CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT";
      case _e.InvalidKycKey:
        return "INVALID_KYC_KEY";
      case _e.InvalidWipeKey:
        return "INVALID_WIPE_KEY";
      case _e.InvalidFreezeKey:
        return "INVALID_FREEZE_KEY";
      case _e.InvalidSupplyKey:
        return "INVALID_SUPPLY_KEY";
      case _e.MissingTokenName:
        return "MISSING_TOKEN_NAME";
      case _e.TokenNameTooLong:
        return "TOKEN_NAME_TOO_LONG";
      case _e.InvalidWipingAmount:
        return "INVALID_WIPING_AMOUNT";
      case _e.TokenIsImmutable:
        return "TOKEN_IS_IMMUTABLE";
      case _e.TokenAlreadyAssociatedToAccount:
        return "TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT";
      case _e.TransactionRequiresZeroTokenBalances:
        return "TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES";
      case _e.AccountIsTreasury:
        return "ACCOUNT_IS_TREASURY";
      case _e.TokenIdRepeatedInTokenList:
        return "TOKEN_ID_REPEATED_IN_TOKEN_LIST";
      case _e.TokenTransferListSizeLimitExceeded:
        return "TOKEN_TRANSFER_LIST_SIZE_LIMIT_EXCEEDED";
      case _e.EmptyTokenTransferBody:
        return "EMPTY_TOKEN_TRANSFER_BODY";
      case _e.EmptyTokenTransferAccountAmounts:
        return "EMPTY_TOKEN_TRANSFER_ACCOUNT_AMOUNTS";
      case _e.InvalidScheduleId:
        return "INVALID_SCHEDULE_ID";
      case _e.ScheduleIsImmutable:
        return "SCHEDULE_IS_IMMUTABLE";
      case _e.InvalidSchedulePayerId:
        return "INVALID_SCHEDULE_PAYER_ID";
      case _e.InvalidScheduleAccountId:
        return "INVALID_SCHEDULE_ACCOUNT_ID";
      case _e.NoNewValidSignatures:
        return "NO_NEW_VALID_SIGNATURES";
      case _e.UnresolvableRequiredSigners:
        return "UNRESOLVABLE_REQUIRED_SIGNERS";
      case _e.ScheduledTransactionNotInWhitelist:
        return "SCHEDULED_TRANSACTION_NOT_IN_WHITELIST";
      case _e.SomeSignaturesWereInvalid:
        return "SOME_SIGNATURES_WERE_INVALID";
      case _e.TransactionIdFieldNotAllowed:
        return "TRANSACTION_ID_FIELD_NOT_ALLOWED";
      case _e.IdenticalScheduleAlreadyCreated:
        return "IDENTICAL_SCHEDULE_ALREADY_CREATED";
      case _e.InvalidZeroByteInString:
        return "INVALID_ZERO_BYTE_IN_STRING";
      case _e.ScheduleAlreadyDeleted:
        return "SCHEDULE_ALREADY_DELETED";
      case _e.ScheduleAlreadyExecuted:
        return "SCHEDULE_ALREADY_EXECUTED";
      case _e.MessageSizeTooLarge:
        return "MESSAGE_SIZE_TOO_LARGE";
      case _e.OperationRepeatedInBucketGroups:
        return "OPERATION_REPEATED_IN_BUCKET_GROUPS";
      case _e.BucketCapacityOverflow:
        return "BUCKET_CAPACITY_OVERFLOW";
      case _e.NodeCapacityNotSufficientForOperation:
        return "NODE_CAPACITY_NOT_SUFFICIENT_FOR_OPERATION";
      case _e.BucketHasNoThrottleGroups:
        return "BUCKET_HAS_NO_THROTTLE_GROUPS";
      case _e.ThrottleGroupHasZeroOpsPerSec:
        return "THROTTLE_GROUP_HAS_ZERO_OPS_PER_SEC";
      case _e.SuccessButMissingExpectedOperation:
        return "SUCCESS_BUT_MISSING_EXPECTED_OPERATION";
      case _e.UnparseableThrottleDefinitions:
        return "UNPARSEABLE_THROTTLE_DEFINITIONS";
      case _e.InvalidThrottleDefinitions:
        return "INVALID_THROTTLE_DEFINITIONS";
      case _e.AccountExpiredAndPendingRemoval:
        return "ACCOUNT_EXPIRED_AND_PENDING_REMOVAL";
      case _e.InvalidTokenMaxSupply:
        return "INVALID_TOKEN_MAX_SUPPLY";
      case _e.InvalidTokenNftSerialNumber:
        return "INVALID_TOKEN_NFT_SERIAL_NUMBER";
      case _e.InvalidNftId:
        return "INVALID_NFT_ID";
      case _e.MetadataTooLong:
        return "METADATA_TOO_LONG";
      case _e.BatchSizeLimitExceeded:
        return "BATCH_SIZE_LIMIT_EXCEEDED";
      case _e.InvalidQueryRange:
        return "INVALID_QUERY_RANGE";
      case _e.FractionDividesByZero:
        return "FRACTION_DIVIDES_BY_ZERO";
      case _e.InsufficientPayerBalanceForCustomFee:
        return "INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE";
      case _e.CustomFeesListTooLong:
        return "CUSTOM_FEES_LIST_TOO_LONG";
      case _e.InvalidCustomFeeCollector:
        return "INVALID_CUSTOM_FEE_COLLECTOR";
      case _e.InvalidTokenIdInCustomFees:
        return "INVALID_TOKEN_ID_IN_CUSTOM_FEES";
      case _e.TokenNotAssociatedToFeeCollector:
        return "TOKEN_NOT_ASSOCIATED_TO_FEE_COLLECTOR";
      case _e.TokenMaxSupplyReached:
        return "TOKEN_MAX_SUPPLY_REACHED";
      case _e.SenderDoesNotOwnNftSerialNo:
        return "SENDER_DOES_NOT_OWN_NFT_SERIAL_NO";
      case _e.CustomFeeNotFullySpecified:
        return "CUSTOM_FEE_NOT_FULLY_SPECIFIED";
      case _e.CustomFeeMustBePositive:
        return "CUSTOM_FEE_MUST_BE_POSITIVE";
      case _e.TokenHasNoFeeScheduleKey:
        return "TOKEN_HAS_NO_FEE_SCHEDULE_KEY";
      case _e.CustomFeeOutsideNumericRange:
        return "CUSTOM_FEE_OUTSIDE_NUMERIC_RANGE";
      case _e.RoyaltyFractionCannotExceedOne:
        return "ROYALTY_FRACTION_CANNOT_EXCEED_ONE";
      case _e.FractionalFeeMaxAmountLessThanMinAmount:
        return "FRACTIONAL_FEE_MAX_AMOUNT_LESS_THAN_MIN_AMOUNT";
      case _e.CustomScheduleAlreadyHasNoFees:
        return "CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES";
      case _e.CustomFeeDenominationMustBeFungibleCommon:
        return "CUSTOM_FEE_DENOMINATION_MUST_BE_FUNGIBLE_COMMON";
      case _e.CustomFractionalFeeOnlyAllowedForFungibleCommon:
        return "CUSTOM_FRACTIONAL_FEE_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
      case _e.InvalidCustomFeeScheduleKey:
        return "INVALID_CUSTOM_FEE_SCHEDULE_KEY";
      case _e.InvalidTokenMintMetadata:
        return "INVALID_TOKEN_MINT_METADATA";
      case _e.InvalidTokenBurnMetadata:
        return "INVALID_TOKEN_BURN_METADATA";
      case _e.CurrentTreasuryStillOwnsNfts:
        return "CURRENT_TREASURY_STILL_OWNS_NFTS";
      case _e.AccountStillOwnsNfts:
        return "ACCOUNT_STILL_OWNS_NFTS";
      case _e.TreasuryMustOwnBurnedNft:
        return "TREASURY_MUST_OWN_BURNED_NFT";
      case _e.AccountDoesNotOwnWipedNft:
        return "ACCOUNT_DOES_NOT_OWN_WIPED_NFT";
      case _e.AccountAmountTransfersOnlyAllowedForFungibleCommon:
        return "ACCOUNT_AMOUNT_TRANSFERS_ONLY_ALLOWED_FOR_FUNGIBLE_COMMON";
      case _e.MaxNftsInPriceRegimeHaveBeenMinted:
        return "MAX_NFTS_IN_PRICE_REGIME_HAVE_BEEN_MINTED";
      case _e.PayerAccountDeleted:
        return "PAYER_ACCOUNT_DELETED";
      case _e.CustomFeeChargingExceededMaxRecursionDepth:
        return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_RECURSION_DEPTH";
      case _e.CustomFeeChargingExceededMaxAccountAmounts:
        return "CUSTOM_FEE_CHARGING_EXCEEDED_MAX_ACCOUNT_AMOUNTS";
      case _e.InsufficientSenderAccountBalanceForCustomFee:
        return "INSUFFICIENT_SENDER_ACCOUNT_BALANCE_FOR_CUSTOM_FEE";
      case _e.SerialNumberLimitReached:
        return "SERIAL_NUMBER_LIMIT_REACHED";
      case _e.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique:
        return "CUSTOM_ROYALTY_FEE_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE";
      case _e.NoRemainingAutomaticAssociations:
        return "NO_REMAINING_AUTOMATIC_ASSOCIATIONS";
      case _e.ExistingAutomaticAssociationsExceedGivenLimit:
        return "EXISTING_AUTOMATIC_ASSOCIATIONS_EXCEED_GIVEN_LIMIT";
      case _e.RequestedNumAutomaticAssociationsExceedsAssociationLimit:
        return "REQUESTED_NUM_AUTOMATIC_ASSOCIATIONS_EXCEEDS_ASSOCIATION_LIMIT";
      case _e.TokenIsPaused:
        return "TOKEN_IS_PAUSED";
      case _e.TokenHasNoPauseKey:
        return "TOKEN_HAS_NO_PAUSE_KEY";
      case _e.InvalidPauseKey:
        return "INVALID_PAUSE_KEY";
      case _e.FreezeUpdateFileDoesNotExist:
        return "FREEZE_UPDATE_FILE_DOES_NOT_EXIST";
      case _e.FreezeUpdateFileHashDoesNotMatch:
        return "FREEZE_UPDATE_FILE_HASH_DOES_NOT_MATCH";
      case _e.NoUpgradeHasBeenPrepared:
        return "NO_UPGRADE_HAS_BEEN_PREPARED";
      case _e.NoFreezeIsScheduled:
        return "NO_FREEZE_IS_SCHEDULED";
      case _e.UpdateFileHashChangedSincePrepareUpgrade:
        return "UPDATE_FILE_HASH_CHANGED_SINCE_PREPARE_UPGRADE";
      case _e.FreezeStartTimeMustBeFuture:
        return "FREEZE_START_TIME_MUST_BE_FUTURE";
      case _e.PreparedUpdateFileIsImmutable:
        return "PREPARED_UPDATE_FILE_IS_IMMUTABLE";
      case _e.FreezeAlreadyScheduled:
        return "FREEZE_ALREADY_SCHEDULED";
      case _e.FreezeUpgradeInProgress:
        return "FREEZE_UPGRADE_IN_PROGRESS";
      case _e.UpdateFileIdDoesNotMatchPrepared:
        return "UPDATE_FILE_ID_DOES_NOT_MATCH_PREPARED";
      case _e.UpdateFileHashDoesNotMatchPrepared:
        return "UPDATE_FILE_HASH_DOES_NOT_MATCH_PREPARED";
      case _e.ConsensusGasExhausted:
        return "CONSENSUS_GAS_EXHAUSTED";
      case _e.RevertedSuccess:
        return "REVERTED_SUCCESS";
      case _e.MaxStorageInPriceRegimeHasBeenUsed:
        return "MAX_STORAGE_IN_PRICE_REGIME_HAS_BEEN_USED";
      case _e.InvalidAliasKey:
        return "INVALID_ALIAS_KEY";
      case _e.UnexpectedTokenDecimals:
        return "UNEXPECTED_TOKEN_DECIMALS";
      case _e.InvalidProxyAccountId:
        return "INVALID_PROXY_ACCOUNT_ID";
      case _e.InvalidTransferAccountId:
        return "INVALID_TRANSFER_ACCOUNT_ID";
      case _e.InvalidFeeCollectorAccountId:
        return "INVALID_FEE_COLLECTOR_ACCOUNT_ID";
      case _e.AliasIsImmutable:
        return "ALIAS_IS_IMMUTABLE";
      case _e.SpenderAccountSameAsOwner:
        return "SPENDER_ACCOUNT_SAME_AS_OWNER";
      case _e.AmountExceedsTokenMaxSupply:
        return "AMOUNT_EXCEEDS_TOKEN_MAX_SUPPLY";
      case _e.NegativeAllowanceAmount:
        return "NEGATIVE_ALLOWANCE_AMOUNT";
      case _e.CannotApproveForAllFungibleCommon:
        return "CANNOT_APPROVE_FOR_ALL_FUNGIBLE_COMMON";
      case _e.SpenderDoesNotHaveAllowance:
        return "SPENDER_DOES_NOT_HAVE_ALLOWANCE";
      case _e.AmountExceedsAllowance:
        return "AMOUNT_EXCEEDS_ALLOWANCE";
      case _e.MaxAllowancesExceeded:
        return "MAX_ALLOWANCES_EXCEEDED";
      case _e.EmptyAllowances:
        return "EMPTY_ALLOWANCES";
      case _e.SpenderAccountRepeatedInAllowances:
        return "SPENDER_ACCOUNT_REPEATED_IN_ALLOWANCES";
      case _e.RepeatedSerialNumsInNftAllowances:
        return "REPEATED_SERIAL_NUMS_IN_NFT_ALLOWANCES";
      case _e.FungibleTokenInNftAllowances:
        return "FUNGIBLE_TOKEN_IN_NFT_ALLOWANCES";
      case _e.NftInFungibleTokenAllowances:
        return "NFT_IN_FUNGIBLE_TOKEN_ALLOWANCES";
      case _e.InvalidAllowanceOwnerId:
        return "INVALID_ALLOWANCE_OWNER_ID";
      case _e.InvalidAllowanceSpenderId:
        return "INVALID_ALLOWANCE_SPENDER_ID";
      case _e.RepeatedAllowancesToDelete:
        return "REPEATED_ALLOWANCES_TO_DELETE";
      case _e.InvalidDelegatingSpender:
        return "INVALID_DELEGATING_SPENDER";
      case _e.DelegatingSpenderCannotGrantApproveForAll:
        return "DELEGATING_SPENDER_CANNOT_GRANT_APPROVE_FOR_ALL";
      case _e.DelegatingSpenderDoesNotHaveApproveForAll:
        return "DELEGATING_SPENDER_DOES_NOT_HAVE_APPROVE_FOR_ALL";
      case _e.ScheduleExpirationTimeTooFarInFuture:
        return "SCHEDULE_EXPIRATION_TIME_TOO_FAR_IN_FUTURE";
      case _e.ScheduleExpirationTimeMustBeHigherThanConsensusTime:
        return "SCHEDULE_EXPIRATION_TIME_MUST_BE_HIGHER_THAN_CONSENSUS_TIME";
      case _e.ScheduleFutureThrottleExceeded:
        return "SCHEDULE_FUTURE_THROTTLE_EXCEEDED";
      case _e.ScheduleFutureGasLimitExceeded:
        return "SCHEDULE_FUTURE_GAS_LIMIT_EXCEEDED";
      case _e.InvalidEthereumTransaction:
        return "INVALID_ETHEREUM_TRANSACTION";
      case _e.WrongChainId:
        return "WRONG_CHAIN_ID";
      case _e.WrongNonce:
        return "WRONG_NONCE";
      case _e.AccessListUnsupported:
        return "ACCESS_LIST_UNSUPPORTED";
      case _e.SchedulePendingExpiration:
        return "SCHEDULE_PENDING_EXPIRATION";
      case _e.ContractIsTokenTreasury:
        return "CONTRACT_IS_TOKEN_TREASURY";
      case _e.ContractHasNonZeroTokenBalances:
        return "CONTRACT_HAS_NON_ZERO_TOKEN_BALANCES";
      case _e.ContractExpiredAndPendingRemoval:
        return "CONTRACT_EXPIRED_AND_PENDING_REMOVAL";
      case _e.ContractHasNoAutoRenewAccount:
        return "CONTRACT_HAS_NO_AUTO_RENEW_ACCOUNT";
      case _e.PermanentRemovalRequiresSystemInitiation:
        return "PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION";
      case _e.ProxyAccountIdFieldIsDeprecated:
        return "PROXY_ACCOUNT_ID_FIELD_IS_DEPRECATED";
      case _e.SelfStakingIsNotAllowed:
        return "SELF_STAKING_IS_NOT_ALLOWED";
      case _e.InvalidStakingId:
        return "INVALID_STAKING_ID";
      case _e.StakingNotEnabled:
        return "STAKING_NOT_ENABLED";
      case _e.InvalidPrngRange:
        return "INVALID_PRNG_RANGE";
      case _e.MaxEntitiesInPriceRegimeHaveBeenCreated:
        return "MAX_ENTITIES_IN_PRICE_REGIME_HAVE_BEEN_CREATED";
      case _e.InvalidFullPrefixSignatureForPrecompile:
        return "INVALID_FULL_PREFIX_SIGNATURE_FOR_PRECOMPILE";
      case _e.InsufficientBalancesForStorageRent:
        return "INSUFFICIENT_BALANCES_FOR_STORAGE_RENT";
      case _e.MaxChildRecordsExceeded:
        return "MAX_CHILD_RECORDS_EXCEEDED";
      case _e.InsufficientBalancesForRenewalFees:
        return "INSUFFICIENT_BALANCES_FOR_RENEWAL_FEES";
      case _e.TransactionHasUnknownFields:
        return "TRANSACTION_HAS_UNKNOWN_FIELDS";
      case _e.AccountIsImmutable:
        return "ACCOUNT_IS_IMMUTABLE";
      case _e.AliasAlreadyAssigned:
        return "ALIAS_ALREADY_ASSIGNED";
      case _e.InvalidMetadataKey:
        return "INVALID_METADATA_KEY";
      case _e.TokenHasNoMetadataKey:
        return "TOKEN_HAS_NO_METADATA_KEY";
      case _e.MissingTokenMetadata:
        return "MISSING_TOKEN_METADATA";
      case _e.MissingSerialNumbers:
        return "MISSING_SERIAL_NUMBERS";
      case _e.TokenHasNoAdminKey:
        return "TOKEN_HAS_NO_ADMIN_KEY";
      case _e.NodeDeleted:
        return "NODE_DELETED";
      case _e.InvalidNodeId:
        return "INVALID_NODE_ID";
      case _e.InvalidGossipEndpoint:
        return "INVALID_GOSSIP_ENDPOINT";
      case _e.InvalidNodeAccountId:
        return "INVALID_NODE_ACCOUNT_ID";
      case _e.InvalidNodeDescription:
        return "INVALID_NODE_DESCRIPTION";
      case _e.InvalidServiceEndpoint:
        return "INVALID_SERVICE_ENDPOINT";
      case _e.InvalidGossipCaCertificate:
        return "INVALID_GOSSIP_CA_CERTIFICATE";
      case _e.InvalidGrpcCertificate:
        return "INVALID_GRPC_CERTIFICATE";
      case _e.InvalidMaxAutoAssociations:
        return "INVALID_MAX_AUTO_ASSOCIATIONS";
      case _e.MaxNodesCreated:
        return "MAX_NODES_CREATED";
      case _e.IpFqdnCannotBeSetForSameEndpoint:
        return "IP_FQDN_CANNOT_BE_SET_FOR_SAME_ENDPOINT";
      case _e.GossipEndpointCannotHaveFqdn:
        return "GOSSIP_ENDPOINT_CANNOT_HAVE_FQDN";
      case _e.FqdnSizeTooLarge:
        return "FQDN_SIZE_TOO_LARGE";
      case _e.InvalidEndpoint:
        return "INVALID_ENDPOINT";
      case _e.GossipEndpointsExceededLimit:
        return "GOSSIP_ENDPOINTS_EXCEEDED_LIMIT";
      case _e.ServiceEndpointsExceededLimit:
        return "SERVICE_ENDPOINTS_EXCEEDED_LIMIT";
      case _e.InvalidIpv4Address:
        return "INVALID_IPV4_ADDRESS";
      case _e.TokenReferenceRepeated:
        return "TOKEN_REFERENCE_REPEATED";
      case _e.InvalidOwnerId:
        return "INVALID_OWNER_ID";
      case _e.TokenReferenceListSizeLimitExceeded:
        return "TOKEN_REFERENCE_LIST_SIZE_LIMIT_EXCEEDED";
      case _e.EmptyTokenReferenceList:
        return "EMPTY_TOKEN_REFERENCE_LIST";
      case _e.UpdateNodeAccountNotAllowed:
        return "UPDATE_NODE_ACCOUNT_NOT_ALLOWED";
      case _e.TokenHasNoMetadataOrSupplyKey:
        return "TOKEN_HAS_NO_METADATA_OR_SUPPLY_KEY";
      case _e.EmptyPendingAirdropIdList:
        return "EMPTY_PENDING_AIRDROP_ID_LIST";
      case _e.PendingAirdropIdRepeated:
        return "PENDING_AIRDROP_ID_REPEATED";
      case _e.MaxPendingAirdropIdExceeded:
        return "PENDING_AIRDROP_ID_LIST_TOO_LONG";
      case _e.PendingNftAirdropAlreadyExists:
        return "PENDING_NFT_AIRDROP_ALREADY_EXISTS";
      case _e.AccountHasPendingAirdrops:
        return "ACCOUNT_HAS_PENDING_AIRDROPS";
      case _e.ThrottledAtConsensus:
        return "THROTTLED_AT_CONSENSUS";
      case _e.InvalidPendingAirdropId:
        return "INVALID_PENDING_AIRDROP_ID";
      case _e.TokenAirdropWithFallbackRoyalty:
        return "TOKEN_AIRDROP_WITH_FALLBACK_ROYALTY";
      case _e.InvalidTokenInPendingAirdrop:
        return "INVALID_TOKEN_IN_PENDING_AIRDROP";
      case _e.ScheduleExpiryIsBusy:
        return "SCHEDULE_EXPIRY_IS_BUSY";
      case _e.InvalidGrpcCertificateHash:
        return "INVALID_GRPC_CERTIFICATE_HASH";
      case _e.MissingExpiryTime:
        return "MISSING_EXPIRY_TIME";
      case _e.NoSchedulingAllowedAfterScheduledRecursion:
        return "NO_SCHEDULING_ALLOWED_AFTER_SCHEDULED_RECURSION";
      case _e.RecursiveSchedulingLimitReached:
        return "RECURSIVE_SCHEDULING_LIMIT_REACHED";
      case _e.WaitingForLedgerId:
        return "WAITING_FOR_LEDGER_ID";
      case _e.MaxEntriesForFeeExemptKeyListExceeded:
        return "MAX_ENTRIES_FOR_FEE_EXEMPT_KEY_LIST_EXCEEDED";
      case _e.FeeExemptKeyListContainsDuplicatedKeys:
        return "FEE_EXEMPT_KEY_LIST_CONTAINS_DUPLICATED_KEYS";
      case _e.InvalidKeyInFeeExemptKeyList:
        return "INVALID_KEY_IN_FEE_EXEMPT_KEY_LIST";
      case _e.InvalidFeeScheduleKey:
        return "INVALID_FEE_SCHEDULE_KEY";
      case _e.FeeScheduleKeyCannotBeUpdated:
        return "FEE_SCHEDULE_KEY_CANNOT_BE_UPDATED";
      case _e.FeeScheduleKeyNotSet:
        return "FEE_SCHEDULE_KEY_NOT_SET";
      case _e.MaxCustomFeeLimitExceeded:
        return "MAX_CUSTOM_FEE_LIMIT_EXCEEDED";
      case _e.NoValidMaxCustomFee:
        return "NO_VALID_MAX_CUSTOM_FEE";
      case _e.InvalidMaxCustomFees:
        return "INVALID_MAX_CUSTOM_FEES";
      case _e.DuplicateDenominationInMaxCustomFeeList:
        return "DUPLICATE_DENOMINATION_IN_MAX_CUSTOM_FEE_LIST";
      case _e.DuplicateAccountIdInMaxCustomFeeList:
        return "DUPLICATE_ACCOUNT_ID_IN_MAX_CUSTOM_FEE_LIST";
      case _e.MaxCustomFeesIsNotSupported:
        return "MAX_CUSTOM_FEES_IS_NOT_SUPPORTED";
      case _e.BatchListEmpty:
        return "BATCH_LIST_EMPTY";
      case _e.BatchListContainsDuplicates:
        return "BATCH_LIST_CONTAINS_DUPLICATES";
      case _e.BatchTransactionInBlacklist:
        return "BATCH_TRANSACTION_IN_BLACKLIST";
      case _e.InnerTransactionFailed:
        return "INNER_TRANSACTION_FAILED";
      case _e.MissingBatchKey:
        return "MISSING_BATCH_KEY";
      case _e.BatchKeySetOnNonInnerTransaction:
        return "BATCH_KEY_SET_ON_NON_INNER_TRANSACTION";
      case _e.InvalidBatchKey:
        return "INVALID_BATCH_KEY";
      case _e.ScheduleExpiryNotConfigurable:
        return "SCHEDULE_EXPIRY_NOT_CONFIGURABLE";
      case _e.CreatingSystemEntities:
        return "CREATING_SYSTEM_ENTITIES";
      case _e.ThrottleGroupLcmOverflow:
        return "THROTTLE_GROUP_LCM_OVERFLOW";
      case _e.AirdropContainsMultipleSendersForAToken:
        return "AIRDROP_CONTAINS_MULTIPLE_SENDERS_FOR_A_TOKEN";
      case _e.GrpcWebProxyNotSupported:
        return "GRPC_WEB_PROXY_NOT_SUPPORTED";
      case _e.NftTransfersOnlyAllowedForNonFungibleUnique:
        return "NFT_TRANSFERS_ONLY_ALLOWED_FOR_NON_FUNGIBLE_UNIQUE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(n31) {
    switch (n31) {
      case 0:
        return _e.Ok;
      case 1:
        return _e.InvalidTransaction;
      case 2:
        return _e.PayerAccountNotFound;
      case 3:
        return _e.InvalidNodeAccount;
      case 4:
        return _e.TransactionExpired;
      case 5:
        return _e.InvalidTransactionStart;
      case 6:
        return _e.InvalidTransactionDuration;
      case 7:
        return _e.InvalidSignature;
      case 8:
        return _e.MemoTooLong;
      case 9:
        return _e.InsufficientTxFee;
      case 10:
        return _e.InsufficientPayerBalance;
      case 11:
        return _e.DuplicateTransaction;
      case 12:
        return _e.Busy;
      case 13:
        return _e.NotSupported;
      case 14:
        return _e.InvalidFileId;
      case 15:
        return _e.InvalidAccountId;
      case 16:
        return _e.InvalidContractId;
      case 17:
        return _e.InvalidTransactionId;
      case 18:
        return _e.ReceiptNotFound;
      case 19:
        return _e.RecordNotFound;
      case 20:
        return _e.InvalidSolidityId;
      case 21:
        return _e.Unknown;
      case 22:
        return _e.Success;
      case 23:
        return _e.FailInvalid;
      case 24:
        return _e.FailFee;
      case 25:
        return _e.FailBalance;
      case 26:
        return _e.KeyRequired;
      case 27:
        return _e.BadEncoding;
      case 28:
        return _e.InsufficientAccountBalance;
      case 29:
        return _e.InvalidSolidityAddress;
      case 30:
        return _e.InsufficientGas;
      case 31:
        return _e.ContractSizeLimitExceeded;
      case 32:
        return _e.LocalCallModificationException;
      case 33:
        return _e.ContractRevertExecuted;
      case 34:
        return _e.ContractExecutionException;
      case 35:
        return _e.InvalidReceivingNodeAccount;
      case 36:
        return _e.MissingQueryHeader;
      case 37:
        return _e.AccountUpdateFailed;
      case 38:
        return _e.InvalidKeyEncoding;
      case 39:
        return _e.NullSolidityAddress;
      case 40:
        return _e.ContractUpdateFailed;
      case 41:
        return _e.InvalidQueryHeader;
      case 42:
        return _e.InvalidFeeSubmitted;
      case 43:
        return _e.InvalidPayerSignature;
      case 44:
        return _e.KeyNotProvided;
      case 45:
        return _e.InvalidExpirationTime;
      case 46:
        return _e.NoWaclKey;
      case 47:
        return _e.FileContentEmpty;
      case 48:
        return _e.InvalidAccountAmounts;
      case 49:
        return _e.EmptyTransactionBody;
      case 50:
        return _e.InvalidTransactionBody;
      case 51:
        return _e.InvalidSignatureTypeMismatchingKey;
      case 52:
        return _e.InvalidSignatureCountMismatchingKey;
      case 53:
        return _e.EmptyLiveHashBody;
      case 54:
        return _e.EmptyLiveHash;
      case 55:
        return _e.EmptyLiveHashKeys;
      case 56:
        return _e.InvalidLiveHashSize;
      case 57:
        return _e.EmptyQueryBody;
      case 58:
        return _e.EmptyLiveHashQuery;
      case 59:
        return _e.LiveHashNotFound;
      case 60:
        return _e.AccountIdDoesNotExist;
      case 61:
        return _e.LiveHashAlreadyExists;
      case 62:
        return _e.InvalidFileWacl;
      case 63:
        return _e.SerializationFailed;
      case 64:
        return _e.TransactionOversize;
      case 65:
        return _e.TransactionTooManyLayers;
      case 66:
        return _e.ContractDeleted;
      case 67:
        return _e.PlatformNotActive;
      case 68:
        return _e.KeyPrefixMismatch;
      case 69:
        return _e.PlatformTransactionNotCreated;
      case 70:
        return _e.InvalidRenewalPeriod;
      case 71:
        return _e.InvalidPayerAccountId;
      case 72:
        return _e.AccountDeleted;
      case 73:
        return _e.FileDeleted;
      case 74:
        return _e.AccountRepeatedInAccountAmounts;
      case 75:
        return _e.SettingNegativeAccountBalance;
      case 76:
        return _e.ObtainerRequired;
      case 77:
        return _e.ObtainerSameContractId;
      case 78:
        return _e.ObtainerDoesNotExist;
      case 79:
        return _e.ModifyingImmutableContract;
      case 80:
        return _e.FileSystemException;
      case 81:
        return _e.AutorenewDurationNotInRange;
      case 82:
        return _e.ErrorDecodingBytestring;
      case 83:
        return _e.ContractFileEmpty;
      case 84:
        return _e.ContractBytecodeEmpty;
      case 85:
        return _e.InvalidInitialBalance;
      case 86:
        return _e.InvalidReceiveRecordThreshold;
      case 87:
        return _e.InvalidSendRecordThreshold;
      case 88:
        return _e.AccountIsNotGenesisAccount;
      case 89:
        return _e.PayerAccountUnauthorized;
      case 90:
        return _e.InvalidFreezeTransactionBody;
      case 91:
        return _e.FreezeTransactionBodyNotFound;
      case 92:
        return _e.TransferListSizeLimitExceeded;
      case 93:
        return _e.ResultSizeLimitExceeded;
      case 94:
        return _e.NotSpecialAccount;
      case 95:
        return _e.ContractNegativeGas;
      case 96:
        return _e.ContractNegativeValue;
      case 97:
        return _e.InvalidFeeFile;
      case 98:
        return _e.InvalidExchangeRateFile;
      case 99:
        return _e.InsufficientLocalCallGas;
      case 100:
        return _e.EntityNotAllowedToDelete;
      case 101:
        return _e.AuthorizationFailed;
      case 102:
        return _e.FileUploadedProtoInvalid;
      case 103:
        return _e.FileUploadedProtoNotSavedToDisk;
      case 104:
        return _e.FeeScheduleFilePartUploaded;
      case 105:
        return _e.ExchangeRateChangeLimitExceeded;
      case 106:
        return _e.MaxContractStorageExceeded;
      case 107:
        return _e.TransferAccountSameAsDeleteAccount;
      case 108:
        return _e.TotalLedgerBalanceInvalid;
      case 110:
        return _e.ExpirationReductionNotAllowed;
      case 111:
        return _e.MaxGasLimitExceeded;
      case 112:
        return _e.MaxFileSizeExceeded;
      case 113:
        return _e.ReceiverSigRequired;
      case 150:
        return _e.InvalidTopicId;
      case 155:
        return _e.InvalidAdminKey;
      case 156:
        return _e.InvalidSubmitKey;
      case 157:
        return _e.Unauthorized;
      case 158:
        return _e.InvalidTopicMessage;
      case 159:
        return _e.InvalidAutorenewAccount;
      case 160:
        return _e.AutorenewAccountNotAllowed;
      case 162:
        return _e.TopicExpired;
      case 163:
        return _e.InvalidChunkNumber;
      case 164:
        return _e.InvalidChunkTransactionId;
      case 165:
        return _e.AccountFrozenForToken;
      case 166:
        return _e.TokensPerAccountLimitExceeded;
      case 167:
        return _e.InvalidTokenId;
      case 168:
        return _e.InvalidTokenDecimals;
      case 169:
        return _e.InvalidTokenInitialSupply;
      case 170:
        return _e.InvalidTreasuryAccountForToken;
      case 171:
        return _e.InvalidTokenSymbol;
      case 172:
        return _e.TokenHasNoFreezeKey;
      case 173:
        return _e.TransfersNotZeroSumForToken;
      case 174:
        return _e.MissingTokenSymbol;
      case 175:
        return _e.TokenSymbolTooLong;
      case 176:
        return _e.AccountKycNotGrantedForToken;
      case 177:
        return _e.TokenHasNoKycKey;
      case 178:
        return _e.InsufficientTokenBalance;
      case 179:
        return _e.TokenWasDeleted;
      case 180:
        return _e.TokenHasNoSupplyKey;
      case 181:
        return _e.TokenHasNoWipeKey;
      case 182:
        return _e.InvalidTokenMintAmount;
      case 183:
        return _e.InvalidTokenBurnAmount;
      case 184:
        return _e.TokenNotAssociatedToAccount;
      case 185:
        return _e.CannotWipeTokenTreasuryAccount;
      case 186:
        return _e.InvalidKycKey;
      case 187:
        return _e.InvalidWipeKey;
      case 188:
        return _e.InvalidFreezeKey;
      case 189:
        return _e.InvalidSupplyKey;
      case 190:
        return _e.MissingTokenName;
      case 191:
        return _e.TokenNameTooLong;
      case 192:
        return _e.InvalidWipingAmount;
      case 193:
        return _e.TokenIsImmutable;
      case 194:
        return _e.TokenAlreadyAssociatedToAccount;
      case 195:
        return _e.TransactionRequiresZeroTokenBalances;
      case 196:
        return _e.AccountIsTreasury;
      case 197:
        return _e.TokenIdRepeatedInTokenList;
      case 198:
        return _e.TokenTransferListSizeLimitExceeded;
      case 199:
        return _e.EmptyTokenTransferBody;
      case 200:
        return _e.EmptyTokenTransferAccountAmounts;
      case 201:
        return _e.InvalidScheduleId;
      case 202:
        return _e.ScheduleIsImmutable;
      case 203:
        return _e.InvalidSchedulePayerId;
      case 204:
        return _e.InvalidScheduleAccountId;
      case 205:
        return _e.NoNewValidSignatures;
      case 206:
        return _e.UnresolvableRequiredSigners;
      case 207:
        return _e.ScheduledTransactionNotInWhitelist;
      case 208:
        return _e.SomeSignaturesWereInvalid;
      case 209:
        return _e.TransactionIdFieldNotAllowed;
      case 210:
        return _e.IdenticalScheduleAlreadyCreated;
      case 211:
        return _e.InvalidZeroByteInString;
      case 212:
        return _e.ScheduleAlreadyDeleted;
      case 213:
        return _e.ScheduleAlreadyExecuted;
      case 214:
        return _e.MessageSizeTooLarge;
      case 215:
        return _e.OperationRepeatedInBucketGroups;
      case 216:
        return _e.BucketCapacityOverflow;
      case 217:
        return _e.NodeCapacityNotSufficientForOperation;
      case 218:
        return _e.BucketHasNoThrottleGroups;
      case 219:
        return _e.ThrottleGroupHasZeroOpsPerSec;
      case 220:
        return _e.SuccessButMissingExpectedOperation;
      case 221:
        return _e.UnparseableThrottleDefinitions;
      case 222:
        return _e.InvalidThrottleDefinitions;
      case 223:
        return _e.AccountExpiredAndPendingRemoval;
      case 224:
        return _e.InvalidTokenMaxSupply;
      case 225:
        return _e.InvalidTokenNftSerialNumber;
      case 226:
        return _e.InvalidNftId;
      case 227:
        return _e.MetadataTooLong;
      case 228:
        return _e.BatchSizeLimitExceeded;
      case 229:
        return _e.InvalidQueryRange;
      case 230:
        return _e.FractionDividesByZero;
      case 231:
        return _e.InsufficientPayerBalanceForCustomFee;
      case 232:
        return _e.CustomFeesListTooLong;
      case 233:
        return _e.InvalidCustomFeeCollector;
      case 234:
        return _e.InvalidTokenIdInCustomFees;
      case 235:
        return _e.TokenNotAssociatedToFeeCollector;
      case 236:
        return _e.TokenMaxSupplyReached;
      case 237:
        return _e.SenderDoesNotOwnNftSerialNo;
      case 238:
        return _e.CustomFeeNotFullySpecified;
      case 239:
        return _e.CustomFeeMustBePositive;
      case 240:
        return _e.TokenHasNoFeeScheduleKey;
      case 241:
        return _e.CustomFeeOutsideNumericRange;
      case 242:
        return _e.RoyaltyFractionCannotExceedOne;
      case 243:
        return _e.FractionalFeeMaxAmountLessThanMinAmount;
      case 244:
        return _e.CustomScheduleAlreadyHasNoFees;
      case 245:
        return _e.CustomFeeDenominationMustBeFungibleCommon;
      case 246:
        return _e.CustomFractionalFeeOnlyAllowedForFungibleCommon;
      case 247:
        return _e.InvalidCustomFeeScheduleKey;
      case 248:
        return _e.InvalidTokenMintMetadata;
      case 249:
        return _e.InvalidTokenBurnMetadata;
      case 250:
        return _e.CurrentTreasuryStillOwnsNfts;
      case 251:
        return _e.AccountStillOwnsNfts;
      case 252:
        return _e.TreasuryMustOwnBurnedNft;
      case 253:
        return _e.AccountDoesNotOwnWipedNft;
      case 254:
        return _e.AccountAmountTransfersOnlyAllowedForFungibleCommon;
      case 255:
        return _e.MaxNftsInPriceRegimeHaveBeenMinted;
      case 256:
        return _e.PayerAccountDeleted;
      case 257:
        return _e.CustomFeeChargingExceededMaxRecursionDepth;
      case 258:
        return _e.CustomFeeChargingExceededMaxAccountAmounts;
      case 259:
        return _e.InsufficientSenderAccountBalanceForCustomFee;
      case 260:
        return _e.SerialNumberLimitReached;
      case 261:
        return _e.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique;
      case 262:
        return _e.NoRemainingAutomaticAssociations;
      case 263:
        return _e.ExistingAutomaticAssociationsExceedGivenLimit;
      case 264:
        return _e.RequestedNumAutomaticAssociationsExceedsAssociationLimit;
      case 265:
        return _e.TokenIsPaused;
      case 266:
        return _e.TokenHasNoPauseKey;
      case 267:
        return _e.InvalidPauseKey;
      case 268:
        return _e.FreezeUpdateFileDoesNotExist;
      case 269:
        return _e.FreezeUpdateFileHashDoesNotMatch;
      case 270:
        return _e.NoUpgradeHasBeenPrepared;
      case 271:
        return _e.NoFreezeIsScheduled;
      case 272:
        return _e.UpdateFileHashChangedSincePrepareUpgrade;
      case 273:
        return _e.FreezeStartTimeMustBeFuture;
      case 274:
        return _e.PreparedUpdateFileIsImmutable;
      case 275:
        return _e.FreezeAlreadyScheduled;
      case 276:
        return _e.FreezeUpgradeInProgress;
      case 277:
        return _e.UpdateFileIdDoesNotMatchPrepared;
      case 278:
        return _e.UpdateFileHashDoesNotMatchPrepared;
      case 279:
        return _e.ConsensusGasExhausted;
      case 280:
        return _e.RevertedSuccess;
      case 281:
        return _e.MaxStorageInPriceRegimeHasBeenUsed;
      case 282:
        return _e.InvalidAliasKey;
      case 283:
        return _e.UnexpectedTokenDecimals;
      case 284:
        return _e.InvalidProxyAccountId;
      case 285:
        return _e.InvalidTransferAccountId;
      case 286:
        return _e.InvalidFeeCollectorAccountId;
      case 287:
        return _e.AliasIsImmutable;
      case 288:
        return _e.SpenderAccountSameAsOwner;
      case 289:
        return _e.AmountExceedsTokenMaxSupply;
      case 290:
        return _e.NegativeAllowanceAmount;
      case 291:
        return _e.CannotApproveForAllFungibleCommon;
      case 292:
        return _e.SpenderDoesNotHaveAllowance;
      case 293:
        return _e.AmountExceedsAllowance;
      case 294:
        return _e.MaxAllowancesExceeded;
      case 295:
        return _e.EmptyAllowances;
      case 296:
        return _e.SpenderAccountRepeatedInAllowances;
      case 297:
        return _e.RepeatedSerialNumsInNftAllowances;
      case 298:
        return _e.FungibleTokenInNftAllowances;
      case 299:
        return _e.NftInFungibleTokenAllowances;
      case 300:
        return _e.InvalidAllowanceOwnerId;
      case 301:
        return _e.InvalidAllowanceSpenderId;
      case 302:
        return _e.RepeatedAllowancesToDelete;
      case 303:
        return _e.InvalidDelegatingSpender;
      case 304:
        return _e.DelegatingSpenderCannotGrantApproveForAll;
      case 305:
        return _e.DelegatingSpenderDoesNotHaveApproveForAll;
      case 306:
        return _e.ScheduleExpirationTimeTooFarInFuture;
      case 307:
        return _e.ScheduleExpirationTimeMustBeHigherThanConsensusTime;
      case 308:
        return _e.ScheduleFutureThrottleExceeded;
      case 309:
        return _e.ScheduleFutureGasLimitExceeded;
      case 310:
        return _e.InvalidEthereumTransaction;
      case 311:
        return _e.WrongChainId;
      case 312:
        return _e.WrongNonce;
      case 313:
        return _e.AccessListUnsupported;
      case 314:
        return _e.SchedulePendingExpiration;
      case 315:
        return _e.ContractIsTokenTreasury;
      case 316:
        return _e.ContractHasNonZeroTokenBalances;
      case 317:
        return _e.ContractExpiredAndPendingRemoval;
      case 318:
        return _e.ContractHasNoAutoRenewAccount;
      case 319:
        return _e.PermanentRemovalRequiresSystemInitiation;
      case 320:
        return _e.ProxyAccountIdFieldIsDeprecated;
      case 321:
        return _e.SelfStakingIsNotAllowed;
      case 322:
        return _e.InvalidStakingId;
      case 323:
        return _e.StakingNotEnabled;
      case 324:
        return _e.InvalidPrngRange;
      case 325:
        return _e.MaxEntitiesInPriceRegimeHaveBeenCreated;
      case 326:
        return _e.InvalidFullPrefixSignatureForPrecompile;
      case 327:
        return _e.InsufficientBalancesForStorageRent;
      case 328:
        return _e.MaxChildRecordsExceeded;
      case 329:
        return _e.InsufficientBalancesForRenewalFees;
      case 330:
        return _e.TransactionHasUnknownFields;
      case 331:
        return _e.AccountIsImmutable;
      case 332:
        return _e.AliasAlreadyAssigned;
      case 333:
        return _e.InvalidMetadataKey;
      case 334:
        return _e.TokenHasNoMetadataKey;
      case 335:
        return _e.MissingTokenMetadata;
      case 336:
        return _e.MissingSerialNumbers;
      case 337:
        return _e.TokenHasNoAdminKey;
      case 338:
        return _e.NodeDeleted;
      case 339:
        return _e.InvalidNodeId;
      case 340:
        return _e.InvalidGossipEndpoint;
      case 341:
        return _e.InvalidNodeAccountId;
      case 342:
        return _e.InvalidNodeDescription;
      case 343:
        return _e.InvalidServiceEndpoint;
      case 344:
        return _e.InvalidGossipCaCertificate;
      case 345:
        return _e.InvalidGrpcCertificate;
      case 346:
        return _e.InvalidMaxAutoAssociations;
      case 347:
        return _e.MaxNodesCreated;
      case 348:
        return _e.IpFqdnCannotBeSetForSameEndpoint;
      case 349:
        return _e.GossipEndpointCannotHaveFqdn;
      case 350:
        return _e.FqdnSizeTooLarge;
      case 351:
        return _e.InvalidEndpoint;
      case 352:
        return _e.GossipEndpointsExceededLimit;
      case 353:
        return _e.TokenReferenceRepeated;
      case 354:
        return _e.InvalidOwnerId;
      case 355:
        return _e.TokenReferenceListSizeLimitExceeded;
      case 356:
        return _e.ServiceEndpointsExceededLimit;
      case 357:
        return _e.InvalidIpv4Address;
      case 358:
        return _e.EmptyTokenReferenceList;
      case 359:
        return _e.UpdateNodeAccountNotAllowed;
      case 360:
        return _e.TokenHasNoMetadataOrSupplyKey;
      case 361:
        return _e.EmptyPendingAirdropIdList;
      case 362:
        return _e.PendingAirdropIdRepeated;
      case 363:
        return _e.MaxPendingAirdropIdExceeded;
      case 364:
        return _e.PendingNftAirdropAlreadyExists;
      case 365:
        return _e.AccountHasPendingAirdrops;
      case 366:
        return _e.ThrottledAtConsensus;
      case 367:
        return _e.InvalidPendingAirdropId;
      case 368:
        return _e.TokenAirdropWithFallbackRoyalty;
      case 369:
        return _e.InvalidTokenInPendingAirdrop;
      case 370:
        return _e.ScheduleExpiryIsBusy;
      case 371:
        return _e.InvalidGrpcCertificateHash;
      case 372:
        return _e.MissingExpiryTime;
      case 373:
        return _e.NoSchedulingAllowedAfterScheduledRecursion;
      case 374:
        return _e.RecursiveSchedulingLimitReached;
      case 375:
        return _e.WaitingForLedgerId;
      case 376:
        return _e.MaxEntriesForFeeExemptKeyListExceeded;
      case 377:
        return _e.FeeExemptKeyListContainsDuplicatedKeys;
      case 378:
        return _e.InvalidKeyInFeeExemptKeyList;
      case 379:
        return _e.InvalidFeeScheduleKey;
      case 380:
        return _e.FeeScheduleKeyCannotBeUpdated;
      case 381:
        return _e.FeeScheduleKeyNotSet;
      case 382:
        return _e.MaxCustomFeeLimitExceeded;
      case 383:
        return _e.NoValidMaxCustomFee;
      case 384:
        return _e.InvalidMaxCustomFees;
      case 385:
        return _e.DuplicateDenominationInMaxCustomFeeList;
      case 386:
        return _e.DuplicateAccountIdInMaxCustomFeeList;
      case 387:
        return _e.MaxCustomFeesIsNotSupported;
      case 388:
        return _e.BatchListEmpty;
      case 389:
        return _e.BatchListContainsDuplicates;
      case 390:
        return _e.BatchTransactionInBlacklist;
      case 391:
        return _e.InnerTransactionFailed;
      case 392:
        return _e.MissingBatchKey;
      case 393:
        return _e.BatchKeySetOnNonInnerTransaction;
      case 394:
        return _e.InvalidBatchKey;
      case 395:
        return _e.ScheduleExpiryNotConfigurable;
      case 396:
        return _e.CreatingSystemEntities;
      case 397:
        return _e.ThrottleGroupLcmOverflow;
      case 398:
        return _e.AirdropContainsMultipleSendersForAToken;
      case 399:
        return _e.GrpcWebProxyNotSupported;
      case 400:
        return _e.NftTransfersOnlyAllowedForNonFungibleUnique;
      default:
        throw new Error(`(BUG) Status.fromCode() does not handle code: ${n31}`);
    }
  }
  valueOf() {
    return this._code;
  }
};
e5.Ok = new e5(0), e5.InvalidTransaction = new e5(1), e5.PayerAccountNotFound = new e5(2), e5.InvalidNodeAccount = new e5(3), e5.TransactionExpired = new e5(4), e5.InvalidTransactionStart = new e5(5), e5.InvalidTransactionDuration = new e5(6), e5.InvalidSignature = new e5(7), e5.MemoTooLong = new e5(8), e5.InsufficientTxFee = new e5(9), e5.InsufficientPayerBalance = new e5(10), e5.DuplicateTransaction = new e5(11), e5.Busy = new e5(12), e5.NotSupported = new e5(13), e5.InvalidFileId = new e5(14), e5.InvalidAccountId = new e5(15), e5.InvalidContractId = new e5(16), e5.InvalidTransactionId = new e5(17), e5.ReceiptNotFound = new e5(18), e5.RecordNotFound = new e5(19), e5.InvalidSolidityId = new e5(20), e5.Unknown = new e5(21), e5.Success = new e5(22), e5.FailInvalid = new e5(23), e5.FailFee = new e5(24), e5.FailBalance = new e5(25), e5.KeyRequired = new e5(26), e5.BadEncoding = new e5(27), e5.InsufficientAccountBalance = new e5(28), e5.InvalidSolidityAddress = new e5(29), e5.InsufficientGas = new e5(30), e5.ContractSizeLimitExceeded = new e5(31), e5.LocalCallModificationException = new e5(32), e5.ContractRevertExecuted = new e5(33), e5.ContractExecutionException = new e5(34), e5.InvalidReceivingNodeAccount = new e5(35), e5.MissingQueryHeader = new e5(36), e5.AccountUpdateFailed = new e5(37), e5.InvalidKeyEncoding = new e5(38), e5.NullSolidityAddress = new e5(39), e5.ContractUpdateFailed = new e5(40), e5.InvalidQueryHeader = new e5(41), e5.InvalidFeeSubmitted = new e5(42), e5.InvalidPayerSignature = new e5(43), e5.KeyNotProvided = new e5(44), e5.InvalidExpirationTime = new e5(45), e5.NoWaclKey = new e5(46), e5.FileContentEmpty = new e5(47), e5.InvalidAccountAmounts = new e5(48), e5.EmptyTransactionBody = new e5(49), e5.InvalidTransactionBody = new e5(50), e5.InvalidSignatureTypeMismatchingKey = new e5(51), e5.InvalidSignatureCountMismatchingKey = new e5(52), e5.EmptyLiveHashBody = new e5(53), e5.EmptyLiveHash = new e5(54), e5.EmptyLiveHashKeys = new e5(55), e5.InvalidLiveHashSize = new e5(56), e5.EmptyQueryBody = new e5(57), e5.EmptyLiveHashQuery = new e5(58), e5.LiveHashNotFound = new e5(59), e5.AccountIdDoesNotExist = new e5(60), e5.LiveHashAlreadyExists = new e5(61), e5.InvalidFileWacl = new e5(62), e5.SerializationFailed = new e5(63), e5.TransactionOversize = new e5(64), e5.TransactionTooManyLayers = new e5(65), e5.ContractDeleted = new e5(66), e5.PlatformNotActive = new e5(67), e5.KeyPrefixMismatch = new e5(68), e5.PlatformTransactionNotCreated = new e5(69), e5.InvalidRenewalPeriod = new e5(70), e5.InvalidPayerAccountId = new e5(71), e5.AccountDeleted = new e5(72), e5.FileDeleted = new e5(73), e5.AccountRepeatedInAccountAmounts = new e5(74), e5.SettingNegativeAccountBalance = new e5(75), e5.ObtainerRequired = new e5(76), e5.ObtainerSameContractId = new e5(77), e5.ObtainerDoesNotExist = new e5(78), e5.ModifyingImmutableContract = new e5(79), e5.FileSystemException = new e5(80), e5.AutorenewDurationNotInRange = new e5(81), e5.ErrorDecodingBytestring = new e5(82), e5.ContractFileEmpty = new e5(83), e5.ContractBytecodeEmpty = new e5(84), e5.InvalidInitialBalance = new e5(85), e5.InvalidReceiveRecordThreshold = new e5(86), e5.InvalidSendRecordThreshold = new e5(87), e5.AccountIsNotGenesisAccount = new e5(88), e5.PayerAccountUnauthorized = new e5(89), e5.InvalidFreezeTransactionBody = new e5(90), e5.FreezeTransactionBodyNotFound = new e5(91), e5.TransferListSizeLimitExceeded = new e5(92), e5.ResultSizeLimitExceeded = new e5(93), e5.NotSpecialAccount = new e5(94), e5.ContractNegativeGas = new e5(95), e5.ContractNegativeValue = new e5(96), e5.InvalidFeeFile = new e5(97), e5.InvalidExchangeRateFile = new e5(98), e5.InsufficientLocalCallGas = new e5(99), e5.EntityNotAllowedToDelete = new e5(100), e5.AuthorizationFailed = new e5(101), e5.FileUploadedProtoInvalid = new e5(102), e5.FileUploadedProtoNotSavedToDisk = new e5(103), e5.FeeScheduleFilePartUploaded = new e5(104), e5.ExchangeRateChangeLimitExceeded = new e5(105), e5.MaxContractStorageExceeded = new e5(106), e5.TransferAccountSameAsDeleteAccount = new e5(107), e5.TotalLedgerBalanceInvalid = new e5(108), e5.ExpirationReductionNotAllowed = new e5(110), e5.MaxGasLimitExceeded = new e5(111), e5.MaxFileSizeExceeded = new e5(112), e5.ReceiverSigRequired = new e5(113), e5.InvalidTopicId = new e5(150), e5.InvalidAdminKey = new e5(155), e5.InvalidSubmitKey = new e5(156), e5.Unauthorized = new e5(157), e5.InvalidTopicMessage = new e5(158), e5.InvalidAutorenewAccount = new e5(159), e5.AutorenewAccountNotAllowed = new e5(160), e5.TopicExpired = new e5(162), e5.InvalidChunkNumber = new e5(163), e5.InvalidChunkTransactionId = new e5(164), e5.AccountFrozenForToken = new e5(165), e5.TokensPerAccountLimitExceeded = new e5(166), e5.InvalidTokenId = new e5(167), e5.InvalidTokenDecimals = new e5(168), e5.InvalidTokenInitialSupply = new e5(169), e5.InvalidTreasuryAccountForToken = new e5(170), e5.InvalidTokenSymbol = new e5(171), e5.TokenHasNoFreezeKey = new e5(172), e5.TransfersNotZeroSumForToken = new e5(173), e5.MissingTokenSymbol = new e5(174), e5.TokenSymbolTooLong = new e5(175), e5.AccountKycNotGrantedForToken = new e5(176), e5.TokenHasNoKycKey = new e5(177), e5.InsufficientTokenBalance = new e5(178), e5.TokenWasDeleted = new e5(179), e5.TokenHasNoSupplyKey = new e5(180), e5.TokenHasNoWipeKey = new e5(181), e5.InvalidTokenMintAmount = new e5(182), e5.InvalidTokenBurnAmount = new e5(183), e5.TokenNotAssociatedToAccount = new e5(184), e5.CannotWipeTokenTreasuryAccount = new e5(185), e5.InvalidKycKey = new e5(186), e5.InvalidWipeKey = new e5(187), e5.InvalidFreezeKey = new e5(188), e5.InvalidSupplyKey = new e5(189), e5.MissingTokenName = new e5(190), e5.TokenNameTooLong = new e5(191), e5.InvalidWipingAmount = new e5(192), e5.TokenIsImmutable = new e5(193), e5.TokenAlreadyAssociatedToAccount = new e5(194), e5.TransactionRequiresZeroTokenBalances = new e5(195), e5.AccountIsTreasury = new e5(196), e5.TokenIdRepeatedInTokenList = new e5(197), e5.TokenTransferListSizeLimitExceeded = new e5(198), e5.EmptyTokenTransferBody = new e5(199), e5.EmptyTokenTransferAccountAmounts = new e5(200), e5.InvalidScheduleId = new e5(201), e5.ScheduleIsImmutable = new e5(202), e5.InvalidSchedulePayerId = new e5(203), e5.InvalidScheduleAccountId = new e5(204), e5.NoNewValidSignatures = new e5(205), e5.UnresolvableRequiredSigners = new e5(206), e5.ScheduledTransactionNotInWhitelist = new e5(207), e5.SomeSignaturesWereInvalid = new e5(208), e5.TransactionIdFieldNotAllowed = new e5(209), e5.IdenticalScheduleAlreadyCreated = new e5(210), e5.InvalidZeroByteInString = new e5(211), e5.ScheduleAlreadyDeleted = new e5(212), e5.ScheduleAlreadyExecuted = new e5(213), e5.MessageSizeTooLarge = new e5(214), e5.OperationRepeatedInBucketGroups = new e5(215), e5.BucketCapacityOverflow = new e5(216), e5.NodeCapacityNotSufficientForOperation = new e5(217), e5.BucketHasNoThrottleGroups = new e5(218), e5.ThrottleGroupHasZeroOpsPerSec = new e5(219), e5.SuccessButMissingExpectedOperation = new e5(220), e5.UnparseableThrottleDefinitions = new e5(221), e5.InvalidThrottleDefinitions = new e5(222), e5.AccountExpiredAndPendingRemoval = new e5(223), e5.InvalidTokenMaxSupply = new e5(224), e5.InvalidTokenNftSerialNumber = new e5(225), e5.InvalidNftId = new e5(226), e5.MetadataTooLong = new e5(227), e5.BatchSizeLimitExceeded = new e5(228), e5.InvalidQueryRange = new e5(229), e5.FractionDividesByZero = new e5(230), e5.InsufficientPayerBalanceForCustomFee = new e5(231), e5.CustomFeesListTooLong = new e5(232), e5.InvalidCustomFeeCollector = new e5(233), e5.InvalidTokenIdInCustomFees = new e5(234), e5.TokenNotAssociatedToFeeCollector = new e5(235), e5.TokenMaxSupplyReached = new e5(236), e5.SenderDoesNotOwnNftSerialNo = new e5(237), e5.CustomFeeNotFullySpecified = new e5(238), e5.CustomFeeMustBePositive = new e5(239), e5.TokenHasNoFeeScheduleKey = new e5(240), e5.CustomFeeOutsideNumericRange = new e5(241), e5.RoyaltyFractionCannotExceedOne = new e5(242), e5.FractionalFeeMaxAmountLessThanMinAmount = new e5(243), e5.CustomScheduleAlreadyHasNoFees = new e5(244), e5.CustomFeeDenominationMustBeFungibleCommon = new e5(245), e5.CustomFractionalFeeOnlyAllowedForFungibleCommon = new e5(246), e5.InvalidCustomFeeScheduleKey = new e5(247), e5.InvalidTokenMintMetadata = new e5(248), e5.InvalidTokenBurnMetadata = new e5(249), e5.CurrentTreasuryStillOwnsNfts = new e5(250), e5.AccountStillOwnsNfts = new e5(251), e5.TreasuryMustOwnBurnedNft = new e5(252), e5.AccountDoesNotOwnWipedNft = new e5(253), e5.AccountAmountTransfersOnlyAllowedForFungibleCommon = new e5(254), e5.MaxNftsInPriceRegimeHaveBeenMinted = new e5(255), e5.PayerAccountDeleted = new e5(256), e5.CustomFeeChargingExceededMaxRecursionDepth = new e5(257), e5.CustomFeeChargingExceededMaxAccountAmounts = new e5(258), e5.InsufficientSenderAccountBalanceForCustomFee = new e5(259), e5.SerialNumberLimitReached = new e5(260), e5.CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique = new e5(261), e5.NoRemainingAutomaticAssociations = new e5(262), e5.ExistingAutomaticAssociationsExceedGivenLimit = new e5(263), e5.RequestedNumAutomaticAssociationsExceedsAssociationLimit = new e5(264), e5.TokenIsPaused = new e5(265), e5.TokenHasNoPauseKey = new e5(266), e5.InvalidPauseKey = new e5(267), e5.FreezeUpdateFileDoesNotExist = new e5(268), e5.FreezeUpdateFileHashDoesNotMatch = new e5(269), e5.NoUpgradeHasBeenPrepared = new e5(270), e5.NoFreezeIsScheduled = new e5(271), e5.UpdateFileHashChangedSincePrepareUpgrade = new e5(272), e5.FreezeStartTimeMustBeFuture = new e5(273), e5.PreparedUpdateFileIsImmutable = new e5(274), e5.FreezeAlreadyScheduled = new e5(275), e5.FreezeUpgradeInProgress = new e5(276), e5.UpdateFileIdDoesNotMatchPrepared = new e5(277), e5.UpdateFileHashDoesNotMatchPrepared = new e5(278), e5.ConsensusGasExhausted = new e5(279), e5.RevertedSuccess = new e5(280), e5.MaxStorageInPriceRegimeHasBeenUsed = new e5(281), e5.InvalidAliasKey = new e5(282), e5.UnexpectedTokenDecimals = new e5(283), e5.InvalidProxyAccountId = new e5(284), e5.InvalidTransferAccountId = new e5(285), e5.InvalidFeeCollectorAccountId = new e5(286), e5.AliasIsImmutable = new e5(287), e5.SpenderAccountSameAsOwner = new e5(288), e5.AmountExceedsTokenMaxSupply = new e5(289), e5.NegativeAllowanceAmount = new e5(290), e5.CannotApproveForAllFungibleCommon = new e5(291), e5.SpenderDoesNotHaveAllowance = new e5(292), e5.AmountExceedsAllowance = new e5(293), e5.MaxAllowancesExceeded = new e5(294), e5.EmptyAllowances = new e5(295), e5.SpenderAccountRepeatedInAllowances = new e5(296), e5.RepeatedSerialNumsInNftAllowances = new e5(297), e5.FungibleTokenInNftAllowances = new e5(298), e5.NftInFungibleTokenAllowances = new e5(299), e5.InvalidAllowanceOwnerId = new e5(300), e5.InvalidAllowanceSpenderId = new e5(301), e5.RepeatedAllowancesToDelete = new e5(302), e5.InvalidDelegatingSpender = new e5(303), e5.DelegatingSpenderCannotGrantApproveForAll = new e5(304), e5.DelegatingSpenderDoesNotHaveApproveForAll = new e5(305), e5.ScheduleExpirationTimeTooFarInFuture = new e5(306), e5.ScheduleExpirationTimeMustBeHigherThanConsensusTime = new e5(307), e5.ScheduleFutureThrottleExceeded = new e5(308), e5.ScheduleFutureGasLimitExceeded = new e5(309), e5.InvalidEthereumTransaction = new e5(310), e5.WrongChainId = new e5(311), e5.WrongNonce = new e5(312), e5.AccessListUnsupported = new e5(313), e5.SchedulePendingExpiration = new e5(314), e5.ContractIsTokenTreasury = new e5(315), e5.ContractHasNonZeroTokenBalances = new e5(316), e5.ContractExpiredAndPendingRemoval = new e5(317), e5.ContractHasNoAutoRenewAccount = new e5(318), e5.PermanentRemovalRequiresSystemInitiation = new e5(319), e5.ProxyAccountIdFieldIsDeprecated = new e5(320), e5.SelfStakingIsNotAllowed = new e5(321), e5.InvalidStakingId = new e5(322), e5.StakingNotEnabled = new e5(323), e5.InvalidPrngRange = new e5(324), e5.MaxEntitiesInPriceRegimeHaveBeenCreated = new e5(325), e5.InvalidFullPrefixSignatureForPrecompile = new e5(326), e5.InsufficientBalancesForStorageRent = new e5(327), e5.MaxChildRecordsExceeded = new e5(328), e5.InsufficientBalancesForRenewalFees = new e5(329), e5.TransactionHasUnknownFields = new e5(330), e5.AccountIsImmutable = new e5(331), e5.AliasAlreadyAssigned = new e5(332), e5.InvalidMetadataKey = new e5(333), e5.TokenHasNoMetadataKey = new e5(334), e5.MissingTokenMetadata = new e5(335), e5.MissingSerialNumbers = new e5(336), e5.TokenHasNoAdminKey = new e5(337), e5.NodeDeleted = new e5(338), e5.InvalidNodeId = new e5(339), e5.InvalidGossipEndpoint = new e5(340), e5.InvalidNodeAccountId = new e5(341), e5.InvalidNodeDescription = new e5(342), e5.InvalidServiceEndpoint = new e5(343), e5.InvalidGossipCaCertificate = new e5(344), e5.InvalidGrpcCertificate = new e5(345), e5.InvalidMaxAutoAssociations = new e5(346), e5.MaxNodesCreated = new e5(347), e5.IpFqdnCannotBeSetForSameEndpoint = new e5(348), e5.GossipEndpointCannotHaveFqdn = new e5(349), e5.FqdnSizeTooLarge = new e5(350), e5.InvalidEndpoint = new e5(351), e5.GossipEndpointsExceededLimit = new e5(352), e5.TokenReferenceRepeated = new e5(353), e5.InvalidOwnerId = new e5(354), e5.TokenReferenceListSizeLimitExceeded = new e5(355), e5.ServiceEndpointsExceededLimit = new e5(356), e5.InvalidIpv4Address = new e5(357), e5.EmptyTokenReferenceList = new e5(358), e5.UpdateNodeAccountNotAllowed = new e5(359), e5.TokenHasNoMetadataOrSupplyKey = new e5(360), e5.EmptyPendingAirdropIdList = new e5(361), e5.PendingAirdropIdRepeated = new e5(362), e5.MaxPendingAirdropIdExceeded = new e5(363), e5.PendingNftAirdropAlreadyExists = new e5(364), e5.AccountHasPendingAirdrops = new e5(365), e5.ThrottledAtConsensus = new e5(366), e5.InvalidPendingAirdropId = new e5(367), e5.TokenAirdropWithFallbackRoyalty = new e5(368), e5.InvalidTokenInPendingAirdrop = new e5(369), e5.ScheduleExpiryIsBusy = new e5(370), e5.InvalidGrpcCertificateHash = new e5(371), e5.MissingExpiryTime = new e5(372), e5.NoSchedulingAllowedAfterScheduledRecursion = new e5(373), e5.RecursiveSchedulingLimitReached = new e5(374), e5.WaitingForLedgerId = new e5(375), e5.MaxEntriesForFeeExemptKeyListExceeded = new e5(376), e5.FeeExemptKeyListContainsDuplicatedKeys = new e5(377), e5.InvalidKeyInFeeExemptKeyList = new e5(378), e5.InvalidFeeScheduleKey = new e5(379), e5.FeeScheduleKeyCannotBeUpdated = new e5(380), e5.FeeScheduleKeyNotSet = new e5(381), e5.MaxCustomFeeLimitExceeded = new e5(382), e5.NoValidMaxCustomFee = new e5(383), e5.InvalidMaxCustomFees = new e5(384), e5.DuplicateDenominationInMaxCustomFeeList = new e5(385), e5.DuplicateAccountIdInMaxCustomFeeList = new e5(386), e5.MaxCustomFeesIsNotSupported = new e5(387), e5.BatchListEmpty = new e5(388), e5.BatchListContainsDuplicates = new e5(389), e5.BatchTransactionInBlacklist = new e5(390), e5.InnerTransactionFailed = new e5(391), e5.MissingBatchKey = new e5(392), e5.BatchKeySetOnNonInnerTransaction = new e5(393), e5.InvalidBatchKey = new e5(394), e5.ScheduleExpiryNotConfigurable = new e5(395), e5.CreatingSystemEntities = new e5(396), e5.ThrottleGroupLcmOverflow = new e5(397), e5.AirdropContainsMultipleSendersForAToken = new e5(398), e5.GrpcWebProxyNotSupported = new e5(399), e5.NftTransfersOnlyAllowedForNonFungibleUnique = new e5(400);

// node_modules/@hashgraph/sdk/lib/grpc/GrpcStatus.js
var e6 = class _e {
  constructor(e39) {
    this._code = e39, Object.freeze(this);
  }
  static _fromValue(n31) {
    switch (n31) {
      case 0:
        return _e.Ok;
      case 1:
        return _e.Cancelled;
      case 2:
        return _e.Unknown;
      case 3:
        return _e.InvalidArgument;
      case 4:
        return _e.DeadlineExceeded;
      case 5:
        return _e.NotFound;
      case 6:
        return _e.AlreadyExists;
      case 7:
        return _e.PermissionDenied;
      case 8:
        return _e.ResourceExhausted;
      case 9:
        return _e.FailedPrecondition;
      case 10:
        return _e.Aborted;
      case 11:
        return _e.OutOfRange;
      case 12:
        return _e.Unimplemented;
      case 13:
        return _e.Internal;
      case 14:
        return _e.Unavailable;
      case 15:
        return _e.DataLoss;
      case 16:
        return _e.Unauthenticated;
      case 17:
        return _e.Timeout;
      case 18:
        return _e.GrpcWeb;
      default:
        throw new Error("(BUG) non-exhaustive GrpcStatus switch statement");
    }
  }
  toString() {
    switch (this) {
      case _e.Ok:
        return "OK";
      case _e.Cancelled:
        return "CANCELLED";
      case _e.Unknown:
        return "UNKNOWN";
      case _e.InvalidArgument:
        return "INVALID_ARGUMENT";
      case _e.DeadlineExceeded:
        return "DEADLINE_EXCEEDED";
      case _e.NotFound:
        return "NOT_FOUND";
      case _e.AlreadyExists:
        return "ALREADY_EXISTS";
      case _e.PermissionDenied:
        return "PERMISSION_DENIED";
      case _e.Unauthenticated:
        return "UNAUTHENTICATED";
      case _e.ResourceExhausted:
        return "RESOURCE_EXHAUSTED";
      case _e.FailedPrecondition:
        return "FAILED_PRECONDITION";
      case _e.Aborted:
        return "ABORTED";
      case _e.OutOfRange:
        return "OUT_OF_RANGE";
      case _e.Unimplemented:
        return "UNIMPLEMENTED";
      case _e.Internal:
        return "INTERNAL";
      case _e.Unavailable:
        return "UNAVAILABLE";
      case _e.DataLoss:
        return "DATA_LOSS";
      case _e.Timeout:
        return "TIMEOUT";
      case _e.GrpcWeb:
        return "GRPC_WEB";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  valueOf() {
    return this._code;
  }
};
e6.Ok = new e6(0), e6.Cancelled = new e6(1), e6.Unknown = new e6(2), e6.InvalidArgument = new e6(3), e6.DeadlineExceeded = new e6(4), e6.NotFound = new e6(5), e6.AlreadyExists = new e6(6), e6.PermissionDenied = new e6(7), e6.ResourceExhausted = new e6(8), e6.FailedPrecondition = new e6(9), e6.Aborted = new e6(10), e6.OutOfRange = new e6(11), e6.Unimplemented = new e6(12), e6.Internal = new e6(13), e6.Unavailable = new e6(14), e6.DataLoss = new e6(15), e6.Unauthenticated = new e6(16), e6.Timeout = new e6(17), e6.GrpcWeb = new e6(18);

// node_modules/@hashgraph/sdk/lib/grpc/GrpcServiceError.js
var r7 = class _r extends Error {
  constructor(t35, e39) {
    super(`gRPC service failed with: Status: ${t35.toString()}, Code: ${t35.valueOf()}`), this.status = t35, this.nodeAccountId = e39, this.name = "GrpcServiceError", void 0 !== Error.captureStackTrace && Error.captureStackTrace(this, _r);
  }
  static _fromResponse(e39) {
    if (null != e39.code && null != e39.details) {
      const s26 = e6._fromValue(e39.code), a23 = new _r(s26);
      return a23.stack += `
Caused by: ${e39.stack ? e39.stack.toString() : ""}`, a23.message += `: ${e39.details}`, a23;
    }
    return e39;
  }
  toString() {
    return `${this.name}: ${this.message}`;
  }
};

// node_modules/@hashgraph/sdk/lib/http/HttpError.js
var r8 = class _r extends Error {
  constructor(t35) {
    super(`failed with error code: ${t35.toString()}`), this.status = t35, this.name = "HttpError", void 0 !== Error.captureStackTrace && Error.captureStackTrace(this, _r);
  }
};

// node_modules/@hashgraph/sdk/lib/MaxAttemptsOrTimeoutError.js
var t10 = class extends Error {
  constructor(t35, e39) {
    super(t35), this.nodeAccountId = e39;
  }
  toJSON() {
    return { message: this.message, nodeAccountId: this.nodeAccountId };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  valueOf() {
    return this.toJSON();
  }
};

// node_modules/@hashgraph/sdk/lib/Executable.js
var c2 = { Finished: "Finished", Retry: "Retry", Error: "Error" };
var a5 = /\brst[^0-9a-zA-Z]stream\b/i;
var u3 = class {
  constructor() {
    this._maxAttempts = 10, this._nodeAccountIds = new t7(), this.transactionNodeIds = [], this._signOnDemand = false, this._minBackoff = null, this._maxBackoff = 8e3, this._operator = null, this._requestTimeout = null, this._grpcDeadline = null, this._logger = null;
  }
  get nodeAccountIds() {
    return this._nodeAccountIds.isEmpty ? null : (this._nodeAccountIds.setLocked(), this._nodeAccountIds.list);
  }
  setNodeAccountIds(t35) {
    return this._nodeAccountIds.setList(t35).setLocked(), this;
  }
  get maxRetries() {
    return console.warn("Deprecated: use maxAttempts instead"), this.maxAttempts;
  }
  setMaxRetries(t35) {
    return console.warn("Deprecated: use setMaxAttempts() instead"), this.setMaxAttempts(t35);
  }
  get maxAttempts() {
    return this._maxAttempts;
  }
  setMaxAttempts(t35) {
    return this._maxAttempts = t35, this;
  }
  get grpcDeadline() {
    return this._grpcDeadline;
  }
  setGrpcDeadline(t35) {
    return this._grpcDeadline = t35, this;
  }
  setMinBackoff(t35) {
    if (null == t35) throw new Error("minBackoff cannot be null.");
    if (null != this._maxBackoff && t35 > this._maxBackoff) throw new Error("minBackoff cannot be larger than maxBackoff.");
    return this._minBackoff = t35, this;
  }
  get minBackoff() {
    return this._minBackoff;
  }
  setMaxBackoff(t35) {
    if (null == t35) throw new Error("maxBackoff cannot be null.");
    if (null != this._minBackoff && t35 < this._minBackoff) throw new Error("maxBackoff cannot be smaller than minBackoff.");
    return this._maxBackoff = t35, this;
  }
  get maxBackoff() {
    return this._maxBackoff;
  }
  _beforeExecute(t35) {
    throw new Error("not implemented");
  }
  _makeRequestAsync() {
    throw new Error("not implemented");
  }
  _mapStatusError(t35, e39, o32) {
    throw new Error("not implemented");
  }
  _mapResponse(t35, e39, o32) {
    throw new Error("not implemented");
  }
  _execute(t35, e39) {
    throw new Error("not implemented");
  }
  _getTransactionId() {
    throw new Error("not implemented");
  }
  _getLogId() {
    throw new Error("not implemented");
  }
  _requestToBytes(t35) {
    throw new Error("not implemented");
  }
  _responseToBytes(t35) {
    throw new Error("not implemented");
  }
  _shouldRetry(t35, e39) {
    throw new Error("not implemented");
  }
  _shouldRetryExceptionally(o32) {
    return !(o32 instanceof r7) || (o32.status._code === e6.Timeout._code || o32.status._code === e6.Unavailable._code || o32.status._code === e6.ResourceExhausted._code || o32.status._code === e6.GrpcWeb._code || o32.status._code === e6.Internal._code && a5.test(o32.message));
  }
  _setOperatorWith(t35, e39, o32) {
    return this._operator = { transactionSigner: o32, accountId: t35, publicKey: e39 }, this;
  }
  async executeWithSigner(t35) {
    return t35.call(this);
  }
  isBatchedAndNotBatchTransaction() {
    return false;
  }
  async execute(e39, o32) {
    const a23 = null != e39.network["127.0.0.1:50211"];
    if (this.isBatchedAndNotBatchTransaction()) throw new Error("Cannot execute batchified transaction outside of BatchTransaction");
    this._logger = null == this._logger ? null != e39._logger ? e39._logger : null : this._logger, null == this._requestTimeout && (this._requestTimeout = null != o32 ? o32 : e39.requestTimeout), await this._beforeExecute(e39), null == this._maxBackoff && (this._maxBackoff = e39.maxBackoff), null == this._minBackoff && (this._minBackoff = e39.minBackoff);
    const h8 = Date.now();
    let u22 = null;
    const m6 = a23 ? 1e3 : e39._maxAttempts ?? this._maxAttempts;
    if (this.transactionNodeIds.length) {
      const t35 = this._nodeAccountIds.list.map(((t36) => t36.toString()));
      if (!this.transactionNodeIds.some(((e40) => t35.includes(e40)))) {
        const e40 = t35.length > 2 ? `${t35.slice(0, 2).join(", ")} ...` : t35.join(", "), o33 = 1 === t35.length;
        throw new Error(`Attempting to execute a transaction against node${o33 ? "" : "s"} ${e40}, which ${o33 ? "is" : "are"} not included in the Client's node list. Please review your Client configuration.`);
      }
    }
    for (let o33 = 1; o33 <= m6; o33 += 1) {
      if (null != this._requestTimeout && h8 + this._requestTimeout <= Date.now()) throw new t10("timeout exceeded", this._nodeAccountIds.isEmpty ? "No node account ID set" : this._nodeAccountIds.current.toString());
      let g5, _4;
      if (this._nodeAccountIds.isEmpty ? (_4 = e39._network.getNode(), g5 = _4.accountId, this._nodeAccountIds.setList([g5])) : (g5 = this._nodeAccountIds.current, _4 = e39._network.getNode(g5)), null == _4) throw new Error(`NodeAccountId not recognized: ${g5.toString()}`);
      if (this.transactionNodeIds.length) {
        if (!this.transactionNodeIds.includes(g5.toString())) {
          console.error(`Attempting to execute a transaction against node ${g5.toString()}, which is not included in the Client's node list. Please review your Client configuration.`), this._nodeAccountIds.advance();
          continue;
        }
      }
      const f4 = this._getLogId();
      this._logger && this._logger.debug(`[${f4}] Node AccountID: ${_4.accountId.toString()}, IP: ${_4.address.toString()}`);
      const p3 = _4.getChannel(), w5 = await this._makeRequestAsync();
      let x2;
      if (!_4.isHealthy()) {
        const t35 = this._nodeAccountIds.index === this._nodeAccountIds.list.length - 1;
        if (d3(w5) || a23) {
          await l2(a23, o33, this._minBackoff, this._maxBackoff);
          continue;
        }
        if (t35 || this._nodeAccountIds.length <= 1) throw new Error(`Network connectivity issue: All nodes are unhealthy. Original node list: ${this._nodeAccountIds.list.join(", ")}`);
        this._logger && this._logger.debug(`[${f4}] Node is not healthy, trying the next node.`), this._nodeAccountIds.advance();
        continue;
      }
      this._nodeAccountIds.advance();
      try {
        const t35 = [];
        null != this._grpcDeadline && t35.push(new Promise(((t36, e40) => setTimeout((() => e40(new Error("grpc deadline exceeded"))), this._grpcDeadline)))), this._logger && this._logger.trace(`[${this._getLogId()}] sending protobuf ${n(this._requestToBytes(w5))}`), t35.push(this._execute(p3, w5)), x2 = await Promise.race(t35);
      } catch (n31) {
        const s26 = r7._fromResponse(n31);
        if (u22 = s26, this._logger && this._logger.debug(`[${f4}] received error ${JSON.stringify(s26)}`), (s26 instanceof r7 || s26 instanceof r8) && this._shouldRetryExceptionally(s26) && o33 <= m6) {
          this._logger && this._logger.debug(`[${this._getLogId()}] node with accountId: ${_4.accountId.toString()} and proxy IP: ${_4.address.toString()} is unhealthy`), e39._network.increaseBackoff(_4);
          continue;
        }
        throw n31;
      }
      this._logger && this._logger.trace(`[${this._getLogId()}] sending protobuf ${n(this._responseToBytes(x2))}`), e39._network.decreaseBackoff(_4);
      const [k3, A3] = this._shouldRetry(w5, x2);
      switch (k3.toString() !== e5.Ok.toString() && k3.toString() !== e5.Success.toString() && (u22 = k3), A3) {
        case c2.Retry:
          await l2(a23, o33, this._minBackoff, this._maxBackoff);
          continue;
        case c2.Finished:
          return this._mapResponse(x2, g5, w5);
        case c2.Error:
          throw this._mapStatusError(w5, x2, g5);
        default:
          throw new Error("(BUG) non-exhaustive switch statement for `ExecutionState`");
      }
    }
    throw new t10(`max attempts of ${m6.toString()} was reached for request with last error being: ${null != u22 ? u22.toString() : ""}`, this._nodeAccountIds.current.toString());
  }
  toBytes() {
    throw new Error("not implemented");
  }
  setLogger(t35) {
    return this._logger = t35, this;
  }
  get logger() {
    return this._logger;
  }
};
function d3(t35) {
  return "object" == typeof t35 && null !== t35 && ("transactionGetReceipt" in t35 || "transactionGetRecord" in t35);
}
function l2(t35, e39, o32, n31) {
  if (t35) return new Promise(((t36) => setTimeout(t36, o32)));
  const r41 = Math.min(Math.floor(o32 * Math.pow(2, e39)), n31);
  return new Promise(((t36) => setTimeout(t36, r41)));
}

// node_modules/@hashgraph/sdk/lib/query/Query.js
var o5 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/lib/PrecheckStatusError.js
var n5 = class extends t9 {
  constructor(t35) {
    super(t35, `transaction ${t35.transactionId.toString()} failed precheck with status ${t35.status.toString()} against node account id ${t35.nodeId.toString()}`), this.contractFunctionResult = t35.contractFunctionResult, this.nodeId = t35.nodeId;
  }
  toJSON() {
    return { name: this.name, status: this.status.toString(), transactionId: this.transactionId.toString(), nodeId: this.nodeId.toString(), message: this.message, contractFunctionResult: this.contractFunctionResult };
  }
};

// node_modules/@hashgraph/sdk/lib/MaxQueryPaymentExceeded.js
var e7 = class extends Error {
  constructor(e39, t35) {
    super(), this.message = `query cost of ${e39.toString()} HBAR exceeds max set on client: ${t35.toString()} HBAR`, this.name = "MaxQueryPaymentExceededError", this.queryCost = e39, this.maxQueryPayment = t35;
  }
};

// node_modules/@hashgraph/sdk/lib/query/QueryBase.js
var a6 = __toESM(require_lib(), 1);
var s5 = class extends u3 {
  constructor() {
    super();
  }
  async _makePaymentTransaction(o32, s26, c17, u22) {
    const e39 = [];
    null != c17 ? (e39.push({ accountID: c17.accountId._toProtobuf(), amount: u22.negated().toTinybars() }), e39.push({ accountID: s26._toProtobuf(), amount: u22.toTinybars() })) : (e39.push({ accountID: new y3(0)._toProtobuf(), amount: u22.negated().toTinybars() }), e39.push({ accountID: s26._toProtobuf(), amount: u22.toTinybars() }));
    const i17 = { transactionID: o32._toProtobuf(), nodeAccountID: s26._toProtobuf(), transactionFee: new e4(1).toTinybars(), transactionValidDuration: { seconds: long_default.fromNumber(120) }, cryptoTransfer: { transfers: { accountAmounts: e39 } } }, f4 = { bodyBytes: a6.proto.TransactionBody.encode(i17).finish() };
    if (null != c17) {
      const o33 = await c17.transactionSigner(f4.bodyBytes);
      f4.sigMap = { sigPair: [c17.publicKey._toProtobufSignature(o33)] };
    }
    return { signedTransactionBytes: a6.proto.SignedTransaction.encode(f4).finish() };
  }
};

// node_modules/@hashgraph/sdk/lib/query/CostQuery.js
var o4 = __toESM(require_lib(), 1);
var n6 = class extends s5 {
  constructor(e39) {
    super(), this._query = e39, this._grpcDeadline = e39._grpcDeadline, this._requestTimeout = e39._requestTimeout, this._nodeAccountIds = e39._nodeAccountIds.clone(), this._operator = e39._operator, this._header = null;
  }
  _getTransactionId() {
    return this._query._getTransactionId();
  }
  _getLogId() {
    return `CostQuery:${this._query._getLogId()}`;
  }
  async _beforeExecute(s26) {
    if (null == s26) throw new Error("Cannot do CostQuery without Client");
    const n31 = null != this._operator ? this._operator : s26._operator;
    if (null == n31) throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");
    this._query._nodeAccountIds.isEmpty && this._query._nodeAccountIds.setList(s26._network.getNodeAccountIdsForExecute());
    const a23 = i4.generate(n31.accountId);
    null == this._query.paymentTransactionId && this._query.setPaymentTransactionId(a23);
    const i17 = this._getLogId(), u22 = new y3(0), _4 = i4.generate(new y3(0)), c17 = new e4(0);
    this._logger && this._logger.debug(`[${i17}] making a payment transaction for node ${u22.toString()} and transaction ID ${_4.toString()} with amount ${c17.toString()}`), this._header = { payment: await this._makePaymentTransaction(_4, new y3(0), n31, c17), responseType: o4.proto.ResponseType.COST_ANSWER };
  }
  _makeRequestAsync() {
    return Promise.resolve(this._query._onMakeRequest(this._header));
  }
  _shouldRetry(e39, t35) {
    return this._query._shouldRetry(e39, t35);
  }
  _mapStatusError(e39, t35, r41) {
    return this._query._mapStatusError(e39, t35, r41);
  }
  _mapResponse(e39, r41, o32) {
    const s26 = this._query._mapResponseHeader(e39).cost;
    return Promise.resolve(e4.fromTinybars(s26));
  }
  _execute(e39, t35) {
    return this._query._execute(e39, t35);
  }
  _requestToBytes(e39) {
    return this._query._requestToBytes(e39);
  }
  _responseToBytes(e39) {
    return this._query._responseToBytes(e39);
  }
};

// node_modules/@hashgraph/sdk/lib/query/Query.js
var m3 = /* @__PURE__ */ new Map();
var h3 = class extends s5 {
  constructor() {
    super(), this._paymentTransactionId = null, this._paymentTransactions = [], this._queryPayment = null, this._maxQueryPayment = null, this._timestamp = Date.now();
  }
  static fromBytes(t35) {
    const e39 = o5.proto.Query.decode(t35);
    if (null == e39.query) throw new Error("(BUG) query.query was not set in the protobuf");
    const n31 = m3.get(e39.query);
    if (null == n31) throw new Error(`(BUG) Query.fromBytes() not implemented for type ${e39.query}`);
    return n31(e39);
  }
  toBytes() {
    return o5.proto.Query.encode(this._makeRequest()).finish();
  }
  setQueryPayment(t35) {
    return this._queryPayment = t35, this;
  }
  setMaxQueryPayment(t35) {
    return this._maxQueryPayment = t35, this;
  }
  async getCost(t35) {
    this._nodeAccountIds.isEmpty && this._nodeAccountIds.setList(t35._network.getNodeAccountIdsForExecute()), this._timestamp = Date.now();
    const e39 = await new n6(this).execute(t35);
    return e4.fromTinybars(e39._valueInTinybar.multipliedBy(1.1).toFixed(0));
  }
  setPaymentTransactionId(t35) {
    return this._paymentTransactionId = t35, this;
  }
  get paymentTransactionId() {
    return this._paymentTransactionId;
  }
  _getTransactionId() {
    if (null == this._paymentTransactionId) throw new Error("Query.PaymentTransactionId was not set duration execution");
    return this._paymentTransactionId;
  }
  _isPaymentRequired() {
    return true;
  }
  _validateChecksums(t35) {
  }
  async _beforeExecute(t35) {
    if (this._paymentTransactions.length > 0) return;
    if (t35.isAutoValidateChecksumsEnabled() && this._validateChecksums(t35), this._nodeAccountIds.isEmpty && this._nodeAccountIds.setList(t35._network.getNodeAccountIdsForExecute()), this._operator = null != this._operator ? this._operator : t35._operator, this._isPaymentRequired()) {
      if (this.transactionNodeIds = Object.values(t35.network).map(((t36) => t36.toString())), null == this._operator) throw new Error("`client` must have an `operator` or an explicit payment transaction must be provided");
      this._paymentTransactionId = i4.generate(this._operator.accountId);
    } else this._paymentTransactionId = i4.generate(new y3(0));
    let s26 = new e4(0);
    const o32 = null != this._maxQueryPayment ? this._maxQueryPayment : t35.defaultMaxQueryPayment;
    if (null != this._queryPayment) s26 = this._queryPayment;
    else if (0 === this._paymentTransactions.length && this._isPaymentRequired()) {
      const e39 = await this.getCost(t35);
      if (o32.toTinybars().toInt() < e39.toTinybars().toInt()) throw new e7(e39, o32);
      s26 = e39, this._logger && this._logger.debug(`[${this._getLogId()}] received cost for query ${s26.toString()}`);
    }
    this._queryPayment = s26, this._timestamp = Date.now(), this._nodeAccountIds.setLocked();
    for (const t36 of this._nodeAccountIds.list) {
      const e39 = this._getLogId(), n31 = this._paymentTransactionId, s27 = this._queryPayment;
      this._logger && this._logger.debug(`[${e39}] making a payment transaction for node ${t36.toString()} and transaction ID ${n31.toString()} with amount ${s27.toString()}`), this._paymentTransactions.push(await this._makePaymentTransaction(n31, t36, this._isPaymentRequired() ? this._operator : null, s27));
    }
  }
  _mapResponseHeader(t35) {
    throw new Error("not implemented");
  }
  _makeRequestHeader() {
    let t35 = {};
    return this._isPaymentRequired() && this._paymentTransactions.length > 0 && (t35 = { responseType: o5.proto.ResponseType.ANSWER_ONLY, payment: this._paymentTransactions[this._nodeAccountIds.index] }), t35;
  }
  _onMakeRequest(t35) {
    throw new Error("not implemented");
  }
  _makeRequest() {
    let t35 = {};
    return this._isPaymentRequired() && null != this._paymentTransactions && (t35 = { payment: this._paymentTransactions[this._nodeAccountIds.index], responseType: o5.proto.ResponseType.ANSWER_ONLY }), this._onMakeRequest(t35);
  }
  async _makeRequestAsync() {
    let t35 = { responseType: o5.proto.ResponseType.ANSWER_ONLY };
    const n31 = this._getLogId(), s26 = this._nodeAccountIds.current, a23 = i4.generate(this._operator ? this._operator.accountId : new y3(0)), i17 = this._queryPayment;
    return this._logger && this._logger.debug(`[${n31}] making a payment transaction for node ${s26.toString()} and transaction ID ${a23.toString()} with amount ${i17.toString()}`), t35.payment = await this._makePaymentTransaction(a23, s26, this._isPaymentRequired() ? this._operator : null, i17), this._onMakeRequest(t35);
  }
  _shouldRetry(e39, n31) {
    const { nodeTransactionPrecheckCode: r41 } = this._mapResponseHeader(n31), a23 = e5._fromCode(null != r41 ? r41 : o5.proto.ResponseCodeEnum.OK);
    switch (this._logger && this._logger.debug(`[${this._getLogId()}] received status ${a23.toString()}`), a23) {
      case e5.Busy:
      case e5.Unknown:
      case e5.PlatformTransactionNotCreated:
      case e5.PlatformNotActive:
        return [a23, c2.Retry];
      case e5.Ok:
        return [a23, c2.Finished];
      default:
        return [a23, c2.Error];
    }
  }
  _mapStatusError(e39, n31, s26) {
    const { nodeTransactionPrecheckCode: r41 } = this._mapResponseHeader(n31), i17 = e5._fromCode(null != r41 ? r41 : o5.proto.ResponseCodeEnum.OK);
    return new n5({ nodeId: s26, status: i17, transactionId: this._getTransactionId(), contractFunctionResult: null });
  }
  _requestToBytes(t35) {
    return o5.proto.Query.encode(t35).finish();
  }
  _responseToBytes(t35) {
    return o5.proto.Response.encode(t35).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/contract/ContractId.js
var u4 = __toESM(require_lib(), 1);
var g4 = class _g extends t2 {
  constructor(t35, s26, e39, o32) {
    super();
    const m6 = g2(t35, s26, e39);
    this.shard = m6.shard, this.realm = m6.realm, this.num = m6.num, this.evmAddress = null != o32 ? o32 : null, this._checksum = null;
  }
  static fromEvmAddress(r41, s26, e39) {
    const o32 = i3.fromString(e39), [m6, i17, n31, h8] = S(r41, s26, o32.toString());
    return new _g(m6, i17, n31, h8 == null ? void 0 : h8.toBytes());
  }
  static fromString(r41) {
    const t35 = y2(r41);
    if (Number.isNaN(t35.shard) || Number.isNaN(t35.realm)) throw new Error("invalid format for entity ID");
    const e39 = null != t35.shard ? long_default.fromString(t35.shard) : long_default.ZERO, o32 = null != t35.realm ? long_default.fromString(t35.realm) : long_default.ZERO, [m6, i17] = t35.numOrHex.length < 40 ? [long_default.fromString(t35.numOrHex), void 0] : [long_default.ZERO, r(t35.numOrHex)];
    return new _g(e39, o32, m6, i17);
  }
  static _fromProtobuf(r41) {
    return new _g(null != r41.shardNum ? r41.shardNum : 0, null != r41.realmNum ? r41.realmNum : 0, null != r41.contractNum ? r41.contractNum : 0);
  }
  get checksum() {
    return this._checksum;
  }
  async populateAccountNum(r41) {
    if (null === this.evmAddress) throw new Error("field `evmAddress` should not be null");
    const t35 = `https://${r41.mirrorNetwork[0].slice(0, r41.mirrorNetwork[0].indexOf(":"))}/api/v1/contracts/${n(this.evmAddress)}`, s26 = await fetch(t35), e39 = (await s26.json()).contract_id;
    return this.num = long_default.fromString(e39.slice(e39.lastIndexOf(".") + 1)), this;
  }
  validate(r41) {
    console.warn("Deprecated: Use `validateChecksum` instead"), this.validateChecksum(r41);
  }
  validateChecksum(r41) {
    b2(this.shard, this.realm, this.num, this._checksum, r41);
  }
  static fromBytes(r41) {
    return _g._fromProtobuf(u4.proto.ContractID.decode(r41));
  }
  static fromSolidityAddress(r41) {
    return w(r(r41)) ? new _g(...E2(r41)) : this.fromEvmAddress(0, 0, r41);
  }
  toSolidityAddress() {
    return null != this.evmAddress ? n(this.evmAddress) : x([this.shard, this.realm, this.num]);
  }
  toEvmAddress() {
    return null != this.evmAddress ? k(this.evmAddress) : k(this.num);
  }
  _toProtobuf() {
    return { contractNum: this.num, shardNum: this.shard, realmNum: this.realm, evmAddress: this.evmAddress };
  }
  toString() {
    return null != this.evmAddress ? `${this.shard.toString()}.${this.realm.toString()}.${n(this.evmAddress)}` : `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(r41) {
    return v2(this.toString(), r41);
  }
  toBytes() {
    return u4.proto.ContractID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const r41 = new _g(this);
    return r41._checksum = this._checksum, r41.evmAddress = this.evmAddress, r41;
  }
  compare(r41) {
    return w2([this.shard, this.realm, this.num], [r41.shard, r41.realm, r41.num]);
  }
  equals(r41) {
    let t35 = false;
    return null != this.evmAddress && null != r41.evmAddress && (t35 = e(this.evmAddress, r41.evmAddress)), this.shard.eq(r41.shard) && this.realm.eq(r41.realm) && this.num.eq(r41.num) && t35;
  }
  _toProtobufKey() {
    return { contractID: this._toProtobuf() };
  }
  static __fromProtobufKey(r41) {
    return _g._fromProtobuf(r41);
  }
};
t.setContractId(((r41) => g4.__fromProtobufKey(r41)));

// node_modules/@hashgraph/sdk/lib/file/FileId.js
var h4 = __toESM(require_lib(), 1);
var c3 = class _c {
  constructor(r41, e39, s26) {
    const o32 = g2(r41, e39, s26);
    this.shard = o32.shard, this.realm = o32.realm, this.num = o32.num, this._checksum = null;
  }
  static getAddressBookFileIdFor(t35 = 0, r41 = 0) {
    return new _c({ num: 102, shard: t35, realm: r41 });
  }
  static getFeeScheduleFileIdFor(t35 = 0, r41 = 0) {
    return new _c({ num: 111, shard: t35, realm: r41 });
  }
  static getExchangeRatesFileIdFor(t35 = 0, r41 = 0) {
    return new _c({ num: 112, shard: t35, realm: r41 });
  }
  static fromString(t35) {
    const e39 = p2(t35), s26 = new _c(e39);
    return s26._checksum = e39.checksum, s26;
  }
  static _fromProtobuf(t35) {
    return new _c(null != t35.shardNum ? long_default.fromString(t35.shardNum.toString()) : 0, null != t35.realmNum ? long_default.fromString(t35.realmNum.toString()) : 0, null != t35.fileNum ? long_default.fromString(t35.fileNum.toString()) : 0);
  }
  get checksum() {
    return this._checksum;
  }
  validate(t35) {
    console.warn("Deprecated: Use `validateChecksum` instead"), this.validateChecksum(t35);
  }
  validateChecksum(t35) {
    b2(this.shard, this.realm, this.num, this._checksum, t35);
  }
  static fromBytes(t35) {
    return _c._fromProtobuf(h4.proto.FileID.decode(t35));
  }
  static fromSolidityAddress(t35) {
    const [r41, e39, o32] = E2(t35);
    return new _c(r41, e39, o32);
  }
  static fromEvmAddress(t35, r41, e39) {
    const s26 = i3.fromString(e39).toBytes();
    if (!w(s26)) throw new Error("FileId.fromEvmAddress does not support non-long-zero addresses");
    const [n31, i17, m6] = S(t35, r41, e39);
    return new _c(n31, i17, m6);
  }
  toSolidityAddress() {
    return x([this.shard, this.realm, this.num]);
  }
  toEvmAddress() {
    return k(this.num);
  }
  _toProtobuf() {
    return { fileNum: this.num, shardNum: this.shard, realmNum: this.realm };
  }
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(t35) {
    return v2(this.toString(), t35);
  }
  toBytes() {
    return h4.proto.FileID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const t35 = new _c(this);
    return t35._checksum = this._checksum, t35;
  }
  compare(t35) {
    return w2([this.shard, this.realm, this.num], [t35.shard, t35.realm, t35.num]);
  }
};
c3.ADDRESS_BOOK = new c3(102), c3.FEE_SCHEDULE = new c3(111), c3.EXCHANGE_RATES = new c3(112);

// node_modules/@hashgraph/sdk/lib/topic/TopicId.js
var u5 = __toESM(require_lib(), 1);
var d4 = class _d {
  constructor(r41, s26, e39) {
    const o32 = g2(r41, s26, e39);
    this.shard = o32.shard, this.realm = o32.realm, this.num = o32.num, this._checksum = null;
  }
  static fromString(t35) {
    const s26 = p2(t35), e39 = new _d(s26);
    return e39._checksum = s26.checksum, e39;
  }
  static _fromProtobuf(t35) {
    return new _d(null != t35.shardNum ? t35.shardNum : 0, null != t35.realmNum ? t35.realmNum : 0, null != t35.topicNum ? t35.topicNum : 0);
  }
  get checksum() {
    return this._checksum;
  }
  validate(t35) {
    console.warn("Deprecated: Use `validateChecksum` instead"), this.validateChecksum(t35);
  }
  validateChecksum(t35) {
    b2(this.shard, this.realm, this.num, this._checksum, t35);
  }
  static fromBytes(t35) {
    return _d._fromProtobuf(u5.proto.TopicID.decode(t35));
  }
  static fromSolidityAddress(t35) {
    const [r41, s26, o32] = E2(t35);
    return new _d(r41, s26, o32);
  }
  static fromEvmAddress(t35, r41, s26) {
    const e39 = i3.fromString(s26).toBytes();
    if (!w(e39)) throw new Error("TopicId.fromEvmAddress does not support non-long-zero addresses");
    const [i17, m6, n31] = S(t35, r41, s26);
    return new _d(i17, m6, n31);
  }
  toSolidityAddress() {
    return x([this.shard, this.realm, this.num]);
  }
  toEvmAddress() {
    return k(this.num);
  }
  _toProtobuf() {
    return { topicNum: this.num, shardNum: this.shard, realmNum: this.realm };
  }
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(t35) {
    return v2(this.toString(), t35);
  }
  toBytes() {
    return u5.proto.TopicID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const t35 = new _d(this);
    return t35._checksum = this._checksum, t35;
  }
  compare(t35) {
    return w2([this.shard, this.realm, this.num], [t35.shard, t35.realm, t35.num]);
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenId.js
var u6 = __toESM(require_lib(), 1);
var c4 = class _c {
  constructor(r41, s26, e39) {
    const o32 = g2(r41, s26, e39);
    this.shard = o32.shard, this.realm = o32.realm, this.num = o32.num, this._checksum = null;
  }
  static fromString(t35) {
    const s26 = p2(t35), e39 = new _c(s26);
    return e39._checksum = s26.checksum, e39;
  }
  static _fromProtobuf(t35) {
    return new _c(null != t35.shardNum ? t35.shardNum : 0, null != t35.realmNum ? t35.realmNum : 0, null != t35.tokenNum ? t35.tokenNum : 0);
  }
  get checksum() {
    return this._checksum;
  }
  validate(t35) {
    console.warn("Deprecated: Use `validateChecksum` instead"), this.validateChecksum(t35);
  }
  validateChecksum(t35) {
    b2(this.shard, this.realm, this.num, this._checksum, t35);
  }
  static fromBytes(t35) {
    return _c._fromProtobuf(u6.proto.TokenID.decode(t35));
  }
  static fromSolidityAddress(t35) {
    return new _c(...E2(t35));
  }
  static fromEvmAddress(t35, r41, s26) {
    const e39 = i3.fromString(s26).toBytes();
    if (!w(e39)) throw new Error("TokenId.fromEvmAddress does not support non-long-zero addresses");
    const [n31, m6, i17] = S(t35, r41, s26);
    return new _c(n31, m6, i17);
  }
  toSolidityAddress() {
    return x([this.shard, this.realm, this.num]);
  }
  toEvmAddress() {
    return k(this.num);
  }
  _toProtobuf() {
    return { tokenNum: this.num, shardNum: this.shard, realmNum: this.realm };
  }
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(t35) {
    return v2(this.toString(), t35);
  }
  toBytes() {
    return u6.proto.TokenID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const t35 = new _c(this);
    return t35._checksum = this._checksum, t35;
  }
  compare(t35) {
    return w2([this.shard, this.realm, this.num], [t35.shard, t35.realm, t35.num]);
  }
};

// node_modules/@hashgraph/sdk/lib/schedule/ScheduleId.js
var m4 = __toESM(require_lib(), 1);
var o6 = class _o {
  constructor(r41, s26, e39) {
    const h8 = g2(r41, s26, e39);
    this.shard = h8.shard, this.realm = h8.realm, this.num = h8.num, this._checksum = null;
  }
  static fromString(t35) {
    const s26 = p2(t35), e39 = new _o(s26);
    return e39._checksum = s26.checksum, e39;
  }
  static _fromProtobuf(t35) {
    return new _o(null != t35.shardNum ? t35.shardNum : 0, null != t35.realmNum ? t35.realmNum : 0, null != t35.scheduleNum ? t35.scheduleNum : 0);
  }
  get checksum() {
    return this._checksum;
  }
  validate(t35) {
    console.warn("Deprecated: Use `validateChecksum` instead"), this.validateChecksum(t35);
  }
  validateChecksum(t35) {
    b2(this.shard, this.realm, this.num, this._checksum, t35);
  }
  static fromBytes(t35) {
    return _o._fromProtobuf(m4.proto.ScheduleID.decode(t35));
  }
  static fromSolidityAddress(t35) {
    return new _o(...E2(t35));
  }
  toSolidityAddress() {
    return x([this.shard, this.realm, this.num]);
  }
  _toProtobuf() {
    return { scheduleNum: this.num, shardNum: this.shard, realmNum: this.realm };
  }
  toString() {
    return `${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`;
  }
  toStringWithChecksum(t35) {
    return v2(this.toString(), t35);
  }
  toBytes() {
    return m4.proto.ScheduleID.encode(this._toProtobuf()).finish();
  }
  clone() {
    const t35 = new _o(this);
    return t35._checksum = this._checksum, t35;
  }
  compare(t35) {
    return w2([this.shard, this.realm, this.num], [t35.shard, t35.realm, t35.num]);
  }
};

// node_modules/@hashgraph/sdk/lib/ExchangeRate.js
var t11 = class _t {
  constructor(e39) {
    this.hbars = e39.hbars, this.cents = e39.cents, this.expirationTime = e39.expirationTime, this.exchangeRateInCents = e39.cents / e39.hbars, Object.freeze(this);
  }
  static _fromProtobuf(i17) {
    return new _t({ hbars: i17.hbarEquiv, cents: i17.centEquiv, expirationTime: new Date(null != i17.expirationTime && null != i17.expirationTime.seconds ? long_default.isLong(i17.expirationTime.seconds) ? 1e3 * i17.expirationTime.seconds.toInt() : i17.expirationTime.seconds : 0) });
  }
  _toProtobuf() {
    return { hbarEquiv: this.hbars, centEquiv: this.cents, expirationTime: { seconds: long_default.fromNumber(Math.trunc(this.expirationTime.getTime() / 1e3)) } };
  }
  toJSON() {
    return { hbars: this.hbars, cents: this.cents, expirationTime: this.expirationTime, exchangeRateInCents: this.exchangeRateInCents };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/TransactionReceipt.js
var r9 = __toESM(require_lib(), 1);
var d5 = class _d {
  constructor(t35) {
    this.status = t35.status, this.accountId = t35.accountId, this.fileId = t35.fileId, this.contractId = t35.contractId, this.topicId = t35.topicId, this.tokenId = t35.tokenId, this.scheduleId = t35.scheduleId, this.exchangeRate = t35.exchangeRate, this.nextExchangeRate = t35.nextExchangeRate, this.topicSequenceNumber = t35.topicSequenceNumber, this.topicRunningHash = t35.topicRunningHash, this.totalSupply = t35.totalSupply, this.scheduledTransactionId = t35.scheduledTransactionId, this.serials = t35.serials ?? [], this.duplicates = t35.duplicates ?? [], this.children = t35.children ?? [], this.nodeId = t35.nodeId, Object.freeze(this);
  }
  _toProtobuf() {
    return { duplicateTransactionReceipts: this.duplicates.map(((t35) => t35._toProtobuf().receipt)), childTransactionReceipts: this.children.map(((t35) => t35._toProtobuf().receipt)), receipt: { status: this.status.valueOf(), accountID: null != this.accountId ? this.accountId._toProtobuf() : null, fileID: null != this.fileId ? this.fileId._toProtobuf() : null, contractID: null != this.contractId ? this.contractId._toProtobuf() : null, topicID: null != this.topicId ? this.topicId._toProtobuf() : null, tokenID: null != this.tokenId ? this.tokenId._toProtobuf() : null, scheduleID: null != this.scheduleId ? this.scheduleId._toProtobuf() : null, topicRunningHash: null == this.topicRunningHash ? null : this.topicRunningHash, topicSequenceNumber: this.topicSequenceNumber, exchangeRate: { nextRate: null != this.nextExchangeRate ? this.nextExchangeRate._toProtobuf() : null, currentRate: null != this.exchangeRate ? this.exchangeRate._toProtobuf() : null }, scheduledTransactionID: null != this.scheduledTransactionId ? this.scheduledTransactionId._toProtobuf() : null, serialNumbers: this.serials, newTotalSupply: this.totalSupply, nodeId: this.nodeId } };
  }
  static _fromProtobuf(r41) {
    const h8 = r41.receipt, p3 = null != r41.childTransactionReceipts ? r41.childTransactionReceipts.map(((t35) => _d._fromProtobuf({ receipt: t35 }))) : [], I3 = null != r41.duplicateTransactionReceipts ? r41.duplicateTransactionReceipts.map(((t35) => _d._fromProtobuf({ receipt: t35 }))) : [];
    return new _d({ status: e5._fromCode(null != h8.status ? h8.status : 0), accountId: null != h8.accountID ? y3._fromProtobuf(h8.accountID) : null, fileId: null != h8.fileID ? c3._fromProtobuf(h8.fileID) : null, contractId: null != h8.contractID ? g4._fromProtobuf(h8.contractID) : null, topicId: null != h8.topicID ? d4._fromProtobuf(h8.topicID) : null, tokenId: null != h8.tokenID ? c4._fromProtobuf(h8.tokenID) : null, scheduleId: null != h8.scheduleID ? o6._fromProtobuf(h8.scheduleID) : null, exchangeRate: null != h8.exchangeRate ? t11._fromProtobuf(h8.exchangeRate.currentRate) : null, nextExchangeRate: null != h8.exchangeRate ? t11._fromProtobuf(h8.exchangeRate.nextRate) : null, topicSequenceNumber: null == h8.topicSequenceNumber ? null : long_default.fromString(h8.topicSequenceNumber.toString()), topicRunningHash: null != h8.topicRunningHash ? new Uint8Array(h8.topicRunningHash) : null, totalSupply: null != h8.newTotalSupply ? long_default.fromString(h8.newTotalSupply.toString()) : null, scheduledTransactionId: null != h8.scheduledTransactionID ? i4._fromProtobuf(h8.scheduledTransactionID) : null, serials: null != h8.serialNumbers ? h8.serialNumbers.map(((t35) => long_default.fromValue(t35))) : [], children: p3, duplicates: I3, nodeId: null != h8.nodeId ? h8.nodeId : null });
  }
  static fromBytes(t35) {
    return _d._fromProtobuf(r9.proto.TransactionGetReceiptResponse.decode(t35));
  }
  toBytes() {
    return r9.proto.TransactionGetReceiptResponse.encode(this._toProtobuf()).finish();
  }
  toJSON() {
    var _a2, _b, _c, _d2, _e, _f, _g, _h, _i, _j, _k, _l;
    return { status: this.status.toString(), accountId: ((_a2 = this.accountId) == null ? void 0 : _a2.toString()) || null, filedId: ((_b = this.fileId) == null ? void 0 : _b.toString()) || null, contractId: ((_c = this.contractId) == null ? void 0 : _c.toString()) || null, topicId: ((_d2 = this.topicId) == null ? void 0 : _d2.toString()) || null, tokenId: ((_e = this.tokenId) == null ? void 0 : _e.toString()) || null, scheduleId: ((_f = this.scheduleId) == null ? void 0 : _f.toString()) || null, exchangeRate: ((_g = this.exchangeRate) == null ? void 0 : _g.toJSON()) || null, nextExchangeRate: ((_h = this.nextExchangeRate) == null ? void 0 : _h.toJSON()) || null, topicSequenceNumber: ((_i = this.topicSequenceNumber) == null ? void 0 : _i.toString()) || null, topicRunningHash: null != this.topicRunningHash ? n(this.topicRunningHash) : null, totalSupply: ((_j = this.totalSupply) == null ? void 0 : _j.toString()) || null, scheduledTransactionId: ((_k = this.scheduledTransactionId) == null ? void 0 : _k.toString()) || null, serials: this.serials.map(((t35) => t35.toString())), duplicates: this.duplicates.map(((t35) => t35.toJSON())), children: this.children.map(((t35) => t35.toJSON())), nodeId: ((_l = this.nodeId) == null ? void 0 : _l.toString()) || null };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/TransactionReceiptQuery.js
var o7 = __toESM(require_lib(), 1);
var { proto: u7 } = o7;
var l3 = class _l extends h3 {
  constructor(t35 = {}) {
    super(), this._transactionId = null, this._includeChildren = null, this._includeDuplicates = null, this._validateStatus = true, null != t35.transactionId && this.setTransactionId(t35.transactionId), null != t35.includeChildren && this.setIncludeChildren(t35.includeChildren), null != t35.includeDuplicates && this.setIncludeDuplicates(t35.includeDuplicates), null != t35.validateStatus && this.setValidateStatus(t35.validateStatus);
  }
  static _fromProtobuf(t35) {
    const e39 = t35.transactionGetReceipt;
    return new _l({ transactionId: e39.transactionID ? i4._fromProtobuf(e39.transactionID) : void 0, includeDuplicates: null != e39.includeDuplicates ? e39.includeDuplicates : void 0, includeChildren: null != e39.includeChildReceipts ? e39.includeChildReceipts : void 0 });
  }
  get transactionId() {
    return this._transactionId;
  }
  setTransactionId(t35) {
    return this._transactionId = "string" == typeof t35 ? i4.fromString(t35) : t35.clone(), this;
  }
  setIncludeDuplicates(t35) {
    return this._includeDuplicates = t35, this;
  }
  get includeDuplicates() {
    return null != this._includeDuplicates && this._includeDuplicates;
  }
  setIncludeChildren(t35) {
    return this._includeChildren = t35, this;
  }
  get includeChildren() {
    return null != this._includeChildren && this._includeChildren;
  }
  setValidateStatus(t35) {
    return this._validateStatus = t35, this;
  }
  get validateStatus() {
    return this._validateStatus;
  }
  _isPaymentRequired() {
    return false;
  }
  _shouldRetry(t35, e39) {
    const { nodeTransactionPrecheckCode: s26 } = this._mapResponseHeader(e39);
    let i17 = e5._fromCode(null != s26 ? s26 : u7.ResponseCodeEnum.OK);
    switch (this._logger && this._logger.debug(`[${this._getLogId()}] received node precheck status ${i17.toString()}`), i17) {
      case e5.Busy:
      case e5.Unknown:
      case e5.ReceiptNotFound:
      case e5.PlatformNotActive:
        return [i17, c2.Retry];
      case e5.Ok:
        break;
      default:
        return [i17, c2.Error];
    }
    const r41 = e39.transactionGetReceipt.receipt.status;
    switch (i17 = e5._fromCode(r41), this._logger && this._logger.debug(`[${this._getLogId()}] received receipt status ${i17.toString()}`), i17) {
      case e5.Busy:
      case e5.Unknown:
      case e5.ReceiptNotFound:
        return [i17, c2.Retry];
      case e5.Success:
      case e5.FeeScheduleFilePartUploaded:
        return [i17, c2.Finished];
      default:
        return [i17, this._validateStatus ? c2.Error : c2.Finished];
    }
  }
  _getTransactionId() {
    return null != this._transactionId ? this._transactionId : super._getTransactionId();
  }
  _mapStatusError(t35, e39, i17) {
    const { nodeTransactionPrecheckCode: c17 } = this._mapResponseHeader(e39);
    let o32 = e5._fromCode(null != c17 ? c17 : u7.ResponseCodeEnum.OK);
    if (o32 !== e5.Ok) return new n5({ nodeId: i17, status: o32, transactionId: this._getTransactionId(), contractFunctionResult: null });
    const l19 = e39.transactionGetReceipt, d18 = l19.receipt.status;
    if (o32 = e5._fromCode(d18), null == this._transactionId) throw new Error("Failed to construct `ReceiptStatusError` because `transactionId` is `null`");
    return new r6({ status: o32, transactionId: this._transactionId, transactionReceipt: d5._fromProtobuf(l19) });
  }
  _validateChecksums(t35) {
    null != this._transactionId && null != this._transactionId.accountId && this._transactionId.accountId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.crypto.getTransactionReceipts(e39);
  }
  _mapResponseHeader(t35) {
    return t35.transactionGetReceipt.header;
  }
  _mapResponse(t35, e39, n31) {
    const i17 = t35.transactionGetReceipt;
    return Promise.resolve(d5._fromProtobuf(i17));
  }
  _onMakeRequest(t35) {
    return { transactionGetReceipt: { header: t35, transactionID: null != this._transactionId ? this._transactionId._toProtobuf() : null, includeDuplicates: this._includeDuplicates, includeChildReceipts: this._includeChildren } };
  }
  _getLogId() {
    return `TransactionReceiptQuery:${this._timestamp.toString()}`;
  }
};
m3.set("transactionGetReceipt", l3._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/Transfer.js
var n7 = class _n {
  constructor(n31) {
    this.accountId = n31.accountId instanceof y3 ? n31.accountId : y3.fromString(n31.accountId), this.amount = n31.amount instanceof e4 ? n31.amount : new e4(n31.amount), this.isApproved = n31.isApproved;
  }
  static _fromProtobuf(r41) {
    const u22 = [];
    for (const a23 of r41) u22.push(new _n({ accountId: y3._fromProtobuf(a23.accountID), amount: e4.fromTinybars(null != a23.amount ? a23.amount : 0), isApproved: a23.isApproval }));
    return u22;
  }
  _toProtobuf() {
    return { accountID: this.accountId._toProtobuf(), amount: this.amount.toTinybars(), isApproval: this.isApproved };
  }
  toJSON() {
    return { accountId: this.accountId.toString(), amount: this.amount.toTinybars().toString(), isApproved: this.isApproved };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/lib/contract/ContractLogInfo.js
var o8 = class _o {
  constructor(t35) {
    this.contractId = t35.contractId, this.bloom = t35.bloom, this.topics = t35.topics, this.data = t35.data, Object.freeze(this);
  }
  static _fromProtobuf(a23) {
    return new _o({ contractId: g4._fromProtobuf(a23.contractID), bloom: null != a23.bloom ? a23.bloom : new Uint8Array(), topics: null != a23.topic ? a23.topic : [], data: null != a23.data ? a23.data : new Uint8Array() });
  }
  _toProtobuf() {
    return { contractID: this.contractId._toProtobuf(), bloom: this.bloom, topic: this.topics, data: this.data };
  }
};

// node_modules/@hashgraph/sdk/lib/encoding/utf8.browser.js
function e8(e39) {
  return new TextDecoder().decode(e39);
}
function n8(e39) {
  return new TextEncoder().encode(e39);
}

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var import_bn = __toESM(require_bn());

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version3 = "bignumber/5.8.0";

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN = import_bn.default.BN;
var logger2 = new Logger(version3);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber2.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes2(value));
}
var _warnedToStringRadix = false;
var BigNumber2 = class _BigNumber {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard) {
      logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return _BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o32 = _BigNumber.from(other);
    if (o32.isZero()) {
      throwFault("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e39) {
    }
    return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof _BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new _BigNumber(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new _BigNumber(_constructorGuard, toHex(new BN(value)));
      }
      return logger2.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return _BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return _BigNumber.from(anyValue.toString());
    }
    if (isBytes2(anyValue)) {
      return _BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return _BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return _BigNumber.from(hex);
          }
        }
      }
    }
    return logger2.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber2.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber2.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}

// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
var logger3 = new Logger(version3);
var _constructorGuard2 = {};
var Zero = BigNumber2.from(0);
var NegativeOne = BigNumber2.from(-1);
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber2.from(decimals).toNumber();
    } catch (e39) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber2.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber2.from(whole);
  const fractionValue = BigNumber2.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var FixedFormat = class _FixedFormat {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof _FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger3.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key, type, defaultValue) => {
        if (value[key] == null) {
          return defaultValue;
        }
        if (typeof value[key] !== type) {
          logger3.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
        }
        return value[key];
      };
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new _FixedFormat(_constructorGuard2, signed2, width, decimals);
  }
};
var FixedNumber = class _FixedNumber {
  constructor(constructorGuard, hex, value, format) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a23 = parseFixed(this._value, this.format.decimals);
    const b5 = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a23.add(b5), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a23 = parseFixed(this._value, this.format.decimals);
    const b5 = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a23.sub(b5), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a23 = parseFixed(this._value, this.format.decimals);
    const b5 = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a23.mul(b5).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a23 = parseFixed(this._value, this.format.decimals);
    const b5 = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a23.mul(this.format._multiplier).div(b5), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = _FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE2.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = _FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE2.toFormat(result.format));
    }
    return result;
  }
  // @TODO: Support other rounding algorithms
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = _FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber2.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return _FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return _FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber2.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return _FixedNumber.fromString(value, format);
    }
    if (isBytes2(value)) {
      return _FixedNumber.fromBytes(value, format);
    }
    try {
      return _FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE2 = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

// node_modules/@ethersproject/properties/lib.esm/_version.js
var version4 = "properties/5.8.0";

// node_modules/@ethersproject/properties/lib.esm/index.js
var logger4 = new Logger(version4);
function defineReadOnly(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value,
    writable: false
  });
}

// node_modules/@ethersproject/abi/lib.esm/_version.js
var version5 = "abi/5.8.0";

// node_modules/@ethersproject/abi/lib.esm/fragments.js
var logger5 = new Logger(version5);
var _constructorGuard3 = {};
var ModifiersBytes = { calldata: true, memory: true, storage: true };
var ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }
  if (ModifiersBytes[name] || name === "payable") {
    logger5.throwArgumentError("invalid modifier", "name", name);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i17) {
    logger5.throwArgumentError(`unexpected character at position ${i17}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i17 = 0; i17 < param.length; i17++) {
    let c17 = param[i17];
    switch (c17) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i17);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i17);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i17);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i17);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      // Hit a space...
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i17);
              }
              if (node.indexed) {
                throwError(i17);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i17);
        }
        node.type += c17;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i17);
        }
        node.type += c17;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c17;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c17;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c17;
        } else {
          throwError(i17);
        }
    }
  }
  if (node.parent) {
    logger5.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key in params) {
    defineReadOnly(object, key, params[key]);
  }
}
var FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
var ParamType = class _ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard3) {
      logger5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: _ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return _ParamType.fromString(value, allowIndexed);
    }
    return _ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (_ParamType.isParamType(value)) {
      return value;
    }
    return new _ParamType(_constructorGuard3, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(_ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return _ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
};
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");

// node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
var logger6 = new Logger(version5);
var Coder = class {
  constructor(name, type, localName, dynamic) {
    this.name = name;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value) {
    logger6.throwArgumentError(message, this.localName, value);
  }
};
var Writer = class {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat2(writer._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes3 = arrayify(value);
    const paddingOffset = bytes3.length % this.wordSize;
    if (paddingOffset) {
      bytes3 = concat2([bytes3, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes3);
  }
  _getValue(value) {
    let bytes3 = arrayify(BigNumber2.from(value));
    if (bytes3.length > this.wordSize) {
      logger6.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes3.length
      });
    }
    if (bytes3.length % this.wordSize) {
      bytes3 = concat2([this._padding.slice(bytes3.length % this.wordSize), bytes3]);
    }
    return bytes3;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
};
var Reader = class _Reader {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name, value) {
    let match = name.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name, value);
    }
    return _Reader.coerce(name, value);
  }
  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger6.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new _Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes3 = this._peekBytes(0, length, !!loose);
    this._offset += bytes3.length;
    return bytes3.slice(0, length);
  }
  readValue() {
    return BigNumber2.from(this.readBytes(this.wordSize));
  }
};

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var import_js_sha3 = __toESM(require_sha3());
function keccak2562(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}

// node_modules/@ethersproject/rlp/lib.esm/_version.js
var version6 = "rlp/5.8.0";

// node_modules/@ethersproject/rlp/lib.esm/index.js
var logger7 = new Logger(version6);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i17 = 0; i17 < length; i17++) {
    result = result * 256 + data[offset + i17];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object)) {
    logger7.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  const data = Array.prototype.slice.call(arrayify(object));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode3(object) {
  return hexlify(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data, offset) {
  if (data.length === 0) {
    logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data[offset]) };
}
function decode5(data) {
  const bytes3 = arrayify(data);
  const decoded = _decode(bytes3, 0);
  if (decoded.consumed !== bytes3.length) {
    logger7.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}

// node_modules/@ethersproject/address/lib.esm/_version.js
var version7 = "address/5.8.0";

// node_modules/@ethersproject/address/lib.esm/index.js
var logger8 = new Logger(version7);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i17 = 0; i17 < 40; i17++) {
    expanded[i17] = chars[i17].charCodeAt(0);
  }
  const hashed = arrayify(keccak2562(expanded));
  for (let i17 = 0; i17 < 40; i17 += 2) {
    if (hashed[i17 >> 1] >> 4 >= 8) {
      chars[i17] = chars[i17].toUpperCase();
    }
    if ((hashed[i17 >> 1] & 15) >= 8) {
      chars[i17 + 1] = chars[i17 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER2 = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
var ibanLookup = {};
for (let i17 = 0; i17 < 10; i17++) {
  ibanLookup[String(i17)] = String(i17);
}
for (let i17 = 0; i17 < 26; i17++) {
  ibanLookup[String.fromCharCode(65 + i17)] = String(10 + i17);
}
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER2));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c17) => {
    return ibanLookup[c17];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger8.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger8.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  return result;
}

// node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder = class extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/array.js
var logger9 = new Logger(version5);
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      if (!name) {
        logger9.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name]) {
        logger9.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name] = true;
      return values[name];
    });
  } else {
    logger9.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger9.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name = coder.localName;
    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }
      accum[name]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name = coder.localName;
    if (!name || uniqueNames[name] !== 1) {
      return;
    }
    if (name === "length") {
      name = "_length";
    }
    if (values[name] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });
  for (let i17 = 0; i17 < values.length; i17++) {
    const value = values[i17];
    if (value instanceof Error) {
      Object.defineProperty(values, i17, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var ArrayCoder = class extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i17 = 0; i17 < this.length; i17++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger9.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i17 = 0; i17 < value.length; i17++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      if (count * 32 > reader._data.length) {
        logger9.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count
        });
      }
    }
    let coders = [];
    for (let i17 = 0; i17 < count; i17++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var DynamicBytesCoder = class extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
};
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var FixedBytesCoder = class extends Coder {
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    this.size = size;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data = arrayify(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
};

// node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2 = BigNumber2.from(-1);
var Zero2 = BigNumber2.from(0);
var One = BigNumber2.from(1);
var Two = BigNumber2.from(2);
var WeiPerEther = BigNumber2.from("1000000000000000000");
var MaxUint256 = BigNumber2.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigNumber2.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt256 = BigNumber2.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder = class extends Coder {
  constructor(size, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    this.size = size;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v3 = BigNumber2.from(value);
    let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v3.gt(bounds) || v3.lt(bounds.add(One).mul(NegativeOne2))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v3.lt(Zero2) || v3.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v3 = v3.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v3 = v3.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v3);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
};

// node_modules/@ethersproject/strings/lib.esm/_version.js
var version8 = "strings/5.8.0";

// node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger10 = new Logger(version8);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes3, output, badCodepoint) {
  return logger10.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
}
function ignoreFunc(reason, offset, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i17 = 0;
    for (let o32 = offset + 1; o32 < bytes3.length; o32++) {
      if (bytes3[o32] >> 6 !== 2) {
        break;
      }
      i17++;
    }
    return i17;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes3.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes3, output, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes3, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes3 = arrayify(bytes3);
  const result = [];
  let i17 = 0;
  while (i17 < bytes3.length) {
    const c17 = bytes3[i17++];
    if (c17 >> 7 === 0) {
      result.push(c17);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c17 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c17 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c17 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c17 & 192) === 128) {
        i17 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i17 - 1, bytes3, result);
      } else {
        i17 += onError(Utf8ErrorReason.BAD_PREFIX, i17 - 1, bytes3, result);
      }
      continue;
    }
    if (i17 - 1 + extraLength >= bytes3.length) {
      i17 += onError(Utf8ErrorReason.OVERRUN, i17 - 1, bytes3, result);
      continue;
    }
    let res = c17 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes3[i17];
      if ((nextChar & 192) != 128) {
        i17 += onError(Utf8ErrorReason.MISSING_CONTINUE, i17, bytes3, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i17++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i17 += onError(Utf8ErrorReason.OUT_OF_RANGE, i17 - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i17 += onError(Utf8ErrorReason.UTF16_SURROGATE, i17 - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i17 += onError(Utf8ErrorReason.OVERLONG, i17 - 1 - extraLength, bytes3, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger10.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i17 = 0; i17 < str.length; i17++) {
    const c17 = str.charCodeAt(i17);
    if (c17 < 128) {
      result.push(c17);
    } else if (c17 < 2048) {
      result.push(c17 >> 6 | 192);
      result.push(c17 & 63 | 128);
    } else if ((c17 & 64512) == 55296) {
      i17++;
      const c22 = str.charCodeAt(i17);
      if (i17 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c17 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c17 >> 12 | 224);
      result.push(c17 >> 6 & 63 | 128);
      result.push(c17 & 63 | 128);
    }
  }
  return arrayify(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes3, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes3, onError));
}

// node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i17 = 0; i17 < data.length; i17 += 4) {
    result.push(parseInt(data.substring(i17, i17 + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v3) => {
    let comps = v3.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v3) => parseInt(v3, 16));
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder = class extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
};

// node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger11 = new Logger(version5);
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var AbiCoder = class {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger11.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger11.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size, param.name);
    }
    return logger11.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger11.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types.length, values: values.length },
        value: { types, values }
      });
    }
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data, loose) {
    const coders = types.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data), loose));
  }
};
var defaultAbiCoder = new AbiCoder();

// node_modules/@ethersproject/hash/lib.esm/_version.js
var version9 = "hash/5.8.0";

// node_modules/@ethersproject/base64/lib.esm/base64.js
function decode6(textData) {
  textData = atob(textData);
  const data = [];
  for (let i17 = 0; i17 < textData.length; i17++) {
    data.push(textData.charCodeAt(i17));
  }
  return arrayify(data);
}

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i17 = 0; i17 < array.length; i17++) {
    const value = array[i17];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes3) {
  let pos = 0;
  function u162() {
    return bytes3[pos++] << 8 | bytes3[pos++];
  }
  let symbol_count = u162();
  let total = 1;
  let acc = [0, 1];
  for (let i17 = 1; i17 < symbol_count; i17++) {
    acc.push(total += u162());
  }
  let skip = u162();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes3[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N4 = 31;
  const FULL = Math.pow(2, N4);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i17 = 0; i17 < N4; i17++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a23 = low + Math.floor(range * acc[start] / total);
    let b5 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a23 ^ b5) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a23 = a23 << 1 & MASK;
      b5 = b5 << 1 & MASK | 1;
    }
    while (a23 & ~b5 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a23 = a23 << 1 ^ HALF;
      b5 = (b5 ^ HALF) << 1 | HALF | 1;
    }
    low = a23;
    range = 1 + b5 - a23;
  }
  let offset = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset) {
      case 3:
        return offset + 65792 + (bytes3[pos_payload++] << 16 | bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 2:
        return offset + 256 + (bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 1:
        return offset + bytes3[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v3) {
  let pos = 0;
  return () => v3[pos++];
}
function read_compressed_payload(bytes3) {
  return read_payload(decode_arithmetic(bytes3));
}
function signed(i17) {
  return i17 & 1 ? ~i17 >> 1 : i17 >> 1;
}
function read_counts(n31, next) {
  let v3 = Array(n31);
  for (let i17 = 0; i17 < n31; i17++)
    v3[i17] = 1 + next();
  return v3;
}
function read_ascending(n31, next) {
  let v3 = Array(n31);
  for (let i17 = 0, x2 = -1; i17 < n31; i17++)
    v3[i17] = x2 += 1 + next();
  return v3;
}
function read_deltas(n31, next) {
  let v3 = Array(n31);
  for (let i17 = 0, x2 = 0; i17 < n31; i17++)
    v3[i17] = x2 += signed(next());
  return v3;
}
function read_member_array(next, lookup) {
  let v3 = read_ascending(next(), next);
  let n31 = next();
  let vX = read_ascending(n31, next);
  let vN = read_counts(n31, next);
  for (let i17 = 0; i17 < n31; i17++) {
    for (let j2 = 0; j2 < vN[i17]; j2++) {
      v3.push(vX[i17] + j2);
    }
  }
  return lookup ? v3.map((x2) => lookup[x2]) : v3;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w5 = next();
    if (w5 == 0)
      break;
    ret.push(read_linear_table(w5, next));
  }
  while (true) {
    let w5 = next() - 1;
    if (w5 < 0)
      break;
    ret.push(read_replacement_table(w5, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v3 = [];
  while (true) {
    let i17 = next();
    if (i17 == 0)
      break;
    v3.push(i17);
  }
  return v3;
}
function read_transposed(n31, w5, next) {
  let m6 = Array(n31).fill(void 0).map(() => []);
  for (let i17 = 0; i17 < w5; i17++) {
    read_deltas(n31, next).forEach((x2, j2) => m6[j2].push(x2));
  }
  return m6;
}
function read_linear_table(w5, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m6 = read_transposed(vN.length, 1 + w5, next);
  return flat(m6.map((v3, i17) => {
    const x2 = v3[0], ys = v3.slice(1);
    return Array(vN[i17]).fill(void 0).map((_4, j2) => {
      let j_dy = j2 * dy;
      return [x2 + j2 * dx, ys.map((y5) => y5 + j_dy)];
    });
  }));
}
function read_replacement_table(w5, next) {
  let n31 = 1 + next();
  let m6 = read_transposed(n31, 1 + w5, next);
  return m6.map((v3) => [v3[0], v3.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a23, b5) => a23 - b5);
  return read2();
  function read2() {
    let branches = [];
    while (true) {
      let keys = read_member_array(next, sorted);
      if (keys.length == 0)
        break;
      branches.push({ set: new Set(keys), node: read2() });
    }
    branches.sort((a23, b5) => b5.set.size - a23.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
}

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js
function getData() {
  return read_compressed_payload(decode6("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js
var r10 = getData();
var VALID = new Set(read_member_array(r10));
var IGNORED = new Set(read_member_array(r10));
var MAPPED = read_mapped_map(r10);
var EMOJI_ROOT = read_emoji_trie(r10);

// node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger12 = new Logger(version9);
var Zeros = new Uint8Array(32);
Zeros.fill(0);

// node_modules/@ethersproject/hash/lib.esm/typed-data.js
var logger13 = new Logger(version9);
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne3 = BigNumber2.from(-1);
var Zero3 = BigNumber2.from(0);
var One2 = BigNumber2.from(1);
var MaxUint2562 = BigNumber2.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue = hexZeroPad(One2.toHexString(), 32);
var hexFalse = hexZeroPad(Zero3.toHexString(), 32);
function checkString(key) {
  return function(value) {
    if (typeof value !== "string") {
      logger13.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    }
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber2.from(value).toString();
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes3 = arrayify(value);
      if (bytes3.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes3);
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

// node_modules/@ethersproject/abi/lib.esm/interface.js
var logger14 = new Logger(version5);

// node_modules/@hashgraph/sdk/lib/contract/ContractNonceInfo.js
var n9 = __toESM(require_lib(), 1);
var { proto: r11 } = n9;
var c5 = class _c {
  constructor(t35) {
    this.contractId = t35.contractId, this.nonce = t35.nonce, Object.freeze(this);
  }
  static _fromProtobuf(n31) {
    return new _c({ contractId: g4._fromProtobuf(n31.contractId), nonce: null != n31.nonce ? n31.nonce : long_default.ZERO });
  }
  _toProtobuf() {
    return { contractId: this.contractId._toProtobuf(), nonce: this.nonce };
  }
  static fromBytes(t35) {
    return _c._fromProtobuf(r11.ContractNonceInfo.decode(t35));
  }
  toBytes() {
    return r11.ContractNonceInfo.encode(this._toProtobuf()).finish();
  }
  toJSON() {
    return { contractId: this.contractId.toString(), nonce: this.nonce.toNumber() };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  equals(t35) {
    return this.contractId.equals(t35.contractId) && this.nonce.eq(t35.nonce);
  }
};

// node_modules/@hashgraph/sdk/lib/contract/ContractFunctionResult.js
var l4 = class _l {
  constructor(t35) {
    this._createResult = t35._createResult, this.contractId = t35.contractId, this.bytes = t35.bytes, this.errorMessage = t35.errorMessage, this.bloom = t35.bloom, this.gasUsed = t35.gasUsed, this.logs = t35.logs, this.createdContractIds = t35.createdContractIds, this.evmAddress = t35.evmAddress, this.stateChanges = t35.stateChanges, this.gas = t35.gas, this.amount = t35.amount, this.functionParameters = t35.functionParameters, this.senderAccountId = t35.senderAccountId, this.contractNonces = t35.contractNonces, this.signerNonce = t35.signerNonce;
  }
  static _fromProtobuf(s26, r41) {
    const o32 = s26.contractID, i17 = s26.gasUsed, u22 = s26.gas ? s26.gas : -1, c17 = s26.amount ? s26.amount : -1;
    return new _l({ _createResult: r41, bytes: s26.contractCallResult, contractId: null != o32 ? g4._fromProtobuf(o32) : null, errorMessage: null != s26.errorMessage ? s26.errorMessage : null, bloom: s26.bloom, gasUsed: i17 instanceof long_default ? i17 : long_default.fromValue(i17), logs: (null != s26.logInfo ? s26.logInfo : []).map(((e39) => o8._fromProtobuf(e39))), createdContractIds: (null != s26.createdContractIDs ? s26.createdContractIDs : []).map(((t35) => g4._fromProtobuf(t35))), evmAddress: null != s26.evmAddress && Object.hasOwn(s26.evmAddress, "value") && null != s26.evmAddress.value ? s26.evmAddress.value : null, stateChanges: [], gas: u22 instanceof long_default ? u22 : long_default.fromValue(u22), amount: c17 instanceof long_default ? c17 : long_default.fromValue(c17), functionParameters: s26.functionParameters, senderAccountId: null != s26.senderId ? y3._fromProtobuf(s26.senderId) : null, contractNonces: (null != s26.contractNonces ? s26.contractNonces : []).map(((t35) => c5._fromProtobuf(t35))), signerNonce: null != s26.signerNonce && Object.hasOwn(s26.signerNonce, "value") && s26.signerNonce.value || null });
  }
  asBytes() {
    return this.bytes;
  }
  getString(t35) {
    return e8(this.getBytes(t35));
  }
  getBytes(t35) {
    const e39 = this.getInt32(t35), n31 = E(this.bytes).getInt32(e39 + 28);
    return this.bytes.subarray(e39 + 32, e39 + 32 + n31);
  }
  getBytes32(t35) {
    return this.bytes.subarray(32 * (null != t35 ? t35 : 0), 32 * (null != t35 ? t35 : 0) + 32);
  }
  getBool(t35) {
    return 0 !== this.bytes[32 * (null != t35 ? t35 : 0) + 31];
  }
  getInt8(t35) {
    const e39 = 32 * (null != t35 ? t35 : 0) + 31;
    return E(this.bytes).getInt8(e39);
  }
  getUint8(t35) {
    return this.bytes[32 * (null != t35 ? t35 : 0) + 31];
  }
  getInt16(t35) {
    const e39 = 32 * (null != t35 ? t35 : 0) + 28;
    return E(this.bytes).getInt32(e39);
  }
  getUint16(t35) {
    const e39 = 32 * (null != t35 ? t35 : 0) + 28;
    return E(this.bytes).getUint32(e39);
  }
  getInt24(t35) {
    const e39 = 32 * (null != t35 ? t35 : 0) + 28;
    return E(this.bytes).getInt32(e39);
  }
  getUint24(t35) {
    const e39 = 32 * (null != t35 ? t35 : 0) + 28;
    return E(this.bytes).getUint32(e39);
  }
  getInt32(t35) {
    const e39 = 32 * (null != t35 ? t35 : 0) + 28;
    return E(this.bytes).getInt32(e39);
  }
  getUint32(t35) {
    const e39 = 32 * (null != t35 ? t35 : 0) + 28;
    return E(this.bytes).getUint32(e39);
  }
  getInt40(t35) {
    const e39 = defaultAbiCoder.decode(["int40"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint40(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(27, 32)), 16);
  }
  getInt48(t35) {
    const e39 = defaultAbiCoder.decode(["int48"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint48(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(26, 32)), 16);
  }
  getInt56(t35) {
    const e39 = defaultAbiCoder.decode(["int56"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint56(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(25, 32)), 16);
  }
  getInt64(t35) {
    const e39 = defaultAbiCoder.decode(["int64"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint64(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(24, 32)), 16);
  }
  getInt72(t35) {
    const e39 = defaultAbiCoder.decode(["int72"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint72(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(23, 32)), 16);
  }
  getInt80(t35) {
    const e39 = defaultAbiCoder.decode(["int80"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint80(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(22, 32)), 16);
  }
  getInt88(t35) {
    const e39 = defaultAbiCoder.decode(["int88"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint88(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(21, 32)), 16);
  }
  getInt96(t35) {
    const e39 = defaultAbiCoder.decode(["int96"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint96(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(20, 32)), 16);
  }
  getInt104(t35) {
    const e39 = defaultAbiCoder.decode(["int104"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint104(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(19, 32)), 16);
  }
  getInt112(t35) {
    const e39 = defaultAbiCoder.decode(["int112"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint112(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(18, 32)), 16);
  }
  getInt120(t35) {
    const e39 = defaultAbiCoder.decode(["int120"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint120(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(17, 32)), 16);
  }
  getInt128(t35) {
    const e39 = defaultAbiCoder.decode(["int128"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint128(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(16, 32)), 16);
  }
  getInt136(t35) {
    const e39 = defaultAbiCoder.decode(["int136"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint136(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(15, 32)), 16);
  }
  getInt144(t35) {
    const e39 = defaultAbiCoder.decode(["int144"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint144(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(14, 32)), 16);
  }
  getInt152(t35) {
    const e39 = defaultAbiCoder.decode(["int152"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint152(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(13, 32)), 16);
  }
  getInt160(t35) {
    const e39 = defaultAbiCoder.decode(["int160"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint160(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(12, 32)), 16);
  }
  getInt168(t35) {
    const e39 = defaultAbiCoder.decode(["int168"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint168(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(11, 32)), 16);
  }
  getInt176(t35) {
    const e39 = defaultAbiCoder.decode(["int176"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint176(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(10, 32)), 16);
  }
  getInt184(t35) {
    const e39 = defaultAbiCoder.decode(["int184"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint184(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(9, 32)), 16);
  }
  getInt192(t35) {
    const e39 = defaultAbiCoder.decode(["int192"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint192(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(8, 32)), 16);
  }
  getInt200(t35) {
    const e39 = defaultAbiCoder.decode(["int200"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint200(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(7, 32)), 16);
  }
  getInt208(t35) {
    const e39 = defaultAbiCoder.decode(["int208"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint208(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(6, 32)), 16);
  }
  getInt216(t35) {
    const e39 = defaultAbiCoder.decode(["int216"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint216(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(5, 32)), 16);
  }
  getInt224(t35) {
    const e39 = defaultAbiCoder.decode(["int224"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint224(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(4, 32)), 16);
  }
  getInt232(t35) {
    const e39 = defaultAbiCoder.decode(["int232"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint232(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(3, 32)), 16);
  }
  getInt240(t35) {
    const e39 = defaultAbiCoder.decode(["int240"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint240(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(2, 32)), 16);
  }
  getInt248(t35) {
    const e39 = defaultAbiCoder.decode(["int248"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint248(t35) {
    return new bignumber_default(n(this._getBytes32(t35).subarray(1, 32)), 16);
  }
  getInt256(t35) {
    const e39 = defaultAbiCoder.decode(["int256"], this._getBytes32(null != t35 ? t35 : 0));
    return new bignumber_default(e39.toString());
  }
  getUint256(t35) {
    return new bignumber_default(n(this._getBytes32(t35)), 16);
  }
  getAddress(t35) {
    return n(this.bytes.subarray(32 * (null != t35 ? t35 : 0) + 12, 32 * (null != t35 ? t35 : 0) + 32));
  }
  getResult(t35) {
    return defaultAbiCoder.decode(t35, this.bytes);
  }
  _getBytes32(t35) {
    return this.bytes.subarray(32 * (null != t35 ? t35 : 0), 32 * (null != t35 ? t35 : 0) + 32);
  }
  _toProtobuf() {
    return { contractID: null != this.contractId ? this.contractId._toProtobuf() : null, contractCallResult: this.bytes, errorMessage: this.errorMessage, bloom: this.bloom, gasUsed: this.gasUsed, logInfo: this.logs.map(((t35) => t35._toProtobuf())), createdContractIDs: this.createdContractIds.map(((t35) => t35._toProtobuf())), evmAddress: null != this.evmAddress ? { value: this.evmAddress } : null, gas: this.gas, amount: this.amount, functionParameters: this.functionParameters, senderId: null != this.senderAccountId ? this.senderAccountId._toProtobuf() : null, contractNonces: this.contractNonces.map(((t35) => t35._toProtobuf())), signerNonce: null != this.signerNonce ? { value: this.signerNonce } : null };
  }
};

// node_modules/@hashgraph/sdk/lib/account/TokenTransferAccountMap.js
var o9 = class extends t3 {
  constructor() {
    super(((r41) => y3.fromString(r41)));
  }
  toJSON() {
    const t35 = {};
    return this._map.forEach(((r41, o32) => {
      t35[o32] = r41.toString();
    })), t35;
  }
};

// node_modules/@hashgraph/sdk/lib/account/TokenTransferMap.js
var n10 = class _n extends t3 {
  constructor() {
    super(((t35) => c4.fromString(t35)));
  }
  __set(o32, t35, s26) {
    const n31 = o32.toString();
    let f4 = this._map.get(n31);
    null == f4 && (f4 = new o9(), this._map.set(n31, f4), this.__map.set(o32, f4)), f4._set(t35, s26);
  }
  static _fromProtobuf(r41) {
    const s26 = new _n();
    for (const n31 of r41) {
      const r42 = c4._fromProtobuf(n31.token);
      for (const o32 of null != n31.transfers ? n31.transfers : []) {
        const n32 = y3._fromProtobuf(o32.accountID);
        s26.__set(r42, n32, o32.amount);
      }
    }
    return s26;
  }
  _toProtobuf() {
    const o32 = [];
    for (const [t35, r41] of this) {
      const s26 = [];
      for (const [o33, t36] of r41) s26.push({ accountID: o33._toProtobuf(), amount: t36 });
      o32.push({ token: t35._toProtobuf(), transfers: s26 });
    }
    return o32;
  }
};

// node_modules/@hashgraph/sdk/lib/account/TokenNftTransferMap.js
var s6 = class _s extends t3 {
  constructor() {
    super(((o32) => c4.fromString(o32)));
  }
  __set(o32, r41) {
    const t35 = o32.toString();
    let e39 = this._map.get(t35);
    null == e39 && (e39 = [], this._map.set(t35, e39), this.__map.set(o32, e39)), e39.push(r41);
  }
  static _fromProtobuf(e39) {
    const n31 = new _s();
    for (const s26 of e39) {
      const e40 = c4._fromProtobuf(s26.token);
      for (const r41 of null != s26.nftTransfers ? s26.nftTransfers : []) {
        const s27 = y3._fromProtobuf(r41.senderAccountID), f4 = y3._fromProtobuf(r41.receiverAccountID);
        n31.__set(e40, { sender: s27, recipient: f4, serial: long_default.fromValue(r41.serialNumber), isApproved: false });
      }
    }
    return n31;
  }
  _toProtobuf() {
    const o32 = [];
    for (const [r41, t35] of this) {
      const e39 = [];
      for (const o33 of t35) e39.push({ senderAccountID: o33.sender._toProtobuf(), receiverAccountID: o33.recipient._toProtobuf(), serialNumber: o33.serial });
      o32.push({ token: r41._toProtobuf(), nftTransfers: e39 });
    }
    return o32;
  }
  toJSON() {
    const o32 = {};
    return this._map.forEach(((r41, t35) => {
      o32[t35] = r41.map(((o33) => ({ sender: o33.sender.toString(), recipient: o33.recipient.toString(), serial: o33.serial, isApproved: o33.isApproved })));
    })), o32;
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/TransactionRecord.js
var u9 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/lib/token/AssessedCustomFee.js
var n11 = class _n {
  constructor(t35 = {}) {
    this._feeCollectorAccountId = null, null != t35.feeCollectorAccountId && this.setFeeCollectorAccountId(t35.feeCollectorAccountId), this._tokenId = null, null != t35.tokenId && this.setTokenId(t35.tokenId), this._amount = null, null != t35.amount && this.setAmount(t35.amount), this._payerAccountIds = null, null != t35.payerAccountIds && this.setPayerAccountIds(t35.payerAccountIds);
  }
  get feeCollectorAccountId() {
    return this._feeCollectorAccountId;
  }
  setFeeCollectorAccountId(t35) {
    return this._feeCollectorAccountId = "string" == typeof t35 ? y3.fromString(t35) : t35, this;
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(o32) {
    return this._tokenId = "string" == typeof o32 ? c4.fromString(o32) : o32, this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(t35) {
    return this._amount = "number" == typeof t35 ? long_default.fromNumber(t35) : t35, this;
  }
  get payerAccountIds() {
    return this._payerAccountIds;
  }
  setPayerAccountIds(t35) {
    return this._payerAccountIds = t35, this;
  }
  static _fromProtobuf(e39) {
    return new _n({ feeCollectorAccountId: null != e39.feeCollectorAccountId ? y3._fromProtobuf(e39.feeCollectorAccountId) : void 0, tokenId: null != e39.tokenId ? c4._fromProtobuf(e39.tokenId) : void 0, amount: null != e39.amount ? e39.amount : void 0, payerAccountIds: null != e39.effectivePayerAccountId ? e39.effectivePayerAccountId.map(((t35) => y3._fromProtobuf(t35))) : void 0 });
  }
  _toProtobuf() {
    return { feeCollectorAccountId: null != this.feeCollectorAccountId ? this.feeCollectorAccountId._toProtobuf() : null, tokenId: null != this._tokenId ? this._tokenId._toProtobuf() : null, amount: this._amount, effectivePayerAccountId: null != this._payerAccountIds ? this._payerAccountIds.map(((t35) => t35._toProtobuf())) : null };
  }
  toJSON() {
    var _a2, _b, _c, _d;
    return { feeCollectorAccountId: ((_a2 = this.feeCollectorAccountId) == null ? void 0 : _a2.toString()) || null, tokenId: ((_b = this._tokenId) == null ? void 0 : _b.toString()) || null, amount: ((_c = this._amount) == null ? void 0 : _c.toString()) || null, payerAccountIds: ((_d = this._payerAccountIds) == null ? void 0 : _d.map(((t35) => t35.toString()))) || [] };
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenAssociation.js
var u8 = class _u {
  constructor(t35 = {}) {
    this._accountId = null, null != t35.accountId && this.setAccountId(t35.accountId), this._tokenId = null, null != t35.tokenId && this.setTokenId(t35.tokenId), this._defaultMaxTransactionFee = new e4(5);
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(o32) {
    return this._accountId = "string" == typeof o32 ? y3.fromString(o32) : o32, this;
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(t35) {
    return this._tokenId = "string" == typeof t35 ? c4.fromString(t35) : t35, this;
  }
  static _fromProtobuf(n31) {
    return new _u({ accountId: null != n31.accountId ? y3._fromProtobuf(n31.accountId) : void 0, tokenId: null != n31.tokenId ? c4._fromProtobuf(n31.tokenId) : void 0 });
  }
  _toProtobuf() {
    return { accountId: null != this._accountId ? this._accountId._toProtobuf() : void 0, tokenId: null != this._tokenId ? this._tokenId._toProtobuf() : void 0 };
  }
  toJSON() {
    var _a2, _b;
    return { accountId: ((_a2 = this._accountId) == null ? void 0 : _a2.toString()) || null, tokenId: ((_b = this._tokenId) == null ? void 0 : _b.toString()) || null };
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenTransfer.js
var n12 = class _n {
  constructor(n31) {
    this.tokenId = n31.tokenId instanceof c4 ? n31.tokenId : c4.fromString(n31.tokenId), this.accountId = n31.accountId instanceof y3 ? n31.accountId : y3.fromString(n31.accountId), this.expectedDecimals = n31.expectedDecimals, this.amount = long_default.fromValue(n31.amount), this.isApproved = n31.isApproved;
  }
  static _fromProtobuf(c17) {
    const s26 = [];
    for (const r41 of c17) {
      const c18 = c4._fromProtobuf(r41.token), i17 = null != r41.expectedDecimals && Object.hasOwn(r41.expectedDecimals, "value") ? r41.expectedDecimals.value : null;
      for (const e39 of null != r41.transfers ? r41.transfers : []) s26.push(new _n({ tokenId: c18, accountId: y3._fromProtobuf(e39.accountID), expectedDecimals: i17 || null, amount: null != e39.amount ? e39.amount : long_default.ZERO, isApproved: 1 == e39.isApproval }));
    }
    return s26;
  }
  _toProtobuf() {
    return { accountID: this.accountId._toProtobuf(), amount: this.amount, isApproval: this.isApproved };
  }
  toJSON() {
    return { tokenId: this.tokenId.toString(), accountId: this.accountId.toString(), expectedDecimals: this.expectedDecimals, amount: this.amount.toString(), isApproved: this.isApproved };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/lib/token/NftId.js
var t12 = __toESM(require_lib(), 1);
var e9 = class _e {
  constructor(t35, r41) {
    this.tokenId = t35, this.serial = "number" == typeof r41 ? long_default.fromNumber(r41) : r41, Object.freeze(this);
  }
  static fromString(t35) {
    const i17 = t35.split("/").length > 1 ? t35.split("/") : t35.split("@");
    for (const t36 of i17) if ("" === t36) throw new Error("invalid format for NftId: use [token]/[serial] or [token]@[serial]");
    const s26 = c4.fromString(i17[0]), n31 = long_default.fromString(i17[1]);
    return new _e(s26, n31);
  }
  static _fromProtobuf(t35) {
    return new _e(c4._fromProtobuf(t35.token_ID), null != t35.serialNumber ? t35.serialNumber : long_default.ZERO);
  }
  static fromBytes(r41) {
    return _e._fromProtobuf(t12.proto.NftID.decode(r41));
  }
  _toProtobuf() {
    return { token_ID: this.tokenId._toProtobuf(), serialNumber: long_default.fromValue(void 0 !== this.serial ? this.serial : 0) };
  }
  toString() {
    return `${this.tokenId.toString()}/${this.serial.toString()}`;
  }
  toBytes() {
    return t12.proto.NftID.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/token/PendingAirdropId.js
var t13 = class _t {
  constructor(e39 = {}) {
    var _a2, _b;
    this._senderId = null, this._receiverId = null, this._tokenId = null, this._nftId = null, e39.receiverId && (this._receiverId = e39.receiverId), e39.senderId && (this._senderId = e39.senderId), e39.tokenId ? this._tokenId = new c4(e39.tokenId) : e39.nftId && (this._nftId = new e9((_a2 = e39.nftId) == null ? void 0 : _a2.tokenId, (_b = e39.nftId) == null ? void 0 : _b.serial));
  }
  static fromBytes(d18) {
    if (null == d18.senderId) throw new Error("senderId is required");
    if (null == d18.receiverId) throw new Error("receiverId is required");
    if (null == d18.fungibleTokenType && null == d18.nonFungibleToken) throw new Error("Either fungibleTokenType or nonFungibleToken is required");
    return new _t({ senderId: y3._fromProtobuf(d18.senderId), receiverId: y3._fromProtobuf(d18.receiverId), nftId: null != d18.nonFungibleToken ? e9._fromProtobuf(d18.nonFungibleToken) : null, tokenId: null != d18.fungibleTokenType ? c4._fromProtobuf(d18.fungibleTokenType) : null });
  }
  setSenderid(e39) {
    return this._senderId = e39, this;
  }
  setReceiverId(e39) {
    return this._receiverId = e39, this;
  }
  setTokenId(e39) {
    return this._nftId = null, this._tokenId = e39, this;
  }
  setNftId(e39) {
    return this._tokenId = null, this._nftId = e39, this;
  }
  get senderId() {
    return this._senderId;
  }
  get receiverId() {
    return this._receiverId;
  }
  get tokenId() {
    return this._tokenId;
  }
  get nftId() {
    return this._nftId;
  }
  toBytes() {
    var _a2, _b, _c, _d;
    return { senderId: (_a2 = this.senderId) == null ? void 0 : _a2._toProtobuf(), receiverId: (_b = this._receiverId) == null ? void 0 : _b._toProtobuf(), fungibleTokenType: (_c = this._tokenId) == null ? void 0 : _c._toProtobuf(), nonFungibleToken: (_d = this._nftId) == null ? void 0 : _d._toProtobuf() };
  }
};

// node_modules/@hashgraph/sdk/lib/token/PendingAirdropRecord.js
var d6 = class _d {
  constructor(r41) {
    this.airdropId = r41.airdropId, this.amount = r41.amount;
  }
  toBytes() {
    return { pendingAirdropId: this.airdropId.toBytes(), pendingAirdropValue: { amount: this.amount } };
  }
  static fromBytes(i17) {
    var _a2;
    if (null == i17.pendingAirdropId) throw new Error("pendingAirdropId is required");
    const n31 = t13.fromBytes(i17.pendingAirdropId), t35 = (_a2 = i17.pendingAirdropValue) == null ? void 0 : _a2.amount;
    return new _d({ airdropId: n31, amount: t35 || long_default.ZERO });
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/TransactionRecord.js
var b3 = class _b {
  constructor(t35) {
    this.receipt = t35.receipt, this.transactionHash = t35.transactionHash, this.consensusTimestamp = t35.consensusTimestamp, this.transactionId = t35.transactionId, this.transactionMemo = t35.transactionMemo, this.transactionFee = t35.transactionFee, this.transfers = t35.transfers, this.contractFunctionResult = null != t35.contractFunctionResult ? t35.contractFunctionResult : null, this.tokenTransfers = t35.tokenTransfers, this.tokenTransfersList = t35.tokenTransfersList, this.scheduleRef = t35.scheduleRef, this.assessedCustomFees = t35.assessedCustomFees, this.nftTransfers = t35.nftTransfers, this.automaticTokenAssociations = t35.automaticTokenAssociations, this.parentConsensusTimestamp = t35.parentConsensusTimestamp, this.aliasKey = t35.aliasKey, this.duplicates = t35.duplicates, this.children = t35.children, this.hbarAllowanceAdjustments = t35.hbarAllowanceAdjustments, this.tokenAllowanceAdjustments = t35.tokenAllowanceAdjustments, this.nftAllowanceAdjustments = t35.nftAllowanceAdjustments, this.ethereumHash = t35.ethereumHash, this.paidStakingRewards = t35.paidStakingRewards, this.prngBytes = t35.prngBytes, this.prngNumber = t35.prngNumber, this.evmAddress = t35.evmAddress, this.newPendingAirdrops = t35.newPendingAirdrops, Object.freeze(this);
  }
  _toProtobuf() {
    const t35 = this.tokenTransfers._toProtobuf(), s26 = this.nftTransfers._toProtobuf(), e39 = [];
    for (const n31 of t35) for (const t36 of s26) null != n31.token && null != t36.token && n31.token.shardNum === t36.token.shardNum && n31.token.realmNum === t36.token.realmNum && n31.token.tokenNum === t36.token.tokenNum ? e39.push({ token: n31.token, transfers: n31.transfers, nftTransfers: n31.nftTransfers }) : (e39.push(n31), e39.push(t36));
    return { duplicateTransactionRecords: this.duplicates.map(((t36) => t36._toProtobuf().transactionRecord)), childTransactionRecords: this.children.map(((t36) => t36._toProtobuf().transactionRecord)), transactionRecord: { receipt: this.receipt._toProtobuf().receipt, transactionHash: null != this.transactionHash ? this.transactionHash : null, consensusTimestamp: null != this.consensusTimestamp ? this.consensusTimestamp._toProtobuf() : null, transactionID: null != this.transactionId ? this.transactionId._toProtobuf() : null, memo: null != this.transactionMemo ? this.transactionMemo : null, transactionFee: null != this.transactionFee ? this.transactionFee.toTinybars() : null, contractCallResult: null == this.contractFunctionResult || this.contractFunctionResult._createResult ? null : this.contractFunctionResult._toProtobuf(), contractCreateResult: null != this.contractFunctionResult && this.contractFunctionResult._createResult ? this.contractFunctionResult._toProtobuf() : null, transferList: null != this.transfers ? { accountAmounts: this.transfers.map(((t36) => t36._toProtobuf())) } : null, tokenTransferLists: e39, scheduleRef: null != this.scheduleRef ? this.scheduleRef._toProtobuf() : null, assessedCustomFees: this.assessedCustomFees.map(((t36) => t36._toProtobuf())), automaticTokenAssociations: this.automaticTokenAssociations.map(((t36) => t36._toProtobuf())), parentConsensusTimestamp: null != this.parentConsensusTimestamp ? this.parentConsensusTimestamp._toProtobuf() : null, alias: null != this.aliasKey ? u9.proto.Key.encode(this.aliasKey._toProtobufKey()).finish() : null, ethereumHash: this.ethereumHash, paidStakingRewards: this.paidStakingRewards.map(((t36) => t36._toProtobuf())), prngBytes: this.prngBytes, prngNumber: null != this.prngNumber ? this.prngNumber : null, evmAddress: null != this.evmAddress ? this.evmAddress.toBytes() : null, newPendingAirdrops: this.newPendingAirdrops.map(((t36) => t36.toBytes())) } };
  }
  static _fromProtobuf(T3) {
    const R = T3.transactionRecord;
    let A3 = null != R.alias && R.alias.length > 0 ? t2._fromProtobufKey(u9.proto.Key.decode(R.alias)) : null;
    A3 instanceof i || (A3 = null);
    const g5 = null != T3.childTransactionRecords ? T3.childTransactionRecords.map(((t35) => _b._fromProtobuf({ transactionRecord: t35 }))) : [], P2 = null != T3.duplicateTransactionRecords ? T3.duplicateTransactionRecords.map(((t35) => _b._fromProtobuf({ transactionRecord: t35 }))) : [], _4 = null != R.contractCallResult ? l4._fromProtobuf(R.contractCallResult, false) : null != R.contractCreateResult ? l4._fromProtobuf(R.contractCreateResult, true) : void 0, y5 = null != R.newPendingAirdrops ? R.newPendingAirdrops.map(((t35) => d6.fromBytes(t35))) : [];
    return new _b({ receipt: d5._fromProtobuf({ receipt: R.receipt }), transactionHash: null != R.transactionHash ? R.transactionHash : new Uint8Array(), consensusTimestamp: s3._fromProtobuf(R.consensusTimestamp), transactionId: i4._fromProtobuf(R.transactionID), transactionMemo: null != R.memo ? R.memo : "", transactionFee: e4.fromTinybars(null != R.transactionFee ? R.transactionFee : 0), transfers: n7._fromProtobuf(null != R.transferList && null != R.transferList.accountAmounts ? R.transferList.accountAmounts : []), contractFunctionResult: _4, tokenTransfers: n10._fromProtobuf(null != R.tokenTransferLists ? R.tokenTransferLists : []), tokenTransfersList: n12._fromProtobuf(null != R.tokenTransferLists ? R.tokenTransferLists : []), scheduleRef: null != R.scheduleRef ? o6._fromProtobuf(R.scheduleRef) : null, assessedCustomFees: null != R.assessedCustomFees ? R.assessedCustomFees.map(((t35) => n11._fromProtobuf(t35))) : [], nftTransfers: s6._fromProtobuf(null != R.tokenTransferLists ? R.tokenTransferLists : []), automaticTokenAssociations: null != R.automaticTokenAssociations ? R.automaticTokenAssociations.map(((t35) => u8._fromProtobuf(t35))) : [], parentConsensusTimestamp: null != R.parentConsensusTimestamp ? s3._fromProtobuf(R.parentConsensusTimestamp) : null, aliasKey: A3, duplicates: P2, children: g5, hbarAllowanceAdjustments: [], tokenAllowanceAdjustments: [], nftAllowanceAdjustments: [], ethereumHash: null != R.ethereumHash ? R.ethereumHash : null, paidStakingRewards: null != R.paidStakingRewards ? n7._fromProtobuf(R.paidStakingRewards) : [], prngBytes: null != R.prngBytes ? R.prngBytes : null, prngNumber: null != R.prngNumber ? R.prngNumber : null, evmAddress: null != R.evmAddress ? i3.fromBytes(R.evmAddress) : null, newPendingAirdrops: y5 });
  }
  static fromBytes(t35) {
    return _b._fromProtobuf(u9.proto.TransactionGetRecordResponse.decode(t35));
  }
  toBytes() {
    return u9.proto.TransactionGetRecordResponse.encode(this._toProtobuf()).finish();
  }
  toJSON() {
    var _a2, _b2, _c, _d;
    return { receipt: this.receipt.toJSON(), transactionHash: n(this.transactionHash), consensusTimestamp: this.consensusTimestamp.toDate(), transactionId: this.transactionId.toString(), transactionMemo: this.transactionMemo, transactionFee: this.transactionFee.toTinybars().toString(), transfers: this.transfers.map(((t35) => t35.toJSON())), tokenTransfers: this.tokenTransfers, tokenTransfersList: this.tokenTransfersList.map(((t35) => t35.toJSON())), scheduleRef: ((_a2 = this.scheduleRef) == null ? void 0 : _a2.toString()) || null, assessedCustomFees: this.assessedCustomFees, nftTransfers: this.nftTransfers, automaticTokenAssociations: this.automaticTokenAssociations, parentConsensusTimestamp: ((_b2 = this.parentConsensusTimestamp) == null ? void 0 : _b2.toDate()) || null, aliasKey: ((_c = this.aliasKey) == null ? void 0 : _c.toString()) || null, duplicates: this.duplicates, children: this.children, ethereumHash: null != this.ethereumHash ? n(this.ethereumHash) : null, paidStakingRewards: this.paidStakingRewards, prngBytes: null != this.prngBytes ? n(this.prngBytes) : null, prngNumber: this.prngNumber, evmAddress: ((_d = this.evmAddress) == null ? void 0 : _d.toString()) || null };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/lib/RecordStatusError.js
var r12 = class extends t9 {
  constructor(t35) {
    super(t35, `Record for transaction ${t35.transactionId.toString()} contained error status ${t35.status.toString()}`), this.transactionRecord = t35.transactionRecord;
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/TransactionRecordQuery.js
var u10 = __toESM(require_lib(), 1);
var { proto: l5 } = u10;
var h5 = class _h extends h3 {
  constructor(t35 = {}) {
    super(), this._transactionId = null, this._includeChildren = null, this._includeDuplicates = null, this._validateReceiptStatus = true, null != t35.transactionId && this.setTransactionId(t35.transactionId), null != t35.includeChildren && this.setIncludeChildren(t35.includeChildren), null != t35.includeDuplicates && this.setIncludeDuplicates(t35.includeDuplicates), null != t35.validateReceiptStatus && this.setValidateReceiptStatus(t35.validateReceiptStatus);
  }
  get transactionId() {
    return this._transactionId;
  }
  static _fromProtobuf(t35) {
    const e39 = t35.transactionGetRecord;
    return new _h({ transactionId: e39.transactionID ? i4._fromProtobuf(e39.transactionID) : void 0, includeChildren: null != e39.includeChildRecords ? e39.includeChildRecords : void 0, includeDuplicates: null != e39.includeDuplicates ? e39.includeDuplicates : void 0 });
  }
  setTransactionId(t35) {
    return this._transactionId = "string" == typeof t35 ? i4.fromString(t35) : t35.clone(), this;
  }
  setIncludeChildren(t35) {
    return this._includeChildren = t35, this;
  }
  get includeChildren() {
    return null != this._includeChildren && this._includeChildren;
  }
  setIncludeDuplicates(t35) {
    return this._duplicates = t35, this;
  }
  get includeDuplicates() {
    return null != this._duplicates && this._duplicates;
  }
  setValidateReceiptStatus(t35) {
    return this._validateReceiptStatus = t35, this;
  }
  get validateReceiptStatus() {
    return this._validateReceiptStatus;
  }
  _shouldRetry(t35, e39) {
    const { nodeTransactionPrecheckCode: r41 } = this._mapResponseHeader(e39);
    let n31 = e5._fromCode(null != r41 ? r41 : l5.ResponseCodeEnum.OK);
    switch (this._logger && this._logger.debug(`[${this._getLogId()}] received node precheck status ${n31.toString()}`), n31) {
      case e5.Busy:
      case e5.Unknown:
      case e5.ReceiptNotFound:
      case e5.RecordNotFound:
      case e5.PlatformNotActive:
        return [n31, c2.Retry];
      case e5.Ok:
        break;
      default:
        return [n31, c2.Error];
    }
    const s26 = e39.transactionGetRecord;
    if (s26.header.responseType === u10.proto.ResponseType.COST_ANSWER) return [n31, c2.Finished];
    const i17 = s26.transactionRecord.receipt.status;
    switch (n31 = e5._fromCode(i17), this._logger && this._logger.debug(`[${this._getLogId()}] received record's receipt ${n31.toString()}`), n31) {
      case e5.Ok:
      case e5.Busy:
      case e5.Unknown:
      case e5.ReceiptNotFound:
      case e5.RecordNotFound:
        return [n31, c2.Retry];
      case e5.Success:
        return [n31, c2.Finished];
      default:
        return [n31, this._validateReceiptStatus ? c2.Error : c2.Finished];
    }
  }
  _mapStatusError(t35, e39, s26) {
    const { nodeTransactionPrecheckCode: d18 } = this._mapResponseHeader(e39);
    let u22 = e5._fromCode(null != d18 ? d18 : l5.ResponseCodeEnum.OK);
    switch (u22) {
      case e5.Ok:
        break;
      case e5.ContractRevertExecuted:
        return new r12({ status: u22, transactionId: this._getTransactionId(), transactionRecord: b3._fromProtobuf({ transactionRecord: e39.transactionGetRecord.transactionRecord }) });
      default:
        return new n5({ nodeId: s26, status: u22, transactionId: this._getTransactionId(), contractFunctionResult: null });
    }
    const h8 = e39.transactionGetRecord.transactionRecord.receipt, p3 = h8.status;
    return u22 = e5._fromCode(p3), u22 === e5.ContractRevertExecuted ? new r12({ status: u22, transactionId: this._getTransactionId(), transactionRecord: b3._fromProtobuf({ transactionRecord: e39.transactionGetRecord.transactionRecord }) }) : new r6({ status: u22, transactionId: this._getTransactionId(), transactionReceipt: d5._fromProtobuf({ receipt: h8 }) });
  }
  _validateChecksums(t35) {
    null != this._transactionId && null != this._transactionId.accountId && this._transactionId.accountId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.crypto.getTxRecordByTxID(e39);
  }
  _mapResponseHeader(t35) {
    return t35.transactionGetRecord.header;
  }
  _mapResponse(t35, e39, n31) {
    const s26 = t35.transactionGetRecord;
    return Promise.resolve(b3._fromProtobuf(s26));
  }
  _onMakeRequest(t35) {
    return { transactionGetRecord: { header: t35, transactionID: null != this._transactionId ? this._transactionId._toProtobuf() : null, includeChildRecords: this._includeChildren, includeDuplicates: this._includeDuplicates } };
  }
  _getLogId() {
    return `TransactionRecordQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("transactionGetRecord", h5._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/transaction/TransactionResponse.js
var h6 = class _h {
  constructor(t35) {
    this.nodeId = t35.nodeId, this.transactionHash = t35.transactionHash, this.transactionId = t35.transactionId, this.transaction = t35.transaction, this.logger = t35.logger;
  }
  static fromJSON(t35) {
    return new _h({ nodeId: y3.fromString(t35.nodeId), transactionHash: r(t35.transactionHash), transactionId: i4.fromString(t35.transactionId) });
  }
  async getReceipt(e39) {
    var _a2;
    let n31;
    try {
      n31 = await this.getReceiptQuery().execute(e39);
    } catch (n32) {
      if (n32 instanceof r6 && n32.status === e5.ThrottledAtConsensus) return (_a2 = this.logger) == null ? void 0 : _a2.info("Transaction throttled at consensus"), this._retryTransaction(e39);
      throw n32;
    }
    if (n31.status !== e5.Success && n31.status !== e5.FeeScheduleFilePartUploaded) throw new r6({ transactionReceipt: n31, status: n31.status, transactionId: this.transactionId });
    return n31;
  }
  async getRecord(t35) {
    return await this.getReceipt(t35), this.getRecordQuery().execute(t35);
  }
  async getVerboseRecord(t35) {
    try {
      return await this.getReceiptQuery().execute(t35), this.getRecordQuery().execute(t35);
    } catch (r41) {
      return this.getRecordQuery().execute(t35);
    }
  }
  async getReceiptWithSigner(e39) {
    const n31 = await this.getReceiptQuery().executeWithSigner(e39);
    if (n31.status !== e5.Success) throw new r6({ transactionReceipt: n31, status: n31.status, transactionId: this.transactionId });
    return n31;
  }
  async getRecordWithSigner(t35) {
    return await this.getReceiptWithSigner(t35), this.getRecordQuery().executeWithSigner(t35);
  }
  getReceiptQuery() {
    return new l3().setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId]);
  }
  getRecordQuery() {
    return new h5().setTransactionId(this.transactionId).setNodeAccountIds([this.nodeId]);
  }
  toJSON() {
    return { nodeId: this.nodeId.toString(), transactionHash: n(this.transactionHash), transactionId: this.transactionId.toString() };
  }
  async _retryTransaction(n31) {
    var _a2, _b, _c, _d, _e, _f, _g, _h2, _i;
    if (!this.transaction) throw new Error("If you retry transaction you should have the transaction set");
    if (((_a2 = n31.operatorAccountId) == null ? void 0 : _a2.toString()) !== ((_c = (_b = this.transaction.transactionId) == null ? void 0 : _b.accountId) == null ? void 0 : _c.toString())) throw new Error("Retry mechanism is not supported when tx id is not generated by the operator account");
    if (null === n31.operatorAccountId) throw new Error("Operator account is not set");
    let s26 = 250;
    for (let a23 = 0; a23 < 5; a23++) {
      if ((_d = this.logger) == null ? void 0 : _d.trace(`Transaction throttled, retry attempt ${a23}`), (_e = this.transaction) == null ? void 0 : _e._resetTransaction(n31), null == this.transaction || null == this.transaction.transactionId) throw new Error("Transaction or Transaction ID is null after reset");
      this.transactionId = this.transaction.transactionId, a23 > 0 && (await I(Math.min(s26, 16e3)), s26 *= 2);
      try {
        this.transaction._resetTransaction(n31);
        const t35 = await this.transaction.execute(n31), s27 = await new l3().setTransactionId(t35.transactionId).setNodeAccountIds([t35.nodeId]).execute(n31);
        if (s27.status !== e5.ThrottledAtConsensus) return (_f = this.logger) == null ? void 0 : _f.info(`Transaction throttle retry succeeded after attempt ${a23}`), s27;
      } catch (e39) {
        if (e39 instanceof r6 && e39.status === e5.ThrottledAtConsensus) {
          (_g = this.logger) == null ? void 0 : _g.info("Transaction throttled at consensus");
          continue;
        }
        throw (_h2 = this.logger) == null ? void 0 : _h2.error(`An error occurred after throttle retry: ${e39 instanceof Error ? e39.message : String(e39)}`), e39;
      }
    }
    throw (_i = this.logger) == null ? void 0 : _i.error("Transaction throttle retry failed after maximum attempts"), new Error("Transaction retry failed after maximum attempts");
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@hashgraph/sdk/lib/cryptography/sha384.browser.js
async function t14(t35) {
  return new Uint8Array(await window.crypto.subtle.digest("SHA-384", t35));
}

// node_modules/@hashgraph/sdk/lib/transaction/TransactionHashMap.js
var n13 = class _n extends t3 {
  constructor() {
    super(((o32) => y3.fromString(o32)));
  }
  static async _fromTransaction(t35) {
    const s26 = new _n();
    for (let n31 = 0; n31 < t35._nodeAccountIds.length; n31++) {
      const r41 = t35._nodeAccountIds.list[n31], c17 = t35._transactions.get(n31), a23 = await t14(c17.signedTransactionBytes);
      s26._set(r41, a23);
    }
    return s26;
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/NodeAccountIdSignatureMapLegacy.js
var t15 = class _t extends t3 {
  constructor() {
    super(((e39) => i.fromString(e39)));
  }
  static _fromTransactionSigMap(e39) {
    const s26 = new _t(), o32 = null != e39.sigPair ? e39.sigPair : [];
    for (const e40 of o32) null != e40.pubKeyPrefix && (null != e40.ed25519 ? s26._set(i.fromBytesED25519(e40.pubKeyPrefix), e40.ed25519) : null != e40.ECDSASecp256k1 && s26._set(i.fromBytesECDSA(e40.pubKeyPrefix), e40.ECDSASecp256k1));
    return s26;
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/SignatureMapLegacy.js
var s7 = class _s extends t3 {
  constructor() {
    super(((t35) => y3.fromString(t35)));
  }
  static _fromTransaction(o32) {
    const n31 = new _s();
    for (let s26 = 0; s26 < o32._nodeAccountIds.length; s26++) {
      const c17 = o32._signedTransactions.get(s26).sigMap;
      null != c17 && n31._set(o32._nodeAccountIds.list[s26], t15._fromTransactionSigMap(c17));
    }
    return n31;
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/Transaction.js
var l7 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/lib/token/CustomFee.js
var e10 = class {
  constructor(t35 = {}) {
    this._feeCollectorAccountId = null, this._allCollectorsAreExempt = false, null != t35.feeCollectorAccountId && this.setFeeCollectorAccountId(t35.feeCollectorAccountId), null != t35.allCollectorsAreExempt && this.setAllCollectorsAreExempt(t35.allCollectorsAreExempt);
  }
  get feeCollectorAccountId() {
    return this._feeCollectorAccountId;
  }
  setFeeCollectorAccountId(e39) {
    return this._feeCollectorAccountId = "string" == typeof e39 ? y3.fromString(e39) : e39, this;
  }
  get allCollectorsAreExempt() {
    return this._allCollectorsAreExempt;
  }
  setAllCollectorsAreExempt(t35) {
    return this._allCollectorsAreExempt = t35, this;
  }
  static _fromProtobuf(t35) {
    throw new Error("not implemented");
  }
  _toProtobuf() {
    throw new Error("not implemented");
  }
};

// node_modules/@hashgraph/sdk/lib/token/CustomFixedFee.js
var l6 = class _l extends e10 {
  constructor(n31 = {}) {
    super(n31), this._denominatingTokenId = null, null != n31.denominatingTokenId && this.setDenominatingTokenId(n31.denominatingTokenId), this._amount = null, null != n31.amount && this.setAmount(n31.amount);
  }
  setHbarAmount(n31) {
    return this._amount = n31.toTinybars(), this._denominatingTokenId = null, this;
  }
  get hbarAmount() {
    return null != this._denominatingTokenId ? null : e4.fromTinybars(null != this._amount ? this._amount : 0);
  }
  setDenominatingTokenToSameToken() {
    return this._denominatingTokenId = new c4(0, 0, 0), this;
  }
  get denominatingTokenId() {
    return this._denominatingTokenId;
  }
  setDenominatingTokenId(o32) {
    return this._denominatingTokenId = "string" == typeof o32 ? c4.fromString(o32) : o32, this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(n31) {
    return this._amount = "number" == typeof n31 ? long_default.fromNumber(n31) : n31, this;
  }
  static _fromProtobuf(o32) {
    const e39 = o32.fixedFee;
    return new _l({ feeCollectorAccountId: null != o32.feeCollectorAccountId ? y3._fromProtobuf(o32.feeCollectorAccountId) : void 0, allCollectorsAreExempt: null != o32.allCollectorsAreExempt ? o32.allCollectorsAreExempt : void 0, denominatingTokenId: null != e39.denominatingTokenId ? c4._fromProtobuf(e39.denominatingTokenId) : void 0, amount: null != e39.amount ? e39.amount : void 0 });
  }
  _toProtobuf() {
    return { feeCollectorAccountId: null != this.feeCollectorAccountId ? this.feeCollectorAccountId._toProtobuf() : null, allCollectorsAreExempt: this.allCollectorsAreExempt, fixedFee: { denominatingTokenId: null != this._denominatingTokenId ? this._denominatingTokenId._toProtobuf() : null, amount: this._amount } };
  }
  _toTopicFeeProtobuf() {
    return { feeCollectorAccountId: null != this.feeCollectorAccountId ? this.feeCollectorAccountId._toProtobuf() : null, fixedFee: { denominatingTokenId: null != this._denominatingTokenId ? this._denominatingTokenId._toProtobuf() : null, amount: this._amount } };
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/CustomFeeLimit.js
var o10 = class _o {
  constructor(t35 = {}) {
    this._accountId = null, t35.accountId && this.setAccountId(t35.accountId), this._fees = null, t35.fees && this.setFees(t35.fees);
  }
  static _fromProtobuf(s26) {
    return new _o({ accountId: null != s26.accountId ? y3._fromProtobuf(s26.accountId) : null, fees: null != s26.fees ? s26.fees.map(((t35) => l6._fromProtobuf({ fixedFee: t35 }))) : null });
  }
  getAccountId() {
    return this._accountId;
  }
  setAccountId(e39) {
    return this._accountId = e39 instanceof y3 ? e39 : y3.fromString(e39), this;
  }
  getFees() {
    return this._fees;
  }
  setFees(t35) {
    return this._fees = t35, this;
  }
  _toProtobuf() {
    const t35 = [];
    return null != this._fees && this._fees.forEach(((e39) => {
      const o32 = e39._toProtobuf();
      null != o32.fixedFee && t35.push(o32.fixedFee);
    })), { accountId: null != this._accountId ? this._accountId._toProtobuf() : null, fees: t35 };
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/SignableNodeTransactionBodyBytes.js
var t16 = class {
  constructor(t35, s26, a23) {
    this.nodeAccountId = t35, this.transactionId = s26, this.signableTransactionBodyBytes = a23;
  }
};

// node_modules/@hashgraph/sdk/lib/transaction/Transaction.js
var w3 = long_default.fromValue(7776e3);
var S2 = e4.fromTinybars(long_default.fromString("9223372036854775807"));
var A2 = new y3(0, 0, 0);
var k2 = 1024;
var B = /* @__PURE__ */ new Map();
var P = class extends u3 {
  constructor() {
    super();
    __publicField(this, "_shouldRemoveSignature", (t35, n31) => n((t35 == null ? void 0 : t35.pubKeyPrefix) || new Uint8Array()) === n31);
    this._transactions = new t7(), this._signedTransactions = new t7(), this._signerPublicKeys = /* @__PURE__ */ new Set(), this._transactionValidDuration = 120, this._defaultMaxTransactionFee = new e4(2), this._customFeeLimits = [], this._maxTransactionFee = null, this._transactionMemo = "", this._transactionIds = new t7(), this._publicKeys = [], this._transactionSigners = [], this._regenerateTransactionId = null, this._batchKey = null, this._isThrottled = false;
  }
  static fromBytes(t35) {
    const n31 = [], i17 = [], e39 = [], o32 = [], r41 = [], a23 = [], c17 = l7.proto.TransactionList.decode(t35).transactionList;
    if (0 === c17.length) {
      const n32 = l7.proto.Transaction.decode(t35);
      0 !== n32.signedTransactionBytes.length ? c17.push(n32) : c17.push({ signedTransactionBytes: l7.proto.SignedTransaction.encode({ sigMap: n32.sigMap, bodyBytes: n32.bodyBytes }).finish() });
    }
    for (const t36 of c17) {
      if (null == t36.bodyBytes && null == t36.signedTransactionBytes) throw new Error("bodyBytes and signedTransactionBytes are null");
      if (t36.bodyBytes && 0 != t36.bodyBytes.length) {
        const n32 = l7.proto.TransactionBody.decode(t36.bodyBytes);
        if (null != n32.transactionID) {
          const t37 = i4._fromProtobuf(n32.transactionID);
          o32.includes(t37.toString()) || (i17.push(t37), o32.push(t37.toString()));
        }
        if (null != n32.nodeAccountID) {
          const t37 = y3._fromProtobuf(n32.nodeAccountID);
          r41.includes(t37.toString()) || (e39.push(t37), r41.push(t37.toString()));
        }
        if (null == n32.data) throw new Error("(BUG) body.data was not set in the protobuf");
        a23.push(n32);
      }
      if (t36.signedTransactionBytes && 0 != t36.signedTransactionBytes.length) {
        const c18 = l7.proto.SignedTransaction.decode(t36.signedTransactionBytes);
        n31.push(c18);
        const h9 = l7.proto.TransactionBody.decode(c18.bodyBytes);
        if (null != h9.transactionID) {
          const t37 = i4._fromProtobuf(h9.transactionID);
          o32.includes(t37.toString()) || (i17.push(t37), o32.push(t37.toString()));
        }
        if (null != h9.nodeAccountID) {
          const t37 = y3._fromProtobuf(h9.nodeAccountID);
          r41.includes(t37.toString()) || (e39.push(t37), r41.push(t37.toString()));
        }
        if (null == h9.data) throw new Error("(BUG) body.data was not set in the protobuf");
        a23.push(h9);
      }
    }
    const h8 = a23[0];
    if (null == h8 || null == h8.data) throw new Error("No transaction found in bytes or failed to decode TransactionBody");
    const u22 = B.get(h8.data);
    if (null == u22) throw new Error(`(BUG) Transaction.fromBytes() not implemented for type ${h8.data}`);
    return u22(c17, n31, i17, e39, a23);
  }
  schedule() {
    if (this._requireNotFrozen(), 1 != F.length) throw new Error("ScheduleCreateTransaction has not been loaded yet");
    return F[0]()._setScheduledTransaction(this);
  }
  async batchify(t35, n31) {
    return this._requireNotFrozen(), this.setBatchKey(n31), await this.signWithOperator(t35);
  }
  static _fromProtobufTransactions(n31, s26, i17, e39, o32, r41) {
    var _a2;
    const a23 = r41[0];
    for (let t35 = 0; t35 < e39.length; t35++) for (let n32 = 0; n32 < o32.length - 1; n32++) if (!L(r41[t35 * o32.length + n32], r41[t35 * o32.length + n32 + 1], /* @__PURE__ */ new Set(["nodeAccountID"]))) throw new Error("failed to validate transaction bodies");
    const c17 = new y3(0);
    for (let t35 = 0; t35 < o32.length; t35++) o32[t35].equals(c17) && o32.splice(t35--, 1);
    n31._transactions.setList(s26), n31._signedTransactions.setList(i17), n31._transactionIds.setList(e39), n31._nodeAccountIds.setList(o32), n31._transactionValidDuration = null != a23.transactionValidDuration && null != a23.transactionValidDuration.seconds ? long_default.fromValue(a23.transactionValidDuration.seconds).toInt() : 120, n31._maxTransactionFee = null != a23.transactionFee && a23.transactionFee > new long_default(0, 0, true) ? e4.fromTinybars(a23.transactionFee) : null, n31._customFeeLimits = null != a23.maxCustomFees ? (_a2 = a23.maxCustomFees) == null ? void 0 : _a2.map(((t35) => o10._fromProtobuf(t35))) : [], n31._batchKey = null != a23.batchKey ? t2._fromProtobufKey(a23 == null ? void 0 : a23.batchKey) : null, n31._transactionMemo = null != a23.memo ? a23.memo : "";
    for (let t35 = 0; t35 < o32.length; t35++) {
      const e40 = i17[t35] || s26[t35];
      if (null != e40.sigMap && null != e40.sigMap.sigPair) for (const t36 of e40.sigMap.sigPair) n31._signerPublicKeys.add(n(t36.pubKeyPrefix)), n31._publicKeys.push(i.fromBytes(t36.pubKeyPrefix)), n31._transactionSigners.push(null);
    }
    return n31;
  }
  setNodeAccountIds(t35) {
    return this._requireNotFrozen(), super.setNodeAccountIds(t35), this;
  }
  get transactionValidDuration() {
    return this._transactionValidDuration;
  }
  get size() {
    return this._requireFrozen(), this._makeRequestAsync().then(((t35) => l7.proto.Transaction.encode(t35).finish().length));
  }
  get bodySize() {
    const t35 = this._makeTransactionBody(y3.fromString("0.0.0"));
    return l7.proto.TransactionBody.encode(t35).finish().length;
  }
  setTransactionValidDuration(t35) {
    return this._requireNotFrozen(), this._transactionValidDuration = t35, this;
  }
  get maxTransactionFee() {
    return this._maxTransactionFee;
  }
  setMaxTransactionFee(n31) {
    return this._requireNotFrozen(), this._maxTransactionFee = n31 instanceof e4 ? n31 : new e4(n31), this;
  }
  get regenerateTransactionId() {
    return this._regenerateTransactionId;
  }
  setRegenerateTransactionId(t35) {
    return this._requireNotFrozen(), this._regenerateTransactionId = t35, this;
  }
  get transactionMemo() {
    return this._transactionMemo;
  }
  setTransactionMemo(t35) {
    return this._requireNotFrozen(), this._transactionMemo = t35, this;
  }
  get transactionId() {
    return this._transactionIds.isEmpty ? null : (this._transactionIds.setLocked(), this._transactionIds.current);
  }
  setTransactionId(t35) {
    return this._requireNotFrozen(), this._transactionIds.setList([t35]).setLocked(), this;
  }
  getRequiredChunks() {
    return 1;
  }
  get bodySizeAllChunks() {
    const t35 = [];
    for (let n31 = 0; n31 < this.getRequiredChunks(); n31++) this._transactionIds.index = n31, t35.push(this.bodySize);
    return this._transactionIds.index = 0, t35;
  }
  sign(t35) {
    return this.signWith(t35.publicKey, ((n31) => Promise.resolve(t35.sign(n31))));
  }
  async signWith(t35, n31) {
    this._signOnDemand || this._requireFrozen();
    const s26 = t35.toBytesRaw(), i17 = n(s26);
    if (this._signerPublicKeys.has(i17)) return this;
    if (this._transactions.clear(), this._signerPublicKeys.add(i17), this._publicKeys.push(t35), this._transactionSigners.push(n31), this._signOnDemand) return this;
    this._transactionIds.setLocked(), this._nodeAccountIds.setLocked();
    for (const s27 of this._signedTransactions.list) {
      const i18 = s27.bodyBytes, e39 = await n31(i18);
      null == s27.sigMap && (s27.sigMap = {}), null == s27.sigMap.sigPair && (s27.sigMap.sigPair = []), s27.sigMap.sigPair.push(t35._toProtobufSignature(e39));
    }
    return this;
  }
  signWithOperator(t35) {
    const n31 = t35._operator;
    if (null == n31) throw new Error("`client` must have an operator to sign with the operator");
    return this._isFrozen() || this.freezeWith(t35), this.signWith(n31.publicKey, n31.transactionSigner);
  }
  _resetTransaction(t35) {
    var _a2;
    if (!t35.operatorAccountId) throw new Error("Client must have an operator account ID");
    (_a2 = this.logger) == null ? void 0 : _a2.info("Resetting transaction id and resigning");
    const n31 = i4.generate(t35.operatorAccountId);
    this._transactionIds.clear(), this._signedTransactions.clear(), this._transactionIds.setList([n31]), this._isThrottled = true;
  }
  addSignature(t35, n31) {
    var _a2, _b;
    if (!(n31 instanceof e2)) return this._addSignatureLegacy(t35, n31);
    this.isFrozen() || this.freeze();
    const i17 = t35.toBytesRaw(), o32 = n(i17);
    if (this._signerPublicKeys.has(o32)) return this;
    this._transactions.clear(), this._transactionIds.setLocked(), this._nodeAccountIds.setLocked(), this._signedTransactions.setLocked();
    for (let i18 = 0; i18 < this._signedTransactions.length; i18++) {
      const e39 = this._signedTransactions.get(i18);
      if (null == e39.sigMap && (e39.sigMap = {}), null == e39.sigMap.sigPair && (e39.sigMap.sigPair = []), e39.bodyBytes) {
        const { transactionID: i19, nodeAccountID: o33 } = l7.proto.TransactionBody.decode(e39.bodyBytes);
        if (!i19 || !o33) throw new Error("Transaction ID or Node Account ID not found in the signed transaction");
        const r41 = i4._fromProtobuf(i19), a23 = y3._fromProtobuf(o33), c17 = n31.get(a23), h8 = c17 == null ? void 0 : c17.get(r41), u22 = h8 == null ? void 0 : h8.get(t35);
        if (!u22) throw new Error("Signature not found for the transaction and public key");
        const d18 = t35._toProtobufSignature(u22);
        (_b = (_a2 = e39.sigMap) == null ? void 0 : _a2.sigPair) == null ? void 0 : _b.push(d18);
      }
    }
    return this._signerPublicKeys.add(o32), this._publicKeys.push(t35), this._transactionSigners.push(null), this;
  }
  _addSignatureLegacy(t35, n31) {
    const s26 = n31 instanceof Uint8Array, i17 = Array.isArray(n31);
    if (this.getRequiredChunks() > 1) throw new Error("Add signature is not supported for chunked transactions");
    if (s26 && 1 !== this._signedTransactions.length) throw new Error("Signature array must match the number of transactions");
    if (i17 && n31.length !== this._signedTransactions.length) throw new Error("Signature array must match the number of transactions");
    this.isFrozen() || this.freeze();
    const e39 = t35.toBytesRaw(), o32 = n(e39);
    if (this._signerPublicKeys.has(o32)) return this;
    this._transactions.clear(), this._transactionIds.setLocked(), this._nodeAccountIds.setLocked(), this._signedTransactions.setLocked();
    const r41 = s26 ? [n31] : n31;
    for (let n32 = 0; n32 < this._signedTransactions.length; n32++) {
      const s27 = this._signedTransactions.get(n32);
      null == s27.sigMap && (s27.sigMap = {}), null == s27.sigMap.sigPair && (s27.sigMap.sigPair = []), s27.sigMap.sigPair.push(t35._toProtobufSignature(r41[n32]));
    }
    return this._signerPublicKeys.add(o32), this._publicKeys.push(t35), this._transactionSigners.push(null), this;
  }
  getSignaturesLegacy() {
    return this._requireFrozen(), this._requireNotSignOnDemand(), this._buildAllTransactions(), this._transactionIds.setLocked(), this._nodeAccountIds.setLocked(), s7._fromTransaction(this);
  }
  removeSignature(t35) {
    this.isFrozen() || this.freeze();
    const n31 = t35.toBytesRaw(), s26 = n(n31);
    if (!this._signerPublicKeys.has(s26)) throw new Error("The public key has not signed this transaction");
    const i17 = [];
    for (const t36 of this._signedTransactions.list) {
      const n32 = this._removeSignaturesFromTransaction(t36, s26);
      i17.push(...n32);
    }
    return this._signerPublicKeys.delete(s26), this._publicKeys = this._publicKeys.filter(((n32) => !n32.equals(t35))), this._transactionSigners.pop(), i17;
  }
  removeAllSignatures() {
    this.isFrozen() || this.freeze();
    const t35 = this._collectSignaturesByPublicKey();
    for (const t36 of this._signedTransactions.list) t36.sigMap && t36.sigMap.sigPair && (t36.sigMap.sigPair = []);
    return this._signerPublicKeys.clear(), this._publicKeys = [], this._transactionSigners = [], t35;
  }
  getSignatures(t35) {
    return t35 ? this.getSignaturesLegacy() : (this._requireFrozen(), this._requireNotSignOnDemand(), this._buildAllTransactions(), this._transactionIds.setLocked(), this._nodeAccountIds.setLocked(), e2._fromTransaction(this));
  }
  async getSignaturesAsync() {
    return this._transactionIds.setLocked(), this._nodeAccountIds.setLocked(), await this._buildAllTransactionsAsync(), this._transactions.setLocked(), this._signedTransactions.setLocked(), e2._fromTransaction(this);
  }
  _setTransactionId() {
    if (null == this._operatorAccountId && this._transactionIds.isEmpty) throw new Error("`transactionId` must be set or `client` must be provided with `freezeWith`");
  }
  _setNodeAccountIds(t35) {
    if (this._nodeAccountIds.isEmpty) {
      if (null == t35) throw new Error("`nodeAccountId` must be set or `client` must be provided with `freezeWith`");
      this._nodeAccountIds.setList(t35._network.getNodeAccountIdsForExecute());
    }
  }
  setBatchKey(t35) {
    return this._requireNotFrozen(), this._batchKey = t35, this;
  }
  get batchKey() {
    return this._batchKey;
  }
  get signableNodeBodyBytesList() {
    return this._requireFrozen(), this._signedTransactions.list.map(((t35) => {
      if (!t35.bodyBytes) throw new Error("Missing bodyBytes in signed transaction.");
      const n31 = l7.proto.TransactionBody.decode(t35.bodyBytes);
      if (!n31.nodeAccountID) throw new Error("Missing nodeAccountID in transaction body.");
      const i17 = y3._fromProtobuf(n31.nodeAccountID);
      if (!n31.transactionID) throw new Error("Missing transactionID in transaction body.");
      const e39 = i4._fromProtobuf(n31.transactionID);
      return new t16(i17, e39, t35.bodyBytes);
    }));
  }
  _buildSignedTransactions() {
    this._signedTransactions.locked || this._signedTransactions.setList(this._nodeAccountIds.list.map(((t35) => this._makeSignedTransaction(t35))));
  }
  _buildIncompleteTransactions() {
    0 == this._nodeAccountIds.length ? this._transactions.setList([this._makeSignedTransaction(null)]) : this._transactions.setList(this._nodeAccountIds.list.map(((t35) => this._makeSignedTransaction(t35))));
  }
  freeze() {
    return this.freezeWith(null);
  }
  _freezeWithAccountId(t35) {
    null == this._operatorAccountId && (this._operatorAccountId = t35);
  }
  freezeWith(t35) {
    if (this._signOnDemand = null != t35 && t35.signOnDemand, this._operator = null != t35 ? t35._operator : null, this._freezeWithAccountId(null != t35 ? t35.operatorAccountId : null), this._maxTransactionFee = null == this._maxTransactionFee ? null != t35 && null != t35.defaultMaxTransactionFee ? t35.defaultMaxTransactionFee : this._defaultMaxTransactionFee : this._maxTransactionFee, this._regenerateTransactionId = null != t35 && null == this._regenerateTransactionId ? t35.defaultRegenerateTransactionId : this._regenerateTransactionId, this.batchKey ? this._nodeAccountIds.setList([A2]) : this._setNodeAccountIds(t35), this._setTransactionId(), null != t35) for (const n31 of this._transactionIds.list) null != n31.accountId && n31.accountId.validateChecksum(t35);
    return this._buildNewTransactionIdList(), this._signOnDemand || this._buildSignedTransactions(), this;
  }
  async signWithSigner(t35) {
    return await t35.signTransaction(this), this;
  }
  async freezeWithSigner(t35) {
    return await t35.populateTransaction(this), this.freeze(), this;
  }
  toBytes() {
    return this._requireNotSignOnDemand(), this._isFrozen() ? (this._transactionIds.setLocked(), this._nodeAccountIds.setLocked(), this._buildAllTransactions()) : this._buildIncompleteTransactions(), l7.proto.TransactionList.encode({ transactionList: this._transactions.list }).finish();
  }
  async toBytesAsync() {
    return this._transactionIds.setLocked(), this._nodeAccountIds.setLocked(), await this._buildAllTransactionsAsync(), this._transactions.setLocked(), this._signedTransactions.setLocked(), l7.proto.TransactionList.encode({ transactionList: this._transactions.list }).finish();
  }
  async getTransactionHash() {
    return this._requireFrozen(), this._transactionIds.setLocked(), this._nodeAccountIds.setLocked(), await this._buildAllTransactionsAsync(), this._transactions.setLocked(), this._signedTransactions.setLocked(), t14(this._transactions.get(0).signedTransactionBytes);
  }
  async getTransactionHashPerNode() {
    return this._requireFrozen(), this._transactionIds.setLocked(), this._nodeAccountIds.setLocked(), await this._buildAllTransactionsAsync(), await n13._fromTransaction(this);
  }
  isFrozen() {
    return this._signedTransactions.length > 0;
  }
  _getTransactionId() {
    const t35 = this.transactionId;
    if (null == t35) throw new Error("transaction must have been frozen before getting the transaction ID, try calling `freeze`");
    return t35;
  }
  _validateChecksums(t35) {
  }
  async _beforeExecute(t35) {
    this.transactionNodeIds = Object.values(t35.network).map(((t36) => t36.toString())), this._logger && this._logger.info(`Network used: ${t35._network.networkName}`), this._isFrozen() || this.freezeWith(t35), t35.isAutoValidateChecksumsEnabled() && this._validateChecksums(t35), null != this._operator && null != this._operator || (this._operator = null != t35 ? t35._operator : null), null != this._operatorAccountId && null != this._operatorAccountId || (this._operatorAccountId = null != t35 && null != t35._operator ? t35._operator.accountId : null), null != this._operator && await this.signWith(this._operator.publicKey, this._operator.transactionSigner);
  }
  async _makeRequestAsync() {
    const t35 = this._transactionIds.index * this._nodeAccountIds.length + this._nodeAccountIds.index;
    return this._signOnDemand || this._isThrottled ? await this._buildTransactionAsync() : (this._buildTransaction(t35), this._transactions.get(t35));
  }
  async _signTransaction() {
    const t35 = this._makeSignedTransaction(this._nodeAccountIds.next), n31 = t35.bodyBytes;
    for (let s26 = 0; s26 < this._publicKeys.length; s26++) {
      const i17 = this._publicKeys[s26], e39 = this._transactionSigners[s26];
      if (null == e39) continue;
      const o32 = await e39(n31);
      null == t35.sigMap && (t35.sigMap = {}), null == t35.sigMap.sigPair && (t35.sigMap.sigPair = []), t35.sigMap.sigPair.push(i17._toProtobufSignature(o32));
    }
    return t35;
  }
  _buildNewTransactionIdList() {
    if (this._transactionIds.locked || null == this._operatorAccountId) return;
    const t35 = i4.withValidStart(this._operatorAccountId, s3.generate());
    this._transactionIds.set(this._transactionIds.index, t35);
  }
  _buildAllTransactions() {
    for (let t35 = 0; t35 < this._signedTransactions.length; t35++) this._buildTransaction(t35);
  }
  async _buildAllTransactionsAsync() {
    if (this._signOnDemand) {
      if (this._buildSignedTransactions(), !this._transactions.locked) for (let t35 = 0; t35 < this._signedTransactions.length; t35++) this._transactions.push(await this._buildTransactionAsync());
    } else this._buildAllTransactions();
  }
  _buildTransaction(t35) {
    if (this._transactions.length < t35) for (let n31 = this._transactions.length; n31 < t35; n31++) this._transactions.push(null);
    null != this._transactions.list[t35] && this._transactions.set(t35, { signedTransactionBytes: l7.proto.SignedTransaction.encode(this._signedTransactions.get(t35)).finish() }), this._transactions.setIfAbsent(t35, (() => ({ signedTransactionBytes: l7.proto.SignedTransaction.encode(this._signedTransactions.get(t35)).finish() })));
  }
  async _buildTransactionAsync() {
    return { signedTransactionBytes: l7.proto.SignedTransaction.encode(await this._signTransaction()).finish() };
  }
  _shouldRetry(t35, n31) {
    const { nodeTransactionPrecheckCode: s26 } = n31, i17 = e5._fromCode(null != s26 ? s26 : l7.proto.ResponseCodeEnum.OK);
    switch (this._logger && (this._logger.debug(`[${this._getLogId()}] received status ${i17.toString()}`), this._logger.info(`SDK Transaction Status Response: ${i17.toString()}`)), i17) {
      case e5.Busy:
      case e5.Unknown:
      case e5.PlatformTransactionNotCreated:
      case e5.PlatformNotActive:
        return [i17, c2.Retry];
      case e5.Ok:
        return [i17, c2.Finished];
      case e5.TransactionExpired:
        return this._transactionIds.locked || null != this._regenerateTransactionId && !this._regenerateTransactionId ? [i17, c2.Error] : (this._buildNewTransactionIdList(), [i17, c2.Retry]);
      default:
        return [i17, c2.Error];
    }
  }
  _mapStatusError(t35, n31, s26) {
    const { nodeTransactionPrecheckCode: i17 } = n31, e39 = e5._fromCode(null != i17 ? i17 : l7.proto.ResponseCodeEnum.OK);
    return this._logger && this._logger.info(`Transaction Error Info: ${e39.toString()}, ${this.transactionId.toString()}`), new n5({ nodeId: s26, status: e39, transactionId: this._getTransactionId(), contractFunctionResult: null });
  }
  async _mapResponse(t35, s26, i17) {
    const e39 = await t14(i17.signedTransactionBytes), o32 = this._getTransactionId();
    return this._transactionIds.advance(), this._logger && this._logger.info(`Transaction Info: ${JSON.stringify(new h6({ nodeId: s26, transactionHash: e39, transactionId: o32, logger: this._logger }).toJSON())}`), new h6({ nodeId: s26, transactionHash: e39, transactionId: o32, transaction: this, logger: this._logger });
  }
  _makeSignedTransaction(t35) {
    const n31 = this._makeTransactionBody(t35);
    this._logger && this._logger.info(`Transaction Body: ${JSON.stringify(n31)}`);
    return { sigMap: { sigPair: [] }, bodyBytes: l7.proto.TransactionBody.encode(n31).finish() };
  }
  isBatchedAndNotBatchTransaction() {
    return null != this.batchKey && "atomicBatch" != this._getTransactionDataCase();
  }
  _makeTransactionBody(t35) {
    var _a2;
    return { [this._getTransactionDataCase()]: this._makeTransactionData(), transactionFee: null != this._maxTransactionFee ? this._maxTransactionFee.toTinybars() : null, memo: this._transactionMemo, transactionID: null != this._transactionIds.current ? this._transactionIds.current._toProtobuf() : null, nodeAccountID: null != t35 ? t35._toProtobuf() : null, transactionValidDuration: { seconds: long_default.fromNumber(this._transactionValidDuration) }, maxCustomFees: null != this._customFeeLimits ? this._customFeeLimits.map(((t36) => t36._toProtobuf())) : null, batchKey: (_a2 = this.batchKey) == null ? void 0 : _a2._toProtobufKey() };
  }
  _getTransactionDataCase() {
    throw new Error("not implemented");
  }
  _getScheduledTransactionBody() {
    return { memo: this.transactionMemo, transactionFee: null == this._maxTransactionFee ? this._defaultMaxTransactionFee.toTinybars() : this._maxTransactionFee.toTinybars(), [this._getTransactionDataCase()]: this._makeTransactionData() };
  }
  _makeTransactionData() {
    throw new Error("not implemented");
  }
  _isFrozen() {
    return this._signOnDemand || this._signedTransactions.length > 0;
  }
  _requireNotFrozen() {
    if (this._isFrozen()) throw new Error("transaction is immutable; it has at least one signature or has been explicitly frozen");
  }
  _requireNotSignOnDemand() {
    if (this._signOnDemand) throw new Error("Please use `toBytesAsync()` if `signOnDemand` is enabled");
  }
  _requireFrozen() {
    if (!this._isFrozen()) throw new Error("transaction must have been frozen before calculating the hash will be stable, try calling `freeze`");
  }
  _requireOneNodeAccountId() {
    if (1 != this._nodeAccountIds.length) throw "transaction did not have exactly one node ID set";
  }
  _requestToBytes(t35) {
    return l7.proto.Transaction.encode(t35).finish();
  }
  _responseToBytes(t35) {
    return l7.proto.TransactionResponse.encode(t35).finish();
  }
  _removeSignaturesFromTransaction(t35, n31) {
    const s26 = [];
    return t35.sigMap && t35.sigMap.sigPair ? (t35.sigMap.sigPair = t35.sigMap.sigPair.filter(((t36) => {
      const i17 = this._shouldRemoveSignature(t36, n31), e39 = t36.ed25519 ?? t36.ECDSASecp256k1;
      return i17 && e39 && s26.push(e39), !i17;
    })), s26) : [];
  }
  _collectSignaturesByPublicKey() {
    const t35 = /* @__PURE__ */ new Map(), n31 = {};
    for (const s26 of this._signedTransactions.list) {
      if (!s26.sigMap || !s26.sigMap.sigPair) return /* @__PURE__ */ new Map();
      for (const i17 of s26.sigMap.sigPair) {
        const s27 = i17.ed25519 ?? i17.ECDSASecp256k1;
        if (!s27 || !i17.pubKeyPrefix) return /* @__PURE__ */ new Map();
        const e39 = n(i17.pubKeyPrefix);
        let o32 = n31[e39];
        o32 || (o32 = i.fromString(e39), n31[e39] = o32), t35.has(o32) || t35.set(o32, []);
        const r41 = t35.get(o32);
        r41 && r41.push(s27);
      }
    }
    return t35;
  }
};
var F = [];

// node_modules/@hashgraph/sdk/lib/token/TokenNftTransfer.js
var t17 = class _t {
  constructor(t35) {
    this.tokenId = t35.tokenId instanceof c4 ? t35.tokenId : c4.fromString(t35.tokenId), this.senderAccountId = t35.senderAccountId instanceof y3 ? t35.senderAccountId : y3.fromString(t35.senderAccountId), this.receiverAccountId = t35.receiverAccountId instanceof y3 ? t35.receiverAccountId : y3.fromString(t35.receiverAccountId), this.serialNumber = long_default.fromValue(t35.serialNumber), this.isApproved = t35.isApproved;
  }
  static _fromProtobuf(n31) {
    const c17 = [];
    for (const s26 of n31) {
      const n32 = c4._fromProtobuf(s26.token);
      for (const e39 of null != s26.nftTransfers ? s26.nftTransfers : []) c17.push(new _t({ tokenId: n32, senderAccountId: y3._fromProtobuf(e39.senderAccountID), receiverAccountId: y3._fromProtobuf(e39.receiverAccountID), serialNumber: null != e39.serialNumber ? e39.serialNumber : long_default.ZERO, isApproved: 1 == e39.isApproval }));
    }
    return c17;
  }
  _toProtobuf() {
    return { senderAccountID: this.senderAccountId._toProtobuf(), receiverAccountID: this.receiverAccountId._toProtobuf(), serialNumber: this.serialNumber, isApproval: this.isApproved };
  }
};

// node_modules/@hashgraph/sdk/lib/account/NullableTokenDecimalMap.js
var t18 = class extends t3 {
  constructor() {
    super(((r41) => c4.fromString(r41)));
  }
};

// node_modules/@hashgraph/sdk/lib/token/AbstractTokenTransferTransaction.js
var u11 = class extends P {
  constructor(e39 = {}) {
    super(), this._tokenTransfers = [], this._nftTransfers = [];
    for (const n31 of null != e39.tokenTransfers ? e39.tokenTransfers : []) this.addTokenTransfer(n31.tokenId, n31.accountId, n31.amount);
    for (const n31 of null != e39.nftTransfers ? e39.nftTransfers : []) this.addNftTransfer(n31.tokenId, n31.serial, n31.sender, n31.recipient);
  }
  addNftTransfer(e39, n31, t35, r41) {
    return this._addNftTransfer(false, e39, n31, t35, r41);
  }
  _addTokenTransfer(n31, r41, o32, f4, c17) {
    this._requireNotFrozen();
    const i17 = n31 instanceof c4 ? n31 : c4.fromString(n31), d18 = r41 instanceof y3 ? r41 : y3.fromString(r41), u22 = o32 instanceof long_default ? o32 : long_default.fromNumber(o32);
    for (const e39 of this._tokenTransfers) if (0 === e39.tokenId.compare(i17) && 0 === e39.accountId.compare(d18)) return e39.amount = e39.amount.add(u22), e39.expectedDecimals = c17, this;
    return this._tokenTransfers.push(new n12({ tokenId: n31, accountId: r41, expectedDecimals: c17, amount: o32, isApproved: f4 })), this;
  }
  addTokenTransfer(e39, n31, t35) {
    return this._addTokenTransfer(e39, n31, t35, false, null);
  }
  _addNftTransfer(e39, o32, a23, f4, c17) {
    let i17, d18, u22;
    if (this._requireNotFrozen(), o32 instanceof e9) i17 = o32, d18 = "string" == typeof a23 ? y3.fromString(a23) : a23, u22 = "string" == typeof f4 ? y3.fromString(f4) : f4;
    else if (o32 instanceof c4) i17 = new e9(o32, a23), d18 = "string" == typeof f4 ? y3.fromString(f4) : f4, u22 = "string" == typeof c17 ? y3.fromString(c17) : c17;
    else try {
      i17 = e9.fromString(o32), d18 = "string" == typeof a23 ? y3.fromString(a23) : a23, u22 = "string" == typeof f4 ? y3.fromString(f4) : f4;
    } catch (e40) {
      const n31 = c4.fromString(o32);
      i17 = new e9(n31, a23), d18 = "string" == typeof f4 ? y3.fromString(f4) : f4, u22 = "string" == typeof c17 ? y3.fromString(c17) : c17;
    }
    for (const e40 of this._nftTransfers) if (0 === e40.tokenId.compare(i17.tokenId) && 0 === e40.serialNumber.compare(i17.serial)) return e40.senderAccountId = d18, e40.receiverAccountId = u22, this;
    return this._nftTransfers.push(new t17({ tokenId: i17.tokenId, serialNumber: i17.serial, senderAccountId: d18, receiverAccountId: u22, isApproved: e39 })), this;
  }
  addApprovedNftTransfer(e39, n31, t35, r41) {
    return this._addNftTransfer(true, e39, n31, t35, r41);
  }
  addApprovedTokenTransfer(e39, n31, t35) {
    return this._addTokenTransfer(e39, n31, t35, true, null);
  }
  addTokenTransferWithDecimals(n31, r41, o32, f4) {
    this._requireNotFrozen();
    const c17 = n31 instanceof c4 ? n31 : c4.fromString(n31), i17 = r41 instanceof y3 ? r41 : y3.fromString(r41), d18 = o32 instanceof long_default ? o32 : long_default.fromNumber(o32);
    let u22 = false;
    for (const e39 of this._tokenTransfers) if (0 === e39.tokenId.compare(c17)) {
      if (null != e39.expectedDecimals && e39.expectedDecimals !== f4) throw new Error("expected decimals mis-match");
      e39.expectedDecimals = f4, 0 === e39.accountId.compare(i17) && (e39.amount = e39.amount.add(d18), e39.expectedDecimals = f4, u22 = true);
    }
    return u22 || this._tokenTransfers.push(new n12({ tokenId: n31, accountId: r41, expectedDecimals: f4, amount: o32, isApproved: false })), this;
  }
  get tokenIdDecimals() {
    const e39 = new t18();
    for (const n31 of this._tokenTransfers) e39._set(n31.tokenId, n31.expectedDecimals);
    return e39;
  }
  get nftTransfers() {
    const e39 = new s6();
    for (const n31 of this._nftTransfers) {
      const t35 = e39.get(n31.tokenId), r41 = { sender: n31.senderAccountId, recipient: n31.receiverAccountId, serial: n31.serialNumber, isApproved: n31.isApproved };
      null != t35 ? t35.push(r41) : e39._set(n31.tokenId, [r41]);
    }
    return e39;
  }
  get tokenTransfers() {
    const e39 = new n10();
    for (const n31 of this._tokenTransfers) {
      let t35 = e39.get(n31.tokenId);
      null != t35 ? t35._set(n31.accountId, n31.amount) : (t35 = new o9(), t35._set(n31.accountId, n31.amount), e39._set(n31.tokenId, t35));
    }
    return e39;
  }
  _makeTransactionData() {
    const e39 = [];
    this._tokenTransfers.sort(((e40, n32) => {
      const t36 = e40.tokenId.compare(n32.tokenId);
      return 0 !== t36 ? t36 : e40.accountId.compare(n32.accountId);
    })), this._nftTransfers.sort(((e40, n32) => {
      const t36 = e40.senderAccountId.compare(n32.senderAccountId);
      if (0 != t36) return t36;
      const r41 = e40.receiverAccountId.compare(n32.receiverAccountId);
      return 0 != r41 ? r41 : e40.serialNumber.compare(n32.serialNumber);
    }));
    let n31 = 0, t35 = 0;
    for (; n31 < this._tokenTransfers.length || t35 < this._nftTransfers.length; ) if (n31 < this._tokenTransfers.length && t35 < this._nftTransfers.length) {
      const r41 = this._tokenTransfers[n31].tokenId, s26 = this._nftTransfers[t35].tokenId, o32 = e39.length > 0 ? e39[e39.length - 1] : null, a23 = null != o32 ? o32.tokenId : null;
      if (null != o32 && null != a23 && 0 === a23.compare(r41)) {
        o32.transfers.push(this._tokenTransfers[n31++]);
        continue;
      }
      if (null != o32 && null != a23 && 0 === a23.compare(s26)) {
        o32.nftTransfers.push(this._nftTransfers[t35++]);
        continue;
      }
      const f4 = r41.compare(s26);
      0 === f4 ? e39.push({ tokenId: r41, expectedDecimals: this._tokenTransfers[n31].expectedDecimals, transfers: [this._tokenTransfers[n31++]], nftTransfers: [this._nftTransfers[t35++]] }) : f4 < 0 ? e39.push({ tokenId: r41, expectedDecimals: this._tokenTransfers[n31].expectedDecimals, transfers: [this._tokenTransfers[n31++]], nftTransfers: [] }) : e39.push({ tokenId: s26, expectedDecimals: null, transfers: [], nftTransfers: [this._nftTransfers[t35++]] });
    } else if (n31 < this._tokenTransfers.length) {
      const t36 = this._tokenTransfers[n31].tokenId;
      let r41;
      for (const n32 of e39) 0 === n32.tokenId.compare(t36) && (r41 = n32);
      const s26 = null != r41 ? r41.tokenId : null;
      if (null != r41 && null != s26 && 0 === s26.compare(t36)) {
        r41.transfers.push(this._tokenTransfers[n31++]);
        continue;
      }
      e39.push({ tokenId: t36, expectedDecimals: this._tokenTransfers[n31].expectedDecimals, transfers: [this._tokenTransfers[n31++]], nftTransfers: [] });
    } else if (t35 < this._nftTransfers.length) {
      const n32 = this._nftTransfers[t35].tokenId;
      let r41;
      for (const t36 of e39) 0 === t36.tokenId.compare(n32) && (r41 = t36);
      const s26 = null != r41 ? r41.tokenId : null;
      if (null != r41 && null != s26 && 0 === s26.compare(n32)) {
        r41.nftTransfers.push(this._nftTransfers[t35++]);
        continue;
      }
      e39.push({ tokenId: n32, expectedDecimals: null, transfers: [], nftTransfers: [this._nftTransfers[t35++]] });
    }
    return { tokenTransfers: e39.map(((e40) => ({ token: e40.tokenId._toProtobuf(), expectedDecimals: null != e40.expectedDecimals ? { value: e40.expectedDecimals } : null, transfers: e40.transfers.map(((e41) => e41._toProtobuf())), nftTransfers: e40.nftTransfers.map(((e41) => e41._toProtobuf())) }))) };
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenAirdropTransaction.js
var s8 = class _s extends u11 {
  constructor(r41 = {}) {
    if (super(), null != r41.tokenTransfers) for (const t35 of r41.tokenTransfers) this._addTokenTransfer(t35.tokenId, t35.accountId, t35.amount, t35.isApproved, t35.expectedDecimals);
    if (this._nftTransfers = [], null != r41.nftTransfers) for (const t35 of r41.nftTransfers) this._addNftTransfer(t35.isApproved, t35.tokenId, t35.serialNumber, t35.senderAccountId, t35.receiverAccountId);
  }
  addApprovedTokenTransferWithDecimals(r41, t35, o32, n31) {
    return this._requireNotFrozen(), this._addTokenTransfer(r41, t35, o32, true, n31), this;
  }
  static _fromProtobuf(t35, e39, a23, f4, i17) {
    const T3 = i17[0].tokenAirdrop, d18 = n12._fromProtobuf(T3.tokenTransfers ?? []), c17 = t17._fromProtobuf(T3.tokenTransfers ?? []);
    return P._fromProtobufTransactions(new _s({ nftTransfers: c17, tokenTransfers: d18 }), t35, e39, a23, f4, i17);
  }
  _execute(r41, t35) {
    return r41.token.airdropTokens(t35);
  }
  _getTransactionDataCase() {
    return "tokenAirdrop";
  }
  _getLogId() {
    return `TokenAirdropTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenAirdrop", s8._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/AirdropPendingTransaction.js
var d7 = class extends P {
  constructor(r41) {
    super(), this._pendingAirdropIds = [], null != (r41 == null ? void 0 : r41.pendingAirdropIds) && (this._pendingAirdropIds = r41.pendingAirdropIds);
  }
  get pendingAirdropIds() {
    return this._pendingAirdropIds;
  }
  addPendingAirdropId(r41) {
    return this._requireNotFrozen(), this._pendingAirdropIds.push(r41), this;
  }
  setPendingAirdropIds(r41) {
    return this._requireNotFrozen(), this._pendingAirdropIds = r41, this;
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenClaimAirdropTransaction.js
var i6 = class _i extends d7 {
  constructor(r41 = {}) {
    super(r41);
  }
  _execute(r41, t35) {
    return r41.token.claimAirdrop(t35);
  }
  _makeTransactionData() {
    return { pendingAirdrops: this.pendingAirdropIds.map(((r41) => r41.toBytes())) };
  }
  static _fromProtobuf(t35, n31, a23, e39, s26) {
    const d18 = s26[0], { pendingAirdrops: p3 } = d18.tokenClaimAirdrop;
    return P._fromProtobufTransactions(new _i({ pendingAirdropIds: p3 == null ? void 0 : p3.map(((t36) => t13.fromBytes(t36))) }), t35, n31, a23, e39, s26);
  }
  _getTransactionDataCase() {
    return "tokenClaimAirdrop";
  }
  _getLogId() {
    return `TokenClaimAirdropTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenClaimAirdrop", i6._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenCancelAirdropTransaction.js
var e11 = class _e extends d7 {
  constructor(r41 = {}) {
    super(r41);
  }
  _makeTransactionData() {
    return { pendingAirdrops: this.pendingAirdropIds.map(((r41) => r41.toBytes())) };
  }
  _execute(r41, t35) {
    return r41.token.cancelAirdrop(t35);
  }
  _getTransactionDataCase() {
    return "tokenCancelAirdrop";
  }
  static _fromProtobuf(n31, o32, a23, i17, s26) {
    const d18 = s26[0], { pendingAirdrops: p3 } = d18.tokenCancelAirdrop;
    return P._fromProtobufTransactions(new _e({ pendingAirdropIds: p3 == null ? void 0 : p3.map(((t35) => t13.fromBytes(t35))) }), n31, o32, a23, i17, s26);
  }
  _getLogId() {
    return `TokenCancelAirdrop:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenCancelAirdrop", e11._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/HbarAllowance.js
var o11 = class _o {
  constructor(n31) {
    this.spenderAccountId = n31.spenderAccountId, this.ownerAccountId = n31.ownerAccountId, this.amount = n31.amount, Object.freeze(this);
  }
  static _fromProtobuf(u22) {
    return new _o({ spenderAccountId: y3._fromProtobuf(u22.spender), ownerAccountId: null != u22.owner ? y3._fromProtobuf(u22.owner) : null, amount: e4.fromTinybars(null != u22.amount ? u22.amount : 0) });
  }
  static _fromGrantedProtobuf(u22, r41) {
    return new _o({ spenderAccountId: y3._fromProtobuf(u22.spender), ownerAccountId: r41, amount: e4.fromTinybars(null != u22.amount ? u22.amount : 0) });
  }
  _toProtobuf() {
    return { owner: null != this.ownerAccountId ? this.ownerAccountId._toProtobuf() : null, spender: null != this.spenderAccountId ? this.spenderAccountId._toProtobuf() : null, amount: null != this.amount ? this.amount.toTinybars() : null };
  }
  _validateChecksums(n31) {
    null != this.spenderAccountId && this.spenderAccountId.validateChecksum(n31), null != this.spenderAccountId && this.spenderAccountId.validateChecksum(n31);
  }
  toJSON() {
    return { ownerAccountId: null != this.ownerAccountId ? this.ownerAccountId.toString() : null, spenderAccountId: null != this.spenderAccountId ? this.spenderAccountId.toString() : null, amount: null != this.amount ? this.amount.toString() : null };
  }
};

// node_modules/@hashgraph/sdk/lib/account/TokenAllowance.js
var e12 = class _e {
  constructor(o32) {
    this.tokenId = o32.tokenId, this.spenderAccountId = o32.spenderAccountId, this.ownerAccountId = o32.ownerAccountId, this.amount = o32.amount, Object.freeze(this);
  }
  static _fromProtobuf(u22) {
    return new _e({ tokenId: c4._fromProtobuf(u22.tokenId), spenderAccountId: y3._fromProtobuf(u22.spender), ownerAccountId: null != u22.owner ? y3._fromProtobuf(u22.owner) : null, amount: null != u22.amount ? long_default.fromValue(u22.amount) : null });
  }
  static _fromGrantedProtobuf(u22, r41) {
    return new _e({ tokenId: c4._fromProtobuf(u22.tokenId), spenderAccountId: y3._fromProtobuf(u22.spender), ownerAccountId: r41, amount: null != u22.amount ? long_default.fromValue(u22.amount) : null });
  }
  _toProtobuf() {
    return { tokenId: this.tokenId._toProtobuf(), spender: null != this.spenderAccountId ? this.spenderAccountId._toProtobuf() : null, owner: null != this.ownerAccountId ? this.ownerAccountId._toProtobuf() : null, amount: this.amount };
  }
  _validateChecksums(o32) {
    this.tokenId.validateChecksum(o32), null != this.ownerAccountId && this.ownerAccountId.validateChecksum(o32), null != this.spenderAccountId && this.spenderAccountId.validateChecksum(o32);
  }
};

// node_modules/@hashgraph/sdk/lib/account/TokenNftAllowance.js
var o12 = class _o {
  constructor(e39) {
    this.tokenId = e39.tokenId, this.spenderAccountId = e39.spenderAccountId, this.ownerAccountId = e39.ownerAccountId, this.serialNumbers = e39.serialNumbers, this.allSerials = e39.allSerials, this.delegatingSpender = e39.delegatingSpender, Object.freeze(this);
  }
  static _fromProtobuf(l19) {
    const t35 = null != l19.approvedForAll && 1 == l19.approvedForAll.value;
    return new _o({ tokenId: c4._fromProtobuf(l19.tokenId), spenderAccountId: null != l19.spender ? y3._fromProtobuf(l19.spender) : null, ownerAccountId: null != l19.owner ? y3._fromProtobuf(l19.owner) : null, serialNumbers: t35 ? null : null != l19.serialNumbers ? l19.serialNumbers.map(((e39) => long_default.fromValue(e39))) : [], allSerials: t35, delegatingSpender: null != l19.delegatingSpender ? y3._fromProtobuf(l19.delegatingSpender) : null });
  }
  static _fromGrantedProtobuf(n31, l19) {
    return new _o({ tokenId: c4._fromProtobuf(n31.tokenId), spenderAccountId: y3._fromProtobuf(n31.spender), ownerAccountId: l19, serialNumbers: [], allSerials: null, delegatingSpender: null });
  }
  static _fromRemoveProtobuf(l19) {
    return new _o({ tokenId: c4._fromProtobuf(l19.tokenId), spenderAccountId: null, ownerAccountId: null != l19.owner ? y3._fromProtobuf(l19.owner) : null, serialNumbers: null != l19.serialNumbers ? l19.serialNumbers.map(((e39) => long_default.fromValue(e39))) : [], allSerials: null, delegatingSpender: null });
  }
  _toProtobuf() {
    return { tokenId: this.tokenId._toProtobuf(), spender: null != this.spenderAccountId ? this.spenderAccountId._toProtobuf() : null, owner: null != this.ownerAccountId ? this.ownerAccountId._toProtobuf() : null, approvedForAll: null == this.serialNumbers ? { value: this.allSerials } : null, serialNumbers: this.serialNumbers, delegatingSpender: null != this.delegatingSpender ? this.delegatingSpender._toProtobuf() : null };
  }
  _validateChecksums(e39) {
    this.tokenId.validateChecksum(e39), null != this.ownerAccountId && this.ownerAccountId.validateChecksum(e39), null != this.spenderAccountId && this.spenderAccountId.validateChecksum(e39);
  }
};

// node_modules/@hashgraph/sdk/lib/account/AccountAllowanceApproveTransaction.js
var c6 = class _c extends P {
  constructor(r41 = {}) {
    super(), this._hbarApprovals = null != r41.hbarApprovals ? r41.hbarApprovals : [], this._tokenApprovals = null != r41.tokenApprovals ? r41.tokenApprovals : [], this._nftApprovals = null != r41.nftApprovals ? r41.nftApprovals : [];
  }
  static _fromProtobuf(o32, t35, e39, n31, s26) {
    const a23 = s26[0].cryptoApproveAllowance;
    return P._fromProtobufTransactions(new _c({ hbarApprovals: (null != a23.cryptoAllowances ? a23.cryptoAllowances : []).map(((r41) => o11._fromProtobuf(r41))), tokenApprovals: (null != a23.tokenAllowances ? a23.tokenAllowances : []).map(((r41) => e12._fromProtobuf(r41))), nftApprovals: (null != a23.nftAllowances ? a23.nftAllowances : []).map(((r41) => o12._fromProtobuf(r41))) }), o32, t35, e39, n31, s26);
  }
  get hbarApprovals() {
    return this._hbarApprovals;
  }
  approveHbarAllowance(r41, o32, n31) {
    return this._requireNotFrozen(), this._hbarApprovals.push(new o11({ spenderAccountId: "string" == typeof o32 ? y3.fromString(o32) : o32 instanceof g4 ? y3.fromEvmAddress(o32.shard, o32.realm, o32.toEvmAddress()) : o32, ownerAccountId: "string" == typeof r41 ? y3.fromString(r41) : r41 instanceof g4 ? y3.fromEvmAddress(r41.shard, r41.realm, r41.toEvmAddress()) : r41, amount: n31 instanceof e4 ? n31 : new e4(n31) })), this;
  }
  addHbarAllowance(r41, o32) {
    return this._requireNotFrozen(), this._hbarApprovals.push(new o11({ spenderAccountId: "string" == typeof r41 ? y3.fromString(r41) : r41, amount: o32 instanceof e4 ? o32 : new e4(o32), ownerAccountId: null })), this;
  }
  get tokenApprovals() {
    return this._tokenApprovals;
  }
  approveTokenAllowance(r41, o32, s26, l19) {
    return this._requireNotFrozen(), this._tokenApprovals.push(new e12({ tokenId: "string" == typeof r41 ? c4.fromString(r41) : r41, spenderAccountId: "string" == typeof s26 ? y3.fromString(s26) : s26 instanceof g4 ? y3.fromEvmAddress(s26.shard, s26.realm, s26.toEvmAddress()) : s26, ownerAccountId: "string" == typeof o32 ? y3.fromString(o32) : o32 instanceof g4 ? y3.fromEvmAddress(o32.shard, o32.realm, o32.toEvmAddress()) : o32, amount: "number" == typeof l19 ? long_default.fromNumber(l19) : l19 })), this;
  }
  addTokenAllowance(r41, o32, e39) {
    return this._requireNotFrozen(), this._tokenApprovals.push(new e12({ tokenId: "string" == typeof r41 ? c4.fromString(r41) : r41, spenderAccountId: "string" == typeof o32 ? y3.fromString(o32) : o32, amount: "number" == typeof e39 ? long_default.fromNumber(e39) : e39, ownerAccountId: null })), this;
  }
  addTokenNftAllowance(r41, o32) {
    return this._approveTokenNftAllowance(r41, null, o32, null);
  }
  get tokenNftApprovals() {
    return this._nftApprovals;
  }
  _approveTokenNftAllowance(r41, o32, n31, a23) {
    this._requireNotFrozen();
    const l19 = "string" == typeof r41 ? e9.fromString(r41) : r41, p3 = "string" == typeof n31 ? y3.fromString(n31) : n31 instanceof g4 ? y3.fromEvmAddress(n31.shard, n31.realm, n31.toEvmAddress()) : n31;
    let i17 = false;
    for (const r42 of this._nftApprovals) if (0 === r42.tokenId.compare(l19.tokenId) && null != r42.spenderAccountId && 0 === r42.spenderAccountId.compare(p3)) {
      null != r42.serialNumbers && r42.serialNumbers.push(l19.serial), i17 = true;
      break;
    }
    return i17 || this._nftApprovals.push(new o12({ tokenId: l19.tokenId, spenderAccountId: p3, ownerAccountId: "string" == typeof o32 ? y3.fromString(o32) : o32 instanceof g4 ? y3.fromEvmAddress(o32.shard, o32.realm, o32.toEvmAddress()) : o32, serialNumbers: [l19.serial], allSerials: false, delegatingSpender: "string" == typeof a23 ? y3.fromString(a23) : a23 })), this;
  }
  approveTokenNftAllowance(r41, o32, t35) {
    return this._approveTokenNftAllowance(r41, o32, t35, null);
  }
  approveTokenNftAllowanceWithDelegatingSpender(r41, o32, t35, e39) {
    return this._approveTokenNftAllowance(r41, o32, t35, e39);
  }
  _approveAllTokenNftAllowance(r41, o32, s26, a23) {
    return this._requireNotFrozen(), this._nftApprovals.push(new o12({ tokenId: "string" == typeof r41 ? c4.fromString(r41) : r41, spenderAccountId: "string" == typeof s26 ? y3.fromString(s26) : s26 instanceof g4 ? y3.fromEvmAddress(s26.shard, s26.realm, s26.toEvmAddress()) : s26, ownerAccountId: "string" == typeof o32 ? y3.fromString(o32) : o32 instanceof g4 ? y3.fromEvmAddress(o32.shard, o32.realm, o32.toEvmAddress()) : o32, serialNumbers: null, allSerials: a23, delegatingSpender: null })), this;
  }
  addAllTokenNftAllowance(r41, o32, t35) {
    return this._approveAllTokenNftAllowance(r41, o32, t35, true);
  }
  approveTokenNftAllowanceAllSerials(r41, o32, t35) {
    return this._approveAllTokenNftAllowance(r41, o32, t35, true);
  }
  deleteTokenNftAllowanceAllSerials(r41, o32, t35) {
    return this._approveAllTokenNftAllowance(r41, o32, t35, false);
  }
  _validateChecksums(r41) {
    this._hbarApprovals.map(((o32) => o32._validateChecksums(r41))), this._tokenApprovals.map(((o32) => o32._validateChecksums(r41))), this._nftApprovals.map(((o32) => o32._validateChecksums(r41)));
  }
  _execute(r41, o32) {
    return r41.crypto.approveAllowances(o32);
  }
  _getTransactionDataCase() {
    return "cryptoApproveAllowance";
  }
  _makeTransactionData() {
    return { cryptoAllowances: this._hbarApprovals.map(((r41) => r41._toProtobuf())), tokenAllowances: this._tokenApprovals.map(((r41) => r41._toProtobuf())), nftAllowances: this._nftApprovals.map(((r41) => r41._toProtobuf())) };
  }
  _getLogId() {
    return `AccountAllowanceApproveTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("cryptoApproveAllowance", c6._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/AccountAllowanceDeleteTransaction.js
var r13 = class _r extends P {
  constructor(t35 = {}) {
    super(), this._nftAllowances = null != t35.nftAllowances ? t35.nftAllowances : [];
  }
  static _fromProtobuf(e39, n31, o32, s26, a23) {
    const c17 = a23[0].cryptoDeleteAllowance;
    return P._fromProtobufTransactions(new _r({ nftAllowances: (null != c17.nftAllowances ? c17.nftAllowances : []).map(((t35) => o12._fromProtobuf(t35))) }), e39, n31, o32, s26, a23);
  }
  get tokenNftAllowanceDeletions() {
    return this._nftAllowances;
  }
  deleteAllTokenNftAllowances(t35, e39) {
    this._requireNotFrozen();
    const r41 = "string" == typeof t35 ? e9.fromString(t35) : t35, s26 = "string" == typeof e39 ? y3.fromString(e39) : e39;
    let a23 = false;
    for (const t36 of this._nftAllowances) if (0 === t36.tokenId.compare(r41.tokenId)) {
      null != t36.serialNumbers && t36.serialNumbers.push(r41.serial), a23 = true;
      break;
    }
    return a23 || this._nftAllowances.push(new o12({ tokenId: r41.tokenId, spenderAccountId: null, serialNumbers: [r41.serial], ownerAccountId: s26, allSerials: false, delegatingSpender: null })), this;
  }
  _validateChecksums(t35) {
    this._nftAllowances.map(((e39) => e39._validateChecksums(t35)));
  }
  _execute(t35, e39) {
    return t35.crypto.deleteAllowances(e39);
  }
  _getTransactionDataCase() {
    return "cryptoDeleteAllowance";
  }
  _makeTransactionData() {
    return { nftAllowances: this._nftAllowances.map(((t35) => t35._toProtobuf())) };
  }
  _getLogId() {
    return `AccountAllowanceDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("cryptoDeleteAllowance", r13._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/TokenBalanceMap.js
var t19 = class extends t3 {
  constructor() {
    super(((r41) => c4.fromString(r41)));
  }
};

// node_modules/@hashgraph/sdk/lib/account/TokenDecimalMap.js
var t20 = class extends t3 {
  constructor() {
    super(((r41) => c4.fromString(r41)));
  }
};

// node_modules/@hashgraph/sdk/lib/account/AccountBalance.js
var r14 = __toESM(require_lib(), 1);
var a7 = class _a2 {
  constructor(t35) {
    this.hbars = t35.hbars, this.tokens = t35.tokens, this.tokenDecimals = t35.tokenDecimals, Object.freeze(this);
  }
  static fromBytes(t35) {
    return _a2._fromProtobuf(r14.proto.CryptoGetAccountBalanceResponse.decode(t35));
  }
  static _fromProtobuf(r41) {
    const i17 = new t19(), l19 = new t20();
    if (null != r41.tokenBalances) for (const o32 of r41.tokenBalances) {
      const s26 = c4._fromProtobuf(o32.tokenId);
      l19._set(s26, null != o32.decimals ? o32.decimals : 0), i17._set(s26, long_default.fromValue(o32.balance));
    }
    return new _a2({ hbars: e4.fromTinybars(r41.balance), tokens: i17, tokenDecimals: l19 });
  }
  _toProtobuf() {
    const t35 = [];
    for (const [o32, e39] of null != this.tokens ? this.tokens : []) t35.push({ tokenId: o32._toProtobuf(), balance: e39, decimals: null != this.tokenDecimals ? this.tokenDecimals.get(o32) : null });
    return { balance: this.hbars.toTinybars(), tokenBalances: t35 };
  }
  toBytes() {
    return r14.proto.CryptoGetAccountBalanceResponse.encode(this._toProtobuf()).finish();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    const t35 = [];
    for (const [o32, e39] of null != this.tokens ? this.tokens : []) {
      const s26 = null != this.tokenDecimals ? this.tokenDecimals.get(o32) : null;
      t35.push({ tokenId: o32.toString(), balance: e39.toString(), decimals: null != s26 ? s26 : 0 });
    }
    return { hbars: this.hbars.toString(), tokens: t35 };
  }
};

// node_modules/@hashgraph/sdk/lib/account/AccountBalanceQuery.js
var e13 = class _e extends h3 {
  constructor(t35 = {}) {
    super(), this._accountId = null, this._contractId = null, null != t35.accountId && this.setAccountId(t35.accountId), null != t35.contractId && this.setContractId(t35.contractId);
  }
  static _fromProtobuf(t35) {
    const c17 = t35.cryptogetAccountBalance;
    return new _e({ accountId: null != c17.accountID ? y3._fromProtobuf(c17.accountID) : void 0, contractId: null != c17.contractID ? g4._fromProtobuf(c17.contractID) : void 0 });
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(t35) {
    return this._contractId = "string" == typeof t35 ? g4.fromString(t35) : t35.clone(), this;
  }
  _isPaymentRequired() {
    return false;
  }
  _validateChecksums(t35) {
    null != this._accountId && this._accountId.validateChecksum(t35), null != this._contractId && this._contractId.validateChecksum(t35);
  }
  _execute(t35, c17) {
    return t35.crypto.cryptoGetBalance(c17);
  }
  _mapResponseHeader(t35) {
    return t35.cryptogetAccountBalance.header;
  }
  _mapResponse(t35, c17, o32) {
    const n31 = t35.cryptogetAccountBalance;
    return Promise.resolve(a7._fromProtobuf(n31));
  }
  _onMakeRequest(t35) {
    return { cryptogetAccountBalance: { header: t35, accountID: null != this._accountId ? this._accountId._toProtobuf() : null, contractID: null != this._contractId ? this._contractId._toProtobuf() : null } };
  }
  _getLogId() {
    return `AccountBalanceQuery:${this._timestamp.toString()}`;
  }
};
m3.set("cryptogetAccountBalance", e13._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/AccountCreateTransaction.js
var import_proto3 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/lib/Duration.js
var s9 = class _s {
  constructor(s26) {
    this.seconds = s26 instanceof long_default ? s26 : long_default.fromNumber(s26), Object.freeze(this);
  }
  _toProtobuf() {
    return { seconds: this.seconds };
  }
  static _fromProtobuf(o32) {
    return new _s(o32.seconds);
  }
};

// node_modules/@hashgraph/sdk/lib/account/AccountCreateTransaction.js
var h7 = class _h extends P {
  constructor(e39 = {}) {
    super(), this._key = null, this._initialBalance = null, this._sendRecordThreshold = S2, this._receiveRecordThreshold = S2, this._receiverSignatureRequired = false, this._proxyAccountId = null, this._autoRenewPeriod = new s9(w3), this._accountMemo = null, this._maxAutomaticTokenAssociations = null, this._stakedAccountId = null, this._stakedNodeId = null, this._declineStakingReward = false, this._alias = null, null != e39.key && this.setKeyWithoutAlias(e39.key), null != e39.receiverSignatureRequired && this.setReceiverSignatureRequired(e39.receiverSignatureRequired), null != e39.initialBalance && this.setInitialBalance(e39.initialBalance), null != e39.proxyAccountId && this.setProxyAccountId(e39.proxyAccountId), null != e39.autoRenewPeriod && this.setAutoRenewPeriod(e39.autoRenewPeriod), null != e39.accountMemo && this.setAccountMemo(e39.accountMemo), null != e39.maxAutomaticTokenAssociations && this.setMaxAutomaticTokenAssociations(e39.maxAutomaticTokenAssociations), null != e39.stakedAccountId && this.setStakedAccountId(e39.stakedAccountId), null != e39.stakedNodeId && this.setStakedNodeId(e39.stakedNodeId), null != e39.declineStakingReward && this.setDeclineStakingReward(e39.declineStakingReward), null != e39.alias && this.setAlias(e39.alias);
  }
  static _fromProtobuf(o32, r41, s26, n31, a23) {
    const c17 = a23[0].cryptoCreateAccount;
    let l19;
    return null != c17.alias && c17.alias.length > 0 && 20 === c17.alias.length && (l19 = i3.fromBytes(c17.alias)), P._fromProtobufTransactions(new _h({ key: null != c17.key ? t2._fromProtobufKey(c17.key) : void 0, initialBalance: null != c17.initialBalance ? e4.fromTinybars(c17.initialBalance) : void 0, receiverSignatureRequired: null != c17.receiverSigRequired ? c17.receiverSigRequired : void 0, proxyAccountId: null != c17.proxyAccountID ? y3._fromProtobuf(c17.proxyAccountID) : void 0, autoRenewPeriod: null != c17.autoRenewPeriod && null != c17.autoRenewPeriod.seconds ? c17.autoRenewPeriod.seconds : void 0, accountMemo: null != c17.memo ? c17.memo : void 0, maxAutomaticTokenAssociations: null != c17.maxAutomaticTokenAssociations ? c17.maxAutomaticTokenAssociations : void 0, stakedAccountId: null != c17.stakedAccountId ? y3._fromProtobuf(c17.stakedAccountId) : void 0, stakedNodeId: null != c17.stakedNodeId ? c17.stakedNodeId : void 0, declineStakingReward: 1 == c17.declineReward, alias: l19 }), o32, r41, s26, n31, a23);
  }
  get key() {
    return this._key;
  }
  setKey(e39) {
    return this._requireNotFrozen(), this._key = e39, this;
  }
  setECDSAKeyWithAlias(e39) {
    this.setKeyWithoutAlias(e39);
    const t35 = this._deriveECDSAKeyAlias(e39);
    return this.setAlias(t35), this;
  }
  setKeyWithAlias(e39, t35) {
    this.setKeyWithoutAlias(e39);
    const i17 = this._deriveECDSAKeyAlias(t35);
    return this.setAlias(i17), this;
  }
  setKeyWithoutAlias(e39) {
    return this._requireNotFrozen(), this._key = e39, this;
  }
  get initialBalance() {
    return this._initialBalance;
  }
  setInitialBalance(t35) {
    return this._requireNotFrozen(), this._initialBalance = t35 instanceof e4 ? t35 : new e4(t35), this;
  }
  get receiverSignatureRequired() {
    return this._receiverSignatureRequired;
  }
  setReceiverSignatureRequired(e39) {
    return this._requireNotFrozen(), this._receiverSignatureRequired = e39, this;
  }
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  setProxyAccountId(e39) {
    return this._requireNotFrozen(), this._proxyAccountId = e39, this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(e39) {
    return this._requireNotFrozen(), this._autoRenewPeriod = e39 instanceof s9 ? e39 : new s9(e39), this;
  }
  get accountMemo() {
    return this._accountMemo;
  }
  setAccountMemo(e39) {
    return this._requireNotFrozen(), this._accountMemo = e39, this;
  }
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  setMaxAutomaticTokenAssociations(e39) {
    return this._requireNotFrozen(), this._maxAutomaticTokenAssociations = "number" == typeof e39 ? long_default.fromNumber(e39) : e39, this;
  }
  get stakedAccountId() {
    return this._stakedAccountId;
  }
  setStakedAccountId(e39) {
    return this._requireNotFrozen(), this._stakedAccountId = "string" == typeof e39 ? y3.fromString(e39) : e39, this;
  }
  get stakedNodeId() {
    return this._stakedNodeId;
  }
  setStakedNodeId(e39) {
    return this._requireNotFrozen(), this._stakedNodeId = long_default.fromValue(e39), this;
  }
  get declineStakingRewards() {
    return this._declineStakingReward;
  }
  setDeclineStakingReward(e39) {
    return this._requireNotFrozen(), this._declineStakingReward = e39, this;
  }
  get alias() {
    return this._alias;
  }
  setAlias(e39) {
    if ("string" == typeof e39) {
      if (!(e39.startsWith("0x") && 42 == e39.length || 40 == e39.length)) throw new Error('evmAddress must be a valid EVM address with or without "0x" prefix');
      this._alias = i3.fromString(e39);
    } else this._alias = e39;
    return this;
  }
  _validateChecksums(e39) {
    null != this._proxyAccountId && this._proxyAccountId.validateChecksum(e39);
  }
  _deriveECDSAKeyAlias(e39) {
    const t35 = e39 instanceof g3 && "secp256k1" === e39.type, i17 = e39 instanceof i && "secp256k1" === e39.type;
    if (t35) return e39.publicKey.toEvmAddress();
    if (i17) return e39.toEvmAddress();
    throw new Error("Invalid key for alias derivation provided: expected an ECDSA (secp256k1) PrivateKey or PublicKey.");
  }
  _execute(e39, t35) {
    return e39.crypto.createAccount(t35);
  }
  _getTransactionDataCase() {
    return "cryptoCreateAccount";
  }
  _makeTransactionData() {
    let e39 = null;
    return null != this._alias && (e39 = this._alias.toBytes()), { key: null != this._key ? this._key._toProtobufKey() : null, initialBalance: null != this._initialBalance ? this._initialBalance.toTinybars() : null, autoRenewPeriod: this._autoRenewPeriod._toProtobuf(), proxyAccountID: null != this._proxyAccountId ? this._proxyAccountId._toProtobuf() : null, receiveRecordThreshold: this._receiveRecordThreshold.toTinybars(), sendRecordThreshold: this._sendRecordThreshold.toTinybars(), receiverSigRequired: this._receiverSignatureRequired, memo: this._accountMemo, maxAutomaticTokenAssociations: null != this._maxAutomaticTokenAssociations ? this._maxAutomaticTokenAssociations.toInt() : null, stakedAccountId: null != this.stakedAccountId ? this.stakedAccountId._toProtobuf() : null, stakedNodeId: this.stakedNodeId, declineReward: this.declineStakingRewards, alias: e39 };
  }
  _getLogId() {
    return `AccountCreateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("cryptoCreateAccount", h7._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/AccountDeleteTransaction.js
var c7 = class _c extends P {
  constructor(t35 = {}) {
    super(), this._accountId = null, this._transferAccountId = null, null != t35.accountId && this.setAccountId(t35.accountId), null != t35.transferAccountId && this.setTransferAccountId(t35.transferAccountId);
  }
  static _fromProtobuf(r41, o32, e39, u22, s26) {
    const a23 = s26[0].cryptoDelete;
    return P._fromProtobufTransactions(new _c({ accountId: null != a23.deleteAccountID ? y3._fromProtobuf(a23.deleteAccountID) : void 0, transferAccountId: null != a23.transferAccountID ? y3._fromProtobuf(a23.transferAccountID) : void 0 }), r41, o32, e39, u22, s26);
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(n31) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof n31 ? y3.fromString(n31) : n31.clone(), this;
  }
  get transferAccountId() {
    return this._transferAccountId;
  }
  setTransferAccountId(n31) {
    return this._requireNotFrozen(), this._transferAccountId = "string" == typeof n31 ? y3.fromString(n31) : n31.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._accountId && this._accountId.validateChecksum(t35), null != this._transferAccountId && this._transferAccountId.validateChecksum(t35);
  }
  _execute(t35, n31) {
    return t35.crypto.cryptoDelete(n31);
  }
  _getTransactionDataCase() {
    return "cryptoDelete";
  }
  _makeTransactionData() {
    return { deleteAccountID: null != this._accountId ? this._accountId._toProtobuf() : null, transferAccountID: null != this._transferAccountId ? this._transferAccountId._toProtobuf() : null };
  }
  _getLogId() {
    return `AccountDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("cryptoDelete", c7._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/LedgerId.js
var r15 = class _r {
  constructor(e39) {
    this._ledgerId = e39, Object.freeze(this);
  }
  static fromString(t35) {
    switch (t35) {
      case n14[0]:
      case "0":
        return _r.MAINNET;
      case n14[1]:
      case "1":
        return _r.TESTNET;
      case n14[2]:
      case "2":
        return _r.PREVIEWNET;
      case n14[3]:
      case "3":
        return _r.LOCAL_NODE;
      default:
        try {
          let n31 = r(t35);
          return new _r(n31);
        } catch (e39) {
          throw new Error("Default reached for fromString");
        }
    }
  }
  toString() {
    if (1 != this._ledgerId.length) return n(this._ledgerId);
    switch (this._ledgerId[0]) {
      case 0:
        return n14[0];
      case 1:
        return n14[1];
      case 2:
        return n14[2];
      case 3:
        return n14[3];
      default:
        return n(this._ledgerId);
    }
  }
  static fromBytes(e39) {
    return new _r(e39);
  }
  toBytes() {
    return this._ledgerId;
  }
  isMainnet() {
    return this.toString() == n14[0];
  }
  isTestnet() {
    return this.toString() == n14[1];
  }
  isPreviewnet() {
    return this.toString() == n14[2];
  }
  isLocalNode() {
    return this.toString() == n14[3];
  }
};
var n14 = ["mainnet", "testnet", "previewnet", "local-node"];
r15.MAINNET = new r15(new Uint8Array([0])), r15.TESTNET = new r15(new Uint8Array([1])), r15.PREVIEWNET = new r15(new Uint8Array([2])), r15.LOCAL_NODE = new r15(new Uint8Array([3]));

// node_modules/@hashgraph/sdk/lib/StakingInfo.js
var o13 = __toESM(require_lib(), 1);
var n15 = class _n {
  constructor(t35) {
    this.declineStakingReward = t35.declineStakingReward, this.stakePeriodStart = t35.stakePeriodStart, this.pendingReward = t35.pendingReward, this.stakedToMe = t35.stakedToMe, this.stakedAccountId = t35.stakedAccountId, this.stakedNodeId = t35.stakedNodeId, Object.freeze(this);
  }
  static _fromProtobuf(o32) {
    return new _n({ declineStakingReward: 1 == o32.declineReward, stakePeriodStart: null != o32.stakePeriodStart ? s3._fromProtobuf(o32.stakePeriodStart) : null, pendingReward: null != o32.pendingReward ? e4.fromTinybars(o32.pendingReward) : null, stakedToMe: null != o32.stakedToMe ? e4.fromTinybars(o32.stakedToMe) : null, stakedAccountId: null != o32.stakedAccountId ? y3._fromProtobuf(o32.stakedAccountId) : null, stakedNodeId: null != o32.stakedNodeId ? o32.stakedNodeId : null });
  }
  _toProtobuf() {
    return { declineReward: this.declineStakingReward, stakePeriodStart: null != this.stakePeriodStart ? this.stakePeriodStart._toProtobuf() : null, pendingReward: null != this.pendingReward ? this.pendingReward.toTinybars() : null, stakedToMe: null != this.stakedToMe ? this.stakedToMe.toTinybars() : null, stakedAccountId: null != this.stakedAccountId ? this.stakedAccountId._toProtobuf() : null, stakedNodeId: this.stakedNodeId };
  }
  static fromBytes(t35) {
    return _n._fromProtobuf(o13.proto.StakingInfo.decode(t35));
  }
  toBytes() {
    return o13.proto.StakingInfo.encode(this._toProtobuf()).finish();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return { declineStakingReward: this.declineStakingReward, stakePeriodStart: null != this.stakePeriodStart ? this.stakePeriodStart.toString() : null, pendingReward: null != this.pendingReward ? this.pendingReward.toString() : null, stakedToMe: null != this.stakedToMe ? this.stakedToMe.toString() : null, stakedAccountId: null != this.stakedAccountId ? this.stakedAccountId.toString() : null, stakedNodeId: null != this.stakedNodeId ? this.stakedNodeId.toString() : null };
  }
};

// node_modules/@hashgraph/sdk/lib/account/LiveHash.js
var s10 = class _s {
  constructor(t35) {
    this.accountId = t35.accountId, this.hash = t35.hash, this.keys = t35.keys, this.duration = t35.duration, Object.freeze(this);
  }
  static _fromProtobuf(u22) {
    const a23 = u22;
    return new _s({ accountId: y3._fromProtobuf(a23.accountId), hash: null != a23.hash ? a23.hash : new Uint8Array(), keys: null != a23.keys ? s4.__fromProtobufKeyList(a23.keys) : new s4(), duration: s9._fromProtobuf(a23.duration) });
  }
  _toProtobuf() {
    return { accountId: this.accountId._toProtobuf(), hash: this.hash, keys: this.keys._toProtobufKey().keyList, duration: this.duration._toProtobuf() };
  }
};

// node_modules/@hashgraph/sdk/lib/account/TokenRelationship.js
var s11 = class _s {
  constructor(t35) {
    this.tokenId = t35.tokenId, this.symbol = t35.symbol, this.balance = t35.balance, this.isKycGranted = t35.isKycGranted, this.isFrozen = t35.isFrozen, this.automaticAssociation = t35.automaticAssociation, Object.freeze(this);
  }
  static _fromProtobuf(a23) {
    const n31 = c4._fromProtobuf(a23.tokenId), e39 = null == a23.kycStatus || 0 === a23.kycStatus ? null : 1 === a23.kycStatus, i17 = null == a23.freezeStatus || 0 === a23.freezeStatus ? null : 1 === a23.freezeStatus;
    return new _s({ tokenId: n31, symbol: a23.symbol, balance: null != a23.balance ? a23.balance instanceof long_default ? a23.balance : long_default.fromValue(a23.balance) : long_default.ZERO, isKycGranted: e39, isFrozen: i17, automaticAssociation: null != a23.automaticAssociation ? a23.automaticAssociation : null });
  }
  _toProtobuf() {
    return { tokenId: this.tokenId._toProtobuf(), symbol: this.symbol, balance: this.balance, kycStatus: null == this.isKycGranted ? 0 : this.isKycGranted ? 1 : 2, freezeStatus: null == this.isFrozen ? 0 : this.isFrozen ? 1 : 2, automaticAssociation: this.automaticAssociation };
  }
};

// node_modules/@hashgraph/sdk/lib/account/TokenRelationshipMap.js
var s12 = class _s extends t3 {
  constructor() {
    super(((t35) => c4.fromString(t35)));
  }
  static _fromProtobuf(r41) {
    const f4 = new _s();
    for (const s26 of r41) {
      const r42 = c4._fromProtobuf(s26.tokenId);
      f4._set(r42, s11._fromProtobuf(s26));
    }
    return f4;
  }
  _toProtobuf() {
    const o32 = [];
    for (const [t35, r41] of this) o32.push(r41._toProtobuf());
    return o32;
  }
};

// node_modules/@hashgraph/sdk/lib/account/AccountInfo.js
var c8 = __toESM(require_lib(), 1);
var d8 = class _d {
  constructor(e39) {
    this.accountId = e39.accountId, this.contractAccountId = e39.contractAccountId, this.isDeleted = e39.isDeleted, this.proxyAccountId = e39.proxyAccountId, this.proxyReceived = e39.proxyReceived, this.key = e39.key, this.balance = e39.balance, this.sendRecordThreshold = e39.sendRecordThreshold, this.receiveRecordThreshold = e39.receiveRecordThreshold, this.isReceiverSignatureRequired = e39.isReceiverSignatureRequired, this.expirationTime = e39.expirationTime, this.autoRenewPeriod = e39.autoRenewPeriod, this.liveHashes = e39.liveHashes, this.tokenRelationships = e39.tokenRelationships, this.accountMemo = e39.accountMemo, this.ownedNfts = e39.ownedNfts, this.maxAutomaticTokenAssociations = e39.maxAutomaticTokenAssociations, this.aliasKey = e39.aliasKey, this.ledgerId = e39.ledgerId, this.hbarAllowances = e39.hbarAllowances, this.tokenAllowances = e39.tokenAllowances, this.nftAllowances = e39.nftAllowances, this.ethereumNonce = e39.ethereumNonce, this.stakingInfo = e39.stakingInfo, Object.freeze(this);
  }
  static _fromProtobuf(m6) {
    let f4 = null != m6.alias && m6.alias.length > 0 ? t2._fromProtobufKey(c8.proto.Key.decode(m6.alias)) : null;
    f4 instanceof i || (f4 = null);
    const p3 = y3._fromProtobuf(m6.accountID);
    return new _d({ accountId: p3, contractAccountId: null != m6.contractAccountID ? m6.contractAccountID : null, isDeleted: null != m6.deleted && m6.deleted, key: t2._fromProtobufKey(m6.key), balance: e4.fromTinybars(null != m6.balance ? m6.balance : 0), sendRecordThreshold: e4.fromTinybars(null != m6.generateSendRecordThreshold ? m6.generateSendRecordThreshold : 0), receiveRecordThreshold: e4.fromTinybars(null != m6.generateReceiveRecordThreshold ? m6.generateReceiveRecordThreshold : 0), isReceiverSignatureRequired: null != m6.receiverSigRequired && m6.receiverSigRequired, expirationTime: s3._fromProtobuf(m6.expirationTime), autoRenewPeriod: null != m6.autoRenewPeriod ? new s9(m6.autoRenewPeriod.seconds) : new s9(0), proxyAccountId: null != m6.proxyAccountID && 0 !== long_default.fromValue(m6.proxyAccountID.shardNum).toInt() && 0 !== long_default.fromValue(m6.proxyAccountID.realmNum).toInt() && 0 !== long_default.fromValue(m6.proxyAccountID.accountNum).toInt() ? y3._fromProtobuf(m6.proxyAccountID) : null, proxyReceived: e4.fromTinybars(null != m6.proxyReceived ? m6.proxyReceived : 0), liveHashes: (null != m6.liveHashes ? m6.liveHashes : []).map(((e39) => s10._fromProtobuf(e39))), tokenRelationships: s12._fromProtobuf(null != m6.tokenRelationships ? m6.tokenRelationships : []), accountMemo: null != m6.memo ? m6.memo : "", ownedNfts: m6.ownedNfts ? m6.ownedNfts : long_default.ZERO, maxAutomaticTokenAssociations: m6.maxAutomaticTokenAssociations ? long_default.fromNumber(m6.maxAutomaticTokenAssociations) : long_default.ZERO, aliasKey: f4, ledgerId: null != m6.ledgerId ? r15.fromBytes(m6.ledgerId) : null, hbarAllowances: [], tokenAllowances: [], nftAllowances: [], ethereumNonce: null != m6.ethereumNonce ? m6.ethereumNonce : null, stakingInfo: null != m6.stakingInfo ? n15._fromProtobuf(m6.stakingInfo) : null });
  }
  _toProtobuf() {
    return { accountID: this.accountId._toProtobuf(), contractAccountID: this.contractAccountId, deleted: this.isDeleted, proxyAccountID: null != this.proxyAccountId ? this.proxyAccountId._toProtobuf() : null, proxyReceived: this.proxyReceived.toTinybars(), key: this.key._toProtobufKey(), balance: this.balance.toTinybars(), generateSendRecordThreshold: this.sendRecordThreshold.toTinybars(), generateReceiveRecordThreshold: this.receiveRecordThreshold.toTinybars(), receiverSigRequired: this.isReceiverSignatureRequired, expirationTime: this.expirationTime._toProtobuf(), autoRenewPeriod: this.autoRenewPeriod._toProtobuf(), liveHashes: this.liveHashes.map(((e39) => e39._toProtobuf())), tokenRelationships: null != this.tokenRelationships ? this.tokenRelationships._toProtobuf() : null, memo: this.accountMemo, ownedNfts: this.ownedNfts, maxAutomaticTokenAssociations: this.maxAutomaticTokenAssociations.toInt(), alias: null != this.aliasKey ? c8.proto.Key.encode(this.aliasKey._toProtobufKey()).finish() : null, ledgerId: null != this.ledgerId ? this.ledgerId.toBytes() : null, ethereumNonce: this.ethereumNonce, stakingInfo: null != this.stakingInfo ? this.stakingInfo._toProtobuf() : null };
  }
  static fromBytes(e39) {
    return _d._fromProtobuf(c8.proto.CryptoGetInfoResponse.AccountInfo.decode(e39));
  }
  toBytes() {
    return c8.proto.CryptoGetInfoResponse.AccountInfo.encode(this._toProtobuf()).finish();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return { balance: this.balance.toString(), accountId: this.accountId.toString(), contractAccountId: this.contractAccountId, isDeleted: this.isDeleted, proxyAccountId: null != this.proxyAccountId ? this.proxyAccountId.toString() : null, proxyReceived: this.proxyReceived.toString(), key: null != this.key ? this.key.toString() : null, sendRecordThreshold: this.sendRecordThreshold.toString(), receiveRecordThreshold: this.receiveRecordThreshold.toString(), isReceiverSignatureRequired: this.isReceiverSignatureRequired, expirationTime: this.expirationTime.toString(), autoRenewPeriod: this.autoRenewPeriod.toString(), accountMemo: this.accountMemo, ownedNfts: this.ownedNfts.toString(), maxAutomaticTokenAssociations: this.maxAutomaticTokenAssociations.toString(), aliasKey: null != this.aliasKey ? this.aliasKey.toString() : null, ledgerId: null != this.ledgerId ? this.ledgerId.toString() : null, ethereumNonce: null != this.ethereumNonce ? this.ethereumNonce.toString() : null, stakingInfo: null != this.stakingInfo ? this.stakingInfo.toJSON() : null };
  }
};

// node_modules/@hashgraph/sdk/lib/account/AccountInfoQuery.js
var c9 = class _c extends h3 {
  constructor(t35 = {}) {
    super(), this._accountId = null, null != t35.accountId && this.setAccountId(t35.accountId);
  }
  static _fromProtobuf(t35) {
    const o32 = t35.cryptoGetInfo;
    return new _c({ accountId: null != o32.accountID ? y3._fromProtobuf(o32.accountID) : void 0 });
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._accountId && this._accountId.validateChecksum(t35);
  }
  _execute(t35, o32) {
    return t35.crypto.getAccountInfo(o32);
  }
  async getCost(t35) {
    return super.getCost(t35);
  }
  _mapResponseHeader(t35) {
    return t35.cryptoGetInfo.header;
  }
  _mapResponse(t35, o32, n31) {
    const c17 = t35.cryptoGetInfo;
    return Promise.resolve(d8._fromProtobuf(c17.accountInfo));
  }
  _onMakeRequest(t35) {
    return { cryptoGetInfo: { header: t35, accountID: null != this._accountId ? this._accountId._toProtobuf() : null } };
  }
  _getLogId() {
    return `AccountInfoQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("cryptoGetInfo", c9._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/AccountRecordsQuery.js
var e14 = class _e extends h3 {
  constructor(t35 = {}) {
    super(), this._accountId = null, null != t35.accountId && this.setAccountId(t35.accountId);
  }
  static _fromProtobuf(t35) {
    const o32 = t35.cryptoGetAccountRecords;
    return new _e({ accountId: null != o32.accountID ? y3._fromProtobuf(o32.accountID) : void 0 });
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._accountId && this._accountId.validateChecksum(t35);
  }
  _execute(t35, o32) {
    return t35.crypto.getAccountRecords(o32);
  }
  _mapResponseHeader(t35) {
    return t35.cryptoGetAccountRecords.header;
  }
  _mapResponse(t35, o32, c17) {
    const e39 = t35.cryptoGetAccountRecords.records;
    return Promise.resolve(e39.map(((t36) => b3._fromProtobuf({ transactionRecord: t36 }))));
  }
  _onMakeRequest(t35) {
    return { cryptoGetAccountRecords: { header: t35, accountID: null != this._accountId ? this._accountId._toProtobuf() : null } };
  }
  _getLogId() {
    return `AccountRecordsQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("cryptoGetAccountRecords", e14._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/AccountUpdateTransaction.js
var s13 = class _s extends P {
  constructor(e39 = {}) {
    super(), this._accountId = null, this._key = null, this._receiverSignatureRequired = null, this._proxyAccountId = null, this._autoRenewPeriod = null, this._expirationTime = null, this._accountMemo = null, this._maxAutomaticTokenAssociations = null, this._aliasKey = null, this._stakedAccountId = null, this._stakedNodeId = null, this._declineStakingReward = null, null != e39.accountId && this.setAccountId(e39.accountId), null != e39.key && this.setKey(e39.key), null != e39.receiverSignatureRequired && this.setReceiverSignatureRequired(e39.receiverSignatureRequired), null != e39.proxyAccountId && this.setProxyAccountId(e39.proxyAccountId), null != e39.autoRenewPeriod && this.setAutoRenewPeriod(e39.autoRenewPeriod), null != e39.expirationTime && this.setExpirationTime(e39.expirationTime), null != e39.accountMemo && this.setAccountMemo(e39.accountMemo), null != e39.maxAutomaticTokenAssociations && this.setMaxAutomaticTokenAssociations(e39.maxAutomaticTokenAssociations), null != e39.stakedAccountId && this.setStakedAccountId(e39.stakedAccountId), null != e39.stakedNodeId && this.setStakedNodeId(e39.stakedNodeId), null != e39.declineStakingReward && this.setDeclineStakingReward(e39.declineStakingReward);
  }
  static _fromProtobuf(t35, n31, a23, c17, d18) {
    const l19 = d18[0].cryptoUpdateAccount;
    return P._fromProtobufTransactions(new _s({ accountId: null != l19.accountIDToUpdate ? y3._fromProtobuf(l19.accountIDToUpdate) : void 0, key: null != l19.key ? t2._fromProtobufKey(l19.key) : void 0, receiverSignatureRequired: null != l19.receiverSigRequiredWrapper && Object.hasOwn(l19.receiverSigRequiredWrapper, "value") ? l19.receiverSigRequiredWrapper.value : void 0, proxyAccountId: null != l19.proxyAccountID ? y3._fromProtobuf(l19.proxyAccountID) : void 0, autoRenewPeriod: null != l19.autoRenewPeriod && null != l19.autoRenewPeriod.seconds ? l19.autoRenewPeriod.seconds : void 0, expirationTime: null != l19.expirationTime ? s3._fromProtobuf(l19.expirationTime) : void 0, accountMemo: null != l19.memo && Object.hasOwn(l19.memo, "value") ? l19.memo.value : void 0, maxAutomaticTokenAssociations: null != l19.maxAutomaticTokenAssociations && null != l19.maxAutomaticTokenAssociations.value && Object.hasOwn(l19.maxAutomaticTokenAssociations, "value") ? long_default.fromNumber(l19.maxAutomaticTokenAssociations.value) : void 0, stakedAccountId: null != l19.stakedAccountId ? y3._fromProtobuf(l19.stakedAccountId) : void 0, stakedNodeId: null != l19.stakedNodeId ? l19.stakedNodeId : void 0, declineStakingReward: null != l19.declineReward && Object.hasOwn(l19.declineReward, "value") ? l19.declineReward.value : void 0 }), t35, n31, a23, c17, d18);
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(e39) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof e39 ? y3.fromString(e39) : e39.clone(), this;
  }
  get key() {
    return this._key;
  }
  setKey(e39) {
    return this._requireNotFrozen(), this._key = e39, this;
  }
  get receiverSignatureRequired() {
    return this._receiverSignatureRequired;
  }
  setReceiverSignatureRequired(e39) {
    return this._requireNotFrozen(), this._receiverSignatureRequired = e39, this;
  }
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  setProxyAccountId(e39) {
    return this._requireNotFrozen(), this._proxyAccountId = e39, this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(e39) {
    return this._requireNotFrozen(), this._autoRenewPeriod = e39 instanceof s9 ? e39 : new s9(e39), this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(e39) {
    return this._requireNotFrozen(), this._expirationTime = e39 instanceof Date ? s3.fromDate(e39) : e39, this;
  }
  get accountMemo() {
    return this._accountMemo;
  }
  setAccountMemo(e39) {
    return this._requireNotFrozen(), this._accountMemo = e39, this;
  }
  clearAccountMemo() {
    return this._requireNotFrozen(), this._accountMemo = null, this;
  }
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  setMaxAutomaticTokenAssociations(e39) {
    return this._requireNotFrozen(), this._maxAutomaticTokenAssociations = "number" == typeof e39 ? long_default.fromNumber(e39) : e39, this;
  }
  get aliasKey() {
    return null;
  }
  setAliasKey(e39) {
    return this;
  }
  get stakedAccountId() {
    return this._stakedAccountId;
  }
  setStakedAccountId(e39) {
    return this._requireNotFrozen(), this._stakedAccountId = "string" == typeof e39 ? y3.fromString(e39) : e39, this;
  }
  clearStakedAccountId() {
    return this._requireNotFrozen(), this._stakedAccountId = new y3(0, 0, 0), this;
  }
  get stakedNodeId() {
    return this._stakedNodeId;
  }
  setStakedNodeId(e39) {
    return this._requireNotFrozen(), this._stakedNodeId = long_default.fromValue(e39), this;
  }
  clearStakedNodeId() {
    return this._requireNotFrozen(), this._stakedNodeId = long_default.fromNumber(-1), this;
  }
  get declineStakingRewards() {
    return this._declineStakingReward;
  }
  setDeclineStakingReward(e39) {
    return this._requireNotFrozen(), this._declineStakingReward = e39, this;
  }
  _validateChecksums(e39) {
    null != this._accountId && this._accountId.validateChecksum(e39), null != this._proxyAccountId && this._proxyAccountId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.crypto.updateAccount(t35);
  }
  _getTransactionDataCase() {
    return "cryptoUpdateAccount";
  }
  _makeTransactionData() {
    return { accountIDToUpdate: null != this._accountId ? this._accountId._toProtobuf() : null, key: null != this._key ? this._key._toProtobufKey() : null, expirationTime: null != this._expirationTime ? this._expirationTime._toProtobuf() : null, proxyAccountID: null != this._proxyAccountId ? this._proxyAccountId._toProtobuf() : null, autoRenewPeriod: null != this._autoRenewPeriod ? this._autoRenewPeriod._toProtobuf() : null, receiverSigRequiredWrapper: null == this._receiverSignatureRequired ? null : { value: this._receiverSignatureRequired }, memo: null != this._accountMemo ? { value: this._accountMemo } : null, maxAutomaticTokenAssociations: null != this._maxAutomaticTokenAssociations ? { value: this._maxAutomaticTokenAssociations.toInt() } : null, stakedAccountId: null != this.stakedAccountId ? this.stakedAccountId._toProtobuf() : null, stakedNodeId: this.stakedNodeId, declineReward: null != this.declineStakingRewards ? { value: this.declineStakingRewards } : null };
  }
  _getLogId() {
    return `AccountUpdateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("cryptoUpdateAccount", s13._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/FreezeType.js
var e15 = class _e {
  constructor(e39) {
    this._code = e39, Object.freeze(this);
  }
  toString() {
    switch (this) {
      case _e.UnknownFreezeType:
        return "UNKNOWN_FREEZE_TYPE";
      case _e.FreezeOnly:
        return "FREEZE_ONLY";
      case _e.PrepareUpgrade:
        return "PREPARE_UPGRADE";
      case _e.FreezeUpgrade:
        return "FREEZE_UPGRADE";
      case _e.FreezeAbort:
        return "FREEZE_ABORT";
      case _e.TelemetryUpgrade:
        return "TELEMETRY_UPGRADE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(r41) {
    switch (r41) {
      case 0:
        return _e.UnknownFreezeType;
      case 1:
        return _e.FreezeOnly;
      case 2:
        return _e.PrepareUpgrade;
      case 3:
        return _e.FreezeUpgrade;
      case 4:
        return _e.FreezeAbort;
      case 5:
        return _e.TelemetryUpgrade;
      default:
        throw new Error(`(BUG) Status.fromCode() does not handle code: ${r41}`);
    }
  }
  valueOf() {
    return this._code;
  }
};
e15.UnknownFreezeType = new e15(0), e15.FreezeOnly = new e15(1), e15.PrepareUpgrade = new e15(2), e15.FreezeUpgrade = new e15(3), e15.FreezeAbort = new e15(4), e15.TelemetryUpgrade = new e15(5);

// node_modules/@hashgraph/sdk/lib/system/FreezeTransaction.js
var l8 = class _l extends P {
  constructor(e39 = {}) {
    super(), this._startTime = null, this._startTimestamp = null, this._endTime = null, this._fileId = null, this._fileHash = null, this._freezeType = null, null != e39.startTime && this.setStartTime(e39.startTime.hour, e39.startTime.minute), null != e39.endTime && this.setEndTime(e39.endTime.hour, e39.endTime.minute), null != e39.startTimestamp && this.setStartTimestamp(e39.startTimestamp), null != e39.updateFileId && this.setUpdateFileId(e39.updateFileId), null != e39.fileId && this.setFileId(e39.fileId), null != e39.fileHash && this.setFileHash(e39.fileHash), null != e39.freezeType && this.setFreezeType(e39.freezeType);
  }
  static _fromProtobuf(t35, s26, a23, u22, o32) {
    const m6 = o32[0].freeze;
    return P._fromProtobufTransactions(new _l({ startTime: null != m6.startHour && null != m6.startMin ? { hour: m6.startHour, minute: m6.startMin } : void 0, endTime: null != m6.endHour && null != m6.endMin ? { hour: m6.endHour, minute: m6.endMin } : void 0, startTimestamp: null != m6.startTime ? s3._fromProtobuf(m6.startTime) : void 0, updateFileId: null != m6.updateFile ? c3._fromProtobuf(m6.updateFile) : void 0, fileHash: null != m6.fileHash ? m6.fileHash : void 0, freezeType: null != m6.freezeType ? e15._fromCode(m6.freezeType) : void 0 }), t35, s26, a23, u22, o32);
  }
  get startTime() {
    return null;
  }
  setStartTime(e39, t35) {
    if (this._requireNotFrozen(), "string" == typeof e39) {
      const t36 = e39.split(":");
      this._startTime = { hour: Number(t36[0]), minute: Number(t36[1]) };
    } else this._startTime = { hour: e39, minute: t35 };
    return this;
  }
  get startTimestamp() {
    return this._startTimestamp;
  }
  setStartTimestamp(e39) {
    return this._requireNotFrozen(), this._startTimestamp = e39, this;
  }
  get endTime() {
    return console.warn("`FreezeTransaction.endTime` is deprecated"), this._endTime;
  }
  setEndTime(e39, t35) {
    if (console.warn("`FreezeTransaction.endTime` is deprecated"), this._requireNotFrozen(), "string" == typeof e39) {
      const t36 = e39.split(":");
      this._endTime = { hour: Number(t36[0]), minute: Number(t36[1]) };
    } else this._endTime = { hour: e39, minute: t35 };
    return this;
  }
  get updateFileId() {
    return this.fileId;
  }
  setUpdateFileId(e39) {
    return this.setFileId(e39);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(e39) {
    return this._requireNotFrozen(), this._fileId = e39, this;
  }
  get fileHash() {
    return this._fileHash;
  }
  setFileHash(e39) {
    return this._requireNotFrozen(), this._fileHash = "string" == typeof e39 ? r(e39) : e39, this;
  }
  get freezeType() {
    return this._freezeType;
  }
  setFreezeType(e39) {
    return this._requireNotFrozen(), this._freezeType = e39, this;
  }
  _getTransactionDataCase() {
    return "freeze";
  }
  _makeTransactionData() {
    return { startTime: null != this._startTimestamp ? this._startTimestamp._toProtobuf() : null, updateFile: null != this._fileId ? this._fileId._toProtobuf() : null, fileHash: this._fileHash, freezeType: null != this._freezeType ? this._freezeType.valueOf() : null };
  }
  _getLogId() {
    return `FreezeTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
  _execute(e39, t35) {
    return e39.freeze.freeze(t35);
  }
};
B.set("freeze", l8._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/transaction/BatchTransaction.js
var import_proto4 = __toESM(require_lib(), 1);
var o14 = class _o extends P {
  constructor(t35) {
    super(), this._batchTransactions = (t35 == null ? void 0 : t35.transactions) || [];
  }
  setInnerTransactions(t35) {
    return t35.forEach(((t36) => this._validateTransaction(t36))), this._batchTransactions = t35, this;
  }
  addInnerTransaction(t35) {
    return this._validateTransaction(t35), this._requireNotFrozen(), this._batchTransactions.push(t35), this;
  }
  get innerTransactions() {
    return this._batchTransactions;
  }
  get innerTransactionIds() {
    return Array.isArray(this._batchTransactions) ? this._batchTransactions.map(((t35) => t35.transactionId)) : [];
  }
  _makeTransactionData() {
    if (!Array.isArray(this._batchTransactions)) return { transactions: [] };
    return { transactions: this._batchTransactions.map(((t35) => import_proto4.proto.SignedTransaction.encode(t35._signedTransactions.get(0)).finish())) };
  }
  static _fromProtobuf(t35, s26, i17, e39, c17) {
    var _a2;
    const h8 = c17[0], d18 = (_a2 = h8.atomicBatch) == null ? void 0 : _a2.transactions, T3 = d18 == null ? void 0 : d18.map(((t36) => import_proto4.proto.SignedTransaction.decode(t36))), u22 = T3 == null ? void 0 : T3.map(((t36) => {
      const a23 = import_proto4.proto.TransactionBody.decode(t36.bodyBytes), o32 = a23.data;
      if (!o32) throw new Error("Transaction type not found");
      const s27 = B.get(o32);
      if (!s27) throw new Error("fromProtobuf not found");
      return s27([], [t36], [], [], [a23]);
    }));
    return P._fromProtobufTransactions(new _o({ transactions: u22 }), t35, s26, i17, e39, c17);
  }
  _getTransactionDataCase() {
    return "atomicBatch";
  }
  _getLogId() {
    return `AtomicBatch:${this._transactionIds.current.validStart.toString()}`;
  }
  _execute(t35, a23) {
    return t35.util.atomicBatch(a23);
  }
  _validateTransaction(a23) {
    if (a23 instanceof _o || a23 instanceof l8) throw new Error("Transaction is not allowed to be added to a batch");
    if (!a23.isFrozen()) throw new Error("Transaction must be frozen before being added to a batch");
    if (!a23.batchKey) throw new Error("Transaction must have a batch key");
  }
};
B.set("atomicBatch", o14._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/contract/ContractByteCodeQuery.js
var o15 = class _o extends h3 {
  constructor(t35 = {}) {
    super(), this._contractId = null, null != t35.contractId && this.setContractId(t35.contractId);
  }
  static _fromProtobuf(t35) {
    const e39 = t35.contractGetBytecode;
    return new _o({ contractId: null != e39.contractID ? g4._fromProtobuf(e39.contractID) : void 0 });
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(t35) {
    return this._contractId = "string" == typeof t35 ? g4.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._contractId && this._contractId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.smartContract.contractGetBytecode(e39);
  }
  _mapResponseHeader(t35) {
    return t35.contractGetBytecodeResponse.header;
  }
  _mapResponse(t35) {
    const e39 = t35.contractGetBytecodeResponse;
    return Promise.resolve(null != e39.bytecode ? e39.bytecode : new Uint8Array());
  }
  _onMakeRequest(t35) {
    return { contractGetBytecode: { header: t35, contractID: null != this._contractId ? this._contractId._toProtobuf() : null } };
  }
  _getLogId() {
    return `ContractByteCodeQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("contractGetBytecode", o15._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/cryptography/keccak.js
var t21 = "0123456789abcdef".split("");
var r16 = [1, 256, 65536, 16777216];
var e16 = [0, 8, 16, 24];
var o16 = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
var s14 = (t35) => {
  var r41, e39, s26, l19, a23, c17, f4, n31, u22, k3, b5, i17, p3, v3, d18, x2, h8, B2, C, y5, I3, g5, A3, j2, m6, q, w5, z, D, E3, F2, G, H, J, K, L2, M, N4, O, P2, Q, R, S3, T3, U, V, W, X, Y, Z, $2, _4, tt, rt, et, ot, st, lt, at, ct, ft, nt, ut;
  for (s26 = 0; s26 < 48; s26 += 2) l19 = t35[0] ^ t35[10] ^ t35[20] ^ t35[30] ^ t35[40], a23 = t35[1] ^ t35[11] ^ t35[21] ^ t35[31] ^ t35[41], c17 = t35[2] ^ t35[12] ^ t35[22] ^ t35[32] ^ t35[42], f4 = t35[3] ^ t35[13] ^ t35[23] ^ t35[33] ^ t35[43], n31 = t35[4] ^ t35[14] ^ t35[24] ^ t35[34] ^ t35[44], u22 = t35[5] ^ t35[15] ^ t35[25] ^ t35[35] ^ t35[45], k3 = t35[6] ^ t35[16] ^ t35[26] ^ t35[36] ^ t35[46], b5 = t35[7] ^ t35[17] ^ t35[27] ^ t35[37] ^ t35[47], r41 = (i17 = t35[8] ^ t35[18] ^ t35[28] ^ t35[38] ^ t35[48]) ^ (c17 << 1 | f4 >>> 31), e39 = (p3 = t35[9] ^ t35[19] ^ t35[29] ^ t35[39] ^ t35[49]) ^ (f4 << 1 | c17 >>> 31), t35[0] ^= r41, t35[1] ^= e39, t35[10] ^= r41, t35[11] ^= e39, t35[20] ^= r41, t35[21] ^= e39, t35[30] ^= r41, t35[31] ^= e39, t35[40] ^= r41, t35[41] ^= e39, r41 = l19 ^ (n31 << 1 | u22 >>> 31), e39 = a23 ^ (u22 << 1 | n31 >>> 31), t35[2] ^= r41, t35[3] ^= e39, t35[12] ^= r41, t35[13] ^= e39, t35[22] ^= r41, t35[23] ^= e39, t35[32] ^= r41, t35[33] ^= e39, t35[42] ^= r41, t35[43] ^= e39, r41 = c17 ^ (k3 << 1 | b5 >>> 31), e39 = f4 ^ (b5 << 1 | k3 >>> 31), t35[4] ^= r41, t35[5] ^= e39, t35[14] ^= r41, t35[15] ^= e39, t35[24] ^= r41, t35[25] ^= e39, t35[34] ^= r41, t35[35] ^= e39, t35[44] ^= r41, t35[45] ^= e39, r41 = n31 ^ (i17 << 1 | p3 >>> 31), e39 = u22 ^ (p3 << 1 | i17 >>> 31), t35[6] ^= r41, t35[7] ^= e39, t35[16] ^= r41, t35[17] ^= e39, t35[26] ^= r41, t35[27] ^= e39, t35[36] ^= r41, t35[37] ^= e39, t35[46] ^= r41, t35[47] ^= e39, r41 = k3 ^ (l19 << 1 | a23 >>> 31), e39 = b5 ^ (a23 << 1 | l19 >>> 31), t35[8] ^= r41, t35[9] ^= e39, t35[18] ^= r41, t35[19] ^= e39, t35[28] ^= r41, t35[29] ^= e39, t35[38] ^= r41, t35[39] ^= e39, t35[48] ^= r41, t35[49] ^= e39, v3 = t35[0], d18 = t35[1], V = t35[11] << 4 | t35[10] >>> 28, W = t35[10] << 4 | t35[11] >>> 28, z = t35[20] << 3 | t35[21] >>> 29, D = t35[21] << 3 | t35[20] >>> 29, ct = t35[31] << 9 | t35[30] >>> 23, ft = t35[30] << 9 | t35[31] >>> 23, R = t35[40] << 18 | t35[41] >>> 14, S3 = t35[41] << 18 | t35[40] >>> 14, J = t35[2] << 1 | t35[3] >>> 31, K = t35[3] << 1 | t35[2] >>> 31, x2 = t35[13] << 12 | t35[12] >>> 20, h8 = t35[12] << 12 | t35[13] >>> 20, X = t35[22] << 10 | t35[23] >>> 22, Y = t35[23] << 10 | t35[22] >>> 22, E3 = t35[33] << 13 | t35[32] >>> 19, F2 = t35[32] << 13 | t35[33] >>> 19, nt = t35[42] << 2 | t35[43] >>> 30, ut = t35[43] << 2 | t35[42] >>> 30, rt = t35[5] << 30 | t35[4] >>> 2, et = t35[4] << 30 | t35[5] >>> 2, L2 = t35[14] << 6 | t35[15] >>> 26, M = t35[15] << 6 | t35[14] >>> 26, B2 = t35[25] << 11 | t35[24] >>> 21, C = t35[24] << 11 | t35[25] >>> 21, Z = t35[34] << 15 | t35[35] >>> 17, $2 = t35[35] << 15 | t35[34] >>> 17, G = t35[45] << 29 | t35[44] >>> 3, H = t35[44] << 29 | t35[45] >>> 3, j2 = t35[6] << 28 | t35[7] >>> 4, m6 = t35[7] << 28 | t35[6] >>> 4, ot = t35[17] << 23 | t35[16] >>> 9, st = t35[16] << 23 | t35[17] >>> 9, N4 = t35[26] << 25 | t35[27] >>> 7, O = t35[27] << 25 | t35[26] >>> 7, y5 = t35[36] << 21 | t35[37] >>> 11, I3 = t35[37] << 21 | t35[36] >>> 11, _4 = t35[47] << 24 | t35[46] >>> 8, tt = t35[46] << 24 | t35[47] >>> 8, T3 = t35[8] << 27 | t35[9] >>> 5, U = t35[9] << 27 | t35[8] >>> 5, q = t35[18] << 20 | t35[19] >>> 12, w5 = t35[19] << 20 | t35[18] >>> 12, lt = t35[29] << 7 | t35[28] >>> 25, at = t35[28] << 7 | t35[29] >>> 25, P2 = t35[38] << 8 | t35[39] >>> 24, Q = t35[39] << 8 | t35[38] >>> 24, g5 = t35[48] << 14 | t35[49] >>> 18, A3 = t35[49] << 14 | t35[48] >>> 18, t35[0] = v3 ^ ~x2 & B2, t35[1] = d18 ^ ~h8 & C, t35[10] = j2 ^ ~q & z, t35[11] = m6 ^ ~w5 & D, t35[20] = J ^ ~L2 & N4, t35[21] = K ^ ~M & O, t35[30] = T3 ^ ~V & X, t35[31] = U ^ ~W & Y, t35[40] = rt ^ ~ot & lt, t35[41] = et ^ ~st & at, t35[2] = x2 ^ ~B2 & y5, t35[3] = h8 ^ ~C & I3, t35[12] = q ^ ~z & E3, t35[13] = w5 ^ ~D & F2, t35[22] = L2 ^ ~N4 & P2, t35[23] = M ^ ~O & Q, t35[32] = V ^ ~X & Z, t35[33] = W ^ ~Y & $2, t35[42] = ot ^ ~lt & ct, t35[43] = st ^ ~at & ft, t35[4] = B2 ^ ~y5 & g5, t35[5] = C ^ ~I3 & A3, t35[14] = z ^ ~E3 & G, t35[15] = D ^ ~F2 & H, t35[24] = N4 ^ ~P2 & R, t35[25] = O ^ ~Q & S3, t35[34] = X ^ ~Z & _4, t35[35] = Y ^ ~$2 & tt, t35[44] = lt ^ ~ct & nt, t35[45] = at ^ ~ft & ut, t35[6] = y5 ^ ~g5 & v3, t35[7] = I3 ^ ~A3 & d18, t35[16] = E3 ^ ~G & j2, t35[17] = F2 ^ ~H & m6, t35[26] = P2 ^ ~R & J, t35[27] = Q ^ ~S3 & K, t35[36] = Z ^ ~_4 & T3, t35[37] = $2 ^ ~tt & U, t35[46] = ct ^ ~nt & rt, t35[47] = ft ^ ~ut & et, t35[8] = g5 ^ ~v3 & x2, t35[9] = A3 ^ ~d18 & h8, t35[18] = G ^ ~j2 & q, t35[19] = H ^ ~m6 & w5, t35[28] = R ^ ~J & L2, t35[29] = S3 ^ ~K & M, t35[38] = _4 ^ ~T3 & V, t35[39] = tt ^ ~U & W, t35[48] = nt ^ ~rt & ot, t35[49] = ut ^ ~et & st, t35[0] ^= o16[s26], t35[1] ^= o16[s26 + 1];
};
var l9 = (a8 = 256, (o32) => {
  var l19;
  if ("0x" === o32.slice(0, 2)) {
    l19 = [];
    for (var c17 = 2, f4 = o32.length; c17 < f4; c17 += 2) l19.push(parseInt(o32.slice(c17, c17 + 2), 16));
  } else l19 = o32;
  return ((o33, l20) => {
    for (var a23, c18, f5 = l20.length, n31 = o33.blocks, u22 = o33.blockCount << 2, k3 = o33.blockCount, b5 = o33.outputBlocks, i17 = o33.s, p3 = 0; p3 < f5; ) {
      if (o33.reset) for (o33.reset = false, n31[0] = o33.block, a23 = 1; a23 < k3 + 1; ++a23) n31[a23] = 0;
      if ("string" != typeof l20) for (a23 = o33.start; p3 < f5 && a23 < u22; ++p3) n31[a23 >> 2] |= l20[p3] << e16[3 & a23++];
      else for (a23 = o33.start; p3 < f5 && a23 < u22; ++p3) (c18 = l20.charCodeAt(p3)) < 128 ? n31[a23 >> 2] |= c18 << e16[3 & a23++] : c18 < 2048 ? (n31[a23 >> 2] |= (192 | c18 >> 6) << e16[3 & a23++], n31[a23 >> 2] |= (128 | 63 & c18) << e16[3 & a23++]) : c18 < 55296 || c18 >= 57344 ? (n31[a23 >> 2] |= (224 | c18 >> 12) << e16[3 & a23++], n31[a23 >> 2] |= (128 | c18 >> 6 & 63) << e16[3 & a23++], n31[a23 >> 2] |= (128 | 63 & c18) << e16[3 & a23++]) : (c18 = 65536 + ((1023 & c18) << 10 | 1023 & l20.charCodeAt(++p3)), n31[a23 >> 2] |= (240 | c18 >> 18) << e16[3 & a23++], n31[a23 >> 2] |= (128 | c18 >> 12 & 63) << e16[3 & a23++], n31[a23 >> 2] |= (128 | c18 >> 6 & 63) << e16[3 & a23++], n31[a23 >> 2] |= (128 | 63 & c18) << e16[3 & a23++]);
      if (o33.lastByteIndex = a23, a23 >= u22) {
        for (o33.start = a23 - u22, o33.block = n31[k3], a23 = 0; a23 < k3; ++a23) i17[a23] ^= n31[a23];
        s14(i17), o33.reset = true;
      } else o33.start = a23;
    }
    if (n31[(a23 = o33.lastByteIndex) >> 2] |= r16[3 & a23], o33.lastByteIndex === u22) for (n31[0] = n31[k3], a23 = 1; a23 < k3 + 1; ++a23) n31[a23] = 0;
    for (n31[k3 - 1] |= 2147483648, a23 = 0; a23 < k3; ++a23) i17[a23] ^= n31[a23];
    s14(i17);
    var v3, d18 = "", x2 = 0;
    for (a23 = 0; x2 < b5; ) {
      for (a23 = 0; a23 < k3 && x2 < b5; ++a23, ++x2) v3 = i17[a23], d18 += t21[v3 >> 4 & 15] + t21[15 & v3] + t21[v3 >> 12 & 15] + t21[v3 >> 8 & 15] + t21[v3 >> 20 & 15] + t21[v3 >> 16 & 15] + t21[v3 >> 28 & 15] + t21[v3 >> 24 & 15];
      x2 % k3 == 0 && (s14(i17), a23 = 0);
    }
    return "0x" + d18;
  })(((t35) => {
    return { blocks: [], reset: true, block: 0, start: 0, blockCount: 1600 - (t35 << 1) >> 5, outputBlocks: t35 >> 5, s: (r41 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [].concat(r41, r41, r41, r41, r41)) };
    var r41;
  })(a8), l19);
});
var a8;

// node_modules/@hashgraph/sdk/lib/contract/ContractFunctionSelector.js
var d9 = { uint8: 0, int8: 1, uint16: 2, int16: 3, uint24: 4, int24: 5, uint32: 6, int32: 7, uint40: 8, int40: 9, uint48: 10, int48: 11, uint56: 12, int56: 13, uint64: 14, int64: 15, uint72: 16, int72: 17, uint80: 18, int80: 19, uint88: 20, int88: 21, uint96: 22, int96: 23, uint104: 24, int104: 25, uint112: 26, int112: 27, uint120: 28, int120: 29, uint128: 30, int128: 31, uint136: 32, int136: 33, uint144: 34, int144: 35, uint152: 36, int152: 37, uint160: 38, int160: 39, uint168: 40, int168: 41, uint176: 42, int176: 43, uint184: 44, int184: 45, uint192: 46, int192: 47, uint200: 48, int200: 49, uint208: 50, int208: 51, uint216: 52, int216: 53, uint224: 54, int224: 55, uint232: 56, int232: 57, uint240: 58, int240: 59, uint248: 60, int248: 61, uint256: 62, int256: 63, string: 64, bool: 65, bytes: 66, bytes32: 67, address: 68, func: 69 };
var i7 = class {
  constructor(a23) {
    this.name = null, this._params = "", this._paramTypes = [], null != a23 && (this._name = a23);
  }
  addString() {
    return this._addParam({ ty: d9.string, array: false });
  }
  addStringArray() {
    return this._addParam({ ty: d9.string, array: true });
  }
  addBytes() {
    return this._addParam({ ty: d9.bytes, array: false });
  }
  addBytes32() {
    return this._addParam({ ty: d9.bytes32, array: false });
  }
  addBytesArray() {
    return this._addParam({ ty: d9.bytes, array: true });
  }
  addBytes32Array() {
    return this._addParam({ ty: d9.bytes32, array: true });
  }
  addInt8() {
    return this._addParam({ ty: d9.int8, array: false });
  }
  addUint8() {
    return this._addParam({ ty: d9.uint8, array: false });
  }
  addInt16() {
    return this._addParam({ ty: d9.int16, array: false });
  }
  addUint16() {
    return this._addParam({ ty: d9.uint16, array: false });
  }
  addInt24() {
    return this._addParam({ ty: d9.int24, array: false });
  }
  addUint24() {
    return this._addParam({ ty: d9.uint24, array: false });
  }
  addInt32() {
    return this._addParam({ ty: d9.int32, array: false });
  }
  addUint32() {
    return this._addParam({ ty: d9.uint32, array: false });
  }
  addInt40() {
    return this._addParam({ ty: d9.int40, array: false });
  }
  addUint40() {
    return this._addParam({ ty: d9.uint40, array: false });
  }
  addInt48() {
    return this._addParam({ ty: d9.int48, array: false });
  }
  addUint48() {
    return this._addParam({ ty: d9.uint48, array: false });
  }
  addInt56() {
    return this._addParam({ ty: d9.int56, array: false });
  }
  addUint56() {
    return this._addParam({ ty: d9.uint56, array: false });
  }
  addInt64() {
    return this._addParam({ ty: d9.int64, array: false });
  }
  addUint64() {
    return this._addParam({ ty: d9.uint64, array: false });
  }
  addInt72() {
    return this._addParam({ ty: d9.int72, array: false });
  }
  addUint72() {
    return this._addParam({ ty: d9.uint72, array: false });
  }
  addInt80() {
    return this._addParam({ ty: d9.int80, array: false });
  }
  addUint80() {
    return this._addParam({ ty: d9.uint80, array: false });
  }
  addInt88() {
    return this._addParam({ ty: d9.int88, array: false });
  }
  addUint88() {
    return this._addParam({ ty: d9.uint88, array: false });
  }
  addInt96() {
    return this._addParam({ ty: d9.int96, array: false });
  }
  addUint96() {
    return this._addParam({ ty: d9.uint96, array: false });
  }
  addInt104() {
    return this._addParam({ ty: d9.int104, array: false });
  }
  addUint104() {
    return this._addParam({ ty: d9.uint104, array: false });
  }
  addInt112() {
    return this._addParam({ ty: d9.int112, array: false });
  }
  addUint112() {
    return this._addParam({ ty: d9.uint112, array: false });
  }
  addInt120() {
    return this._addParam({ ty: d9.int120, array: false });
  }
  addUint120() {
    return this._addParam({ ty: d9.uint120, array: false });
  }
  addInt128() {
    return this._addParam({ ty: d9.int128, array: false });
  }
  addUint128() {
    return this._addParam({ ty: d9.uint128, array: false });
  }
  addInt136() {
    return this._addParam({ ty: d9.int136, array: false });
  }
  addUint136() {
    return this._addParam({ ty: d9.uint136, array: false });
  }
  addInt144() {
    return this._addParam({ ty: d9.int144, array: false });
  }
  addUint144() {
    return this._addParam({ ty: d9.uint144, array: false });
  }
  addInt152() {
    return this._addParam({ ty: d9.int152, array: false });
  }
  addUint152() {
    return this._addParam({ ty: d9.uint152, array: false });
  }
  addInt160() {
    return this._addParam({ ty: d9.int160, array: false });
  }
  addUint160() {
    return this._addParam({ ty: d9.uint160, array: false });
  }
  addInt168() {
    return this._addParam({ ty: d9.int168, array: false });
  }
  addUint168() {
    return this._addParam({ ty: d9.uint168, array: false });
  }
  addInt176() {
    return this._addParam({ ty: d9.int176, array: false });
  }
  addUint176() {
    return this._addParam({ ty: d9.uint176, array: false });
  }
  addInt184() {
    return this._addParam({ ty: d9.int184, array: false });
  }
  addUint184() {
    return this._addParam({ ty: d9.uint184, array: false });
  }
  addInt192() {
    return this._addParam({ ty: d9.int192, array: false });
  }
  addUint192() {
    return this._addParam({ ty: d9.uint192, array: false });
  }
  addInt200() {
    return this._addParam({ ty: d9.int200, array: false });
  }
  addUint200() {
    return this._addParam({ ty: d9.uint200, array: false });
  }
  addInt208() {
    return this._addParam({ ty: d9.int208, array: false });
  }
  addUint208() {
    return this._addParam({ ty: d9.uint208, array: false });
  }
  addInt216() {
    return this._addParam({ ty: d9.int216, array: false });
  }
  addUint216() {
    return this._addParam({ ty: d9.uint216, array: false });
  }
  addInt224() {
    return this._addParam({ ty: d9.int224, array: false });
  }
  addUint224() {
    return this._addParam({ ty: d9.uint224, array: false });
  }
  addInt232() {
    return this._addParam({ ty: d9.int232, array: false });
  }
  addUint232() {
    return this._addParam({ ty: d9.uint232, array: false });
  }
  addInt240() {
    return this._addParam({ ty: d9.int240, array: false });
  }
  addUint240() {
    return this._addParam({ ty: d9.uint240, array: false });
  }
  addInt248() {
    return this._addParam({ ty: d9.int248, array: false });
  }
  addUint248() {
    return this._addParam({ ty: d9.uint248, array: false });
  }
  addInt256() {
    return this._addParam({ ty: d9.int256, array: false });
  }
  addUint256() {
    return this._addParam({ ty: d9.uint256, array: false });
  }
  addInt8Array() {
    return this._addParam({ ty: d9.int8, array: true });
  }
  addUint8Array() {
    return this._addParam({ ty: d9.uint8, array: true });
  }
  addInt16Array() {
    return this._addParam({ ty: d9.int16, array: true });
  }
  addUint16Array() {
    return this._addParam({ ty: d9.uint16, array: true });
  }
  addInt24Array() {
    return this._addParam({ ty: d9.int24, array: true });
  }
  addUint24Array() {
    return this._addParam({ ty: d9.uint24, array: true });
  }
  addInt32Array() {
    return this._addParam({ ty: d9.int32, array: true });
  }
  addUint32Array() {
    return this._addParam({ ty: d9.uint32, array: true });
  }
  addInt40Array() {
    return this._addParam({ ty: d9.int40, array: true });
  }
  addUint40Array() {
    return this._addParam({ ty: d9.uint40, array: true });
  }
  addInt48Array() {
    return this._addParam({ ty: d9.int48, array: true });
  }
  addUint48Array() {
    return this._addParam({ ty: d9.uint48, array: true });
  }
  addInt56Array() {
    return this._addParam({ ty: d9.int56, array: true });
  }
  addUint56Array() {
    return this._addParam({ ty: d9.uint56, array: true });
  }
  addInt64Array() {
    return this._addParam({ ty: d9.int64, array: true });
  }
  addUint64Array() {
    return this._addParam({ ty: d9.uint64, array: true });
  }
  addInt72Array() {
    return this._addParam({ ty: d9.int72, array: true });
  }
  addUint72Array() {
    return this._addParam({ ty: d9.uint72, array: true });
  }
  addInt80Array() {
    return this._addParam({ ty: d9.int80, array: true });
  }
  addUint80Array() {
    return this._addParam({ ty: d9.uint80, array: true });
  }
  addInt88Array() {
    return this._addParam({ ty: d9.int88, array: true });
  }
  addUint88Array() {
    return this._addParam({ ty: d9.uint88, array: true });
  }
  addInt96Array() {
    return this._addParam({ ty: d9.int96, array: true });
  }
  addUint96Array() {
    return this._addParam({ ty: d9.uint96, array: true });
  }
  addInt104Array() {
    return this._addParam({ ty: d9.int104, array: true });
  }
  addUint104Array() {
    return this._addParam({ ty: d9.uint104, array: true });
  }
  addInt112Array() {
    return this._addParam({ ty: d9.int112, array: true });
  }
  addUint112Array() {
    return this._addParam({ ty: d9.uint112, array: true });
  }
  addInt120Array() {
    return this._addParam({ ty: d9.int120, array: true });
  }
  addUint120Array() {
    return this._addParam({ ty: d9.uint120, array: true });
  }
  addInt128Array() {
    return this._addParam({ ty: d9.int128, array: true });
  }
  addUint128Array() {
    return this._addParam({ ty: d9.uint128, array: true });
  }
  addInt136Array() {
    return this._addParam({ ty: d9.int136, array: true });
  }
  addUint136Array() {
    return this._addParam({ ty: d9.uint136, array: true });
  }
  addInt144Array() {
    return this._addParam({ ty: d9.int144, array: true });
  }
  addUint144Array() {
    return this._addParam({ ty: d9.uint144, array: true });
  }
  addInt152Array() {
    return this._addParam({ ty: d9.int152, array: true });
  }
  addUint152Array() {
    return this._addParam({ ty: d9.uint152, array: true });
  }
  addInt160Array() {
    return this._addParam({ ty: d9.int160, array: true });
  }
  addUint160Array() {
    return this._addParam({ ty: d9.uint160, array: true });
  }
  addInt168Array() {
    return this._addParam({ ty: d9.int168, array: true });
  }
  addUint168Array() {
    return this._addParam({ ty: d9.uint168, array: true });
  }
  addInt176Array() {
    return this._addParam({ ty: d9.int176, array: true });
  }
  addUint176Array() {
    return this._addParam({ ty: d9.uint176, array: true });
  }
  addInt184Array() {
    return this._addParam({ ty: d9.int184, array: true });
  }
  addUint184Array() {
    return this._addParam({ ty: d9.uint184, array: true });
  }
  addInt192Array() {
    return this._addParam({ ty: d9.int192, array: true });
  }
  addUint192Array() {
    return this._addParam({ ty: d9.uint192, array: true });
  }
  addInt200Array() {
    return this._addParam({ ty: d9.int200, array: true });
  }
  addUint200Array() {
    return this._addParam({ ty: d9.uint200, array: true });
  }
  addInt208Array() {
    return this._addParam({ ty: d9.int208, array: true });
  }
  addUint208Array() {
    return this._addParam({ ty: d9.uint208, array: true });
  }
  addInt216Array() {
    return this._addParam({ ty: d9.int216, array: true });
  }
  addUint216Array() {
    return this._addParam({ ty: d9.uint216, array: true });
  }
  addInt224Array() {
    return this._addParam({ ty: d9.int224, array: true });
  }
  addUint224Array() {
    return this._addParam({ ty: d9.uint224, array: true });
  }
  addInt232Array() {
    return this._addParam({ ty: d9.int232, array: true });
  }
  addUint232Array() {
    return this._addParam({ ty: d9.uint232, array: true });
  }
  addInt240Array() {
    return this._addParam({ ty: d9.int240, array: true });
  }
  addUint240Array() {
    return this._addParam({ ty: d9.uint240, array: true });
  }
  addInt248Array() {
    return this._addParam({ ty: d9.int248, array: true });
  }
  addUint248Array() {
    return this._addParam({ ty: d9.uint248, array: true });
  }
  addInt256Array() {
    return this._addParam({ ty: d9.int256, array: true });
  }
  addUint256Array() {
    return this._addParam({ ty: d9.uint256, array: true });
  }
  addBool() {
    return this._addParam({ ty: d9.bool, array: false });
  }
  addAddress() {
    return this._addParam({ ty: d9.address, array: false });
  }
  addAddressArray() {
    return this._addParam({ ty: d9.address, array: true });
  }
  addFunction() {
    return this._addParam({ ty: d9.func, array: false });
  }
  _addParam(a23) {
    return this._paramTypes.length > 0 && (this._params += ","), this._params += y4(a23), this._paramTypes.push(a23), this;
  }
  _build(d18) {
    if (null != d18) this._name = d18;
    else if (null == this._name) throw new Error("`name` required for ContractFunctionSelector");
    const i17 = n(n8(this.toString()));
    return r(l9(`0x${i17}`)).slice(0, 4);
  }
  toString() {
    return `${null != this._name ? this._name.toString() : ""}(${this._params})`;
  }
};
function y4(a23) {
  let r41 = "";
  switch (a23.ty) {
    case d9.uint8:
      r41 = "uint8";
      break;
    case d9.int8:
      r41 = "int8";
      break;
    case d9.uint16:
      r41 = "uint16";
      break;
    case d9.int16:
      r41 = "int16";
      break;
    case d9.uint24:
      r41 = "uint24";
      break;
    case d9.int24:
      r41 = "int24";
      break;
    case d9.uint32:
      r41 = "uint32";
      break;
    case d9.int32:
      r41 = "int32";
      break;
    case d9.uint40:
      r41 = "uint40";
      break;
    case d9.int40:
      r41 = "int40";
      break;
    case d9.uint48:
      r41 = "uint48";
      break;
    case d9.int48:
      r41 = "int48";
      break;
    case d9.uint56:
      r41 = "uint56";
      break;
    case d9.int56:
      r41 = "int56";
      break;
    case d9.uint64:
      r41 = "uint64";
      break;
    case d9.int64:
      r41 = "int64";
      break;
    case d9.uint72:
      r41 = "uint72";
      break;
    case d9.int72:
      r41 = "int72";
      break;
    case d9.uint80:
      r41 = "uint80";
      break;
    case d9.int80:
      r41 = "int80";
      break;
    case d9.uint88:
      r41 = "uint88";
      break;
    case d9.int88:
      r41 = "int88";
      break;
    case d9.uint96:
      r41 = "uint96";
      break;
    case d9.int96:
      r41 = "int96";
      break;
    case d9.uint104:
      r41 = "uint104";
      break;
    case d9.int104:
      r41 = "int104";
      break;
    case d9.uint112:
      r41 = "uint112";
      break;
    case d9.int112:
      r41 = "int112";
      break;
    case d9.uint120:
      r41 = "uint120";
      break;
    case d9.int120:
      r41 = "int120";
      break;
    case d9.uint128:
      r41 = "uint128";
      break;
    case d9.int128:
      r41 = "int128";
      break;
    case d9.uint136:
      r41 = "uint136";
      break;
    case d9.int136:
      r41 = "int136";
      break;
    case d9.uint144:
      r41 = "uint144";
      break;
    case d9.int144:
      r41 = "int144";
      break;
    case d9.uint152:
      r41 = "uint152";
      break;
    case d9.int152:
      r41 = "int152";
      break;
    case d9.uint160:
      r41 = "uint160";
      break;
    case d9.int160:
      r41 = "int160";
      break;
    case d9.uint168:
      r41 = "uint168";
      break;
    case d9.int168:
      r41 = "int168";
      break;
    case d9.uint176:
      r41 = "uint176";
      break;
    case d9.int176:
      r41 = "int176";
      break;
    case d9.uint184:
      r41 = "uint184";
      break;
    case d9.int184:
      r41 = "int184";
      break;
    case d9.uint192:
      r41 = "uint192";
      break;
    case d9.int192:
      r41 = "int192";
      break;
    case d9.uint200:
      r41 = "uint200";
      break;
    case d9.int200:
      r41 = "int200";
      break;
    case d9.uint208:
      r41 = "uint208";
      break;
    case d9.int208:
      r41 = "int208";
      break;
    case d9.uint216:
      r41 = "uint216";
      break;
    case d9.int216:
      r41 = "int216";
      break;
    case d9.uint224:
      r41 = "uint224";
      break;
    case d9.int224:
      r41 = "int224";
      break;
    case d9.uint232:
      r41 = "uint232";
      break;
    case d9.int232:
      r41 = "int232";
      break;
    case d9.uint240:
      r41 = "uint240";
      break;
    case d9.int240:
      r41 = "int240";
      break;
    case d9.uint248:
      r41 = "uint248";
      break;
    case d9.int248:
      r41 = "int248";
      break;
    case d9.uint256:
      r41 = "uint256";
      break;
    case d9.int256:
      r41 = "int256";
      break;
    case d9.string:
      r41 = "string";
      break;
    case d9.bool:
      r41 = "bool";
      break;
    case d9.bytes:
      r41 = "bytes";
      break;
    case d9.bytes32:
      r41 = "bytes32";
      break;
    case d9.address:
      r41 = "address";
      break;
    case d9.func:
      r41 = "function";
      break;
    default:
      r41 = "";
  }
  return a23.array && (r41 += "[]"), r41;
}

// node_modules/@hashgraph/sdk/lib/contract/ContractFunctionParameters.js
var _2 = class {
  constructor() {
    this._selector = new i7(), this._arguments = [];
  }
  addString(t35) {
    return this._selector.addString(), this._addParam(t35, true);
  }
  addStringArray(t35) {
    return this._selector.addStringArray(), this._addParam(t35, true);
  }
  addBytes(t35) {
    return this._selector.addBytes(), this._addParam(t35, true);
  }
  addBytes32(t35) {
    if (32 !== t35.length) throw new Error(`addBytes32 expected array to be of length 32, but received ${t35.length}`);
    return this._selector.addBytes32(), this._addParam(t35, false);
  }
  addBytesArray(t35) {
    return this._selector.addBytesArray(), this._addParam(t35, true);
  }
  addBytes32Array(t35) {
    for (const [a23, r41] of t35.entries()) if (32 !== r41.length) throw new Error(`addBytes32 expected array to be of length 32, but received ${r41.length}`);
    return this._selector.addBytes32Array(), this._addParam(t35, true);
  }
  addBool(t35) {
    return this._selector.addBool(), this._addParam(t35, false);
  }
  addInt8(t35) {
    return this._selector.addInt8(), this._addParam(v(t35), false);
  }
  addUint8(t35) {
    return this._selector.addUint8(), this._addParam(v(t35), false);
  }
  addInt16(t35) {
    return this._selector.addInt16(), this._addParam(v(t35), false);
  }
  addUint16(t35) {
    return this._selector.addUint16(), this._addParam(v(t35), false);
  }
  addInt24(t35) {
    return this._selector.addInt24(), this._addParam(v(t35), false);
  }
  addUint24(t35) {
    return this._selector.addUint24(), this._addParam(v(t35), false);
  }
  addInt32(t35) {
    return this._selector.addInt32(), this._addParam(v(t35), false);
  }
  addUint32(t35) {
    return this._selector.addUint32(), this._addParam(v(t35), false);
  }
  addInt40(t35) {
    return this._selector.addInt40(), this._addParam(v(t35), false);
  }
  addUint40(t35) {
    return this._selector.addUint40(), this._addParam(v(t35), false);
  }
  addInt48(t35) {
    return this._selector.addInt48(), this._addParam(v(t35), false);
  }
  addUint48(t35) {
    return this._selector.addUint48(), this._addParam(v(t35), false);
  }
  addInt56(t35) {
    return this._selector.addInt56(), this._addParam(v(t35), false);
  }
  addUint56(t35) {
    return this._selector.addUint56(), this._addParam(v(t35), false);
  }
  addInt64(t35) {
    return this._selector.addInt64(), this._addParam(v(t35), false);
  }
  addUint64(t35) {
    return this._selector.addUint64(), this._addParam(v(t35), false);
  }
  addInt72(t35) {
    return this._selector.addInt72(), this._addParam(v(t35), false);
  }
  addUint72(t35) {
    return this._selector.addUint72(), this._addParam(v(t35), false);
  }
  addInt80(t35) {
    return this._selector.addInt80(), this._addParam(v(t35), false);
  }
  addUint80(t35) {
    return this._selector.addUint80(), this._addParam(v(t35), false);
  }
  addInt88(t35) {
    return this._selector.addInt88(), this._addParam(v(t35), false);
  }
  addUint88(t35) {
    return this._selector.addUint88(), this._addParam(v(t35), false);
  }
  addInt96(t35) {
    return this._selector.addInt96(), this._addParam(v(t35), false);
  }
  addUint96(t35) {
    return this._selector.addUint96(), this._addParam(v(t35), false);
  }
  addInt104(t35) {
    return this._selector.addInt104(), this._addParam(v(t35), false);
  }
  addUint104(t35) {
    return this._selector.addUint104(), this._addParam(v(t35), false);
  }
  addInt112(t35) {
    return this._selector.addInt112(), this._addParam(v(t35), false);
  }
  addUint112(t35) {
    return this._selector.addUint112(), this._addParam(v(t35), false);
  }
  addInt120(t35) {
    return this._selector.addInt120(), this._addParam(v(t35), false);
  }
  addUint120(t35) {
    return this._selector.addUint120(), this._addParam(v(t35), false);
  }
  addInt128(t35) {
    return this._selector.addInt128(), this._addParam(v(t35), false);
  }
  addUint128(t35) {
    return this._selector.addUint128(), this._addParam(v(t35), false);
  }
  addInt136(t35) {
    return this._selector.addInt136(), this._addParam(v(t35), false);
  }
  addUint136(t35) {
    return this._selector.addUint136(), this._addParam(v(t35), false);
  }
  addInt144(t35) {
    return this._selector.addInt144(), this._addParam(v(t35), false);
  }
  addUint144(t35) {
    return this._selector.addUint144(), this._addParam(v(t35), false);
  }
  addInt152(t35) {
    return this._selector.addInt152(), this._addParam(v(t35), false);
  }
  addUint152(t35) {
    return this._selector.addUint152(), this._addParam(v(t35), false);
  }
  addInt160(t35) {
    return this._selector.addInt160(), this._addParam(v(t35), false);
  }
  addUint160(t35) {
    return this._selector.addUint160(), this._addParam(v(t35), false);
  }
  addInt168(t35) {
    return this._selector.addInt168(), this._addParam(v(t35), false);
  }
  addUint168(t35) {
    return this._selector.addUint168(), this._addParam(v(t35), false);
  }
  addInt176(t35) {
    return this._selector.addInt176(), this._addParam(v(t35), false);
  }
  addUint176(t35) {
    return this._selector.addUint176(), this._addParam(v(t35), false);
  }
  addInt184(t35) {
    return this._selector.addInt184(), this._addParam(v(t35), false);
  }
  addUint184(t35) {
    return this._selector.addUint184(), this._addParam(v(t35), false);
  }
  addInt192(t35) {
    return this._selector.addInt192(), this._addParam(v(t35), false);
  }
  addUint192(t35) {
    return this._selector.addUint192(), this._addParam(v(t35), false);
  }
  addInt200(t35) {
    return this._selector.addInt200(), this._addParam(v(t35), false);
  }
  addUint200(t35) {
    return this._selector.addUint200(), this._addParam(v(t35), false);
  }
  addInt208(t35) {
    return this._selector.addInt208(), this._addParam(v(t35), false);
  }
  addUint208(t35) {
    return this._selector.addUint208(), this._addParam(v(t35), false);
  }
  addInt216(t35) {
    return this._selector.addInt216(), this._addParam(v(t35), false);
  }
  addUint216(t35) {
    return this._selector.addUint216(), this._addParam(v(t35), false);
  }
  addInt224(t35) {
    return this._selector.addInt224(), this._addParam(v(t35), false);
  }
  addUint224(t35) {
    return this._selector.addUint224(), this._addParam(v(t35), false);
  }
  addInt232(t35) {
    return this._selector.addInt232(), this._addParam(v(t35), false);
  }
  addUint232(t35) {
    return this._selector.addUint232(), this._addParam(v(t35), false);
  }
  addInt240(t35) {
    return this._selector.addInt240(), this._addParam(v(t35), false);
  }
  addUint240(t35) {
    return this._selector.addUint240(), this._addParam(v(t35), false);
  }
  addInt248(t35) {
    return this._selector.addInt248(), this._addParam(v(t35), false);
  }
  addUint248(t35) {
    return this._selector.addUint248(), this._addParam(v(t35), false);
  }
  addInt256(t35) {
    return this._selector.addInt256(), this._addParam(v(t35), false);
  }
  addUint256(t35) {
    return this._selector.addUint256(), this._addParam(v(t35), false);
  }
  addInt8Array(t35) {
    return this._selector.addInt8Array(), this._addParam(N2(t35), true);
  }
  addUint8Array(t35) {
    return this._selector.addUint8Array(), this._addParam(N2(t35), true);
  }
  addInt16Array(t35) {
    return this._selector.addInt16Array(), this._addParam(N2(t35), true);
  }
  addUint16Array(t35) {
    return this._selector.addUint16Array(), this._addParam(N2(t35), true);
  }
  addInt24Array(t35) {
    return this._selector.addInt24Array(), this._addParam(N2(t35), true);
  }
  addUint24Array(t35) {
    return this._selector.addUint24Array(), this._addParam(N2(t35), true);
  }
  addInt32Array(t35) {
    return this._selector.addInt32Array(), this._addParam(N2(t35), true);
  }
  addUint32Array(t35) {
    return this._selector.addUint32Array(), this._addParam(N2(t35), true);
  }
  addInt40Array(t35) {
    return this._selector.addInt40Array(), this._addParam(N2(t35), true);
  }
  addUint40Array(t35) {
    return this._selector.addUint40Array(), this._addParam(N2(t35), true);
  }
  addInt48Array(t35) {
    return this._selector.addInt48Array(), this._addParam(N2(t35), true);
  }
  addUint48Array(t35) {
    return this._selector.addUint48Array(), this._addParam(N2(t35), true);
  }
  addInt56Array(t35) {
    return this._selector.addInt56Array(), this._addParam(N2(t35), true);
  }
  addUint56Array(t35) {
    return this._selector.addUint56Array(), this._addParam(N2(t35), true);
  }
  addInt64Array(t35) {
    return this._selector.addInt64Array(), this._addParam(N2(t35), true);
  }
  addUint64Array(t35) {
    return this._selector.addUint64Array(), this._addParam(N2(t35), true);
  }
  addInt72Array(t35) {
    return this._selector.addInt72Array(), this._addParam(N2(t35), true);
  }
  addUint72Array(t35) {
    return this._selector.addUint72Array(), this._addParam(N2(t35), true);
  }
  addInt80Array(t35) {
    return this._selector.addInt80Array(), this._addParam(N2(t35), true);
  }
  addUint80Array(t35) {
    return this._selector.addUint80Array(), this._addParam(N2(t35), true);
  }
  addInt88Array(t35) {
    return this._selector.addInt88Array(), this._addParam(N2(t35), true);
  }
  addUint88Array(t35) {
    return this._selector.addUint88Array(), this._addParam(N2(t35), true);
  }
  addInt96Array(t35) {
    return this._selector.addInt96Array(), this._addParam(N2(t35), true);
  }
  addUint96Array(t35) {
    return this._selector.addUint96Array(), this._addParam(N2(t35), true);
  }
  addInt104Array(t35) {
    return this._selector.addInt104Array(), this._addParam(N2(t35), true);
  }
  addUint104Array(t35) {
    return this._selector.addUint104Array(), this._addParam(N2(t35), true);
  }
  addInt112Array(t35) {
    return this._selector.addInt112Array(), this._addParam(N2(t35), true);
  }
  addUint112Array(t35) {
    return this._selector.addUint112Array(), this._addParam(N2(t35), true);
  }
  addInt120Array(t35) {
    return this._selector.addInt120Array(), this._addParam(N2(t35), true);
  }
  addUint120Array(t35) {
    return this._selector.addUint120Array(), this._addParam(N2(t35), true);
  }
  addInt128Array(t35) {
    return this._selector.addInt128Array(), this._addParam(N2(t35), true);
  }
  addUint128Array(t35) {
    return this._selector.addUint128Array(), this._addParam(N2(t35), true);
  }
  addInt136Array(t35) {
    return this._selector.addInt136Array(), this._addParam(N2(t35), true);
  }
  addUint136Array(t35) {
    return this._selector.addUint136Array(), this._addParam(N2(t35), true);
  }
  addInt144Array(t35) {
    return this._selector.addInt144Array(), this._addParam(N2(t35), true);
  }
  addUint144Array(t35) {
    return this._selector.addUint144Array(), this._addParam(N2(t35), true);
  }
  addInt152Array(t35) {
    return this._selector.addInt152Array(), this._addParam(N2(t35), true);
  }
  addUint152Array(t35) {
    return this._selector.addUint152Array(), this._addParam(N2(t35), true);
  }
  addInt160Array(t35) {
    return this._selector.addInt160Array(), this._addParam(N2(t35), true);
  }
  addUint160Array(t35) {
    return this._selector.addUint160Array(), this._addParam(N2(t35), true);
  }
  addInt168Array(t35) {
    return this._selector.addInt168Array(), this._addParam(N2(t35), true);
  }
  addUint168Array(t35) {
    return this._selector.addUint168Array(), this._addParam(N2(t35), true);
  }
  addInt176Array(t35) {
    return this._selector.addInt176Array(), this._addParam(N2(t35), true);
  }
  addUint176Array(t35) {
    return this._selector.addUint176Array(), this._addParam(N2(t35), true);
  }
  addInt184Array(t35) {
    return this._selector.addInt184Array(), this._addParam(N2(t35), true);
  }
  addUint184Array(t35) {
    return this._selector.addUint184Array(), this._addParam(N2(t35), true);
  }
  addInt192Array(t35) {
    return this._selector.addInt192Array(), this._addParam(N2(t35), true);
  }
  addUint192Array(t35) {
    return this._selector.addUint192Array(), this._addParam(N2(t35), true);
  }
  addInt200Array(t35) {
    return this._selector.addInt200Array(), this._addParam(N2(t35), true);
  }
  addUint200Array(t35) {
    return this._selector.addUint200Array(), this._addParam(N2(t35), true);
  }
  addInt208Array(t35) {
    return this._selector.addInt208Array(), this._addParam(N2(t35), true);
  }
  addUint208Array(t35) {
    return this._selector.addUint208Array(), this._addParam(N2(t35), true);
  }
  addInt216Array(t35) {
    return this._selector.addInt216Array(), this._addParam(N2(t35), true);
  }
  addUint216Array(t35) {
    return this._selector.addUint216Array(), this._addParam(N2(t35), true);
  }
  addInt224Array(t35) {
    return this._selector.addInt224Array(), this._addParam(N2(t35), true);
  }
  addUint224Array(t35) {
    return this._selector.addUint224Array(), this._addParam(N2(t35), true);
  }
  addInt232Array(t35) {
    return this._selector.addInt232Array(), this._addParam(N2(t35), true);
  }
  addUint232Array(t35) {
    return this._selector.addUint232Array(), this._addParam(N2(t35), true);
  }
  addInt240Array(t35) {
    return this._selector.addInt240Array(), this._addParam(N2(t35), true);
  }
  addUint240Array(t35) {
    return this._selector.addUint240Array(), this._addParam(N2(t35), true);
  }
  addInt248Array(t35) {
    return this._selector.addInt248Array(), this._addParam(N2(t35), true);
  }
  addUint248Array(t35) {
    return this._selector.addUint248Array(), this._addParam(N2(t35), true);
  }
  addInt256Array(t35) {
    return this._selector.addInt256Array(), this._addParam(N2(t35), true);
  }
  addUint256Array(t35) {
    return this._selector.addUint256Array(), this._addParam(N2(t35), true);
  }
  addAddress(t35) {
    let a23;
    if ("string" == typeof t35) {
      if (40 !== t35.length && 42 !== t35.length) throw new Error("`address` type requires parameter to be 40 or 42 characters");
      a23 = t35;
    } else a23 = t35.toString();
    const r41 = 40 === a23.length ? r(a23) : r(a23.substring(2));
    return this._selector.addAddress(), this._addParam(r41, false);
  }
  addAddressArray(t35) {
    const a23 = [];
    for (const [r41, d18] of t35.entries()) {
      let t36;
      if ("string" == typeof d18) {
        if (40 !== d18.length && 42 !== d18.length) throw new Error("`address` type requires parameter to be 40 or 42 characters");
        t36 = d18;
      } else t36 = d18.toString();
      const r42 = 40 === t36.length ? r(t36) : r(t36.substring(2));
      a23.push(r42);
    }
    return this._selector.addAddressArray(), this._addParam(a23, true);
  }
  addFunction(t35, a23) {
    const r41 = r(t35), d18 = a23._build();
    if (20 !== r41.length) throw new Error("`function` type requires parameter `address` to be exactly 20 bytes");
    this._selector.addFunction();
    const s26 = new Uint8Array(24);
    return s26.set(r41, 0), s26.set(d18, 20), this._addParam(s26, false);
  }
  _addParam(t35, a23) {
    const r41 = this._selector._paramTypes.length - 1, d18 = u12(t35, this._selector._paramTypes[r41]);
    return this._arguments.push({ dynamic: a23, value: d18 }), this;
  }
  _build(t35) {
    const a23 = null != t35, r41 = a23 ? 4 : 0, d18 = 0 === this._arguments.length ? r41 : 32 * this._arguments.length + this._arguments.map(((t36) => t36.dynamic ? t36.value.length : 0)).reduce(((t36, a24) => t36 + a24)) + r41, e39 = new Uint8Array(d18);
    a23 && e39.set(this._selector._build(t35), 0);
    let s26 = 32 * this._arguments.length;
    for (const [t36, { dynamic: a24, value: d19 }] of this._arguments.entries()) if (a24) {
      const a25 = E(e39, r41 + 32 * t36 + 28);
      a25.setUint32(0, s26), e39.set(d19, a25.getUint32(0) + r41), s26 += d19.length;
    } else e39.set(d19, r41 + 32 * t36);
    return e39;
  }
};
function u12(t35, e39) {
  let s26, n31 = new Uint8Array(32), _4 = E(n31);
  if (e39.array) {
    if (!Array.isArray(t35)) throw new TypeError("SolidityType indicates type is array, but parameter is not an array");
    const r41 = [];
    for (const [a23, d19] of t35.entries()) {
      const t36 = u12(d19, { ty: e39.ty, array: false });
      r41.push(t36);
    }
    const d18 = r41.map(((t36) => t36.length)).reduce(((t36, a23) => t36 + a23), 0);
    switch (e39.ty) {
      case d9.uint8:
      case d9.int8:
      case d9.uint16:
      case d9.int16:
      case d9.uint24:
      case d9.int24:
      case d9.uint32:
      case d9.int32:
      case d9.uint40:
      case d9.int40:
      case d9.uint48:
      case d9.int48:
      case d9.uint56:
      case d9.int56:
      case d9.uint64:
      case d9.int64:
      case d9.uint72:
      case d9.int72:
      case d9.uint80:
      case d9.int80:
      case d9.uint88:
      case d9.int88:
      case d9.uint96:
      case d9.int96:
      case d9.uint104:
      case d9.int104:
      case d9.uint112:
      case d9.int112:
      case d9.uint120:
      case d9.int120:
      case d9.uint128:
      case d9.int128:
      case d9.uint136:
      case d9.int136:
      case d9.uint144:
      case d9.int144:
      case d9.uint152:
      case d9.int152:
      case d9.uint160:
      case d9.int160:
      case d9.uint168:
      case d9.int168:
      case d9.uint176:
      case d9.int176:
      case d9.uint184:
      case d9.int184:
      case d9.uint192:
      case d9.int192:
      case d9.uint200:
      case d9.int200:
      case d9.uint208:
      case d9.int208:
      case d9.uint216:
      case d9.int216:
      case d9.uint224:
      case d9.int224:
      case d9.uint232:
      case d9.int232:
      case d9.uint240:
      case d9.int240:
      case d9.uint248:
      case d9.int248:
      case d9.uint256:
      case d9.int256:
      case d9.bool:
      case d9.bytes32:
      case d9.address:
      case d9.func:
        n31 = new Uint8Array(d18 + 32);
        break;
      case d9.bytes:
      case d9.string:
        n31 = new Uint8Array(32 * r41.length + d18 + 32);
        break;
      default:
        throw new TypeError(`Expected param type to be ArgumentType, but received ${e39.ty}`);
    }
    _4 = E(n31, 28), _4.setUint32(0, r41.length);
    let s27 = 32 * r41.length;
    for (const [t36, d19] of r41.entries()) switch (e39.ty) {
      case d9.uint8:
      case d9.int8:
      case d9.uint16:
      case d9.int16:
      case d9.uint24:
      case d9.int24:
      case d9.uint32:
      case d9.int32:
      case d9.uint40:
      case d9.int40:
      case d9.uint48:
      case d9.int48:
      case d9.uint56:
      case d9.int56:
      case d9.uint64:
      case d9.int64:
      case d9.uint72:
      case d9.int72:
      case d9.uint80:
      case d9.int80:
      case d9.uint88:
      case d9.int88:
      case d9.uint96:
      case d9.int96:
      case d9.uint104:
      case d9.int104:
      case d9.uint112:
      case d9.int112:
      case d9.uint120:
      case d9.int120:
      case d9.uint128:
      case d9.int128:
      case d9.uint136:
      case d9.int136:
      case d9.uint144:
      case d9.int144:
      case d9.uint152:
      case d9.int152:
      case d9.uint160:
      case d9.int160:
      case d9.uint168:
      case d9.int168:
      case d9.uint176:
      case d9.int176:
      case d9.uint184:
      case d9.int184:
      case d9.uint192:
      case d9.int192:
      case d9.uint200:
      case d9.int200:
      case d9.uint208:
      case d9.int208:
      case d9.uint216:
      case d9.int216:
      case d9.uint224:
      case d9.int224:
      case d9.uint232:
      case d9.int232:
      case d9.uint240:
      case d9.int240:
      case d9.uint248:
      case d9.int248:
      case d9.uint256:
      case d9.int256:
      case d9.bool:
      case d9.bytes32:
      case d9.address:
      case d9.func:
        n31.set(d19, 32 * t36 + 32);
        break;
      case d9.bytes:
      case d9.string:
        const r42 = E(n31, 32 * (t36 + 1) + 28);
        r42.setUint32(0, s27), n31.set(d19, r42.getUint32(0) + 32), s27 += d19.length;
        break;
      default:
        throw new TypeError(`Expected param type to be ArgumentType, but received ${e39.ty}`);
    }
    return n31;
  }
  switch (e39.ty) {
    case d9.uint8:
    case d9.int8:
    case d9.uint16:
    case d9.int16:
    case d9.uint24:
    case d9.int24:
    case d9.uint32:
    case d9.int32:
    case d9.uint40:
    case d9.int40:
    case d9.uint48:
    case d9.int48:
    case d9.uint56:
    case d9.int56:
    case d9.uint64:
    case d9.int64:
    case d9.uint72:
    case d9.int72:
    case d9.uint80:
    case d9.int80:
    case d9.uint88:
    case d9.int88:
    case d9.uint96:
    case d9.int96:
    case d9.uint104:
    case d9.int104:
    case d9.uint112:
    case d9.int112:
    case d9.uint120:
    case d9.int120:
    case d9.uint128:
    case d9.int128:
    case d9.uint136:
    case d9.int136:
    case d9.uint144:
    case d9.int144:
    case d9.uint152:
    case d9.int152:
    case d9.uint160:
    case d9.int160:
    case d9.uint168:
    case d9.int168:
    case d9.uint176:
    case d9.int176:
    case d9.uint184:
    case d9.int184:
    case d9.uint192:
    case d9.int192:
    case d9.uint200:
    case d9.int200:
    case d9.uint208:
    case d9.int208:
    case d9.uint216:
    case d9.int216:
    case d9.uint224:
    case d9.int224:
    case d9.uint232:
    case d9.int232:
    case d9.uint240:
    case d9.int240:
    case d9.uint248:
    case d9.int248:
    case d9.int256:
    case d9.uint256: {
      let a23 = t35.toString(16);
      a23 = t35 > 0 || 0 == t35 ? "0x" + a23 : a23.slice(0, 1) + "0x" + a23.slice(1);
      const d18 = defaultAbiCoder.encode([y4(e39)], [a23]);
      return arrayify(d18);
    }
    case d9.address:
      return n31.set(t35, 12), n31;
    case d9.bool:
      return n31[31] = t35 ? 1 : 0, n31;
    case d9.func:
      return n31.set(t35, 8), n31;
    case d9.bytes32:
      return n31.set(t35, 0), n31;
    case d9.bytes:
    case d9.string:
      return s26 = t35 instanceof Uint8Array ? t35 : n8(t35), n31 = Math.floor(s26.length / 32) >= 0 ? 0 !== Math.floor(s26.length % 32) ? new Uint8Array(32 * (Math.floor(s26.length / 32) + 1) + 32) : new Uint8Array(32 * Math.floor(s26.length / 32) + 32) : new Uint8Array(64), n31.set(s26, 32), _4 = E(n31, 28), _4.setUint32(0, s26.length), n31;
    default:
      throw new Error(`Unsupported argument type: ${e39.toString()}`);
  }
}

// node_modules/@hashgraph/sdk/lib/contract/ContractCallQuery.js
var c10 = __toESM(require_lib(), 1);
var l10 = class _l extends h3 {
  constructor(t35 = {}) {
    super(), this._contractId = null, null != t35.contractId && this.setContractId(t35.contractId), this._gas = null, null != t35.gas && this.setGas(t35.gas), this._functionParameters = null, null != t35.functionParameters && (t35.functionParameters instanceof Uint8Array ? this.setFunctionParameters(t35.functionParameters) : this.setFunction(t35.functionParameters.name, t35.functionParameters.parameters)), this._maxResultSize = null, null != t35.maxResultSize && this.setMaxResultSize(t35.maxResultSize), this._senderAccountId = null, null != t35.senderAccountId && this.setSenderAccountId(t35.senderAccountId);
  }
  static _fromProtobuf(t35) {
    const n31 = t35.contractCallLocal;
    return new _l({ contractId: null != n31.contractID ? g4._fromProtobuf(n31.contractID) : void 0, gas: null != n31.gas ? n31.gas : void 0, functionParameters: null != n31.functionParameters ? n31.functionParameters : void 0, maxResultSize: null != n31.maxResultSize ? n31.maxResultSize : void 0 });
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(t35) {
    return this._contractId = "string" == typeof t35 ? g4.fromString(t35) : t35.clone(), this;
  }
  get gas() {
    return this._gas;
  }
  setGas(t35) {
    return this._gas = t35 instanceof long_default ? t35 : long_default.fromValue(t35), this;
  }
  get senderAccountId() {
    return this._senderAccountId;
  }
  setSenderAccountId(t35) {
    return this._senderAccountId = "string" == typeof t35 ? y3.fromString(t35) : t35, this;
  }
  get functionParameters() {
    return this._functionParameters;
  }
  setFunctionParameters(t35) {
    return this._functionParameters = t35, this;
  }
  setFunction(t35, n31) {
    return this._functionParameters = (null != n31 ? n31 : new _2())._build(t35), this;
  }
  setMaxResultSize(t35) {
    return this._maxResultSize = t35 instanceof long_default ? t35 : long_default.fromValue(t35), this;
  }
  _validateChecksums(t35) {
    null != this._contractId && this._contractId.validateChecksum(t35);
  }
  _mapStatusError(t35, n31, e39) {
    const { nodeTransactionPrecheckCode: r41 } = this._mapResponseHeader(n31), s26 = e5._fromCode(null != r41 ? r41 : c10.proto.ResponseCodeEnum.OK);
    if (!n31.contractCallLocal.functionResult) return new n5({ nodeId: e39, status: s26, transactionId: this._getTransactionId(), contractFunctionResult: null });
    const o32 = this._mapResponseSync(n31);
    return new n5({ nodeId: e39, status: s26, transactionId: this._getTransactionId(), contractFunctionResult: o32 });
  }
  _execute(t35, n31) {
    return t35.smartContract.contractCallLocalMethod(n31);
  }
  _mapResponseHeader(t35) {
    return t35.contractCallLocal.header;
  }
  _mapResponse(t35) {
    const n31 = t35.contractCallLocal;
    return Promise.resolve(l4._fromProtobuf(n31.functionResult, false));
  }
  _mapResponseSync(t35) {
    const n31 = t35.contractCallLocal;
    return l4._fromProtobuf(n31.functionResult, false);
  }
  _onMakeRequest(t35) {
    return { contractCallLocal: { header: t35, contractID: null != this._contractId ? this._contractId._toProtobuf() : null, gas: this._gas, maxResultSize: this._maxResultSize, functionParameters: this._functionParameters, senderId: null != this._senderAccountId ? this._senderAccountId._toProtobuf() : null } };
  }
  _getLogId() {
    return `ContractCallQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("contractCallLocal", l10._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/file/FileCreateTransaction.js
var l11 = class _l extends P {
  constructor(t35 = {}) {
    super(), this._keys = null, this._expirationTime = new s3(0, 0).plusNanos(long_default.fromNumber(Date.now()).mul(1e6).add(w3.mul(1e9))), this._contents = null, this._fileMemo = null, this._defaultMaxTransactionFee = new e4(5), null != t35.keys && this.setKeys(t35.keys), null != t35.expirationTime && this.setExpirationTime(t35.expirationTime), null != t35.contents && this.setContents(t35.contents), t35.fileMemo && null != t35.fileMemo && this.setFileMemo(t35.fileMemo);
  }
  static _fromProtobuf(e39, i17, o32, n31, a23) {
    const m6 = a23[0].fileCreate;
    return P._fromProtobufTransactions(new _l({ keys: null != m6.keys && null != m6.keys.keys ? m6.keys.keys.map(((e40) => t2._fromProtobufKey(e40))) : void 0, expirationTime: null != m6.expirationTime ? s3._fromProtobuf(m6.expirationTime) : void 0, contents: null != m6.contents ? m6.contents : void 0, fileMemo: null != m6.memo ? m6.memo : void 0 }), e39, i17, o32, n31, a23);
  }
  get keys() {
    return this._keys;
  }
  setKeys(e39) {
    if (this._requireNotFrozen(), e39 instanceof s4 && null != e39.threshold) throw new Error("Cannot set threshold key as file key");
    return this._keys = e39 instanceof s4 ? e39.toArray() : e39, this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(e39) {
    return this._requireNotFrozen(), this._expirationTime = e39 instanceof s3 ? e39 : s3.fromDate(e39), this;
  }
  get contents() {
    return this._contents;
  }
  setContents(e39) {
    return this._requireNotFrozen(), this._contents = e39 instanceof Uint8Array ? e39 : n8(e39), this;
  }
  get fileMemo() {
    return this._fileMemo;
  }
  setFileMemo(e39) {
    return this._requireNotFrozen(), this._fileMemo = e39, this;
  }
  _execute(e39, t35) {
    return e39.file.createFile(t35);
  }
  _getTransactionDataCase() {
    return "fileCreate";
  }
  _makeTransactionData() {
    return { keys: null != this._keys ? { keys: this._keys.map(((e39) => e39._toProtobufKey())) } : null, expirationTime: this._expirationTime._toProtobuf(), contents: this._contents, memo: this._fileMemo };
  }
  _getLogId() {
    return `FileCreateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("fileCreate", l11._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/file/FileAppendTransaction.js
var c11 = class _c extends P {
  constructor(n31 = {}) {
    super(), this._fileId = null, this._contents = null, this._maxChunks = 20, this._chunkSize = 4096, this._chunkInterval = 10, this._defaultMaxTransactionFee = new e4(5), null != n31.fileId && this.setFileId(n31.fileId), null != n31.contents && this.setContents(n31.contents), null != n31.maxChunks && this.setMaxChunks(n31.maxChunks), null != n31.chunkSize && this.setChunkSize(n31.chunkSize), null != n31.chunkInterval && this.setChunkInterval(n31.chunkInterval), this._transactionIds = new t7();
  }
  static _fromProtobuf(t35, s26, e39, r41, a23) {
    var _a2;
    const h8 = a23[0].fileAppend;
    let o32;
    const u22 = r41.length > 0 ? r41.length : 1;
    for (let t36 = 0; t36 < a23.length; t36 += u22) {
      const n31 = a23[t36].fileAppend;
      if (null == n31.contents) break;
      if (null == o32) {
        o32 = new Uint8Array(n31.contents);
        continue;
      }
      const s27 = new Uint8Array(o32.length + n31.contents.length);
      s27.set(o32, 0), s27.set(n31.contents, o32.length), o32 = s27;
    }
    const l19 = ((_a2 = h8.contents) == null ? void 0 : _a2.length) || void 0, d18 = a23.length ? a23.length / u22 : void 0;
    let _4;
    if (e39.length > 1) {
      const t36 = e39[0].validStart, n31 = e39[1].validStart;
      t36 && n31 && (_4 = n31.nanos.sub(t36.nanos).toNumber());
    }
    return P._fromProtobufTransactions(new _c({ fileId: null != h8.fileID ? c3._fromProtobuf(h8.fileID) : void 0, contents: o32, chunkSize: l19, maxChunks: d18, chunkInterval: _4 }), t35, s26, e39, r41, a23);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(t35) {
    return this._requireNotFrozen(), this._fileId = "string" == typeof t35 ? c3.fromString(t35) : t35.clone(), this;
  }
  getRequiredChunks() {
    if (null == this._contents) return 1;
    return Math.ceil(this._contents.length / this._chunkSize);
  }
  get contents() {
    return this._contents;
  }
  setContents(t35) {
    return this._requireNotFrozen(), this._contents = t35 instanceof Uint8Array ? t35 : n8(t35), this;
  }
  get maxChunks() {
    return this._maxChunks;
  }
  setMaxChunks(t35) {
    if (t35 <= 0) throw new Error("Max chunks must be greater than 0");
    return this._requireNotFrozen(), this._maxChunks = t35, this;
  }
  get chunkSize() {
    return this._chunkSize;
  }
  setChunkSize(t35) {
    if (t35 <= 0) throw new Error("Chunk size must be greater than 0");
    return this._chunkSize = t35, this;
  }
  get chunkInterval() {
    return this._chunkInterval;
  }
  setChunkInterval(t35) {
    return this._chunkInterval = t35, this;
  }
  freezeWith(t35) {
    if (super.freezeWith(t35), null == this._contents) return this;
    let n31 = this._getTransactionId();
    this._transactionIds.locked = false, this._transactions.clear(), this._transactionIds.clear(), this._signedTransactions.clear();
    for (let t36 = 0; t36 < this.getRequiredChunks(); t36++) {
      this._transactionIds.push(n31), this._transactionIds.advance();
      for (const t37 of this._nodeAccountIds.list) this._signedTransactions.push(this._makeSignedTransaction(t37));
      n31 = new i4(n31.accountId, new s3(n31.validStart.seconds, n31.validStart.nanos.add(this._chunkInterval)));
    }
    return this._transactionIds.advance(), this._transactionIds.setLocked(), this;
  }
  schedule() {
    if (this._requireNotFrozen(), null != this._contents && this._contents.length > this._chunkSize) throw new Error(`cannot schedule \`FileAppendTransaction\` with message over ${this._chunkSize} bytes`);
    return super.schedule();
  }
  async execute(t35, n31) {
    return (await this.executeAll(t35, n31))[0];
  }
  async executeAll(t35, n31) {
    if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) throw new Error(`cannot execute \`FileAppendTransaction\` with more than ${this.maxChunks} chunks`);
    super._isFrozen() || this.freezeWith(t35);
    const s26 = this._getTransactionId(), e39 = t35.operatorAccountId;
    null != e39 && e39.equals(s26.accountId) && await super.signWithOperator(t35);
    const i17 = [];
    let r41 = n31;
    for (let n32 = 0; n32 < this._transactionIds.length; n32++) {
      const n33 = Date.now(), s27 = await super.execute(t35, r41);
      null != r41 && (r41 = Date.now() - n33), await s27.getReceipt(t35), i17.push(s27);
    }
    return i17;
  }
  _validateChecksums(t35) {
    null != this._fileId && this._fileId.validateChecksum(t35);
  }
  _execute(t35, n31) {
    return t35.file.appendContent(n31);
  }
  _getTransactionDataCase() {
    return "fileAppend";
  }
  _buildIncompleteTransactions() {
    var _a2, _b;
    const t35 = y3.fromString("0.0.0"), n31 = ((_a2 = this.transactionId) == null ? void 0 : _a2.accountId) || t35, s26 = ((_b = this.transactionId) == null ? void 0 : _b.validStart) || s3.fromDate(/* @__PURE__ */ new Date());
    if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) throw new Error(`cannot build \`FileAppendTransaction\` with more than ${this.maxChunks} chunks`);
    this._transactionIds.locked = false, this._transactions.clear(), this._transactionIds.clear(), this._signedTransactions.clear();
    for (let t36 = 0; t36 < this.getRequiredChunks(); t36++) {
      let e39 = i4.withValidStart(n31, s26.plusNanos(this._chunkInterval * t36));
      if (this._transactionIds.push(e39), this._transactionIds.advance(), 0 === this._nodeAccountIds.list.length) this._transactions.push(this._makeSignedTransaction(null));
      else for (const t37 of this._nodeAccountIds.list) this._transactions.push(this._makeSignedTransaction(t37));
    }
    this._transactionIds.advance(), this._transactionIds.setLocked();
  }
  _buildAllTransactions() {
    if (this.maxChunks && this.getRequiredChunks() > this.maxChunks) throw new Error(`cannot build \`FileAppendTransaction\` with more than ${this.maxChunks} chunks`);
    for (let t35 = 0; t35 < this._signedTransactions.length; t35++) this._buildTransaction(t35);
  }
  _getLogId() {
    return `FileAppendTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
  _makeTransactionData() {
    const t35 = null != this._contents ? this._contents.length : 0, n31 = this._transactionIds.index * this._chunkSize, s26 = Math.min(n31 + this._chunkSize, t35);
    return { fileID: null != this._fileId ? this._fileId._toProtobuf() : null, contents: null != this._contents ? this._contents.slice(n31, s26) : null };
  }
};
B.set("fileAppend", c11._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/file/FileDeleteTransaction.js
var r17 = class _r extends P {
  constructor(e39 = {}) {
    super(), this._fileId = null, null != e39.fileId && this.setFileId(e39.fileId);
  }
  static _fromProtobuf(t35, l19, o32, s26, n31) {
    const f4 = n31[0].fileDelete;
    return P._fromProtobufTransactions(new _r({ fileId: null != f4.fileID ? c3._fromProtobuf(f4.fileID) : void 0 }), t35, l19, o32, s26, n31);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(e39) {
    return this._requireNotFrozen(), this._fileId = "string" == typeof e39 ? c3.fromString(e39) : e39.clone(), this;
  }
  _validateChecksums(e39) {
    null != this._fileId && this._fileId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.file.deleteFile(t35);
  }
  _getTransactionDataCase() {
    return "fileDelete";
  }
  _makeTransactionData() {
    return { fileID: null != this._fileId ? this._fileId._toProtobuf() : null };
  }
  _getLogId() {
    return `FileDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("fileDelete", r17._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/contract/ContractCreateTransaction.js
var d10 = class _d extends P {
  constructor(e39 = {}) {
    super(), this._bytecodeFileId = null, this._bytecode = null, this._adminKey = null, this._gas = null, this._initialBalance = null, this._proxyAccountId = null, this._autoRenewPeriod = new s9(w3), this._constructorParameters = null, this._contractMemo = null, this._maxAutomaticTokenAssociations = null, this._defaultMaxTransactionFee = new e4(20), this._stakedAccountId = null, this._stakedNodeId = null, this._declineStakingReward = false, this._autoRenewAccountId = null, null != e39.bytecodeFileId && this.setBytecodeFileId(e39.bytecodeFileId), null != e39.bytecode && this.setBytecode(e39.bytecode), null != e39.adminKey && this.setAdminKey(e39.adminKey), null != e39.gas && this.setGas(e39.gas), null != e39.initialBalance && this.setInitialBalance(e39.initialBalance), null != e39.proxyAccountId && this.setProxyAccountId(e39.proxyAccountId), null != e39.autoRenewPeriod && this.setAutoRenewPeriod(e39.autoRenewPeriod), null != e39.constructorParameters && this.setConstructorParameters(e39.constructorParameters), null != e39.contractMemo && this.setContractMemo(e39.contractMemo), null != e39.maxAutomaticTokenAssociations && this.setMaxAutomaticTokenAssociations(e39.maxAutomaticTokenAssociations), null != e39.stakedAccountId && this.setStakedAccountId(e39.stakedAccountId), null != e39.stakedNodeId && this.setStakedNodeId(e39.stakedNodeId), null != e39.declineStakingReward && this.setDeclineStakingReward(e39.declineStakingReward), null != e39.autoRenewAccountId && this.setAutoRenewAccountId(e39.autoRenewAccountId);
  }
  static _fromProtobuf(n31, r41, s26, a23, c17) {
    const l19 = c17[0].contractCreateInstance;
    return P._fromProtobufTransactions(new _d({ bytecodeFileId: null != l19.fileID ? c3._fromProtobuf(l19.fileID) : void 0, adminKey: null != l19.adminKey ? t2._fromProtobufKey(l19.adminKey) : void 0, gas: null != l19.gas ? l19.gas : void 0, initialBalance: null != l19.initialBalance ? e4.fromTinybars(l19.initialBalance) : void 0, proxyAccountId: null != l19.proxyAccountID ? y3._fromProtobuf(l19.proxyAccountID) : void 0, autoRenewPeriod: null != l19.autoRenewPeriod && null != l19.autoRenewPeriod.seconds ? l19.autoRenewPeriod.seconds : void 0, constructorParameters: null != l19.constructorParameters ? l19.constructorParameters : void 0, contractMemo: null != l19.memo ? l19.memo : void 0, maxAutomaticTokenAssociations: null != l19.maxAutomaticTokenAssociations ? l19.maxAutomaticTokenAssociations : void 0, stakedAccountId: null != l19.stakedAccountId ? y3._fromProtobuf(l19.stakedAccountId) : void 0, stakedNodeId: null != l19.stakedNodeId ? l19.stakedNodeId : void 0, declineStakingReward: 1 == l19.declineReward, autoRenewAccountId: null != l19.autoRenewAccountId ? y3._fromProtobuf(l19.autoRenewAccountId) : void 0 }), n31, r41, s26, a23, c17);
  }
  get bytecodeFileId() {
    return this._bytecodeFileId;
  }
  setBytecodeFileId(t35) {
    return this._requireNotFrozen(), this._bytecodeFileId = "string" == typeof t35 ? c3.fromString(t35) : t35.clone(), this._bytecode = null, this;
  }
  get bytecode() {
    return this._bytecode;
  }
  setBytecode(t35) {
    return this._requireNotFrozen(), this._bytecode = t35, this._bytecodeFileId = null, this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(t35) {
    return this._requireNotFrozen(), this._adminKey = t35, this;
  }
  get gas() {
    return this._gas;
  }
  setGas(t35) {
    if (this._requireNotFrozen(), this._gas = t35 instanceof long_default ? t35 : long_default.fromValue(t35), this._gas.lessThan(0)) throw new Error("Gas cannot be negative number");
    return this;
  }
  get initialBalance() {
    return this._initialBalance;
  }
  setInitialBalance(e39) {
    return this._requireNotFrozen(), this._initialBalance = e39 instanceof e4 ? e39 : new e4(e39), this;
  }
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  setProxyAccountId(t35) {
    return this._requireNotFrozen(), this._proxyAccountId = t35 instanceof y3 ? t35 : y3.fromString(t35), this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(t35) {
    return this._requireNotFrozen(), this._autoRenewPeriod = t35 instanceof s9 ? t35 : new s9(t35), this;
  }
  get constructorParameters() {
    return this._constructorParameters;
  }
  setConstructorParameters(t35) {
    return this._requireNotFrozen(), this._constructorParameters = t35 instanceof _2 ? t35._build() : t35, this;
  }
  get contractMemo() {
    return this._contractMemo;
  }
  setContractMemo(t35) {
    return this._requireNotFrozen(), this._contractMemo = t35, this;
  }
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  setMaxAutomaticTokenAssociations(t35) {
    return this._maxAutomaticTokenAssociations = t35, this;
  }
  get stakedAccountId() {
    return this._stakedAccountId;
  }
  setStakedAccountId(t35) {
    return this._requireNotFrozen(), this._stakedAccountId = "string" == typeof t35 ? y3.fromString(t35) : t35, this._stakedNodeId = null, this;
  }
  get stakedNodeId() {
    return this._stakedNodeId;
  }
  setStakedNodeId(t35) {
    return this._requireNotFrozen(), this._stakedNodeId = long_default.fromValue(t35), this._stakedAccountId = null, this;
  }
  get declineStakingRewards() {
    return this._declineStakingReward;
  }
  setDeclineStakingReward(t35) {
    return this._requireNotFrozen(), this._declineStakingReward = t35, this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(t35) {
    return this._requireNotFrozen(), this._autoRenewAccountId = "string" == typeof t35 ? y3.fromString(t35) : t35, this;
  }
  _validateChecksums(t35) {
    null != this._bytecodeFileId && this._bytecodeFileId.validateChecksum(t35), null != this._proxyAccountId && this._proxyAccountId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.smartContract.createContract(e39);
  }
  _getTransactionDataCase() {
    return "contractCreateInstance";
  }
  _makeTransactionData() {
    return { fileID: null != this._bytecodeFileId ? this._bytecodeFileId._toProtobuf() : null, initcode: this._bytecode, adminKey: null != this._adminKey ? this._adminKey._toProtobufKey() : null, gas: this._gas, initialBalance: null != this._initialBalance ? this._initialBalance.toTinybars() : null, proxyAccountID: null != this._proxyAccountId ? this._proxyAccountId._toProtobuf() : null, autoRenewPeriod: this._autoRenewPeriod._toProtobuf(), constructorParameters: this._constructorParameters, memo: this._contractMemo, maxAutomaticTokenAssociations: this._maxAutomaticTokenAssociations, stakedAccountId: null != this.stakedAccountId ? this.stakedAccountId._toProtobuf() : null, stakedNodeId: this.stakedNodeId, declineReward: this.declineStakingRewards, autoRenewAccountId: null != this._autoRenewAccountId ? this._autoRenewAccountId._toProtobuf() : null };
  }
  _getLogId() {
    return `ContractCreateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("contractCreateInstance", d10._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/contract/ContractDeleteTransaction.js
var a9 = class _a2 extends P {
  constructor(t35 = {}) {
    super(), this._contractId = null, this._transferAccountId = null, this._transferContractId = null, this._permanentRemoval = false, null != t35.contractId && this.setContractId(t35.contractId), null != t35.transferAccountId && this.setTransferAccountId(t35.transferAccountId), null != t35.transferContractId && this.setTransferContractId(t35.transferContractId), null != t35.permanentRemoval && this.setPermanentRemoval(t35.permanentRemoval);
  }
  static _fromProtobuf(r41, o32, c17, s26, u22) {
    const i17 = u22[0].contractDeleteInstance;
    return P._fromProtobufTransactions(new _a2({ contractId: null != i17.contractID ? g4._fromProtobuf(i17.contractID) : void 0, transferAccountId: null != i17.transferAccountID ? y3._fromProtobuf(i17.transferAccountID) : void 0, transferContractId: null != i17.transferContractID ? g4._fromProtobuf(i17.transferContractID) : void 0, permanentRemoval: i17.permanentRemoval ?? false }), r41, o32, c17, s26, u22);
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(t35) {
    return this._requireNotFrozen(), this._contractId = "string" == typeof t35 ? g4.fromString(t35) : t35.clone(), this;
  }
  get transferContractId() {
    return this._transferContractId;
  }
  setTransferContractId(t35) {
    return this._requireNotFrozen(), this._transferContractId = t35 instanceof g4 ? t35 : g4.fromString(t35), this._transferAccountId = null, this;
  }
  get transferAccountId() {
    return this._transferAccountId;
  }
  setTransferAccountId(t35) {
    return this._requireNotFrozen(), this._transferAccountId = t35 instanceof y3 ? t35 : y3.fromString(t35), this._transferContractId = null, this;
  }
  get permanentRemoval() {
    return this._permanentRemoval;
  }
  setPermanentRemoval(t35) {
    return this._requireNotFrozen(), this._permanentRemoval = t35, this;
  }
  _validateChecksums(t35) {
    null != this._contractId && this._contractId.validateChecksum(t35), null != this._transferAccountId && this._transferAccountId.validateChecksum(t35), null != this._transferContractId && this._transferContractId.validateChecksum(t35);
  }
  _execute(t35, r41) {
    return t35.smartContract.deleteContract(r41);
  }
  _getTransactionDataCase() {
    return "contractDeleteInstance";
  }
  _makeTransactionData() {
    return { contractID: null != this._contractId ? this._contractId._toProtobuf() : null, transferAccountID: this._transferAccountId ? this._transferAccountId._toProtobuf() : null, transferContractID: null != this._transferContractId ? this._transferContractId._toProtobuf() : null, permanentRemoval: this._permanentRemoval };
  }
  _getLogId() {
    return `ContractDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("contractDeleteInstance", a9._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/contract/ContractExecuteTransaction.js
var i8 = class _i extends P {
  constructor(t35 = {}) {
    super(), this._contractId = null, this._gas = null, this._amount = null, this._functionParameters = null, null != t35.contractId && this.setContractId(t35.contractId), null != t35.gas && this.setGas(t35.gas), null != t35.amount && this.setPayableAmount(t35.amount), null != t35.functionParameters ? this.setFunctionParameters(t35.functionParameters) : null != t35.function && this.setFunction(t35.function.name, t35.function.parameters);
  }
  static _fromProtobuf(r41, o32, s26, e39, u22) {
    const c17 = u22[0].contractCall;
    return P._fromProtobufTransactions(new _i({ contractId: null != c17.contractID ? g4._fromProtobuf(c17.contractID) : void 0, gas: null != c17.gas ? c17.gas : void 0, amount: null != c17.amount ? e4.fromTinybars(c17.amount) : void 0, functionParameters: null != c17.functionParameters ? c17.functionParameters : void 0 }), r41, o32, s26, e39, u22);
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(t35) {
    return this._requireNotFrozen(), this._contractId = "string" == typeof t35 ? g4.fromString(t35) : t35.clone(), this;
  }
  get gas() {
    return this._gas;
  }
  setGas(t35) {
    return this._requireNotFrozen(), this._gas = t35 instanceof long_default ? t35 : long_default.fromValue(t35), this;
  }
  get payableAmount() {
    return this._amount;
  }
  setPayableAmount(n31, r41 = e3.Hbar) {
    return this._requireNotFrozen(), this._amount = n31 instanceof e4 ? n31 : e4.from(n31, r41), this;
  }
  get functionParameters() {
    return this._functionParameters;
  }
  setFunctionParameters(t35) {
    return this._requireNotFrozen(), this._functionParameters = t35, this;
  }
  setFunction(t35, n31) {
    return this._requireNotFrozen(), this._functionParameters = null != n31 ? n31._build(t35) : new _2()._build(t35), this;
  }
  _validateChecksums(t35) {
    null != this._contractId && this._contractId.validateChecksum(t35);
  }
  _execute(t35, n31) {
    return t35.smartContract.contractCallMethod(n31);
  }
  _getTransactionDataCase() {
    return "contractCall";
  }
  _makeTransactionData() {
    return { contractID: null != this._contractId ? this._contractId._toProtobuf() : null, gas: this._gas, amount: null != this._amount ? this._amount.toTinybars() : null, functionParameters: this._functionParameters };
  }
  _getLogId() {
    return `ContractExecuteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("contractCall", i8._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/contract/ContractInfo.js
var r18 = __toESM(require_lib(), 1);
var { proto: m5 } = r18;
var d11 = class _d {
  constructor(t35) {
    this.contractId = t35.contractId, this.accountId = t35.accountId, this.contractAccountId = t35.contractAccountId, this.adminKey = null != t35.adminKey ? t35.adminKey : null, this.expirationTime = t35.expirationTime, this.autoRenewPeriod = t35.autoRenewPeriod, this.autoRenewAccountId = t35.autoRenewAccountId, this.storage = t35.storage, this.contractMemo = t35.contractMemo, this.balance = t35.balance, this.isDeleted = t35.isDeleted, this.tokenRelationships = t35.tokenRelationships, this.maxAutomaticTokenAssociations = t35.maxAutomaticTokenAssociations, this.ledgerId = t35.ledgerId, this.stakingInfo = t35.stakingInfo, Object.freeze(this);
  }
  static _fromProtobuf(r41) {
    const m6 = r41.autoRenewPeriod.seconds;
    return new _d({ contractId: g4._fromProtobuf(r41.contractID), accountId: y3._fromProtobuf(r41.accountID), contractAccountId: null != r41.contractAccountID ? r41.contractAccountID : "", adminKey: null != r41.adminKey ? t2._fromProtobufKey(r41.adminKey) : null, expirationTime: s3._fromProtobuf(r41.expirationTime), autoRenewPeriod: new s9(m6), autoRenewAccountId: null != r41.autoRenewAccountId ? y3._fromProtobuf(r41.autoRenewAccountId) : null, storage: null != r41.storage ? r41.storage instanceof long_default ? r41.storage : long_default.fromValue(r41.storage) : long_default.ZERO, contractMemo: null != r41.memo ? r41.memo : "", balance: e4.fromTinybars(null != r41.balance ? r41.balance : 0), isDeleted: r41.deleted, tokenRelationships: s12._fromProtobuf(null != r41.tokenRelationships ? r41.tokenRelationships : []), ledgerId: null != r41.ledgerId ? r15.fromBytes(r41.ledgerId) : null, stakingInfo: null != r41.stakingInfo ? n15._fromProtobuf(r41.stakingInfo) : null, maxAutomaticTokenAssociations: null != r41.maxAutomaticTokenAssociations ? long_default.isLong(r41.maxAutomaticTokenAssociations) ? r41.maxAutomaticTokenAssociations : long_default.fromValue(r41.maxAutomaticTokenAssociations) : long_default.ZERO });
  }
  _toProtobuf() {
    return { contractID: this.contractId._toProtobuf(), accountID: this.accountId._toProtobuf(), contractAccountID: this.contractAccountId, adminKey: null != this.adminKey ? this.adminKey._toProtobufKey() : null, expirationTime: this.expirationTime._toProtobuf(), autoRenewPeriod: null != this.autoRenewPeriod ? this.autoRenewPeriod._toProtobuf() : null, autoRenewAccountId: null != this.autoRenewAccountId ? this.autoRenewAccountId._toProtobuf() : null, storage: this.storage, memo: this.contractMemo, balance: this.balance.toTinybars(), deleted: this.isDeleted, tokenRelationships: null != this.tokenRelationships ? this.tokenRelationships._toProtobuf() : null, ledgerId: null != this.ledgerId ? this.ledgerId.toBytes() : null, stakingInfo: null != this.stakingInfo ? this.stakingInfo._toProtobuf() : null, maxAutomaticTokenAssociations: this.maxAutomaticTokenAssociations.toNumber() };
  }
  static fromBytes(t35) {
    return _d._fromProtobuf(m5.ContractGetInfoResponse.ContractInfo.decode(t35));
  }
  toBytes() {
    return m5.ContractGetInfoResponse.ContractInfo.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/contract/ContractInfoQuery.js
var e17 = class _e extends h3 {
  constructor(t35 = {}) {
    super(), this._contractId = null, null != t35.contractId && this.setContractId(t35.contractId);
  }
  static _fromProtobuf(t35) {
    const r41 = t35.contractGetInfo;
    return new _e({ contractId: null != r41.contractID ? g4._fromProtobuf(r41.contractID) : void 0 });
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(t35) {
    return this._contractId = "string" == typeof t35 ? g4.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._contractId && this._contractId.validateChecksum(t35);
  }
  _execute(t35, r41) {
    return t35.smartContract.getContractInfo(r41);
  }
  async getCost(t35) {
    return super.getCost(t35);
  }
  _mapResponseHeader(t35) {
    return t35.contractGetInfo.header;
  }
  _mapResponse(t35, r41, o32) {
    const e39 = t35.contractGetInfo;
    return Promise.resolve(d11._fromProtobuf(e39.contractInfo));
  }
  _onMakeRequest(t35) {
    return { contractGetInfo: { header: t35, contractID: null != this._contractId ? this._contractId._toProtobuf() : null } };
  }
  _getLogId() {
    return `ContractInfoQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("contractGetInfo", e17._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/contract/ContractUpdateTransaction.js
var u13 = __toESM(require_lib(), 1);
var d12 = class _d extends P {
  constructor(t35 = {}) {
    super(), this._contractId = null, this._expirationTime = null, this._adminKey = null, this._proxyAccountId = null, this._autoRenewPeriod = null, this._bytecodeFileId = null, this._contractMemo = null, this._maxAutomaticTokenAssociations = null, this._stakedAccountId = null, this._stakedNodeId = null, this._declineStakingReward = null, this._autoRenewAccountId = null, null != t35.contractId && this.setContractId(t35.contractId), null != t35.expirationTime && this.setExpirationTime(t35.expirationTime), null != t35.adminKey && this.setAdminKey(t35.adminKey), null != t35.proxyAccountId && this.setProxyAccountId(t35.proxyAccountId), null != t35.autoRenewPeriod && this.setAutoRenewPeriod(t35.autoRenewPeriod), null != t35.bytecodeFileId && this.setBytecodeFileId(t35.bytecodeFileId), null != t35.contractMemo && this.setContractMemo(t35.contractMemo), null != t35.maxAutomaticTokenAssociations && this.setMaxAutomaticTokenAssociations(t35.maxAutomaticTokenAssociations), null != t35.stakedAccountId && this.setStakedAccountId(t35.stakedAccountId), null != t35.stakedNodeId && this.setStakedNodeId(t35.stakedNodeId), null != t35.declineStakingReward && this.setDeclineStakingReward(t35.declineStakingReward), null != t35.autoRenewAccountId && this.setAutoRenewAccountId(t35.autoRenewAccountId);
  }
  static _fromProtobuf(i17, r41, s26, u22, l19) {
    const m6 = l19[0].contractUpdateInstance;
    let h8, I3, _4;
    return null != m6.autoRenewPeriod && null != m6.autoRenewPeriod.seconds && (h8 = m6.autoRenewPeriod.seconds), null != m6.memoWrapper && Object.hasOwn(m6.memoWrapper, "value") && null != m6.memoWrapper.value && (I3 = m6.memoWrapper.value), null != m6.maxAutomaticTokenAssociations && null != m6.maxAutomaticTokenAssociations.value && (_4 = m6.maxAutomaticTokenAssociations.value), P._fromProtobufTransactions(new _d({ contractId: null != m6.contractID ? g4._fromProtobuf(m6.contractID) : void 0, bytecodeFileId: null != m6.fileID ? c3._fromProtobuf(m6.fileID) : void 0, expirationTime: null != m6.expirationTime ? s3._fromProtobuf(m6.expirationTime) : void 0, adminKey: null != m6.adminKey ? t2._fromProtobufKey(m6.adminKey) : void 0, proxyAccountId: null != m6.proxyAccountID ? y3._fromProtobuf(m6.proxyAccountID) : void 0, autoRenewPeriod: h8, contractMemo: I3, maxAutomaticTokenAssociations: _4, stakedAccountId: null != m6.stakedAccountId ? y3._fromProtobuf(m6.stakedAccountId) : void 0, stakedNodeId: null != m6.stakedNodeId ? m6.stakedNodeId : void 0, declineStakingReward: null != m6.declineReward && 1 == Boolean(m6.declineReward), autoRenewAccountId: null != m6.autoRenewAccountId ? y3._fromProtobuf(m6.autoRenewAccountId) : void 0 }), i17, r41, s26, u22, l19);
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(t35) {
    return this._requireNotFrozen(), this._contractId = "string" == typeof t35 ? g4.fromString(t35) : t35.clone(), this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(t35) {
    return this._requireNotFrozen(), this._expirationTime = t35 instanceof s3 ? t35 : s3.fromDate(t35), this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(t35) {
    return this._requireNotFrozen(), this._adminKey = t35, this;
  }
  get proxyAccountId() {
    return this._proxyAccountId;
  }
  setProxyAccountId(e39) {
    return this._requireNotFrozen(), this._proxyAccountId = "string" == typeof e39 ? y3.fromString(e39) : e39.clone(), this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(t35) {
    return this._requireNotFrozen(), this._autoRenewPeriod = t35 instanceof s9 ? t35 : new s9(t35), this;
  }
  get bytecodeFileId() {
    return this._bytecodeFileId;
  }
  setBytecodeFileId(t35) {
    return console.warn("Deprecated: there is no replacement"), this._requireNotFrozen(), this._bytecodeFileId = "string" == typeof t35 ? c3.fromString(t35) : t35.clone(), this;
  }
  get contractMemo() {
    return this._contractMemo;
  }
  setContractMemo(t35) {
    return this._requireNotFrozen(), this._contractMemo = t35, this;
  }
  clearContractMemo() {
    return this._requireNotFrozen(), this._contractMemo = null, this;
  }
  get maxAutomaticTokenAssociations() {
    return this._maxAutomaticTokenAssociations;
  }
  setMaxAutomaticTokenAssociations(t35) {
    return this._requireNotFrozen(), this._maxAutomaticTokenAssociations = t35, this;
  }
  get stakedAccountId() {
    return this._stakedAccountId;
  }
  setStakedAccountId(e39) {
    return this._requireNotFrozen(), this._stakedAccountId = "string" == typeof e39 ? y3.fromString(e39) : e39, this;
  }
  get stakedNodeId() {
    return this._stakedNodeId;
  }
  setStakedNodeId(t35) {
    return this._requireNotFrozen(), this._stakedNodeId = long_default.fromValue(t35), this;
  }
  get declineStakingRewards() {
    return this._declineStakingReward;
  }
  setDeclineStakingReward(t35) {
    return this._requireNotFrozen(), this._declineStakingReward = t35, this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(e39) {
    return this._requireNotFrozen(), this._autoRenewAccountId = "string" == typeof e39 ? y3.fromString(e39) : e39, this;
  }
  clearAutoRenewAccountId() {
    return this._autoRenewAccountId = new y3(0), this;
  }
  _validateChecksums(t35) {
    null != this._contractId && this._contractId.validateChecksum(t35), null != this._bytecodeFileId && this._bytecodeFileId.validateChecksum(t35), null != this._proxyAccountId && this._proxyAccountId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.smartContract.updateContract(e39);
  }
  _getTransactionDataCase() {
    return "contractUpdateInstance";
  }
  _makeTransactionData() {
    return { contractID: null != this._contractId ? this._contractId._toProtobuf() : null, expirationTime: null != this._expirationTime ? this._expirationTime._toProtobuf() : null, adminKey: null != this._adminKey ? this._adminKey._toProtobufKey() : null, proxyAccountID: null != this._proxyAccountId ? this._proxyAccountId._toProtobuf() : null, autoRenewPeriod: null != this._autoRenewPeriod ? this._autoRenewPeriod._toProtobuf() : null, fileID: this._bytecodeFileId ? this._bytecodeFileId._toProtobuf() : null, memoWrapper: null != this._contractMemo ? { value: this._contractMemo } : null, maxAutomaticTokenAssociations: null != this._maxAutomaticTokenAssociations ? { value: this._maxAutomaticTokenAssociations } : null, stakedAccountId: null != this.stakedAccountId ? this.stakedAccountId._toProtobuf() : null, stakedNodeId: this.stakedNodeId, declineReward: null != this.declineStakingRewards ? { value: this.declineStakingRewards } : null, autoRenewAccountId: null != this._autoRenewAccountId ? "0.0.0" == this._autoRenewAccountId.toString() ? u13.proto.AccountID.create() : this._autoRenewAccountId._toProtobuf() : null };
  }
  _getLogId() {
    return `ContractUpdateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("contractUpdateInstance", d12._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/FeeAssessmentMethod.js
var e18 = class _e {
  constructor(e39) {
    this._value = e39, Object.freeze(this);
  }
  toString() {
    switch (this) {
      case _e.Inclusive:
        return "INCLUSIVE";
      case _e.Exclusive:
        return "EXCLUSIVE";
      default:
        return `UNKNOWN (${this._value.toString()})`;
    }
  }
  static _fromValue(t35) {
    switch (t35) {
      case false:
        return _e.Inclusive;
      case true:
        return _e.Exclusive;
    }
  }
  valueOf() {
    return this._value;
  }
};
e18.Inclusive = new e18(false), e18.Exclusive = new e18(true);

// node_modules/@hashgraph/sdk/lib/contract/DelegateContractId.js
var o17 = class _o extends g4 {
  constructor(t35, r41, o32, e39) {
    super(t35, r41, o32, e39);
  }
  static fromString(t35) {
    return new _o(g4.fromString(t35));
  }
  static _fromProtobuf(t35) {
    return new _o(g4._fromProtobuf(t35));
  }
  static fromBytes(t35) {
    return new _o(g4.fromBytes(t35));
  }
  static fromSolidityAddress(t35) {
    return new _o(g4.fromSolidityAddress(t35));
  }
  clone() {
    const t35 = new _o(this);
    return t35._checksum = this._checksum, t35;
  }
  _toProtobufKey() {
    return { delegatableContractId: this._toProtobuf() };
  }
  static __fromProtobufKey(t35) {
    return _o._fromProtobuf(t35);
  }
};
t.setDelegateContractId(((t35) => o17.__fromProtobufKey(t35)));

// node_modules/@hashgraph/sdk/lib/EthereumTransaction.js
var r19 = class _r extends P {
  constructor(a23 = {}) {
    super(), this._ethereumData = null, this._callDataFileId = null, this._maxGasAllowance = null, null != a23.ethereumData && this.setEthereumData(a23.ethereumData), null != a23.callData && this.setCallDataFileId(a23.callData), null != a23.callDataFileId && this.setCallDataFileId(a23.callDataFileId), null != a23.maxGasAllowance && this.setMaxGasAllowanceHbar(a23.maxGasAllowance);
  }
  static _fromProtobuf(l19, s26, n31, i17, o32) {
    const u22 = o32[0].ethereumTransaction;
    return P._fromProtobufTransactions(new _r({ ethereumData: null != u22.ethereumData ? u22.ethereumData : void 0, callData: null != u22.callData ? c3._fromProtobuf(u22.callData) : void 0, maxGasAllowance: null != u22.maxGasAllowance ? e4.fromTinybars(u22.maxGasAllowance) : void 0 }), l19, s26, n31, i17, o32);
  }
  get ethereumData() {
    return this._ethereumData;
  }
  setEthereumData(a23) {
    return this._requireNotFrozen(), this._ethereumData = a23, this;
  }
  get callData() {
    return this.callDataFileId;
  }
  setCallData(a23) {
    return this.setCallDataFileId(a23);
  }
  get callDataFileId() {
    return this._callDataFileId;
  }
  setCallDataFileId(a23) {
    return this._requireNotFrozen(), this._callDataFileId = a23, this;
  }
  get maxGasAllowance() {
    return this._maxGasAllowance;
  }
  setMaxGasAllowance(a23) {
    return this.setMaxGasAllowanceHbar(a23);
  }
  setMaxGasAllowanceHbar(t35) {
    return this._requireNotFrozen(), this._maxGasAllowance = t35 instanceof e4 ? t35 : new e4(t35), this;
  }
  _validateChecksums(a23) {
    null != this._ethereumData && this._ethereumData instanceof c3 && this._ethereumData.validateChecksum(a23);
  }
  _execute(a23, t35) {
    return a23.smartContract.callEthereum(t35);
  }
  _getTransactionDataCase() {
    return "ethereumTransaction";
  }
  _makeTransactionData() {
    return { ethereumData: this._ethereumData, callData: null != this._callDataFileId ? this._callDataFileId._toProtobuf() : null, maxGasAllowance: null != this._maxGasAllowance ? this._maxGasAllowance.toTinybars() : null };
  }
  _getLogId() {
    return `EthereumTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("ethereumTransaction", r19._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/EthereumTransactionData.js
var e19 = class {
  constructor(t35) {
    this.callData = t35.callData;
  }
  static fromBytes(e39) {
    if (0 === e39.length) throw new Error("empty bytes");
    switch (e39[0]) {
      case 1:
        return t.ethereumTransactionDataEip2930FromBytes(e39);
      case 2:
        return t.ethereumTransactionDataEip1559FromBytes(e39);
      default:
        return t.ethereumTransactionDataLegacyFromBytes(e39);
    }
  }
  toBytes() {
    throw new Error("not implemented");
  }
  toString() {
    throw new Error("not implemented");
  }
  toJSON() {
    throw new Error("not implemented");
  }
};

// node_modules/@hashgraph/sdk/lib/EthereumTransactionDataLegacy.js
var a10 = class _a2 extends e19 {
  constructor(t35) {
    super(t35), this.nonce = t35.nonce, this.gasPrice = t35.gasPrice, this.gasLimit = t35.gasLimit, this.to = t35.to, this.value = t35.value, this.v = t35.v, this.r = t35.r, this.s = t35.s;
  }
  static fromBytes(i17) {
    if (0 === i17.length) throw new Error("empty bytes");
    const e39 = decode5(i17);
    if (9 != e39.length) throw new Error("invalid ethereum transaction data");
    return new _a2({ nonce: r(e39[0]), gasPrice: r(e39[1]), gasLimit: r(e39[2]), to: r(e39[3]), value: r(e39[4]), callData: r(e39[5]), v: r(e39[6]), r: r(e39[7]), s: r(e39[8]) });
  }
  toBytes() {
    return r(encode3([this.nonce, this.gasPrice, this.gasLimit, this.to, this.value, this.callData, this.v, this.r, this.s]));
  }
  toString() {
    return JSON.stringify(this.toJSON(), null, 2);
  }
  toJSON() {
    return { nonce: n(this.nonce), gasPrice: n(this.gasPrice), gasLimit: n(this.gasLimit), to: n(this.to), value: n(this.value), callData: n(this.callData), v: n(this.v), r: n(this.r), s: n(this.s) };
  }
};
t.setEthereumTransactionDataLegacyFromBytes(((t35) => a10.fromBytes(t35)));

// node_modules/@hashgraph/sdk/lib/EthereumTransactionDataEip1559.js
var e20 = class _e extends e19 {
  constructor(t35) {
    super(t35), this.chainId = t35.chainId, this.nonce = t35.nonce, this.maxPriorityGas = t35.maxPriorityGas, this.maxGas = t35.maxGas, this.gasLimit = t35.gasLimit, this.to = t35.to, this.value = t35.value, this.accessList = t35.accessList, this.recId = t35.recId, this.r = t35.r, this.s = t35.s;
  }
  static fromBytes(i17) {
    if (0 === i17.length) throw new Error("empty bytes");
    const a23 = decode5(i17.subarray(1));
    if (!Array.isArray(a23)) throw new Error("ethereum data is not a list");
    if (12 != a23.length) throw new Error("invalid ethereum transaction data");
    return new _e({ chainId: r(a23[0]), nonce: r(a23[1]), maxPriorityGas: r(a23[2]), maxGas: r(a23[3]), gasLimit: r(a23[4]), to: r(a23[5]), value: r(a23[6]), callData: r(a23[7]), accessList: a23[8].map(((t35) => r(t35))), recId: r(a23[9]), r: r(a23[10]), s: r(a23[11]) });
  }
  toBytes() {
    const i17 = encode3([this.chainId, this.nonce, this.maxPriorityGas, this.maxGas, this.gasLimit, this.to, this.value, this.callData, this.accessList, this.recId, this.r, this.s]);
    return r("02" + i17.substring(2));
  }
  toString() {
    return JSON.stringify(this.toJSON(), null, 2);
  }
  toJSON() {
    return { chainId: n(this.chainId), nonce: n(this.nonce), maxPriorityGas: n(this.maxPriorityGas), maxGas: n(this.maxGas), gasLimit: n(this.gasLimit), to: n(this.to), value: n(this.value), callData: n(this.callData), accessList: this.accessList.map(((t35) => n(t35))), recId: n(this.recId), r: n(this.r), s: n(this.s) };
  }
};
t.setEthereumTransactionDataEip1559FromBytes(((t35) => e20.fromBytes(t35)));

// node_modules/@hashgraph/sdk/lib/EthereumTransactionDataEip2930.js
var a11 = class _a2 extends e19 {
  constructor(t35) {
    super(t35), this.chainId = t35.chainId, this.nonce = t35.nonce, this.gasPrice = t35.gasPrice, this.gasLimit = t35.gasLimit, this.to = t35.to, this.value = t35.value, this.accessList = t35.accessList, this.recId = t35.recId, this.r = t35.r, this.s = t35.s;
  }
  static fromBytes(i17) {
    if (0 === i17.length) throw new Error("empty bytes");
    const e39 = decode5(i17.subarray(1));
    if (!Array.isArray(e39)) throw new Error("ethereum data is not a list");
    if (11 !== e39.length) throw new Error("invalid ethereum transaction data");
    return new _a2({ chainId: r(e39[0]), nonce: r(e39[1]), gasPrice: r(e39[2]), gasLimit: r(e39[3]), to: r(e39[4]), value: r(e39[5]), callData: r(e39[6]), accessList: e39[7].map(((t35) => r(t35))), recId: r(e39[8]), r: r(e39[9]), s: r(e39[10]) });
  }
  toBytes() {
    const i17 = encode3([this.chainId, this.nonce, this.gasPrice, this.gasLimit, this.to, this.value, this.callData, this.accessList, this.recId, this.r, this.s]);
    return r("01" + i17.substring(2));
  }
  toString() {
    return JSON.stringify(this.toJSON(), null, 2);
  }
  toJSON() {
    return { chainId: n(this.chainId), nonce: n(this.nonce), gasPrice: n(this.gasPrice), gasLimit: n(this.gasLimit), to: n(this.to), value: n(this.value), callData: n(this.callData), accessList: this.accessList.map(((t35) => n(t35))), recId: n(this.recId), r: n(this.r), s: n(this.s) };
  }
};
t.setEthereumTransactionDataEip2930FromBytes(((t35) => a11.fromBytes(t35)));

// node_modules/@hashgraph/sdk/lib/FeeDataType.js
var e21 = class _e {
  constructor(e39) {
    this._code = e39, Object.freeze(this);
  }
  toString() {
    switch (this) {
      case _e.Default:
        return "DEFAULT";
      case _e.TokenFungibleCommon:
        return "TOKEN_FUNGIBLE_COMMON";
      case _e.TokenNonFungibleUnique:
        return "TOKEN_NON_FUNGIBLE_UNIQUE";
      case _e.TokenFungibleCommonWithCustomFees:
        return "TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES";
      case _e.TokenNonFungibleUniqueWithCustomFees:
        return "TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES";
      case _e.ScheduleCreateContractCall:
        return "SCHEDULE_CREATE_CONTRACT_CALL";
      case _e.TopicCreateWithCustomFees:
        return "TOPIC_CREATE_WITH_CUSTOM_FEES";
      case _e.SubmitMessageWithCustomFees:
        return "SUBMIT_MESSAGE_WITH_CUSTOM_FEES";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(t35) {
    switch (t35) {
      case 0:
        return _e.Default;
      case 1:
        return _e.TokenFungibleCommon;
      case 2:
        return _e.TokenNonFungibleUnique;
      case 3:
        return _e.TokenFungibleCommonWithCustomFees;
      case 4:
        return _e.TokenNonFungibleUniqueWithCustomFees;
      case 5:
        return _e.ScheduleCreateContractCall;
      case 6:
        return _e.TopicCreateWithCustomFees;
      case 7:
        return _e.SubmitMessageWithCustomFees;
    }
    throw new Error(`(BUG) SubType.fromCode() does not handle code: ${t35}`);
  }
  valueOf() {
    return this._code;
  }
};
e21.Default = new e21(0), e21.TokenFungibleCommon = new e21(1), e21.TokenNonFungibleUnique = new e21(2), e21.TokenFungibleCommonWithCustomFees = new e21(3), e21.TokenNonFungibleUniqueWithCustomFees = new e21(4), e21.ScheduleCreateContractCall = new e21(5), e21.TopicCreateWithCustomFees = new e21(6), e21.SubmitMessageWithCustomFees = new e21(7);

// node_modules/@hashgraph/sdk/lib/RequestType.js
var e22 = class _e {
  constructor(e39) {
    this._code = e39, Object.freeze(this);
  }
  toString() {
    switch (this) {
      case _e.None:
        return "NONE";
      case _e.CryptoTransfer:
        return "CryptoTransfer";
      case _e.CryptoUpdate:
        return "CryptoUpdate";
      case _e.CryptoDelete:
        return "CryptoDelete";
      case _e.CryptoAddLiveHash:
        return "CryptoAddLiveHash";
      case _e.CryptoDeleteLiveHash:
        return "CryptoDeleteLiveHash";
      case _e.ContractCall:
        return "ContractCall";
      case _e.ContractCreate:
        return "ContractCreate";
      case _e.ContractUpdate:
        return "ContractUpdate";
      case _e.FileCreate:
        return "FileCreate";
      case _e.FileAppend:
        return "FileAppend";
      case _e.FileUpdate:
        return "FileUpdate";
      case _e.FileDelete:
        return "FileDelete";
      case _e.CryptoGetAccountBalance:
        return "CryptoGetAccountBalance";
      case _e.CryptoGetAccountRecords:
        return "CryptoGetAccountRecords";
      case _e.CryptoGetInfo:
        return "CryptoGetInfo";
      case _e.ContractCallLocal:
        return "ContractCallLocal";
      case _e.ContractGetInfo:
        return "ContractGetInfo";
      case _e.ContractGetBytecode:
        return "ContractGetBytecode";
      case _e.GetBySolidityID:
        return "GetBySolidityID";
      case _e.GetByKey:
        return "GetByKey";
      case _e.CryptoGetLiveHash:
        return "CryptoGetLiveHash";
      case _e.CryptoGetStakers:
        return "CryptoGetStakers";
      case _e.FileGetContents:
        return "FileGetContents";
      case _e.FileGetInfo:
        return "FileGetInfo";
      case _e.TransactionGetRecord:
        return "TransactionGetRecord";
      case _e.ContractGetRecords:
        return "ContractGetRecords";
      case _e.CryptoCreate:
        return "CryptoCreate";
      case _e.SystemDelete:
        return "SystemDelete";
      case _e.SystemUndelete:
        return "SystemUndelete";
      case _e.ContractDelete:
        return "ContractDelete";
      case _e.Freeze:
        return "Freeze";
      case _e.CreateTransactionRecord:
        return "CreateTransactionRecord";
      case _e.CryptoAccountAutoRenew:
        return "CryptoAccountAutoRenew";
      case _e.ContractAutoRenew:
        return "ContractAutoRenew";
      case _e.GetVersionInfo:
        return "GetVersionInfo";
      case _e.TransactionGetReceipt:
        return "TransactionGetReceipt";
      case _e.ConsensusCreateTopic:
        return "ConsensusCreateTopic";
      case _e.ConsensusUpdateTopic:
        return "ConsensusUpdateTopic";
      case _e.ConsensusDeleteTopic:
        return "ConsensusDeleteTopic";
      case _e.ConsensusGetTopicInfo:
        return "ConsensusGetTopicInfo";
      case _e.ConsensusSubmitMessage:
        return "ConsensusSubmitMessage";
      case _e.UncheckedSubmit:
        return "UncheckedSubmit";
      case _e.TokenCreate:
        return "TokenCreate";
      case _e.TokenGetInfo:
        return "TokenGetInfo";
      case _e.TokenFreezeAccount:
        return "TokenFreezeAccount";
      case _e.TokenUnfreezeAccount:
        return "TokenUnfreezeAccount";
      case _e.TokenGrantKycToAccount:
        return "TokenGrantKycToAccount";
      case _e.TokenRevokeKycFromAccount:
        return "TokenRevokeKycFromAccount";
      case _e.TokenDelete:
        return "TokenDelete";
      case _e.TokenUpdate:
        return "TokenUpdate";
      case _e.TokenMint:
        return "TokenMint";
      case _e.TokenBurn:
        return "TokenBurn";
      case _e.TokenAccountWipe:
        return "TokenAccountWipe";
      case _e.TokenAssociateToAccount:
        return "TokenAssociateToAccount";
      case _e.TokenDissociateFromAccount:
        return "TokenDissociateFromAccount";
      case _e.ScheduleCreate:
        return "ScheduleCreate";
      case _e.ScheduleDelete:
        return "ScheduleDelete";
      case _e.ScheduleSign:
        return "ScheduleSign";
      case _e.ScheduleGetInfo:
        return "ScheduleGetInfo";
      case _e.TokenGetAccountNftInfos:
        return "TokenGetAccountNftInfos";
      case _e.TokenGetNftInfo:
        return "TokenGetNftInfo";
      case _e.TokenGetNftInfos:
        return "TokenGetNftInfos";
      case _e.TokenFeeScheduleUpdate:
        return "TokenFeeScheduleUpdate";
      case _e.NetworkGetExecutionTime:
        return "NetworkGetExecutionTime";
      case _e.TokenPause:
        return "TokenPause";
      case _e.TokenUnpause:
        return "TokenUnpause";
      case _e.CryptoApproveAllowance:
        return "CryptoApproveAllowance";
      case _e.CryptoDeleteAllowance:
        return "CryptoDeleteAllowance";
      case _e.GetAccountDetails:
        return "GetAccountDetails";
      case _e.EthereumTransaction:
        return "EthereumTransaction";
      case _e.NodeStakeUpdate:
        return "NodeStakeUpdate";
      case _e.Prng:
        return "UtilPrng";
      case _e.TransactionGetFastRecord:
        return "TransactionGetFastRecord";
      case _e.TokenUpdateNfts:
        return "TokenUpdateNfts";
      case _e.NodeCreate:
        return "NodeCreate";
      case _e.NodeUpdate:
        return "NodeUpdate";
      case _e.NodeDelete:
        return "NodeDelete";
      case _e.TokenReject:
        return "TokenReject";
      case _e.TokenAirdrop:
        return "TokenAirdrop";
      case _e.TokenCancelAirdrop:
        return "TokenCancelAirdrop";
      case _e.TokenClaimAirdrop:
        return "TokenClaimAirdrop";
      case _e.TssMessage:
        return "TssMessage";
      case _e.TssVote:
        return "TssVote";
      case _e.TssShareSignature:
        return "TssShareSignature";
      case _e.TssEncryptionKey:
        return "TssEncryptionKey";
      case _e.StateSignatureTransaction:
        return "StateSignatureTransaction";
      case _e.HistoryAssemblySignature:
        return "HistoryAssemblySignature";
      case _e.HistoryProofKeyPublication:
        return "HistoryProofKeyPublication";
      case _e.HistoryProofVote:
        return "HistoryProofVote";
      case _e.HintsKeyPublication:
        return "HintsKeyPublication";
      case _e.HintsPreprocessingVote:
        return "HintsPreprocessingVote";
      case _e.HintsPartialSignature:
        return "HintsPartialSignature";
      case _e.CrsPublication:
        return "CrsPublication";
      case _e.AtomicBatch:
        return "AtomicBatch";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(t35) {
    switch (t35) {
      case 0:
        return _e.None;
      case 1:
        return _e.CryptoTransfer;
      case 2:
        return _e.CryptoUpdate;
      case 3:
        return _e.CryptoDelete;
      case 4:
        return _e.CryptoAddLiveHash;
      case 5:
        return _e.CryptoDeleteLiveHash;
      case 6:
        return _e.ContractCall;
      case 7:
        return _e.ContractCreate;
      case 8:
        return _e.ContractUpdate;
      case 9:
        return _e.FileCreate;
      case 10:
        return _e.FileAppend;
      case 11:
        return _e.FileUpdate;
      case 12:
        return _e.FileDelete;
      case 13:
        return _e.CryptoGetAccountBalance;
      case 14:
        return _e.CryptoGetAccountRecords;
      case 15:
        return _e.CryptoGetInfo;
      case 16:
        return _e.ContractCallLocal;
      case 17:
        return _e.ContractGetInfo;
      case 18:
        return _e.ContractGetBytecode;
      case 19:
        return _e.GetBySolidityID;
      case 20:
        return _e.GetByKey;
      case 21:
        return _e.CryptoGetLiveHash;
      case 22:
        return _e.CryptoGetStakers;
      case 23:
        return _e.FileGetContents;
      case 24:
        return _e.FileGetInfo;
      case 25:
        return _e.TransactionGetRecord;
      case 26:
        return _e.ContractGetRecords;
      case 27:
        return _e.CryptoCreate;
      case 28:
        return _e.SystemDelete;
      case 29:
        return _e.SystemUndelete;
      case 30:
        return _e.ContractDelete;
      case 31:
        return _e.Freeze;
      case 32:
        return _e.CreateTransactionRecord;
      case 33:
        return _e.CryptoAccountAutoRenew;
      case 34:
        return _e.ContractAutoRenew;
      case 35:
        return _e.GetVersionInfo;
      case 36:
        return _e.TransactionGetReceipt;
      case 50:
        return _e.ConsensusCreateTopic;
      case 51:
        return _e.ConsensusUpdateTopic;
      case 52:
        return _e.ConsensusDeleteTopic;
      case 53:
        return _e.ConsensusGetTopicInfo;
      case 54:
        return _e.ConsensusSubmitMessage;
      case 55:
        return _e.UncheckedSubmit;
      case 56:
        return _e.TokenCreate;
      case 58:
        return _e.TokenGetInfo;
      case 59:
        return _e.TokenFreezeAccount;
      case 60:
        return _e.TokenUnfreezeAccount;
      case 61:
        return _e.TokenGrantKycToAccount;
      case 62:
        return _e.TokenRevokeKycFromAccount;
      case 63:
        return _e.TokenDelete;
      case 64:
        return _e.TokenUpdate;
      case 65:
        return _e.TokenMint;
      case 66:
        return _e.TokenBurn;
      case 67:
        return _e.TokenAccountWipe;
      case 68:
        return _e.TokenAssociateToAccount;
      case 69:
        return _e.TokenDissociateFromAccount;
      case 70:
        return _e.ScheduleCreate;
      case 71:
        return _e.ScheduleDelete;
      case 72:
        return _e.ScheduleSign;
      case 73:
        return _e.ScheduleGetInfo;
      case 74:
        return _e.TokenGetAccountNftInfos;
      case 75:
        return _e.TokenGetNftInfo;
      case 76:
        return _e.TokenGetNftInfos;
      case 77:
        return _e.TokenFeeScheduleUpdate;
      case 78:
        return _e.NetworkGetExecutionTime;
      case 79:
        return _e.TokenPause;
      case 80:
        return _e.TokenUnpause;
      case 81:
        return _e.CryptoApproveAllowance;
      case 82:
        return _e.CryptoDeleteAllowance;
      case 83:
        return _e.GetAccountDetails;
      case 84:
        return _e.EthereumTransaction;
      case 85:
        return _e.NodeStakeUpdate;
      case 86:
        return _e.Prng;
      case 87:
        return _e.TransactionGetFastRecord;
      case 88:
        return _e.TokenUpdateNfts;
      case 89:
        return _e.NodeCreate;
      case 90:
        return _e.NodeUpdate;
      case 91:
        return _e.NodeDelete;
      case 92:
        return _e.TokenReject;
      case 93:
        return _e.TokenAirdrop;
      case 94:
        return _e.TokenCancelAirdrop;
      case 95:
        return _e.TokenClaimAirdrop;
      case 96:
        return _e.TssMessage;
      case 97:
        return _e.TssVote;
      case 98:
        return _e.TssShareSignature;
      case 99:
        return _e.TssEncryptionKey;
      case 100:
        return _e.StateSignatureTransaction;
      case 101:
        return _e.HintsKeyPublication;
      case 102:
        return _e.HintsPreprocessingVote;
      case 103:
        return _e.HintsPartialSignature;
      case 104:
        return _e.HistoryAssemblySignature;
      case 105:
        return _e.HistoryProofKeyPublication;
      case 106:
        return _e.HistoryProofVote;
      case 107:
        return _e.CrsPublication;
      case 108:
        return _e.AtomicBatch;
    }
    throw new Error(`(BUG) RequestType.fromCode() does not handle code: ${t35}`);
  }
  valueOf() {
    return this._code;
  }
};
e22.None = new e22(0), e22.CryptoTransfer = new e22(1), e22.CryptoUpdate = new e22(2), e22.CryptoDelete = new e22(3), e22.CryptoAddLiveHash = new e22(4), e22.CryptoDeleteLiveHash = new e22(5), e22.ContractCall = new e22(6), e22.ContractCreate = new e22(7), e22.ContractUpdate = new e22(8), e22.FileCreate = new e22(9), e22.FileAppend = new e22(10), e22.FileUpdate = new e22(11), e22.FileDelete = new e22(12), e22.CryptoGetAccountBalance = new e22(13), e22.CryptoGetAccountRecords = new e22(14), e22.CryptoGetInfo = new e22(15), e22.ContractCallLocal = new e22(16), e22.ContractGetInfo = new e22(17), e22.ContractGetBytecode = new e22(18), e22.GetBySolidityID = new e22(19), e22.GetByKey = new e22(20), e22.CryptoGetLiveHash = new e22(21), e22.CryptoGetStakers = new e22(22), e22.FileGetContents = new e22(23), e22.FileGetInfo = new e22(24), e22.TransactionGetRecord = new e22(25), e22.ContractGetRecords = new e22(26), e22.CryptoCreate = new e22(27), e22.SystemDelete = new e22(28), e22.SystemUndelete = new e22(29), e22.ContractDelete = new e22(30), e22.Freeze = new e22(31), e22.CreateTransactionRecord = new e22(32), e22.CryptoAccountAutoRenew = new e22(33), e22.ContractAutoRenew = new e22(34), e22.GetVersionInfo = new e22(35), e22.TransactionGetReceipt = new e22(36), e22.ConsensusCreateTopic = new e22(50), e22.ConsensusUpdateTopic = new e22(51), e22.ConsensusDeleteTopic = new e22(52), e22.ConsensusGetTopicInfo = new e22(53), e22.ConsensusSubmitMessage = new e22(54), e22.UncheckedSubmit = new e22(55), e22.TokenCreate = new e22(56), e22.TokenGetInfo = new e22(58), e22.TokenFreezeAccount = new e22(59), e22.TokenUnfreezeAccount = new e22(60), e22.TokenGrantKycToAccount = new e22(61), e22.TokenRevokeKycFromAccount = new e22(62), e22.TokenDelete = new e22(63), e22.TokenUpdate = new e22(64), e22.TokenMint = new e22(65), e22.TokenBurn = new e22(66), e22.TokenAccountWipe = new e22(67), e22.TokenAssociateToAccount = new e22(68), e22.TokenDissociateFromAccount = new e22(69), e22.ScheduleCreate = new e22(70), e22.ScheduleDelete = new e22(71), e22.ScheduleSign = new e22(72), e22.ScheduleGetInfo = new e22(73), e22.TokenGetAccountNftInfos = new e22(74), e22.TokenGetNftInfo = new e22(75), e22.TokenGetNftInfos = new e22(76), e22.TokenFeeScheduleUpdate = new e22(77), e22.NetworkGetExecutionTime = new e22(78), e22.TokenPause = new e22(79), e22.TokenUnpause = new e22(80), e22.CryptoApproveAllowance = new e22(81), e22.CryptoDeleteAllowance = new e22(82), e22.GetAccountDetails = new e22(83), e22.EthereumTransaction = new e22(84), e22.NodeStakeUpdate = new e22(85), e22.Prng = new e22(86), e22.TransactionGetFastRecord = new e22(87), e22.TokenUpdateNfts = new e22(88), e22.NodeCreate = new e22(89), e22.NodeUpdate = new e22(90), e22.NodeDelete = new e22(91), e22.TokenReject = new e22(92), e22.TokenAirdrop = new e22(93), e22.TokenCancelAirdrop = new e22(94), e22.TokenClaimAirdrop = new e22(95), e22.TssMessage = new e22(96), e22.TssVote = new e22(97), e22.TssShareSignature = new e22(98), e22.TssEncryptionKey = new e22(99), e22.StateSignatureTransaction = new e22(100), e22.HintsKeyPublication = new e22(101), e22.HintsPreprocessingVote = new e22(102), e22.HintsPartialSignature = new e22(103), e22.HistoryAssemblySignature = new e22(104), e22.HistoryProofKeyPublication = new e22(105), e22.HistoryProofVote = new e22(106), e22.CrsPublication = new e22(107), e22.HistoryAssemblySignature = new e22(104), e22.HistoryProofKeyPublication = new e22(105), e22.HistoryProofVote = new e22(106), e22.AtomicBatch = new e22(108);

// node_modules/@hashgraph/sdk/lib/file/FileContentsQuery.js
var n17 = class _n extends h3 {
  constructor(e39 = {}) {
    super(), this._fileId = null, null != e39.fileId && this.setFileId(e39.fileId);
  }
  static _fromProtobuf(e39) {
    const t35 = e39.fileGetContents;
    return new _n({ fileId: null != t35.fileID ? c3._fromProtobuf(t35.fileID) : void 0 });
  }
  _validateChecksums(e39) {
    null != this._fileId && this._fileId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.file.getFileContent(t35);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(e39) {
    return this._fileId = "string" == typeof e39 ? c3.fromString(e39) : e39.clone(), this;
  }
  _mapResponseHeader(e39) {
    return e39.fileGetContents.header;
  }
  _mapResponse(e39) {
    const t35 = e39.fileGetContents.fileContents.contents;
    return Promise.resolve(t35);
  }
  _onMakeRequest(e39) {
    return { fileGetContents: { header: e39, fileID: null != this._fileId ? this._fileId._toProtobuf() : null } };
  }
  _getLogId() {
    return `FileContentsQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("fileGetContents", n17._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/file/FileInfo.js
var r20 = __toESM(require_lib(), 1);
var { proto: l12 } = r20;
var f3 = class _f {
  constructor(e39) {
    this.fileId = e39.fileId, this.size = e39.size, this.expirationTime = e39.expirationTime, this.isDeleted = e39.isDeleted, this.keys = e39.keys, this.fileMemo = e39.fileMemo, this.ledgerId = e39.ledgerId, Object.freeze(this);
  }
  static _fromProtobuf(r41) {
    const l19 = r41.size;
    return new _f({ fileId: c3._fromProtobuf(r41.fileID), size: l19 instanceof long_default ? l19 : long_default.fromValue(l19), expirationTime: s3._fromProtobuf(r41.expirationTime), isDeleted: r41.deleted, keys: null != r41.keys ? s4.__fromProtobufKeyList(r41.keys) : new s4(), fileMemo: null != r41.memo ? r41.memo : "", ledgerId: null != r41.ledgerId ? r15.fromBytes(r41.ledgerId) : null });
  }
  _toProtobuf() {
    return { fileID: this.fileId._toProtobuf(), size: this.size, expirationTime: this.expirationTime._toProtobuf(), deleted: this.isDeleted, keys: this.keys._toProtobufKey().keyList, memo: this.fileMemo, ledgerId: null != this.ledgerId ? this.ledgerId.toBytes() : null };
  }
  static fromBytes(e39) {
    return _f._fromProtobuf(r20.proto.FileGetInfoResponse.FileInfo.decode(e39));
  }
  toBytes() {
    return l12.FileGetInfoResponse.FileInfo.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/file/FileInfoQuery.js
var o18 = class _o extends h3 {
  constructor(e39 = {}) {
    super(), this._fileId = null, null != e39.fileId && this.setFileId(e39.fileId);
  }
  static _fromProtobuf(e39) {
    const t35 = e39.fileGetInfo;
    return new _o({ fileId: null != t35.fileID ? c3._fromProtobuf(t35.fileID) : void 0 });
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(e39) {
    return this._fileId = "string" == typeof e39 ? c3.fromString(e39) : e39.clone(), this;
  }
  async getCost(e39) {
    return super.getCost(e39);
  }
  _validateChecksums(e39) {
    null != this._fileId && this._fileId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.file.getFileInfo(t35);
  }
  _mapResponseHeader(e39) {
    return e39.fileGetInfo.header;
  }
  _mapResponse(e39, t35, i17) {
    const o32 = e39.fileGetInfo;
    return Promise.resolve(f3._fromProtobuf(o32.fileInfo));
  }
  _onMakeRequest(e39) {
    return { fileGetInfo: { header: e39, fileID: null != this._fileId ? this._fileId._toProtobuf() : null } };
  }
  _getLogId() {
    return `FileInfoQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("fileGetInfo", o18._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/file/FileUpdateTransaction.js
var l13 = class _l extends P {
  constructor(e39 = {}) {
    super(), this._fileId = null, this._keys = null, this._expirationTime = null, this._contents = null, this._fileMemo = null, null != e39.fileId && this.setFileId(e39.fileId), null != e39.keys && this.setKeys(e39.keys), null != e39.expirationTime && this.setExpirationTime(e39.expirationTime), null != e39.contents && this.setContents(e39.contents), e39.fileMemo && null != e39.fileMemo && this.setFileMemo(e39.fileMemo);
  }
  static _fromProtobuf(t35, o32, r41, u22, a23) {
    const m6 = a23[0].fileUpdate;
    return P._fromProtobufTransactions(new _l({ fileId: null != m6.fileID ? c3._fromProtobuf(m6.fileID) : void 0, keys: null != m6.keys && null != m6.keys.keys ? m6.keys.keys.map(((e39) => t2._fromProtobufKey(e39))) : void 0, expirationTime: null != m6.expirationTime ? s3._fromProtobuf(m6.expirationTime) : void 0, contents: null != m6.contents ? m6.contents : void 0, fileMemo: null != m6.memo && Object.hasOwn(m6.memo, "value") ? m6.memo.value : void 0 }), t35, o32, r41, u22, a23);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(e39) {
    return this._requireNotFrozen(), this._fileId = "string" == typeof e39 ? c3.fromString(e39) : e39.clone(), this;
  }
  get keys() {
    return this._keys;
  }
  setKeys(e39) {
    if (this._requireNotFrozen(), e39 instanceof s4 && null != e39.threshold) throw new Error("Cannot set threshold key as file key");
    return this._keys = e39 instanceof s4 ? e39.toArray() : e39, this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(e39) {
    return this._requireNotFrozen(), this._expirationTime = e39 instanceof s3 ? e39 : s3.fromDate(e39), this;
  }
  get contents() {
    return this._contents;
  }
  setContents(e39) {
    return this._requireNotFrozen(), this._contents = e39 instanceof Uint8Array ? e39 : n8(e39), this;
  }
  get fileMemo() {
    return this._fileMemo;
  }
  setFileMemo(e39) {
    return this._requireNotFrozen(), this._fileMemo = e39, this;
  }
  clearFileMemo() {
    return this._requireNotFrozen(), this._fileMemo = null, this;
  }
  _validateChecksums(e39) {
    null != this._fileId && this._fileId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.file.updateFile(t35);
  }
  _getTransactionDataCase() {
    return "fileUpdate";
  }
  _makeTransactionData() {
    return { fileID: null != this._fileId ? this._fileId._toProtobuf() : null, keys: null != this._keys ? { keys: this._keys.map(((e39) => e39._toProtobufKey())) } : null, expirationTime: null != this._expirationTime ? this._expirationTime._toProtobuf() : null, contents: this._contents, memo: null != this._fileMemo ? { value: this._fileMemo } : null };
  }
  _getLogId() {
    return `FileUpdateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("fileUpdate", l13._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/LiveHashAddTransaction.js
var i9 = class _i extends P {
  constructor(t35 = {}) {
    super(), this._hash = null, this._keys = null, this._duration = null, this._accountId = null, null != t35.hash && this.setHash(t35.hash), null != t35.keys && this.setKeys(t35.keys), null != t35.duration && this.setDuration(t35.duration), null != t35.accountId && this.setAccountId(t35.accountId);
  }
  static _fromProtobuf(s26, r41, e39, a23, u22) {
    const h8 = u22[0].cryptoAddLiveHash.liveHash;
    return P._fromProtobufTransactions(new _i({ hash: null != h8.hash ? h8.hash : void 0, keys: null != h8.keys && null != h8.keys.keys ? h8.keys.keys.map(((t35) => t2._fromProtobufKey(t35))) : void 0, duration: null != h8.duration && null != h8.duration.seconds ? h8.duration.seconds : void 0, accountId: null != h8.accountId ? y3._fromProtobuf(h8.accountId) : void 0 }), s26, r41, e39, a23, u22);
  }
  get hash() {
    return this._hash;
  }
  setHash(t35) {
    return this._requireNotFrozen(), this._hash = t35, this;
  }
  get keys() {
    return this._keys;
  }
  setKeys(t35) {
    return this._requireNotFrozen(), this._keys = t35 instanceof s4 ? t35.toArray() : t35, this;
  }
  get duration() {
    return this._duration;
  }
  setDuration(t35) {
    return this._requireNotFrozen(), this._duration = t35 instanceof s9 ? t35 : new s9(t35), this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._accountId && this._accountId.validateChecksum(t35);
  }
  _execute(t35, s26) {
    return t35.crypto.addLiveHash(s26);
  }
  _getTransactionDataCase() {
    return "cryptoAddLiveHash";
  }
  _makeTransactionData() {
    return { liveHash: { hash: this._hash, keys: null != this._keys ? { keys: this._keys.map(((t35) => t35._toProtobufKey())) } : void 0, duration: null != this._duration ? this._duration._toProtobuf() : null, accountId: null != this._accountId ? this._accountId._toProtobuf() : null } };
  }
  _getLogId() {
    return `LiveHashAddTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("cryptoAddLiveHash", i9._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/LiveHashDeleteTransaction.js
var a12 = class _a2 extends P {
  constructor(t35 = {}) {
    super(), this._hash = null, this._accountId = null, null != t35.hash && this.setHash(t35.hash), null != t35.accountId && this.setAccountId(t35.accountId);
  }
  static _fromProtobuf(e39, o32, n31, r41, c17) {
    const h8 = c17[0].cryptoDeleteLiveHash;
    return P._fromProtobufTransactions(new _a2({ hash: null != h8.liveHashToDelete ? h8.liveHashToDelete : void 0, accountId: null != h8.accountOfLiveHash ? y3._fromProtobuf(h8.accountOfLiveHash) : void 0 }), e39, o32, n31, r41, c17);
  }
  get hash() {
    return this._hash;
  }
  setHash(t35) {
    return this._requireNotFrozen(), this._hash = t35, this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._accountId && this._accountId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.crypto.deleteLiveHash(e39);
  }
  _getTransactionDataCase() {
    return "cryptoDeleteLiveHash";
  }
  _makeTransactionData() {
    return { liveHashToDelete: this._hash, accountOfLiveHash: null != this._accountId ? this._accountId._toProtobuf() : null };
  }
  _getLogId() {
    return `LiveHashDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("cryptoDeleteLiveHash", a12._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/LiveHashQuery.js
var o19 = class _o extends h3 {
  constructor(t35 = {}) {
    super(), this._accountId = null, null != t35.accountId && this.setAccountId(t35.accountId), this._hash = null, null != t35.hash && this.setHash(t35.hash);
  }
  static _fromProtobuf(t35) {
    const s26 = t35.cryptoGetLiveHash;
    return new _o({ accountId: null != s26.accountID ? y3._fromProtobuf(s26.accountID) : void 0, hash: null != s26.hash ? s26.hash : void 0 });
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._accountId = t35 instanceof y3 ? t35 : y3.fromString(t35), this;
  }
  get liveHash() {
    return this._hash;
  }
  setHash(t35) {
    return this._hash = t35, this;
  }
  _validateChecksums(t35) {
    null != this._accountId && this._accountId.validateChecksum(t35);
  }
  _execute(t35, s26) {
    return t35.crypto.getLiveHash(s26);
  }
  _mapResponseHeader(t35) {
    return t35.cryptoGetLiveHash.header;
  }
  _mapResponse(t35) {
    const s26 = t35.cryptoGetLiveHash;
    return Promise.resolve(s10._fromProtobuf(s26.liveHash));
  }
  _onMakeRequest(t35) {
    return { cryptoGetLiveHash: { header: t35, accountID: null != this._accountId ? this._accountId._toProtobuf() : null, hash: this._hash } };
  }
  _getLogId() {
    return `LiveHashQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("cryptoGetLiveHash", o19._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/network/SemanticVersion.js
var t22 = __toESM(require_lib(), 1);
var o20 = class _o {
  constructor(t35) {
    this.major = t35.major, this.minor = t35.minor, this.patch = t35.patch, Object.freeze(this);
  }
  static _fromProtobuf(t35) {
    return new _o({ major: t35.major, minor: t35.minor, patch: t35.patch });
  }
  _toProtobuf() {
    return { major: this.major, minor: this.minor, patch: this.patch };
  }
  static fromBytes(r41) {
    return _o._fromProtobuf(t22.proto.SemanticVersion.decode(r41));
  }
  toBytes() {
    return t22.proto.SemanticVersion.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/network/NetworkVersionInfo.js
var r21 = __toESM(require_lib(), 1);
var e23 = class _e {
  constructor(o32) {
    this.protobufVersion = o32.protobufVersion, this.servicesVersion = o32.servicesVersion, Object.freeze(this);
  }
  static _fromProtobuf(r41) {
    return new _e({ protobufVersion: o20._fromProtobuf(r41.hapiProtoVersion), servicesVersion: o20._fromProtobuf(r41.hederaServicesVersion) });
  }
  _toProtobuf() {
    return { hapiProtoVersion: this.protobufVersion._toProtobuf(), hederaServicesVersion: this.servicesVersion._toProtobuf() };
  }
  static fromBytes(o32) {
    return _e._fromProtobuf(r21.proto.NetworkGetVersionInfoResponse.decode(o32));
  }
  toBytes() {
    return r21.proto.NetworkGetVersionInfoResponse.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/network/NetworkVersionInfoQuery.js
var o21 = class _o extends h3 {
  constructor() {
    super();
  }
  static _fromProtobuf(e39) {
    return new _o();
  }
  _execute(e39, r41) {
    return e39.network.getVersionInfo(r41);
  }
  _mapResponseHeader(e39) {
    return e39.networkGetVersionInfo.header;
  }
  _mapResponse(e39) {
    const r41 = e39.networkGetVersionInfo;
    return Promise.resolve(e23._fromProtobuf(r41));
  }
  _onMakeRequest(e39) {
    return { networkGetVersionInfo: { header: e39 } };
  }
  _getLogId() {
    return `NetworkVersionInfoQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("networkGetVersionInfo", o21._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/PrngTransaction.js
var e24 = class _e extends P {
  constructor(t35 = {}) {
    super(), this._range = null, null != t35.range && this.setRange(t35.range);
  }
  setRange(t35) {
    return this._range = t35, this;
  }
  get range() {
    return this._range;
  }
  _validateChecksums(t35) {
    null != this._range && s2(this._range) && this._validateChecksums(t35);
  }
  _execute(t35, r41) {
    return t35.util.prng(r41);
  }
  static _fromProtobuf(r41, n31, a23, s26, i17) {
    const o32 = i17[0].utilPrng;
    return P._fromProtobufTransactions(new _e({ range: o32.range }), r41, n31, a23, s26, i17);
  }
  _getTransactionDataCase() {
    return "utilPrng";
  }
  _makeTransactionData() {
    return { range: this.range };
  }
  _getLogId() {
    return `RandomGenerate:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("utilPrng", e24._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/schedule/ScheduleCreateTransaction.js
var a13 = __toESM(require_lib(), 1);
var u14 = class _u extends P {
  constructor(e39 = {}) {
    super(), this._adminKey = null, this._scheduledTransaction = null, this._payerAccountId = null, this._scheduleMemo = null, this._scheduledSignerPublicKeys = /* @__PURE__ */ new Set(), this._expirationTime = null, this._waitForExpiry = null, null != e39.adminKey && this.setAdminKey(e39.adminKey), null != e39.payerAccountID && this.setPayerAccountId(e39.payerAccountID), null != e39.scheduleMemo && this.setScheduleMemo(e39.scheduleMemo), this._defaultMaxTransactionFee = new e4(5);
  }
  static _fromProtobuf(r41, n31, s26, c17, d18) {
    const h8 = d18[0], l19 = h8.scheduleCreate, m6 = new _u({ adminKey: null != l19.adminKey ? t2._fromProtobufKey(l19.adminKey) : void 0, payerAccountID: null != l19.payerAccountID ? y3._fromProtobuf(l19.payerAccountID) : void 0, scheduleMemo: null != l19.memo ? l19.memo : void 0, waitForExpiry: null != l19.waitForExpiry ? l19.waitForExpiry : void 0, expirationTime: null != l19.expirationTime ? s3._fromProtobuf(l19.expirationTime) : void 0 });
    if (null != h8.scheduleCreate) {
      const e39 = h8.scheduleCreate.scheduledTransactionBody, t35 = a13.proto.TransactionBody.encode(e39).finish(), r42 = { signedTransactionBytes: a13.proto.SignedTransaction.encode({ bodyBytes: t35 }).finish() }, n32 = a13.proto.TransactionList.encode({ transactionList: [r42] }).finish(), o32 = P.fromBytes(n32);
      m6._setScheduledTransaction(o32);
    }
    return P._fromProtobufTransactions(m6, r41, n31, s26, c17, d18);
  }
  _setScheduledTransaction(e39) {
    return this._scheduledTransaction = e39, this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(e39) {
    return this._requireNotFrozen(), this._adminKey = e39, this;
  }
  get payerAccountId() {
    return this._payerAccountId;
  }
  setPayerAccountId(e39) {
    return this._requireNotFrozen(), this._payerAccountId = e39, this;
  }
  setScheduleMemo(e39) {
    return this._requireNotFrozen(), this._scheduleMemo = e39, this;
  }
  get getScheduleMemo() {
    return this._requireNotFrozen(), this._scheduleMemo;
  }
  setScheduledTransaction(e39) {
    return this._requireNotFrozen(), e39._requireNotFrozen(), this._scheduledTransaction = e39.schedule()._scheduledTransaction, this;
  }
  _validateChecksums(e39) {
    null != this._payerAccountId && this._payerAccountId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.schedule.createSchedule(t35);
  }
  _getTransactionDataCase() {
    return "scheduleCreate";
  }
  _makeTransactionData() {
    return { adminKey: null != this._adminKey ? this._adminKey._toProtobufKey() : null, payerAccountID: null != this._payerAccountId ? this._payerAccountId._toProtobuf() : null, scheduledTransactionBody: null != this._scheduledTransaction ? this._scheduledTransaction._getScheduledTransactionBody() : null, memo: this._scheduleMemo, waitForExpiry: this._waitForExpiry, expirationTime: null != this._expirationTime ? this._expirationTime._toProtobuf() : null };
  }
  _getLogId() {
    return `ScheduleCreateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
  setExpirationTime(e39) {
    return this._expirationTime = e39, this;
  }
  get expirationTime() {
    return this._requireNotFrozen(), this._expirationTime;
  }
  setWaitForExpiry(e39) {
    return this._waitForExpiry = e39, this;
  }
  get waitForExpiry() {
    return this._requireNotFrozen(), this._waitForExpiry;
  }
};
B.set("scheduleCreate", u14._fromProtobuf), F.push((() => new u14()));

// node_modules/@hashgraph/sdk/lib/schedule/ScheduleDeleteTransaction.js
var u15 = class _u extends P {
  constructor(e39 = {}) {
    super(), this._scheduleId = null, null != e39.scheduleId && this.setScheduleId(e39.scheduleId), this._defaultMaxTransactionFee = new e4(5);
  }
  static _fromProtobuf(s26, r41, d18, l19, c17) {
    const o32 = c17[0].scheduleDelete;
    return P._fromProtobufTransactions(new _u({ scheduleId: null != o32.scheduleID ? o6._fromProtobuf(o32.scheduleID) : void 0 }), s26, r41, d18, l19, c17);
  }
  get scheduleId() {
    return this._scheduleId;
  }
  setScheduleId(t35) {
    return this._requireNotFrozen(), this._scheduleId = "string" == typeof t35 ? o6.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(e39) {
    null != this._scheduleId && this._scheduleId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.schedule.deleteSchedule(t35);
  }
  _getTransactionDataCase() {
    return "scheduleDelete";
  }
  _makeTransactionData() {
    return { scheduleID: null != this._scheduleId ? this._scheduleId._toProtobuf() : null };
  }
  _getLogId() {
    return `ScheduleDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("scheduleDelete", u15._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/schedule/ScheduleInfo.js
var i10 = __toESM(require_lib(), 1);
var { proto: a14 } = i10;
var c12 = class _c {
  constructor(e39) {
    this.scheduleId = e39.scheduleId, this.creatorAccountId = e39.creatorAccountID, this.payerAccountId = e39.payerAccountID, this.schedulableTransactionBody = e39.schedulableTransactionBody, this.signers = e39.signers, this.scheduleMemo = e39.scheduleMemo, this.adminKey = null != e39.adminKey ? e39.adminKey : null, this.expirationTime = e39.expirationTime, this.executed = e39.executed, this.deleted = e39.deleted, this.scheduledTransactionId = e39.scheduledTransactionId, this.waitForExpiry = e39.waitForExpiry, Object.freeze(this);
  }
  static _fromProtobuf(n31) {
    return new _c({ scheduleId: o6._fromProtobuf(n31.scheduleID), creatorAccountID: null != n31.creatorAccountID ? y3._fromProtobuf(n31.creatorAccountID) : null, payerAccountID: null != n31.payerAccountID ? y3._fromProtobuf(n31.payerAccountID) : null, schedulableTransactionBody: null != n31.scheduledTransactionBody ? n31.scheduledTransactionBody : null, adminKey: null != n31.adminKey ? t2._fromProtobufKey(n31.adminKey) : null, signers: null != n31.signers ? s4.__fromProtobufKeyList(n31.signers) : null, scheduleMemo: null != n31.memo ? n31.memo : null, expirationTime: null != n31.expirationTime ? s3._fromProtobuf(n31.expirationTime) : null, executed: null != n31.executionTime ? s3._fromProtobuf(n31.executionTime) : null, deleted: null != n31.deletionTime ? s3._fromProtobuf(n31.deletionTime) : null, scheduledTransactionId: null != n31.scheduledTransactionID ? i4._fromProtobuf(n31.scheduledTransactionID) : null, waitForExpiry: null != n31.waitForExpiry && n31.waitForExpiry });
  }
  _toProtobuf() {
    return { scheduleID: null != this.scheduleId ? this.scheduleId._toProtobuf() : null, creatorAccountID: null != this.creatorAccountId ? this.creatorAccountId._toProtobuf() : null, payerAccountID: null != this.payerAccountId ? this.payerAccountId._toProtobuf() : null, scheduledTransactionBody: null != this.schedulableTransactionBody ? this.schedulableTransactionBody : null, adminKey: null != this.adminKey ? this.adminKey._toProtobufKey() : null, signers: null != this.signers ? this.signers._toProtobufKey().keyList : null, memo: null != this.scheduleMemo ? this.scheduleMemo : "", expirationTime: null != this.expirationTime ? this.expirationTime._toProtobuf() : null, scheduledTransactionID: null != this.scheduledTransactionId ? this.scheduledTransactionId._toProtobuf() : null, waitForExpiry: this.waitForExpiry };
  }
  get scheduledTransaction() {
    if (null == this.schedulableTransactionBody) throw new Error("Scheduled transaction body is empty");
    const e39 = new a14.SchedulableTransactionBody(this.schedulableTransactionBody), o32 = e39.data;
    return P.fromBytes(a14.TransactionList.encode({ transactionList: [{ signedTransactionBytes: a14.SignedTransaction.encode({ bodyBytes: a14.TransactionBody.encode({ transactionFee: this.schedulableTransactionBody.transactionFee, memo: this.schedulableTransactionBody.memo, [o32]: e39[o32] }).finish() }).finish() }] }).finish());
  }
};

// node_modules/@hashgraph/sdk/lib/schedule/ScheduleInfoQuery.js
var r22 = class _r extends h3 {
  constructor(e39 = {}) {
    super(), this._scheduleId = null, null != e39.scheduleId && this.setScheduleId(e39.scheduleId);
  }
  static _fromProtobuf(e39) {
    const t35 = e39.scheduleGetInfo;
    return new _r({ scheduleId: null != t35.scheduleID ? o6._fromProtobuf(t35.scheduleID) : void 0 });
  }
  get scheduleId() {
    return this._scheduleId;
  }
  setScheduleId(e39) {
    return this._scheduleId = "string" == typeof e39 ? o6.fromString(e39) : e39.clone(), this;
  }
  async getCost(e39) {
    return super.getCost(e39);
  }
  _validateChecksums(e39) {
    null != this._scheduleId && this._scheduleId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.schedule.getScheduleInfo(t35);
  }
  _mapResponseHeader(e39) {
    return e39.scheduleGetInfo.header;
  }
  _mapResponse(e39, t35, s26) {
    const r41 = e39.scheduleGetInfo;
    return Promise.resolve(c12._fromProtobuf(r41.scheduleInfo));
  }
  _onMakeRequest(e39) {
    return { scheduleGetInfo: { header: e39, scheduleID: null != this._scheduleId ? this._scheduleId._toProtobuf() : null } };
  }
  _getLogId() {
    return `ScheduleInfoQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("scheduleGetInfo", r22._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/schedule/ScheduleSignTransaction.js
var u16 = class _u extends P {
  constructor(e39 = {}) {
    super(), this._scheduleId = null, null != e39.scheduleId && this.setScheduleId(e39.scheduleId), this._defaultMaxTransactionFee = new e4(5);
  }
  static _fromProtobuf(t35, r41, d18, n31, l19) {
    const c17 = l19[0].scheduleSign;
    return P._fromProtobufTransactions(new _u({ scheduleId: null != c17.scheduleID ? o6._fromProtobuf(c17.scheduleID) : void 0 }), t35, r41, d18, n31, l19);
  }
  get scheduleId() {
    return this._scheduleId;
  }
  setScheduleId(t35) {
    return this._requireNotFrozen(), this._scheduleId = "string" == typeof t35 ? o6.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(e39) {
    null != this._scheduleId && this._scheduleId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.schedule.signSchedule(t35);
  }
  _getTransactionDataCase() {
    return "scheduleSign";
  }
  _makeTransactionData() {
    return { scheduleID: null != this._scheduleId ? this._scheduleId._toProtobuf() : null };
  }
  _getLogId() {
    return `ScheduleSignTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("scheduleSign", u16._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/system/SystemDeleteTransaction.js
var n18 = class _n extends P {
  constructor(t35 = {}) {
    super(), this._fileId = null, this._contractId = null, this._expirationTime = null, null != t35.fileId && this.setFileId(t35.fileId), null != t35.contractId && this.setContractId(t35.contractId), null != t35.expirationTime && this.setExpirationTime(t35.expirationTime);
  }
  static _fromProtobuf(e39, s26, a23, l19, c17) {
    const u22 = c17[0].systemDelete;
    return P._fromProtobufTransactions(new _n({ fileId: null != u22.fileID ? c3._fromProtobuf(u22.fileID) : void 0, contractId: null != u22.contractID ? g4._fromProtobuf(u22.contractID) : void 0, expirationTime: null != u22.expirationTime ? s3._fromProtobuf(u22.expirationTime) : void 0 }), e39, s26, a23, l19, c17);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(t35) {
    return this._requireNotFrozen(), this._fileId = t35 instanceof c3 ? t35 : c3.fromString(t35), this;
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(t35) {
    return this._requireNotFrozen(), this._contractId = t35 instanceof g4 ? t35 : g4.fromString(t35), this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(t35) {
    return this._requireNotFrozen(), this._expirationTime = t35, this;
  }
  _execute(t35, e39) {
    return null != this._fileId ? t35.file.systemDelete(e39) : t35.smartContract.systemDelete(e39);
  }
  _getTransactionDataCase() {
    return "systemDelete";
  }
  _makeTransactionData() {
    return { fileID: null != this._fileId ? this._fileId._toProtobuf() : null, contractID: null != this._contractId ? this._contractId._toProtobuf() : null, expirationTime: null != this._expirationTime ? this._expirationTime._toProtobuf() : null };
  }
  _getLogId() {
    return `SystemDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("systemDelete", n18._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/system/SystemUndeleteTransaction.js
var o22 = class _o extends P {
  constructor(t35 = {}) {
    super(), this._fileId = null, this._contractId = null, null != t35.fileId && this.setFileId(t35.fileId), null != t35.contractId && this.setContractId(t35.contractId);
  }
  static _fromProtobuf(e39, s26, i17, l19, a23) {
    const c17 = a23[0].systemUndelete;
    return P._fromProtobufTransactions(new _o({ fileId: null != c17.fileID ? c3._fromProtobuf(c17.fileID) : void 0, contractId: null != c17.contractID ? g4._fromProtobuf(c17.contractID) : void 0 }), e39, s26, i17, l19, a23);
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(t35) {
    return this._requireNotFrozen(), this._fileId = t35 instanceof c3 ? t35 : c3.fromString(t35), this;
  }
  get contractId() {
    return this._contractId;
  }
  setContractId(t35) {
    return this._requireNotFrozen(), this._contractId = t35 instanceof g4 ? t35 : g4.fromString(t35), this;
  }
  _execute(t35, e39) {
    return null != this._fileId ? t35.file.systemUndelete(e39) : t35.smartContract.systemUndelete(e39);
  }
  _getTransactionDataCase() {
    return "systemUndelete";
  }
  _makeTransactionData() {
    return { fileID: null != this._fileId ? this._fileId._toProtobuf() : null, contractID: null != this._contractId ? this._contractId._toProtobuf() : null };
  }
  _getLogId() {
    return `SystemUndeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("systemUndelete", o22._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenAssociateTransaction.js
var r23 = class _r extends P {
  constructor(o32 = {}) {
    super(), this._tokenIds = null, this._accountId = null, this._defaultMaxTransactionFee = new e4(5), null != o32.tokenIds && this.setTokenIds(o32.tokenIds), null != o32.accountId && this.setAccountId(o32.accountId);
  }
  static _fromProtobuf(t35, e39, c17, a23, u22) {
    const i17 = u22[0].tokenAssociate;
    return P._fromProtobufTransactions(new _r({ tokenIds: null != i17.tokens ? i17.tokens.map(((t36) => c4._fromProtobuf(t36))) : void 0, accountId: null != i17.account ? y3._fromProtobuf(i17.account) : void 0 }), t35, e39, c17, a23, u22);
  }
  get tokenIds() {
    return this._tokenIds;
  }
  setTokenIds(t35) {
    return this._requireNotFrozen(), this._tokenIds = t35.map(((t36) => "string" == typeof t36 ? c4.fromString(t36) : t36.clone())), this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._accountId && this._accountId.validateChecksum(t35);
    for (const o32 of null != this._tokenIds ? this._tokenIds : []) null != o32 && o32.validateChecksum(t35);
  }
  _execute(t35, o32) {
    return t35.token.associateTokens(o32);
  }
  _getTransactionDataCase() {
    return "tokenAssociate";
  }
  _makeTransactionData() {
    return { tokens: null != this._tokenIds ? this._tokenIds.map(((t35) => t35._toProtobuf())) : null, account: null != this._accountId ? this._accountId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenAssociateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenAssociate", r23._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenBurnTransaction.js
var r24 = class _r extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, this._amount = null, this._serials = [], null != t35.tokenId && this.setTokenId(t35.tokenId), null != t35.amount && this.setAmount(t35.amount), null != t35.serials && this.setSerials(t35.serials);
  }
  static _fromProtobuf(e39, o32, s26, i17, u22) {
    const a23 = u22[0].tokenBurn;
    return P._fromProtobufTransactions(new _r({ tokenId: null != a23.token ? c4._fromProtobuf(a23.token) : void 0, amount: null != a23.amount ? a23.amount : void 0, serials: null != a23.serialNumbers ? a23.serialNumbers : void 0 }), e39, o32, s26, i17, u22);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(n31) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof n31 ? c4.fromString(n31) : n31.clone(), this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(t35) {
    return this._requireNotFrozen(), this._amount = t35 instanceof long_default ? t35 : long_default.fromValue(t35), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35);
  }
  get serials() {
    return this._serials;
  }
  setSerials(t35) {
    return this._requireNotFrozen(), this._serials = t35.map(((t36) => t36 instanceof long_default ? t36 : long_default.fromValue(t36))), this;
  }
  _execute(t35, n31) {
    return t35.token.burnToken(n31);
  }
  _getTransactionDataCase() {
    return "tokenBurn";
  }
  _makeTransactionData() {
    return { amount: this._amount, serialNumbers: this._serials, token: null != this._tokenId ? this._tokenId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenBurnTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenBurn", r24._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenReference.js
var t23 = class {
  constructor() {
    this.fungibleToken = null, this.nft = null;
  }
  static _fromProtobuf(t35) {
    return { fungibleToken: null != t35.fungibleToken ? c4._fromProtobuf(t35.fungibleToken) : null, nft: null != t35.nft ? e9._fromProtobuf(t35.nft) : null };
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenRejectTransaction.js
var o23 = class _o extends P {
  constructor(t35 = {}) {
    super(), this._owner = null, null != t35.owner && this.setOwnerId(t35.owner), this._tokenIds = [], this._nftIds = [], null != t35.tokenIds && this.setTokenIds(t35.tokenIds), null != t35.nftIds && this.setNftIds(t35.nftIds);
  }
  static _fromProtobuf(n31, s26, i17, u22, f4) {
    var _a2;
    const d18 = f4[0].tokenReject, a23 = (_a2 = d18.rejections) == null ? void 0 : _a2.map(((t35) => t23._fromProtobuf(t35))), h8 = a23 == null ? void 0 : a23.filter(((t35) => t35.fungibleToken)).map((({ fungibleToken: t35 }) => {
      if (null == t35) throw new Error("Fungible Token cannot be null");
      return t35;
    })), c17 = a23 == null ? void 0 : a23.filter(((t35) => t35.nft)).map((({ nft: t35 }) => {
      if (null == t35) throw new Error("Nft cannot be null");
      return t35;
    }));
    return P._fromProtobufTransactions(new _o({ owner: null != d18.owner ? y3._fromProtobuf(d18.owner) : void 0, tokenIds: h8, nftIds: c17 }), n31, s26, i17, u22, f4);
  }
  get tokenIds() {
    return this._tokenIds;
  }
  setTokenIds(t35) {
    return this._requireNotFrozen(), this._tokenIds = t35, this;
  }
  addTokenId(t35) {
    var _a2;
    return this._requireNotFrozen(), (_a2 = this._tokenIds) == null ? void 0 : _a2.push(t35), this;
  }
  get nftIds() {
    return this._nftIds;
  }
  setNftIds(t35) {
    return this._requireNotFrozen(), this._nftIds = t35, this;
  }
  addNftId(t35) {
    var _a2;
    return this._requireNotFrozen(), (_a2 = this._nftIds) == null ? void 0 : _a2.push(t35), this;
  }
  get ownerId() {
    return this._owner;
  }
  setOwnerId(t35) {
    return this._requireNotFrozen(), this._owner = t35, this;
  }
  _execute(t35, e39) {
    return t35.token.rejectToken(e39);
  }
  _getTransactionDataCase() {
    return "tokenReject";
  }
  _makeTransactionData() {
    var _a2;
    const t35 = [];
    for (const e39 of this._tokenIds) t35.push({ fungibleToken: e39._toProtobuf() });
    for (const e39 of this._nftIds) t35.push({ nft: e39._toProtobuf() });
    return { owner: ((_a2 = this.ownerId) == null ? void 0 : _a2._toProtobuf()) ?? null, rejections: t35 };
  }
  _getLogId() {
    return `TokenRejectTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenReject", o23._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenDissociateTransaction.js
var r25 = class _r extends P {
  constructor(o32 = {}) {
    super(), this._tokenIds = null, this._accountId = null, this._defaultMaxTransactionFee = new e4(5), null != o32.tokenIds && this.setTokenIds(o32.tokenIds), null != o32.accountId && this.setAccountId(o32.accountId);
  }
  static _fromProtobuf(t35, e39, c17, a23, i17) {
    const u22 = i17[0].tokenDissociate;
    return P._fromProtobufTransactions(new _r({ tokenIds: null != u22.tokens ? u22.tokens.map(((t36) => c4._fromProtobuf(t36))) : void 0, accountId: null != u22.account ? y3._fromProtobuf(u22.account) : void 0 }), t35, e39, c17, a23, i17);
  }
  get tokenIds() {
    return this._tokenIds;
  }
  setTokenIds(t35) {
    return this._requireNotFrozen(), this._tokenIds = t35.map(((t36) => "string" == typeof t36 ? c4.fromString(t36) : t36.clone())), this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._accountId && this._accountId.validateChecksum(t35);
    for (const o32 of null != this._tokenIds ? this._tokenIds : []) null != o32 && o32.validateChecksum(t35);
  }
  _execute(t35, o32) {
    return t35.token.dissociateTokens(o32);
  }
  _getTransactionDataCase() {
    return "tokenDissociate";
  }
  _makeTransactionData() {
    return { tokens: null != this._tokenIds ? this._tokenIds.map(((t35) => t35._toProtobuf())) : null, account: null != this._accountId ? this._accountId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenDissociateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenDissociate", r25._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/CustomFractionalFee.js
var r26 = class _r extends e10 {
  constructor(t35 = {}) {
    super(t35), this._numerator = null, null != t35.numerator && this.setNumerator(t35.numerator), this._denominator = null, null != t35.denominator && this.setDenominator(t35.denominator), this._min = null, null != t35.min && this.setMin(t35.min), this._max, null != t35.max && this.setMax(t35.max), this._assessmentMethod, null != t35.assessmentMethod && this.setAssessmentMethod(t35.assessmentMethod);
  }
  get numerator() {
    return this._numerator;
  }
  setNumerator(t35) {
    return this._numerator = "number" == typeof t35 ? long_default.fromNumber(t35) : t35, this;
  }
  get denominator() {
    return this._denominator;
  }
  setDenominator(t35) {
    return this._denominator = "number" == typeof t35 ? long_default.fromNumber(t35) : t35, this;
  }
  get min() {
    return this._min;
  }
  setMin(t35) {
    return this._min = "number" == typeof t35 ? long_default.fromNumber(t35) : t35, this;
  }
  get max() {
    return this._max;
  }
  setMax(t35) {
    return this._max = "number" == typeof t35 ? long_default.fromNumber(t35) : t35, this;
  }
  get assessmentMethod() {
    return this._assessmentMethod;
  }
  setAssessmentMethod(t35) {
    return this._assessmentMethod = t35, this;
  }
  static _fromProtobuf(t35) {
    const n31 = t35.fractionalFee, s26 = n31.fractionalAmount;
    return new _r({ feeCollectorAccountId: null != t35.feeCollectorAccountId ? y3._fromProtobuf(t35.feeCollectorAccountId) : void 0, allCollectorsAreExempt: null != t35.allCollectorsAreExempt ? t35.allCollectorsAreExempt : void 0, numerator: null != s26.numerator ? s26.numerator : void 0, denominator: null != s26.denominator ? s26.denominator : void 0, min: null != n31.minimumAmount ? n31.minimumAmount : void 0, max: null != n31.maximumAmount ? n31.maximumAmount : void 0, assessmentMethod: null != n31.netOfTransfers ? new e18(n31.netOfTransfers) : void 0 });
  }
  _toProtobuf() {
    return { feeCollectorAccountId: null != this.feeCollectorAccountId ? this.feeCollectorAccountId._toProtobuf() : null, allCollectorsAreExempt: this.allCollectorsAreExempt, fractionalFee: { fractionalAmount: { numerator: this._numerator, denominator: this._denominator }, minimumAmount: this._min, maximumAmount: this._max, netOfTransfers: null != this._assessmentMethod && this._assessmentMethod.valueOf() } };
  }
};

// node_modules/@hashgraph/sdk/lib/token/CustomRoyaltyFee.js
var l14 = class _l extends e10 {
  constructor(e39 = {}) {
    super(e39), this._fallbackFee = null, null != e39.fallbackFee && this.setFallbackFee(e39.fallbackFee), this._numerator = null, null != e39.numerator && this.setNumerator(e39.numerator), this._denominator = null, null != e39.denominator && this.setDenominator(e39.denominator);
  }
  get fallbackFee() {
    return this._fallbackFee;
  }
  setFallbackFee(e39) {
    return this._fallbackFee = e39, this;
  }
  get numerator() {
    return this._numerator;
  }
  setNumerator(e39) {
    return this._numerator = "number" == typeof e39 ? long_default.fromNumber(e39) : e39, this;
  }
  get denominator() {
    return this._denominator;
  }
  setDenominator(e39) {
    return this._denominator = "number" == typeof e39 ? long_default.fromNumber(e39) : e39, this;
  }
  static _fromProtobuf(e39) {
    const o32 = e39.royaltyFee, n31 = o32.exchangeValueFraction;
    return new _l({ feeCollectorAccountId: null != e39.feeCollectorAccountId ? y3._fromProtobuf(e39.feeCollectorAccountId) : void 0, allCollectorsAreExempt: null != e39.allCollectorsAreExempt ? e39.allCollectorsAreExempt : void 0, fallbackFee: null != o32.fallbackFee ? l6._fromProtobuf({ fixedFee: o32.fallbackFee }) : void 0, numerator: null != n31.numerator ? n31.numerator : void 0, denominator: null != n31.denominator ? n31.denominator : void 0 });
  }
  _toProtobuf() {
    return { feeCollectorAccountId: null != this.feeCollectorAccountId ? this.feeCollectorAccountId._toProtobuf() : null, allCollectorsAreExempt: this.allCollectorsAreExempt, royaltyFee: { exchangeValueFraction: { numerator: this._numerator, denominator: this._denominator }, fallbackFee: null != this._fallbackFee ? this._fallbackFee._toProtobuf().fixedFee : null } };
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenType.js
var e25 = class _e {
  constructor(e39) {
    this._code = e39, Object.freeze(this);
  }
  toString() {
    switch (this) {
      case _e.FungibleCommon:
        return "FUNGIBLE_COMMON";
      case _e.NonFungibleUnique:
        return "NON_FUNGIBLE_UNIQUE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(n31) {
    switch (n31) {
      case 0:
        return _e.FungibleCommon;
      case 1:
        return _e.NonFungibleUnique;
    }
    throw new Error(`(BUG) TokenType.fromCode() does not handle code: ${n31}`);
  }
  valueOf() {
    return this._code;
  }
};
e25.FungibleCommon = new e25(0), e25.NonFungibleUnique = new e25(1);

// node_modules/@hashgraph/sdk/lib/token/TokenSupplyType.js
var e26 = class _e {
  constructor(e39) {
    this._code = e39, Object.freeze(this);
  }
  toString() {
    switch (this) {
      case _e.Infinite:
        return "INFINITE";
      case _e.Finite:
        return "FINITE";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(t35) {
    switch (t35) {
      case 0:
        return _e.Infinite;
      case 1:
        return _e.Finite;
    }
    throw new Error(`(BUG) TokenSupplyType.fromCode() does not handle code: ${t35}`);
  }
  valueOf() {
    return this._code;
  }
};
e26.Infinite = new e26(0), e26.Finite = new e26(1);

// node_modules/@hashgraph/sdk/lib/token/TokenCreateTransaction.js
var _3 = class __ extends P {
  constructor(t35 = {}) {
    super(), this._tokenName = null, this._tokenSymbol = null, this._decimals = null, this._initialSupply = null, this._treasuryAccountId = null, this._adminKey = null, this._kycKey = null, this._freezeKey = null, this._pauseKey = null, this._wipeKey = null, this._supplyKey = null, this._feeScheduleKey = null, this._freezeDefault = null, this._autoRenewAccountId = null, this._expirationTime = new s3(Math.floor(Date.now() / 1e3 + w3.toNumber()), 0), this._autoRenewPeriod = new s9(w3), this._tokenMemo = null, this._customFees = [], this._tokenType = null, this._supplyType = null, this._maxSupply = null, this._defaultMaxTransactionFee = new e4(30), this._metadataKey = null, this._metadata = null, null != t35.tokenName && this.setTokenName(t35.tokenName), null != t35.tokenSymbol && this.setTokenSymbol(t35.tokenSymbol), null != t35.decimals && this.setDecimals(t35.decimals), null != t35.initialSupply && this.setInitialSupply(t35.initialSupply), null != t35.treasuryAccountId && this.setTreasuryAccountId(t35.treasuryAccountId), null != t35.adminKey && this.setAdminKey(t35.adminKey), null != t35.kycKey && this.setKycKey(t35.kycKey), null != t35.freezeKey && this.setFreezeKey(t35.freezeKey), null != t35.pauseKey && this.setPauseKey(t35.pauseKey), null != t35.wipeKey && this.setWipeKey(t35.wipeKey), null != t35.supplyKey && this.setSupplyKey(t35.supplyKey), null != t35.feeScheduleKey && this.setFeeScheduleKey(t35.feeScheduleKey), null != t35.freezeDefault && this.setFreezeDefault(t35.freezeDefault), null != t35.autoRenewAccountId && this.setAutoRenewAccountId(t35.autoRenewAccountId), null != t35.expirationTime && this.setExpirationTime(t35.expirationTime), null != t35.autoRenewPeriod && this.setAutoRenewPeriod(t35.autoRenewPeriod), null != t35.tokenMemo && this.setTokenMemo(t35.tokenMemo), null != t35.customFees && this.setCustomFees(t35.customFees), null != t35.tokenType && this.setTokenType(t35.tokenType), null != t35.supplyType && this.setSupplyType(t35.supplyType), null != t35.maxSupply && this.setMaxSupply(t35.maxSupply), null != t35.metadataKey && this.setMetadataKey(t35.metadataKey), null != t35.metadata && this.setMetadata(t35.metadata);
  }
  static _fromProtobuf(e39, o32, u22, i17, c17) {
    const d18 = c17[0].tokenCreation;
    return P._fromProtobufTransactions(new __({ tokenName: null != d18.name ? d18.name : void 0, tokenSymbol: null != d18.symbol ? d18.symbol : void 0, decimals: null != d18.decimals ? d18.decimals : void 0, initialSupply: null != d18.initialSupply ? d18.initialSupply : void 0, treasuryAccountId: null != d18.treasury ? y3._fromProtobuf(d18.treasury) : void 0, adminKey: null != d18.adminKey ? t2._fromProtobufKey(d18.adminKey) : void 0, kycKey: null != d18.kycKey ? t2._fromProtobufKey(d18.kycKey) : void 0, freezeKey: null != d18.freezeKey ? t2._fromProtobufKey(d18.freezeKey) : void 0, pauseKey: null != d18.pauseKey ? t2._fromProtobufKey(d18.pauseKey) : void 0, wipeKey: null != d18.wipeKey ? t2._fromProtobufKey(d18.wipeKey) : void 0, supplyKey: null != d18.supplyKey ? t2._fromProtobufKey(d18.supplyKey) : void 0, feeScheduleKey: null != d18.feeScheduleKey ? t2._fromProtobufKey(d18.feeScheduleKey) : void 0, freezeDefault: null != d18.freezeDefault ? d18.freezeDefault : void 0, autoRenewAccountId: null != d18.autoRenewAccount ? y3._fromProtobuf(d18.autoRenewAccount) : void 0, expirationTime: null != d18.expiry ? s3._fromProtobuf(d18.expiry) : void 0, autoRenewPeriod: null != d18.autoRenewPeriod ? s9._fromProtobuf(d18.autoRenewPeriod) : void 0, tokenMemo: null != d18.memo ? d18.memo : void 0, customFees: null != d18.customFees ? d18.customFees.map(((e40) => null != e40.fixedFee ? l6._fromProtobuf(e40) : null != e40.fractionalFee ? r26._fromProtobuf(e40) : l14._fromProtobuf(e40))) : void 0, tokenType: null != d18.tokenType ? e25._fromCode(d18.tokenType) : void 0, supplyType: null != d18.supplyType ? e26._fromCode(d18.supplyType) : void 0, maxSupply: null != d18.maxSupply ? d18.maxSupply : void 0, metadataKey: null != d18.metadataKey ? t2._fromProtobufKey(d18.metadataKey) : void 0, metadata: null != d18.metadata ? d18.metadata : void 0 }), e39, o32, u22, i17, c17);
  }
  get tokenName() {
    return this._tokenName;
  }
  setTokenName(e39) {
    return this._requireNotFrozen(), this._tokenName = e39, this;
  }
  get tokenSymbol() {
    return this._tokenSymbol;
  }
  setTokenSymbol(e39) {
    return this._requireNotFrozen(), this._tokenSymbol = e39, this;
  }
  get decimals() {
    return this._decimals;
  }
  setDecimals(e39) {
    return this._requireNotFrozen(), this._decimals = e39 instanceof long_default ? e39 : long_default.fromValue(e39), this;
  }
  get initialSupply() {
    return this._initialSupply;
  }
  setInitialSupply(e39) {
    return this._requireNotFrozen(), this._initialSupply = long_default.fromValue(e39), this;
  }
  get treasuryAccountId() {
    return this._treasuryAccountId;
  }
  setTreasuryAccountId(e39) {
    return this._requireNotFrozen(), this._treasuryAccountId = "string" == typeof e39 ? y3.fromString(e39) : e39.clone(), this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(e39) {
    return this._requireNotFrozen(), this._adminKey = e39, this;
  }
  get kycKey() {
    return this._kycKey;
  }
  setKycKey(e39) {
    return this._requireNotFrozen(), this._kycKey = e39, this;
  }
  get freezeKey() {
    return this._freezeKey;
  }
  freezeWith(e39) {
    var _a2, _b;
    return !this._autoRenewAccountId && ((_a2 = this.transactionId) == null ? void 0 : _a2.accountId) && null != this.autoRenewPeriod ? this.setAutoRenewAccountId((_b = this.transactionId) == null ? void 0 : _b.accountId) : !this._autoRenewAccountId && (e39 == null ? void 0 : e39.operatorAccountId) && null != this.autoRenewPeriod && this.setAutoRenewAccountId(e39.operatorAccountId), super.freezeWith(e39);
  }
  setFreezeKey(e39) {
    return this._requireNotFrozen(), this._freezeKey = e39, this;
  }
  get pauseKey() {
    return this._pauseKey;
  }
  setPauseKey(e39) {
    return this._requireNotFrozen(), this._pauseKey = e39, this;
  }
  get wipeKey() {
    return this._wipeKey;
  }
  setWipeKey(e39) {
    return this._requireNotFrozen(), this._wipeKey = e39, this;
  }
  get supplyKey() {
    return this._supplyKey;
  }
  setSupplyKey(e39) {
    return this._requireNotFrozen(), this._supplyKey = e39, this;
  }
  get feeScheduleKey() {
    return this._feeScheduleKey;
  }
  setFeeScheduleKey(e39) {
    return this._requireNotFrozen(), this._feeScheduleKey = e39, this;
  }
  get freezeDefault() {
    return this._freezeDefault;
  }
  setFreezeDefault(e39) {
    return this._requireNotFrozen(), this._freezeDefault = e39, this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(e39) {
    return this._requireNotFrozen(), this._expirationTime = e39 instanceof s3 ? e39 : s3.fromDate(e39), this._autoRenewPeriod = null, this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(e39) {
    return this._requireNotFrozen(), this._autoRenewAccountId = e39 instanceof y3 ? e39 : y3.fromString(e39), this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(e39) {
    return this._requireNotFrozen(), this._autoRenewPeriod = e39 instanceof s9 ? e39 : new s9(e39), this;
  }
  get tokenMemo() {
    return this._tokenMemo;
  }
  setTokenMemo(e39) {
    return this._requireNotFrozen(), this._tokenMemo = e39, this;
  }
  get customFees() {
    return this._customFees;
  }
  setCustomFees(e39) {
    return this._customFees = e39, this;
  }
  get tokenType() {
    return this._tokenType;
  }
  setTokenType(e39) {
    return this._tokenType = e39, this;
  }
  get supplyType() {
    return this._supplyType;
  }
  setSupplyType(e39) {
    return this._supplyType = e39, this;
  }
  get maxSupply() {
    return this._maxSupply;
  }
  setMaxSupply(e39) {
    return this._maxSupply = "number" == typeof e39 ? long_default.fromNumber(e39) : e39, this;
  }
  get metadataKey() {
    return this._metadataKey;
  }
  setMetadataKey(e39) {
    return this._requireNotFrozen(), this._metadataKey = e39, this;
  }
  get metadata() {
    return this._metadata;
  }
  setMetadata(e39) {
    return this._requireNotFrozen(), this._metadata = e39, this;
  }
  _validateChecksums(e39) {
    null != this._treasuryAccountId && this._treasuryAccountId.validateChecksum(e39), null != this._autoRenewAccountId && this._autoRenewAccountId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.token.createToken(t35);
  }
  _getTransactionDataCase() {
    return "tokenCreation";
  }
  _makeTransactionData() {
    return { name: this._tokenName, symbol: this._tokenSymbol, decimals: null != this._decimals ? this._decimals.toInt() : null, initialSupply: this._initialSupply, treasury: null != this._treasuryAccountId ? this._treasuryAccountId._toProtobuf() : null, adminKey: null != this._adminKey ? this._adminKey._toProtobufKey() : null, kycKey: null != this._kycKey ? this._kycKey._toProtobufKey() : null, freezeKey: null != this._freezeKey ? this._freezeKey._toProtobufKey() : null, pauseKey: null != this._pauseKey ? this._pauseKey._toProtobufKey() : null, wipeKey: null != this._wipeKey ? this._wipeKey._toProtobufKey() : null, supplyKey: null != this._supplyKey ? this._supplyKey._toProtobufKey() : null, feeScheduleKey: null != this._feeScheduleKey ? this._feeScheduleKey._toProtobufKey() : null, freezeDefault: this._freezeDefault, autoRenewAccount: null != this._autoRenewAccountId ? this._autoRenewAccountId._toProtobuf() : null, expiry: null != this._expirationTime ? this._expirationTime._toProtobuf() : null, autoRenewPeriod: null != this._autoRenewPeriod ? this._autoRenewPeriod._toProtobuf() : null, memo: this._tokenMemo, customFees: this.customFees.map(((e39) => e39._toProtobuf())), tokenType: null != this._tokenType ? this._tokenType._code : null, supplyType: null != this._supplyType ? this._supplyType._code : null, maxSupply: this.maxSupply, metadataKey: null != this._metadataKey ? this._metadataKey._toProtobufKey() : null, metadata: null != this._metadata ? this._metadata : void 0 };
  }
  _getLogId() {
    return `TokenCreateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenCreation", _3._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenDeleteTransaction.js
var n19 = class _n extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, null != t35.tokenId && this.setTokenId(t35.tokenId);
  }
  static _fromProtobuf(o32, r41, s26, i17, a23) {
    const k3 = a23[0].tokenDeletion;
    return P._fromProtobufTransactions(new _n({ tokenId: null != k3.token ? c4._fromProtobuf(k3.token) : void 0 }), o32, r41, s26, i17, a23);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(e39) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof e39 ? c4.fromString(e39) : e39.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.token.deleteToken(e39);
  }
  _getTransactionDataCase() {
    return "tokenDeletion";
  }
  _makeTransactionData() {
    return { token: null != this._tokenId ? this._tokenId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenDeletion", n19._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenFeeScheduleUpdateTransaction.js
var u17 = class _u extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, this._customFees = [], null != t35.tokenId && this.setTokenId(t35.tokenId), null != t35.customFees && this.setCustomFees(t35.customFees);
  }
  static _fromProtobuf(o32, i17, a23, m6, d18) {
    const c17 = d18[0].tokenFeeScheduleUpdate;
    return P._fromProtobufTransactions(new _u({ tokenId: null != c17.tokenId ? c4._fromProtobuf(c17.tokenId) : void 0, customFees: null != c17.customFees ? c17.customFees.map(((t35) => null != t35.fixedFee ? l6._fromProtobuf(t35) : null != t35.fractionalFee ? r26._fromProtobuf(t35) : l14._fromProtobuf(t35))) : void 0 }), o32, i17, a23, m6, d18);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(e39) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof e39 ? c4.fromString(e39) : c4._fromProtobuf(e39._toProtobuf()), this;
  }
  get customFees() {
    return this._customFees;
  }
  setCustomFees(t35) {
    return this._requireNotFrozen(), this._customFees = t35, this;
  }
  _execute(t35, e39) {
    return t35.token.updateTokenFeeSchedule(e39);
  }
  _getTransactionDataCase() {
    return "tokenFeeScheduleUpdate";
  }
  _makeTransactionData() {
    return { tokenId: null != this._tokenId ? this._tokenId._toProtobuf() : null, customFees: this._customFees.map(((t35) => t35._toProtobuf())) };
  }
  _getLogId() {
    return `TokenFeeScheduleUpdateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenFeeScheduleUpdate", u17._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenFreezeTransaction.js
var r27 = class _r extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, this._accountId = null, null != t35.tokenId && this.setTokenId(t35.tokenId), null != t35.accountId && this.setAccountId(t35.accountId);
  }
  static _fromProtobuf(e39, c17, u22, s26, a23) {
    const i17 = a23[0].tokenFreeze;
    return P._fromProtobufTransactions(new _r({ tokenId: null != i17.token ? c4._fromProtobuf(i17.token) : void 0, accountId: null != i17.account ? y3._fromProtobuf(i17.account) : void 0 }), e39, c17, u22, s26, a23);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(o32) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof o32 ? c4.fromString(o32) : o32.clone(), this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35), null != this._accountId && this._accountId.validateChecksum(t35);
  }
  _execute(t35, o32) {
    return t35.token.freezeTokenAccount(o32);
  }
  _getTransactionDataCase() {
    return "tokenFreeze";
  }
  _makeTransactionData() {
    return { token: null != this._tokenId ? this._tokenId._toProtobuf() : null, account: null != this._accountId ? this._accountId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenFreezeTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenFreeze", r27._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenGrantKycTransaction.js
var r28 = class _r extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, this._accountId = null, null != t35.tokenId && this.setTokenId(t35.tokenId), null != t35.accountId && this.setAccountId(t35.accountId);
  }
  static _fromProtobuf(e39, c17, u22, s26, a23) {
    const i17 = a23[0].tokenGrantKyc;
    return P._fromProtobufTransactions(new _r({ tokenId: null != i17.token ? c4._fromProtobuf(i17.token) : void 0, accountId: null != i17.account ? y3._fromProtobuf(i17.account) : void 0 }), e39, c17, u22, s26, a23);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(n31) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof n31 ? c4.fromString(n31) : n31.clone(), this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35), null != this._accountId && this._accountId.validateChecksum(t35);
  }
  _execute(t35, n31) {
    return t35.token.grantKycToTokenAccount(n31);
  }
  _getTransactionDataCase() {
    return "tokenGrantKyc";
  }
  _makeTransactionData() {
    return { token: null != this._tokenId ? this._tokenId._toProtobuf() : null, account: null != this._accountId ? this._accountId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenGrantKycTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenGrantKyc", r28._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenInfo.js
var s15 = __toESM(require_lib(), 1);
var d13 = class _d {
  constructor(e39) {
    this.tokenId = e39.tokenId, this.name = e39.name, this.symbol = e39.symbol, this.decimals = e39.decimals, this.totalSupply = e39.totalSupply, this.treasuryAccountId = e39.treasuryAccountId, this.adminKey = e39.adminKey, this.kycKey = e39.kycKey, this.freezeKey = e39.freezeKey, this.pauseKey = e39.pauseKey, this.wipeKey = e39.wipeKey, this.supplyKey = e39.supplyKey, this.feeScheduleKey = e39.feeScheduleKey, this.defaultFreezeStatus = e39.defaultFreezeStatus, this.defaultKycStatus = e39.defaultKycStatus, this.pauseStatus = e39.pauseStatus, this.isDeleted = e39.isDeleted, this.autoRenewAccountId = e39.autoRenewAccountId, this.autoRenewPeriod = e39.autoRenewPeriod, this.expirationTime = e39.expirationTime, this.tokenMemo = e39.tokenMemo, this.customFees = e39.customFees, this.tokenType = e39.tokenType, this.supplyType = e39.supplyType, this.maxSupply = e39.maxSupply, this.ledgerId = e39.ledgerId, this.metadataKey = e39.metadataKey, this.metadata = e39.metadata;
  }
  static _fromProtobuf(s26) {
    const f4 = s26.defaultFreezeStatus, h8 = s26.defaultKycStatus, K = s26.pauseStatus, c17 = null != s26.autoRenewAccount ? y3._fromProtobuf(s26.autoRenewAccount) : new y3(0);
    return new _d({ tokenId: c4._fromProtobuf(s26.tokenId), name: s26.name, symbol: s26.symbol, decimals: s26.decimals, totalSupply: long_default.fromValue(s26.totalSupply), treasuryAccountId: null != s26.treasury ? y3._fromProtobuf(s26.treasury) : null, adminKey: null != s26.adminKey ? t2._fromProtobufKey(s26.adminKey) : null, kycKey: null != s26.kycKey ? t2._fromProtobufKey(s26.kycKey) : null, freezeKey: null != s26.freezeKey ? t2._fromProtobufKey(s26.freezeKey) : null, pauseKey: null != s26.pauseKey ? t2._fromProtobufKey(s26.pauseKey) : null, wipeKey: null != s26.wipeKey ? t2._fromProtobufKey(s26.wipeKey) : null, supplyKey: null != s26.supplyKey ? t2._fromProtobufKey(s26.supplyKey) : null, feeScheduleKey: null != s26.feeScheduleKey ? t2._fromProtobufKey(s26.feeScheduleKey) : null, defaultFreezeStatus: 0 === f4 ? null : 1 == f4, defaultKycStatus: 0 === h8 ? null : 1 == h8, pauseStatus: 0 === K ? null : 1 == K, isDeleted: s26.deleted, autoRenewAccountId: 0 != c17.shard.toInt() || 0 != c17.realm.toInt() || 0 != c17.num.toInt() ? c17 : null, autoRenewPeriod: null != s26.autoRenewPeriod ? s9._fromProtobuf(s26.autoRenewPeriod) : null, expirationTime: null != s26.expiry ? s3._fromProtobuf(s26.expiry) : null, tokenMemo: null != s26.memo ? s26.memo : "", customFees: null != s26.customFees ? s26.customFees.map(((e39) => null != e39.fixedFee ? l6._fromProtobuf(e39) : null != e39.fractionalFee ? r26._fromProtobuf(e39) : l14._fromProtobuf(e39))) : [], tokenType: null != s26.tokenType ? e25._fromCode(s26.tokenType) : null, supplyType: null != s26.supplyType ? e26._fromCode(s26.supplyType) : null, maxSupply: null != s26.maxSupply ? s26.maxSupply : null, ledgerId: null != s26.ledgerId ? r15.fromBytes(s26.ledgerId) : null, metadataKey: null != s26.metadataKey ? t2._fromProtobufKey(s26.metadataKey) : null, metadata: null != s26.metadata ? s26.metadata : new Uint8Array() });
  }
  _toProtobuf() {
    return { tokenId: this.tokenId._toProtobuf(), name: this.name, symbol: this.symbol, decimals: this.decimals, totalSupply: this.totalSupply, treasury: null != this.treasuryAccountId ? this.treasuryAccountId._toProtobuf() : null, adminKey: null != this.adminKey ? this.adminKey._toProtobufKey() : null, kycKey: null != this.kycKey ? this.kycKey._toProtobufKey() : null, freezeKey: null != this.freezeKey ? this.freezeKey._toProtobufKey() : null, pauseKey: null != this.pauseKey ? this.pauseKey._toProtobufKey() : null, wipeKey: null != this.wipeKey ? this.wipeKey._toProtobufKey() : null, supplyKey: null != this.supplyKey ? this.supplyKey._toProtobufKey() : null, feeScheduleKey: null != this.feeScheduleKey ? this.feeScheduleKey._toProtobufKey() : null, defaultFreezeStatus: null == this.defaultFreezeStatus ? 0 : this.defaultFreezeStatus ? 1 : 2, defaultKycStatus: null == this.defaultKycStatus ? 0 : this.defaultKycStatus ? 1 : 2, pauseStatus: null == this.pauseStatus ? 0 : this.pauseStatus ? 1 : 2, deleted: this.isDeleted, autoRenewAccount: null != this.autoRenewAccountId ? this.autoRenewAccountId._toProtobuf() : void 0, autoRenewPeriod: null != this.autoRenewPeriod ? this.autoRenewPeriod._toProtobuf() : null, expiry: null != this.expirationTime ? this.expirationTime._toProtobuf() : null, memo: this.tokenMemo, customFees: this.customFees.map(((e39) => e39._toProtobuf())), tokenType: null != this.tokenType ? this.tokenType._code : null, supplyType: null != this.supplyType ? this.supplyType._code : null, maxSupply: this.maxSupply, ledgerId: null != this.ledgerId ? this.ledgerId.toBytes() : null, metadataKey: null != this.metadataKey ? this.metadataKey._toProtobufKey() : null, metadata: null != this.metadata ? this.metadata : null };
  }
  static fromBytes(e39) {
    return _d._fromProtobuf(s15.proto.TokenInfo.decode(e39));
  }
  toBytes() {
    return s15.proto.TokenInfo.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenInfoQuery.js
var r29 = class _r extends h3 {
  constructor(t35 = {}) {
    super(), this._tokenId = null, null != t35.tokenId && this.setTokenId(t35.tokenId);
  }
  static _fromProtobuf(t35) {
    const e39 = t35.tokenGetInfo;
    return new _r({ tokenId: null != e39.token ? c4._fromProtobuf(e39.token) : void 0 });
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(t35) {
    return this._tokenId = "string" == typeof t35 ? c4.fromString(t35) : t35.clone(), this;
  }
  async getCost(t35) {
    return super.getCost(t35);
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.token.getTokenInfo(e39);
  }
  _mapResponseHeader(t35) {
    return t35.tokenGetInfo.header;
  }
  _mapResponse(t35, e39, o32) {
    const r41 = t35.tokenGetInfo;
    return Promise.resolve(d13._fromProtobuf(r41.tokenInfo));
  }
  _onMakeRequest(t35) {
    return { tokenGetInfo: { header: t35, token: null != this._tokenId ? this._tokenId._toProtobuf() : null } };
  }
  _getLogId() {
    return `TokenInfoQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("tokenGetInfo", r29._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenMintTransaction.js
var r30 = class _r extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, this._amount = null, this._metadata = [], null != t35.tokenId && this.setTokenId(t35.tokenId), null != t35.amount && this.setAmount(t35.amount), null != t35.metadata && this.setMetadata(t35.metadata);
  }
  static _fromProtobuf(n31, a23, o32, s26, i17) {
    const d18 = i17[0].tokenMint;
    return P._fromProtobufTransactions(new _r({ tokenId: null != d18.token ? c4._fromProtobuf(d18.token) : void 0, amount: null != d18.amount ? d18.amount : void 0, metadata: null != d18.metadata ? d18.metadata : void 0 }), n31, a23, o32, s26, i17);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(e39) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof e39 ? c4.fromString(e39) : e39.clone(), this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(t35) {
    return this._requireNotFrozen(), this._amount = t35 instanceof long_default ? t35 : long_default.fromValue(t35), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35);
  }
  get metadata() {
    return this._metadata;
  }
  addMetadata(t35) {
    return this._requireNotFrozen(), "string" == typeof t35 && console.warn("Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead."), this._metadata.push("string" == typeof t35 ? r(t35) : t35), this;
  }
  setMetadata(t35) {
    this._requireNotFrozen();
    for (const e39 of t35) if ("string" == typeof e39) {
      console.warn("Passing a `string` for token metadata is considered a bug, and has been removed. Please provide a `Uint8Array` instead.");
      break;
    }
    return this._metadata = t35.map(((t36) => "string" == typeof t36 ? r(t36) : t36)), this;
  }
  _execute(t35, e39) {
    return t35.token.mintToken(e39);
  }
  _getTransactionDataCase() {
    return "tokenMint";
  }
  _makeTransactionData() {
    return { amount: this._amount, token: null != this._tokenId ? this._tokenId._toProtobuf() : null, metadata: this._metadata };
  }
  _getLogId() {
    return `TokenMintTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenMint", r30._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenNftInfo.js
var n20 = class _n {
  constructor(t35) {
    this.nftId = t35.nftId, this.accountId = t35.accountId, this.creationTime = t35.creationTime, this.metadata = t35.metadata, this.ledgerId = t35.ledgerId, this.spenderId = t35.spenderId, Object.freeze(this);
  }
  static _fromProtobuf(o32) {
    return new _n({ nftId: e9._fromProtobuf(o32.nftID), accountId: y3._fromProtobuf(o32.accountID), creationTime: s3._fromProtobuf(o32.creationTime), metadata: void 0 !== o32.metadata ? o32.metadata : null, ledgerId: null != o32.ledgerId ? r15.fromBytes(o32.ledgerId) : null, spenderId: null != o32.spenderId ? y3._fromProtobuf(o32.spenderId) : null });
  }
  _toProtobuf() {
    return { nftID: this.nftId._toProtobuf(), accountID: this.accountId._toProtobuf(), creationTime: this.creationTime._toProtobuf(), metadata: this.metadata, ledgerId: null != this.ledgerId ? this.ledgerId.toBytes() : null, spenderId: null != this.spenderId ? this.spenderId._toProtobuf() : null };
  }
  toJson() {
    return { nftId: this.nftId.toString(), accountId: this.accountId.toString(), creationTime: this.creationTime.toString(), metadata: null != this.metadata ? n(this.metadata) : null, ledgerId: null != this.ledgerId ? this.ledgerId.toString() : null, spenderId: null != this.spenderId ? this.spenderId.toString() : null };
  }
  toString() {
    return JSON.stringify(this.toJson());
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenNftInfoQuery.js
var u18 = class _u extends h3 {
  constructor(t35 = {}) {
    super(), this._nftId = null, null != t35.nftId && this.setNftId(t35.nftId), this._accountId = null, null != t35.accountId && this.setAccountId(t35.accountId), this._tokenId = null, null != t35.tokenId && this.setTokenId(t35.tokenId), this._start = null, null != t35.start && this.setStart(t35.start), this._end = null, null != t35.end && this.setEnd(t35.end);
  }
  static _fromProtobuf(t35) {
    if (null != t35.tokenGetNftInfo) {
      const e39 = t35.tokenGetNftInfo;
      return new _u({ nftId: null != e39.nftID ? e9._fromProtobuf(e39.nftID) : void 0 });
    }
    if (null != t35.tokenGetAccountNftInfos) {
      const e39 = t35.tokenGetAccountNftInfos;
      return new _u({ accountId: null != e39.accountID ? y3._fromProtobuf(e39.accountID) : void 0, start: null != e39.start ? e39.start : void 0, end: null != e39.end ? e39.end : void 0 });
    }
    {
      const e39 = t35.tokenGetNftInfos;
      return new _u({ tokenId: null != e39.tokenID ? c4._fromProtobuf(e39.tokenID) : void 0, start: null != e39.start ? e39.start : void 0, end: null != e39.end ? e39.end : void 0 });
    }
  }
  get nftId() {
    return this._nftId;
  }
  setNftId(t35) {
    return this._nftId = "string" == typeof t35 ? e9.fromString(t35) : e9._fromProtobuf(t35._toProtobuf()), this;
  }
  get accountId() {
    return console.warn("`TokenNftInfoQuery.accountId` is deprecated with no replacement"), this._accountId;
  }
  setAccountId(t35) {
    return console.warn("`TokenNftInfoQuery.setAccountId()` is deprecated with no replacement"), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : y3._fromProtobuf(t35._toProtobuf()), this;
  }
  get tokenId() {
    return console.warn("`TokenNftInfoQuery.tokenId` is deprecated with no replacement"), this._tokenId;
  }
  setTokenId(t35) {
    return console.warn("`TokenNftInfoQuery.setTokenId()` is deprecated with no replacement"), this._tokenId = "string" == typeof t35 ? c4.fromString(t35) : c4._fromProtobuf(t35._toProtobuf()), this;
  }
  get start() {
    return console.warn("`TokenNftInfoQuery.start` is deprecated with no replacement"), this._start;
  }
  setStart(t35) {
    return console.warn("`TokenNftInfoQuery.setStart()` is deprecated with no replacement"), this._start = "number" == typeof t35 ? long_default.fromNumber(t35) : t35, this;
  }
  get end() {
    return console.warn("`TokenNftInfoQuery.end` is deprecated with no replacement"), this._end;
  }
  setEnd(t35) {
    return console.warn("`TokenNftInfoQuery.setEnd()` is deprecated with no replacement"), this._end = "number" == typeof t35 ? long_default.fromNumber(t35) : t35, this;
  }
  async getCost(t35) {
    return super.getCost(t35);
  }
  _execute(t35, e39) {
    return t35.token.getTokenNftInfo(e39);
  }
  _mapResponseHeader(t35) {
    return t35.tokenGetNftInfo.header;
  }
  _mapResponse(t35, e39, n31) {
    const o32 = [t35.tokenGetNftInfo.nft];
    return Promise.resolve(o32.map(((t36) => n20._fromProtobuf(t36))));
  }
  _onMakeRequest(t35) {
    return { tokenGetNftInfo: { header: t35, nftID: null != this._nftId ? this._nftId._toProtobuf() : null } };
  }
  _getLogId() {
    return `TokenNftInfoQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("tokenGetNftInfo", u18._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenPauseTransaction.js
var n21 = class _n extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, null != t35.tokenId && this.setTokenId(t35.tokenId);
  }
  static _fromProtobuf(o32, r41, s26, a23, u22) {
    const i17 = u22[0].tokenPause;
    return P._fromProtobufTransactions(new _n({ tokenId: null != i17.token ? c4._fromProtobuf(i17.token) : void 0 }), o32, r41, s26, a23, u22);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(e39) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof e39 ? c4.fromString(e39) : e39.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.token.pauseToken(e39);
  }
  _getTransactionDataCase() {
    return "tokenPause";
  }
  _makeTransactionData() {
    return { token: null != this._tokenId ? this._tokenId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenPauseTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenPause", n21._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenRevokeKycTransaction.js
var r31 = class _r extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, this._accountId = null, null != t35.tokenId && this.setTokenId(t35.tokenId), null != t35.accountId && this.setAccountId(t35.accountId);
  }
  static _fromProtobuf(e39, c17, u22, s26, a23) {
    const i17 = a23[0].tokenRevokeKyc;
    return P._fromProtobufTransactions(new _r({ tokenId: null != i17.token ? c4._fromProtobuf(i17.token) : void 0, accountId: null != i17.account ? y3._fromProtobuf(i17.account) : void 0 }), e39, c17, u22, s26, a23);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(o32) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof o32 ? c4.fromString(o32) : o32.clone(), this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35), null != this._accountId && this._accountId.validateChecksum(t35);
  }
  _execute(t35, o32) {
    return t35.token.revokeKycFromTokenAccount(o32);
  }
  _getTransactionDataCase() {
    return "tokenRevokeKyc";
  }
  _makeTransactionData() {
    return { token: null != this._tokenId ? this._tokenId._toProtobuf() : null, account: null != this._accountId ? this._accountId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenRevokeKycTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenRevokeKyc", r31._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenUnfreezeTransaction.js
var r32 = class _r extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, this._accountId = null, null != t35.tokenId && this.setTokenId(t35.tokenId), null != t35.accountId && this.setAccountId(t35.accountId);
  }
  static _fromProtobuf(e39, u22, c17, s26, a23) {
    const i17 = a23[0].tokenUnfreeze;
    return P._fromProtobufTransactions(new _r({ tokenId: null != i17.token ? c4._fromProtobuf(i17.token) : void 0, accountId: null != i17.account ? y3._fromProtobuf(i17.account) : void 0 }), e39, u22, c17, s26, a23);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(n31) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof n31 ? c4.fromString(n31) : n31.clone(), this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35), null != this._accountId && this._accountId.validateChecksum(t35);
  }
  _execute(t35, n31) {
    return t35.token.unfreezeTokenAccount(n31);
  }
  _getTransactionDataCase() {
    return "tokenUnfreeze";
  }
  _makeTransactionData() {
    return { token: null != this._tokenId ? this._tokenId._toProtobuf() : null, account: null != this._accountId ? this._accountId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenUnfreezeTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenUnfreeze", r32._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenUnpauseTransaction.js
var o24 = class _o extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, null != t35.tokenId && this.setTokenId(t35.tokenId);
  }
  static _fromProtobuf(e39, r41, s26, a23, u22) {
    const i17 = u22[0].tokenUnpause;
    return P._fromProtobufTransactions(new _o({ tokenId: null != i17.token ? c4._fromProtobuf(i17.token) : void 0 }), e39, r41, s26, a23, u22);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(n31) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof n31 ? c4.fromString(n31) : n31.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35);
  }
  _execute(t35, n31) {
    return t35.token.unpauseToken(n31);
  }
  _getTransactionDataCase() {
    return "tokenUnpause";
  }
  _makeTransactionData() {
    return { token: null != this._tokenId ? this._tokenId._toProtobuf() : null };
  }
  _getLogId() {
    return `TokenUnpauseTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenUnpause", o24._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenKeyValidation.js
var t24 = class _t {
  constructor(t35) {
    this._code = t35, Object.freeze(this);
  }
  toString() {
    switch (this) {
      case _t.FullValidation:
        return "FULL_VALIDATION";
      case _t.NoValidation:
        return "NO_VALIDATION";
      default:
        return `UNKNOWN (${this._code})`;
    }
  }
  static _fromCode(e39) {
    switch (e39) {
      case 0:
        return _t.FullValidation;
      case 1:
        return _t.NoValidation;
    }
    throw new Error(`(BUG) TokenKeyValidation.fromCode() does not handle code: ${e39}`);
  }
  valueOf() {
    return this._code;
  }
};
t24.FullValidation = new t24(0), t24.NoValidation = new t24(1);

// node_modules/@hashgraph/sdk/lib/token/TokenUpdateTransaction.js
var a15 = class _a2 extends P {
  constructor(e39 = {}) {
    super(), this._tokenId = null, this._tokenName = null, this._tokenSymbol = null, this._treasuryAccountId = null, this._adminKey = null, this._kycKey = null, this._freezeKey = null, this._wipeKey = null, this._supplyKey = null, this._autoRenewAccountId = null, this._expirationTime = null, this._autoRenewPeriod = null, this._tokenMemo = null, this._feeScheduleKey = null, this._pauseKey = null, this._metadataKey = null, this._metadata = null, this._keyVerificationMode = t24.FullValidation, null != e39.tokenId && this.setTokenId(e39.tokenId), null != e39.tokenName && this.setTokenName(e39.tokenName), null != e39.tokenSymbol && this.setTokenSymbol(e39.tokenSymbol), null != e39.treasuryAccountId && this.setTreasuryAccountId(e39.treasuryAccountId), null != e39.adminKey && this.setAdminKey(e39.adminKey), null != e39.kycKey && this.setKycKey(e39.kycKey), null != e39.freezeKey && this.setFreezeKey(e39.freezeKey), null != e39.wipeKey && this.setWipeKey(e39.wipeKey), null != e39.supplyKey && this.setSupplyKey(e39.supplyKey), null != e39.autoRenewAccountId && this.setAutoRenewAccountId(e39.autoRenewAccountId), null != e39.expirationTime && this.setExpirationTime(e39.expirationTime), null != e39.autoRenewPeriod && this.setAutoRenewPeriod(e39.autoRenewPeriod), null != e39.tokenMemo && this.setTokenMemo(e39.tokenMemo), null != e39.feeScheduleKey && this.setFeeScheduleKey(e39.feeScheduleKey), null != e39.pauseKey && this.setPauseKey(e39.pauseKey), null != e39.metadataKey && this.setMetadataKey(e39.metadataKey), null != e39.metadata && this.setMetadata(e39.metadata), null != e39.keyVerificationMode && this.setKeyVerificationMode(e39.keyVerificationMode);
  }
  static _fromProtobuf(o32, l19, y5, h8, d18) {
    const _4 = d18[0].tokenUpdate;
    return P._fromProtobufTransactions(new _a2({ tokenId: null != _4.token ? c4._fromProtobuf(_4.token) : void 0, tokenName: Object.hasOwn(_4, "name") ? _4.name : void 0, tokenSymbol: Object.hasOwn(_4, "symbol") ? _4.symbol : void 0, treasuryAccountId: null != _4.treasury ? y3._fromProtobuf(_4.treasury) : void 0, adminKey: null != _4.adminKey ? t2._fromProtobufKey(_4.adminKey) : void 0, kycKey: null != _4.kycKey ? t2._fromProtobufKey(_4.kycKey) : void 0, freezeKey: null != _4.freezeKey ? t2._fromProtobufKey(_4.freezeKey) : void 0, wipeKey: null != _4.wipeKey ? t2._fromProtobufKey(_4.wipeKey) : void 0, supplyKey: null != _4.supplyKey ? t2._fromProtobufKey(_4.supplyKey) : void 0, autoRenewAccountId: null != _4.autoRenewAccount ? y3._fromProtobuf(_4.autoRenewAccount) : void 0, expirationTime: null != _4.expiry ? s3._fromProtobuf(_4.expiry) : void 0, autoRenewPeriod: null != _4.autoRenewPeriod ? s9._fromProtobuf(_4.autoRenewPeriod) : void 0, tokenMemo: null != _4.memo && Object.hasOwn(_4.memo, "value") ? _4.memo.value : void 0, feeScheduleKey: null != _4.feeScheduleKey ? t2._fromProtobufKey(_4.feeScheduleKey) : void 0, pauseKey: null != _4.pauseKey ? t2._fromProtobufKey(_4.pauseKey) : void 0, metadataKey: null != _4.metadataKey ? t2._fromProtobufKey(_4.metadataKey) : void 0, metadata: null != _4.metadata && Object.hasOwn(_4.metadata, "value") ? _4.metadata.value : void 0, keyVerificationMode: null != _4.keyVerificationMode ? t24._fromCode(_4.keyVerificationMode) : void 0 }), o32, l19, y5, h8, d18);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(t35) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof t35 ? c4.fromString(t35) : t35.clone(), this;
  }
  get tokenName() {
    return this._tokenName;
  }
  setTokenName(e39) {
    return this._requireNotFrozen(), this._tokenName = e39, this;
  }
  get tokenSymbol() {
    return this._tokenSymbol;
  }
  setTokenSymbol(e39) {
    return this._requireNotFrozen(), this._tokenSymbol = e39, this;
  }
  get treasuryAccountId() {
    return this._treasuryAccountId;
  }
  setTreasuryAccountId(e39) {
    return this._requireNotFrozen(), this._treasuryAccountId = "string" == typeof e39 ? y3.fromString(e39) : e39.clone(), this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(e39) {
    return this._requireNotFrozen(), this._adminKey = e39, this;
  }
  get kycKey() {
    return this._kycKey;
  }
  setKycKey(e39) {
    return this._requireNotFrozen(), this._kycKey = e39, this;
  }
  get freezeKey() {
    return this._freezeKey;
  }
  setFreezeKey(e39) {
    return this._requireNotFrozen(), this._freezeKey = e39, this;
  }
  get wipeKey() {
    return this._wipeKey;
  }
  setWipeKey(e39) {
    return this._requireNotFrozen(), this._wipeKey = e39, this;
  }
  get supplyKey() {
    return this._supplyKey;
  }
  setSupplyKey(e39) {
    return this._requireNotFrozen(), this._supplyKey = e39, this;
  }
  setsupplyKey(e39) {
    return this._requireNotFrozen(), this._supplyKey = e39, this;
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(e39) {
    return this._requireNotFrozen(), this._expirationTime = e39 instanceof s3 ? e39 : s3.fromDate(e39), this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(e39) {
    return this._requireNotFrozen(), this._autoRenewAccountId = e39 instanceof y3 ? e39 : y3.fromString(e39), this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(e39) {
    return this._requireNotFrozen(), this._autoRenewPeriod = e39 instanceof s9 ? e39 : new s9(e39), this;
  }
  get tokenMemo() {
    return this._tokenMemo;
  }
  setTokenMemo(e39) {
    return this._requireNotFrozen(), this._tokenMemo = e39, this;
  }
  get feeScheduleKey() {
    return this._feeScheduleKey;
  }
  setFeeScheduleKey(e39) {
    return this._requireNotFrozen(), this._feeScheduleKey = e39, this;
  }
  get pauseKey() {
    return this._pauseKey;
  }
  setPauseKey(e39) {
    return this._requireNotFrozen(), this._pauseKey = e39, this;
  }
  get metadataKey() {
    return this._metadataKey;
  }
  setMetadataKey(e39) {
    return this._requireNotFrozen(), this._metadataKey = e39, this;
  }
  get metadata() {
    return this._metadata;
  }
  setMetadata(e39) {
    return this._requireNotFrozen(), this._metadata = e39, this;
  }
  get keyVerificationMode() {
    return this._keyVerificationMode;
  }
  setKeyVerificationMode(e39) {
    return this._requireNotFrozen(), this._keyVerificationMode = e39, this;
  }
  clearTokenMemo() {
    return this._requireNotFrozen(), this._tokenMemo = null, this;
  }
  _validateChecksums(e39) {
    null != this._tokenId && this._tokenId.validateChecksum(e39), null != this._treasuryAccountId && this._treasuryAccountId.validateChecksum(e39), null != this._autoRenewAccountId && this._autoRenewAccountId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.token.updateToken(t35);
  }
  _getTransactionDataCase() {
    return "tokenUpdate";
  }
  _makeTransactionData() {
    return { token: null != this._tokenId ? this._tokenId._toProtobuf() : null, name: null != this.tokenName ? this.tokenName : null, symbol: this.tokenSymbol, treasury: null != this._treasuryAccountId ? this._treasuryAccountId._toProtobuf() : null, adminKey: null != this._adminKey ? this._adminKey._toProtobufKey() : null, kycKey: null != this._kycKey ? this._kycKey._toProtobufKey() : null, freezeKey: null != this._freezeKey ? this._freezeKey._toProtobufKey() : null, pauseKey: null != this._pauseKey ? this._pauseKey._toProtobufKey() : null, wipeKey: null != this._wipeKey ? this._wipeKey._toProtobufKey() : null, supplyKey: null != this._supplyKey ? this._supplyKey._toProtobufKey() : null, autoRenewAccount: null != this._autoRenewAccountId ? this._autoRenewAccountId._toProtobuf() : null, expiry: null != this._expirationTime ? this._expirationTime._toProtobuf() : null, autoRenewPeriod: null != this._autoRenewPeriod ? this._autoRenewPeriod._toProtobuf() : null, memo: null != this._tokenMemo ? { value: this._tokenMemo } : null, feeScheduleKey: null != this._feeScheduleKey ? this._feeScheduleKey._toProtobufKey() : null, metadataKey: null != this._metadataKey ? this._metadataKey._toProtobufKey() : null, metadata: null != this._metadata ? { value: this._metadata } : null, keyVerificationMode: null != this._keyVerificationMode ? this._keyVerificationMode._code : void 0 };
  }
  _getLogId() {
    return `TokenUpdateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenUpdate", a15._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/token/TokenWipeTransaction.js
var s16 = class _s extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, this._accountId = null, this._serials = [], this._amount = null, null != t35.tokenId && this.setTokenId(t35.tokenId), null != t35.accountId && this.setAccountId(t35.accountId), null != t35.amount && this.setAmount(t35.amount), null != t35.serials && this.setSerials(t35.serials);
  }
  static _fromProtobuf(e39, r41, u22, i17, a23) {
    const c17 = a23[0].tokenWipe;
    return P._fromProtobufTransactions(new _s({ tokenId: null != c17.token ? c4._fromProtobuf(c17.token) : void 0, accountId: null != c17.account ? y3._fromProtobuf(c17.account) : void 0, amount: null != c17.amount ? c17.amount : void 0, serials: null != c17.serialNumbers ? c17.serialNumbers : void 0 }), e39, r41, u22, i17, a23);
  }
  get tokenId() {
    return this._tokenId;
  }
  setTokenId(o32) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof o32 ? c4.fromString(o32) : o32.clone(), this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(t35) {
    return this._requireNotFrozen(), this._accountId = "string" == typeof t35 ? y3.fromString(t35) : t35.clone(), this;
  }
  get amount() {
    return this._amount;
  }
  setAmount(t35) {
    return this._requireNotFrozen(), this._amount = t35 instanceof long_default ? t35 : long_default.fromValue(t35), this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35), null != this._accountId && this._accountId.validateChecksum(t35);
  }
  get serials() {
    return this._serials;
  }
  setSerials(t35) {
    return this._requireNotFrozen(), this._serials = t35.map(((t36) => "number" == typeof t36 ? long_default.fromNumber(t36) : t36)), this;
  }
  _execute(t35, o32) {
    return t35.token.wipeTokenAccount(o32);
  }
  _getTransactionDataCase() {
    return "tokenWipe";
  }
  _makeTransactionData() {
    return { amount: this._amount, token: null != this._tokenId ? this._tokenId._toProtobuf() : null, account: null != this._accountId ? this._accountId._toProtobuf() : null, serialNumbers: this.serials };
  }
  _getLogId() {
    return `TokenWipeTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenWipe", s16._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/topic/TopicCreateTransaction.js
var c13 = class _c extends P {
  constructor(e39 = {}) {
    super(), this._defaultMaxTransactionFee = new e4(25), this._adminKey = null, this._submitKey = null, this._feeScheduleKey = null, this._feeExemptKeys = [], this._autoRenewAccountId = null, this._autoRenewPeriod = new s9(w3), this._customFees = [], this._topicMemo = null, null != e39.adminKey && this.setAdminKey(e39.adminKey), null != e39.submitKey && this.setSubmitKey(e39.submitKey), null != e39.feeScheduleKey && this.setFeeScheduleKey(e39.feeScheduleKey), null != e39.feeExemptKeys && this.setFeeExemptKeys(e39.feeExemptKeys), null != e39.autoRenewAccountId && this.setAutoRenewAccountId(e39.autoRenewAccountId), null != e39.autoRenewPeriod && this.setAutoRenewPeriod(e39.autoRenewPeriod), null != e39.customFees && this.setCustomFees(e39.customFees), null != e39.topicMemo && this.setTopicMemo(e39.topicMemo);
  }
  static _fromProtobuf(s26, u22, i17, r41, m6) {
    const h8 = m6[0].consensusCreateTopic;
    return P._fromProtobufTransactions(new _c({ adminKey: null != h8.adminKey ? t2._fromProtobufKey(h8.adminKey) : void 0, submitKey: null != h8.submitKey ? t2._fromProtobufKey(h8.submitKey) : void 0, feeScheduleKey: null != h8.feeScheduleKey ? t2._fromProtobufKey(h8.feeScheduleKey) : void 0, feeExemptKeys: null != h8.feeExemptKeyList ? h8.feeExemptKeyList.map(((e39) => t2._fromProtobufKey(e39))) : void 0, autoRenewAccountId: null != h8.autoRenewAccount ? y3._fromProtobuf(h8.autoRenewAccount) : void 0, autoRenewPeriod: null != h8.autoRenewPeriod && null != h8.autoRenewPeriod.seconds ? h8.autoRenewPeriod.seconds : void 0, customFees: null != h8.customFees ? h8.customFees.map(((e39) => l6._fromProtobuf(e39))) : void 0, topicMemo: null != h8.memo ? h8.memo : void 0 }), s26, u22, i17, r41, m6);
  }
  get topicMemo() {
    return this._topicMemo;
  }
  getTopicMemo() {
    return this._topicMemo;
  }
  setTopicMemo(e39) {
    return this._requireNotFrozen(), this._topicMemo = e39, this;
  }
  get adminKey() {
    return this._adminKey;
  }
  getAdminKey() {
    return this._adminKey;
  }
  setAdminKey(e39) {
    return this._requireNotFrozen(), this._adminKey = e39, this;
  }
  get submitKey() {
    return this._submitKey;
  }
  getSubmitKey() {
    return this._submitKey;
  }
  setSubmitKey(e39) {
    return this._requireNotFrozen(), this._submitKey = e39, this;
  }
  getFeeScheduleKey() {
    return this._feeScheduleKey;
  }
  setFeeScheduleKey(e39) {
    return this._requireNotFrozen(), this._feeScheduleKey = e39, this;
  }
  getFeeExemptKeys() {
    return this._feeExemptKeys;
  }
  setFeeExemptKeys(e39) {
    return this._requireNotFrozen(), this._feeExemptKeys = e39, this;
  }
  addFeeExemptKey(e39) {
    return this._requireNotFrozen(), this._feeExemptKeys.push(e39), this;
  }
  clearFeeExemptKeys() {
    return this._requireNotFrozen(), this._feeExemptKeys = [], this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  getAutoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(t35) {
    return this._requireNotFrozen(), this._autoRenewAccountId = t35 instanceof y3 ? t35 : y3.fromString(t35), this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  getAutoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(e39) {
    return this._requireNotFrozen(), this._autoRenewPeriod = e39 instanceof s9 ? e39 : new s9(e39), this;
  }
  getCustomFees() {
    return this._customFees;
  }
  setCustomFees(e39) {
    return this._requireNotFrozen(), this._customFees = e39, this;
  }
  addCustomFee(e39) {
    return this._requireNotFrozen(), this._customFees.push(e39), this;
  }
  clearCustomFees() {
    return this._requireNotFrozen(), this._customFees = [], this;
  }
  _validateChecksums(e39) {
    null != this._autoRenewAccountId && this._autoRenewAccountId.validateChecksum(e39);
  }
  freezeWith(e39) {
    var _a2, _b;
    return !this._autoRenewAccountId && ((_a2 = this.transactionId) == null ? void 0 : _a2.accountId) ? this.setAutoRenewAccountId((_b = this.transactionId) == null ? void 0 : _b.accountId) : !this._autoRenewAccountId && (e39 == null ? void 0 : e39.operatorAccountId) && this.setAutoRenewAccountId(e39.operatorAccountId), super.freezeWith(e39);
  }
  _execute(e39, t35) {
    return e39.consensus.createTopic(t35);
  }
  _getTransactionDataCase() {
    return "consensusCreateTopic";
  }
  _makeTransactionData() {
    return { adminKey: null != this._adminKey ? this._adminKey._toProtobufKey() : null, submitKey: null != this._submitKey ? this._submitKey._toProtobufKey() : null, feeScheduleKey: null != this._feeScheduleKey ? this._feeScheduleKey._toProtobufKey() : null, feeExemptKeyList: this._feeExemptKeys.map(((e39) => e39._toProtobufKey())), autoRenewAccount: null != this._autoRenewAccountId ? this._autoRenewAccountId._toProtobuf() : null, autoRenewPeriod: this._autoRenewPeriod._toProtobuf(), customFees: this._customFees.map(((e39) => e39._toTopicFeeProtobuf())), memo: this._topicMemo };
  }
  _getLogId() {
    return `TopicCreateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("consensusCreateTopic", c13._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/topic/TopicDeleteTransaction.js
var i11 = class _i extends P {
  constructor(t35 = {}) {
    super(), this._topicId = null, null != t35.topicId && this.setTopicId(t35.topicId);
  }
  static _fromProtobuf(o32, s26, r41, n31, c17) {
    const a23 = c17[0].consensusDeleteTopic;
    return P._fromProtobufTransactions(new _i({ topicId: null != a23.topicID ? d4._fromProtobuf(a23.topicID) : void 0 }), o32, s26, r41, n31, c17);
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(t35) {
    return this._requireNotFrozen(), this._topicId = "string" == typeof t35 ? d4.fromString(t35) : t35.clone(), this;
  }
  _validateChecksums(t35) {
    null != this._topicId && this._topicId.validateChecksum(t35);
  }
  _execute(t35, o32) {
    return t35.consensus.deleteTopic(o32);
  }
  _getTransactionDataCase() {
    return "consensusDeleteTopic";
  }
  _makeTransactionData() {
    return { topicID: null != this._topicId ? this._topicId._toProtobuf() : null };
  }
  _getLogId() {
    return `TopicDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("consensusDeleteTopic", i11._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/topic/TopicInfo.js
var i12 = __toESM(require_lib(), 1);
var l15 = class _l {
  constructor(e39) {
    this.topicId = e39.topicId, this.topicMemo = e39.topicMemo, this.runningHash = e39.runningHash, this.sequenceNumber = e39.sequenceNumber, this.expirationTime = e39.expirationTime, this.adminKey = e39.adminKey, this.submitKey = e39.submitKey, this.feeScheduleKey = e39.feeScheduleKey, this.feeExemptKeys = e39.feeExemptKeys, this.autoRenewPeriod = e39.autoRenewPeriod, this.autoRenewAccountId = e39.autoRenewAccountId, this.customFees = e39.customFees, this.ledgerId = e39.ledgerId, Object.freeze(this);
  }
  static _fromProtobuf(i17) {
    const c17 = i17.topicInfo;
    return new _l({ topicId: d4._fromProtobuf(i17.topicID), topicMemo: null != c17.memo ? c17.memo : "", runningHash: null != c17.runningHash ? c17.runningHash : new Uint8Array(), sequenceNumber: null != c17.sequenceNumber ? c17.sequenceNumber instanceof long_default ? c17.sequenceNumber : long_default.fromValue(c17.sequenceNumber) : long_default.ZERO, expirationTime: null != c17.expirationTime ? s3._fromProtobuf(c17.expirationTime) : null, adminKey: null != c17.adminKey ? t2._fromProtobufKey(c17.adminKey) : null, submitKey: null != c17.submitKey ? t2._fromProtobufKey(c17.submitKey) : null, feeScheduleKey: null != c17.feeScheduleKey ? t2._fromProtobufKey(c17.feeScheduleKey) : null, feeExemptKeys: null != c17.feeExemptKeyList ? c17.feeExemptKeyList.map(((e39) => t2._fromProtobufKey(e39))) : null, autoRenewPeriod: null != c17.autoRenewPeriod ? new s9(c17.autoRenewPeriod.seconds) : null, autoRenewAccountId: null != c17.autoRenewAccount ? y3._fromProtobuf(c17.autoRenewAccount) : null, customFees: null != c17.customFees ? c17.customFees.map(((e39) => l6._fromProtobuf(e39))) : null, ledgerId: null != c17.ledgerId ? r15.fromBytes(c17.ledgerId) : null });
  }
  _toProtobuf() {
    return { topicID: this.topicId._toProtobuf(), topicInfo: { memo: this.topicMemo, runningHash: this.runningHash, sequenceNumber: this.sequenceNumber, expirationTime: null != this.expirationTime ? this.expirationTime._toProtobuf() : null, adminKey: null != this.adminKey ? this.adminKey._toProtobufKey() : null, submitKey: null != this.submitKey ? this.submitKey._toProtobufKey() : null, feeScheduleKey: null != this.feeScheduleKey ? this.feeScheduleKey._toProtobufKey() : null, feeExemptKeyList: null != this.feeExemptKeys ? this.feeExemptKeys.map(((e39) => e39._toProtobufKey())) : null, autoRenewPeriod: null != this.autoRenewPeriod ? this.autoRenewPeriod._toProtobuf() : null, autoRenewAccount: null != this.autoRenewAccountId ? this.autoRenewAccountId._toProtobuf() : null, customFees: null != this.customFees ? this.customFees.map(((e39) => e39._toProtobuf())) : null } };
  }
  static fromBytes(e39) {
    return _l._fromProtobuf(i12.proto.ConsensusGetTopicInfoResponse.decode(e39));
  }
  toBytes() {
    return i12.proto.ConsensusGetTopicInfoResponse.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/topic/TopicInfoQuery.js
var n22 = class _n extends h3 {
  constructor(t35 = {}) {
    super(), this._topicId = null, null != t35.topicId && this.setTopicId(t35.topicId);
  }
  static _fromProtobuf(t35) {
    const o32 = t35.consensusGetTopicInfo;
    return new _n({ topicId: null != o32.topicID ? d4._fromProtobuf(o32.topicID) : void 0 });
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(t35) {
    return this._topicId = "string" == typeof t35 ? d4.fromString(t35) : t35.clone(), this;
  }
  async getCost(t35) {
    return super.getCost(t35);
  }
  _validateChecksums(t35) {
    null != this._topicId && this._topicId.validateChecksum(t35);
  }
  _execute(t35, o32) {
    return t35.consensus.getTopicInfo(o32);
  }
  _mapResponseHeader(t35) {
    return t35.consensusGetTopicInfo.header;
  }
  _mapResponse(t35, o32, e39) {
    return Promise.resolve(l15._fromProtobuf(t35.consensusGetTopicInfo));
  }
  _onMakeRequest(t35) {
    return { consensusGetTopicInfo: { header: t35, topicID: null != this._topicId ? this._topicId._toProtobuf() : null } };
  }
  _getLogId() {
    return `TopicInfoQuery:${(null != this._paymentTransactionId && null != this._paymentTransactionId.validStart ? this._paymentTransactionId.validStart : this._timestamp).toString()}`;
  }
};
m3.set("consensusGetTopicInfo", n22._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/topic/TopicMessageSubmitTransaction.js
var u19 = class _u extends P {
  constructor(t35 = {}) {
    super(), this._topicId = null, null != t35.topicId && this.setTopicId(t35.topicId), this._message = null, null != t35.message && this.setMessage(t35.message), this._maxChunks = 20, this._chunkSize = k2, null != t35.maxChunks && this.setMaxChunks(t35.maxChunks), null != t35.chunkSize && this.setChunkSize(t35.chunkSize), this._chunkInfo = null;
  }
  static _fromProtobuf(s26, e39, n31, r41, o32) {
    const h8 = o32[0].consensusSubmitMessage;
    return P._fromProtobufTransactions(new _u({ topicId: null != h8.topicID ? d4._fromProtobuf(h8.topicID) : void 0, message: null != h8.message ? h8.message : void 0 }), s26, e39, n31, r41, o32);
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(t35) {
    return this._requireNotFrozen(), this._topicId = "string" == typeof t35 ? d4.fromString(t35) : t35.clone(), this;
  }
  get message() {
    return this._message;
  }
  getMessage() {
    return this._message;
  }
  setMessage(t35) {
    return this._requireNotFrozen(), t35 = p(t35), this._message = t35 instanceof Uint8Array ? t35 : n8(t35), this;
  }
  getCustomFeeLimits() {
    return this._customFeeLimits;
  }
  setCustomFeeLimits(t35) {
    return this._requireNotFrozen(), this._customFeeLimits = t35, this;
  }
  addCustomFeeLimit(t35) {
    return this._requireNotFrozen(), this._customFeeLimits.push(t35), this;
  }
  get maxChunks() {
    return this._maxChunks;
  }
  getMaxChunks() {
    return this._maxChunks;
  }
  setMaxChunks(t35) {
    return this._requireNotFrozen(), this._maxChunks = t35, this;
  }
  get chunkSize() {
    return this._chunkSize;
  }
  getChunkSize() {
    return this._chunkSize;
  }
  setChunkSize(t35) {
    return this._chunkSize = t35, this;
  }
  getRequiredChunks() {
    if (null == this._message) return 1;
    return Math.ceil(this._message.length / this._chunkSize);
  }
  freezeWith(t35) {
    if (super.freezeWith(t35), null == this._message) return this;
    const s26 = Math.floor((this._message.length + (this._chunkSize - 1)) / this._chunkSize);
    if (s26 > this._maxChunks) throw new Error(`Message with size ${this._message.length} too long for ${this._maxChunks} chunks`);
    const e39 = this._getTransactionId()._toProtobuf();
    let i17 = this._getTransactionId();
    this._transactionIds.locked = false, this._transactions.clear(), this._transactionIds.clear(), this._signedTransactions.clear();
    for (let t36 = 0; t36 < s26; t36++) {
      this._chunkInfo = { initialTransactionID: e39, total: s26, number: t36 + 1 }, this._transactionIds.push(i17), this._transactionIds.advance();
      for (const t37 of this._nodeAccountIds.list) this._signedTransactions.push(this._makeSignedTransaction(t37));
      i17 = new i4(i17.accountId, new s3(i17.validStart.seconds, i17.validStart.nanos.add(1)));
    }
    return this._transactionIds.advance(), this._chunkInfo = null, this;
  }
  schedule() {
    if (this._requireNotFrozen(), null != this._message && this._message.length > this._chunkSize) throw new Error(`cannot schedule \`TopicMessageSubmitTransaction\` with message over ${this._chunkSize} bytes`);
    return super.schedule();
  }
  async execute(t35, s26) {
    return (await this.executeAll(t35, s26))[0];
  }
  async executeAll(t35, s26) {
    super._isFrozen() || this.freezeWith(t35);
    const e39 = this._getTransactionId(), i17 = t35.operatorAccountId;
    null != i17 && i17.equals(e39.accountId) && await super.signWithOperator(t35);
    const n31 = [];
    let r41 = s26;
    for (let s27 = 0; s27 < this._transactionIds.length; s27++) {
      const s28 = Date.now();
      n31.push(await super.execute(t35, r41)), null != r41 && (r41 = Date.now() - s28);
    }
    return n31;
  }
  _execute(t35, s26) {
    return t35.consensus.submitMessage(s26);
  }
  _getTransactionDataCase() {
    return "consensusSubmitMessage";
  }
  _makeTransactionData() {
    if (null != this._chunkInfo && null != this._message) {
      const t35 = (this._chunkInfo.number - 1) * this._chunkSize;
      let s26 = t35 + this._chunkSize;
      return s26 > this._message.length && (s26 = this._message.length), { topicID: null != this._topicId ? this._topicId._toProtobuf() : null, message: this._message.slice(t35, s26), chunkInfo: this._chunkInfo };
    }
    return { topicID: null != this._topicId ? this._topicId._toProtobuf() : null, message: this._message };
  }
  _getLogId() {
    return `TopicMessageSubmitTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("consensusSubmitMessage", u19._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/topic/TopicUpdateTransaction.js
var l16 = class _l extends P {
  constructor(e39 = {}) {
    super(), this._topicId = null, null != e39.topicId && this.setTopicId(e39.topicId), this._topicMemo = null, null != e39.topicMemo && this.setTopicMemo(e39.topicMemo), this._submitKey = null, null != e39.submitKey && this.setSubmitKey(e39.submitKey), this._adminKey = null, null != e39.adminKey && this.setAdminKey(e39.adminKey), this._feeScheduleKey = null, null != e39.feeScheduleKey && this.setFeeScheduleKey(e39.feeScheduleKey), this._feeExemptKeys = null, null != e39.feeExemptKeys && this.setFeeExemptKeys(e39.feeExemptKeys), this._autoRenewAccountId = null, null != e39.autoRenewAccountId && this.setAutoRenewAccountId(e39.autoRenewAccountId), this._autoRenewPeriod = null, null != e39.autoRenewPeriod && this.setAutoRenewPeriod(e39.autoRenewPeriod), this._customFees = null, null != e39.customFees && this.setCustomFees(e39.customFees), this._expirationTime = null, null != e39.expirationTime && this.setExpirationTime(e39.expirationTime);
  }
  static _fromProtobuf(t35, s26, m6, c17, h8) {
    const a23 = h8[0].consensusUpdateTopic;
    return P._fromProtobufTransactions(new _l({ topicId: null != a23.topicID ? d4._fromProtobuf(a23.topicID) : void 0, adminKey: null != a23.adminKey ? t2._fromProtobufKey(a23.adminKey) : void 0, submitKey: null != a23.submitKey ? t2._fromProtobufKey(a23.submitKey) : void 0, feeScheduleKey: null != a23.feeScheduleKey ? t2._fromProtobufKey(a23.feeScheduleKey) : void 0, feeExemptKeys: null != a23.feeExemptKeyList && null != a23.feeExemptKeyList.keys ? a23 == null ? void 0 : a23.feeExemptKeyList.keys.map(((e39) => t2._fromProtobufKey(e39))) : void 0, autoRenewAccountId: null != a23.autoRenewAccount ? y3._fromProtobuf(a23.autoRenewAccount) : void 0, autoRenewPeriod: null != a23.autoRenewPeriod && null != a23.autoRenewPeriod.seconds ? a23.autoRenewPeriod.seconds : void 0, customFees: null != a23.customFees && null != a23.customFees.fees ? a23.customFees.fees.map(((e39) => l6._fromProtobuf(e39))) : void 0, topicMemo: null != a23.memo && Object.hasOwn(a23.memo, "value") ? a23.memo.value : void 0, expirationTime: null != a23.expirationTime ? s3._fromProtobuf(a23.expirationTime) : void 0 }), t35, s26, m6, c17, h8);
  }
  get expirationTime() {
    return this._expirationTime;
  }
  setExpirationTime(e39) {
    return this._requireNotFrozen(), this._expirationTime = e39 instanceof Date ? s3.fromDate(e39) : e39, this;
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(e39) {
    return this._requireNotFrozen(), this._topicId = "string" == typeof e39 ? d4.fromString(e39) : e39.clone(), this;
  }
  clearTopicId() {
    return this._requireNotFrozen(), this._topicId = null, this;
  }
  get topicMemo() {
    return this._topicMemo;
  }
  setTopicMemo(e39) {
    return this._requireNotFrozen(), this._topicMemo = e39, this;
  }
  clearTopicMemo() {
    return this._requireNotFrozen(), this._topicMemo = null, this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setAdminKey(e39) {
    return this._requireNotFrozen(), this._adminKey = e39, this;
  }
  clearAdminKey() {
    return this._requireNotFrozen(), this._adminKey = null, this;
  }
  get submitKey() {
    return this._submitKey;
  }
  setSubmitKey(e39) {
    return this._requireNotFrozen(), this._submitKey = e39, this;
  }
  clearSubmitKey() {
    return this._requireNotFrozen(), this._submitKey = null, this;
  }
  getFeeScheduleKey() {
    return this._feeScheduleKey;
  }
  setFeeScheduleKey(e39) {
    return this._requireNotFrozen(), this._feeScheduleKey = e39, this;
  }
  clearFeeScheduleKey() {
    return this._requireNotFrozen(), this._feeScheduleKey = null, this;
  }
  getFeeExemptKeys() {
    return this._feeExemptKeys;
  }
  setFeeExemptKeys(e39) {
    return this._requireNotFrozen(), this._feeExemptKeys = e39, this;
  }
  addFeeExemptKey(e39) {
    return this._requireNotFrozen(), null == this._feeExemptKeys && (this._feeExemptKeys = []), this._feeExemptKeys.push(e39), this;
  }
  clearFeeExemptKeys() {
    return this._requireNotFrozen(), this._feeExemptKeys = [], this;
  }
  get autoRenewAccountId() {
    return this._autoRenewAccountId;
  }
  setAutoRenewAccountId(e39) {
    return this._requireNotFrozen(), this._autoRenewAccountId = e39 instanceof y3 ? e39 : y3.fromString(e39), this;
  }
  clearAutoRenewAccountId() {
    return this._requireNotFrozen(), this._autoRenewAccountId = null, this;
  }
  get autoRenewPeriod() {
    return this._autoRenewPeriod;
  }
  setAutoRenewPeriod(e39) {
    return this._requireNotFrozen(), this._autoRenewPeriod = e39 instanceof s9 ? e39 : new s9(e39), this;
  }
  getCustomFees() {
    return this._customFees;
  }
  setCustomFees(e39) {
    return this._requireNotFrozen(), this._customFees = e39, this;
  }
  addCustomFee(e39) {
    return this._requireNotFrozen(), null == this._customFees && (this._customFees = []), this._customFees.push(e39), this;
  }
  clearCustomFees() {
    return this._requireNotFrozen(), this._customFees = [], this;
  }
  _validateChecksums(e39) {
    null != this._topicId && this._topicId.validateChecksum(e39), null != this._autoRenewAccountId && this._autoRenewAccountId.validateChecksum(e39);
  }
  _execute(e39, t35) {
    return e39.consensus.updateTopic(t35);
  }
  _getTransactionDataCase() {
    return "consensusUpdateTopic";
  }
  _makeTransactionData() {
    return { topicID: null != this._topicId ? this._topicId._toProtobuf() : null, adminKey: null != this._adminKey ? this._adminKey._toProtobufKey() : null, submitKey: null != this._submitKey ? this._submitKey._toProtobufKey() : null, feeScheduleKey: null != this._feeScheduleKey ? this._feeScheduleKey._toProtobufKey() : null, feeExemptKeyList: null != this._feeExemptKeys ? { keys: this._feeExemptKeys.map(((e39) => e39._toProtobufKey())) } : null, memo: null != this._topicMemo ? { value: this._topicMemo } : null, autoRenewAccount: null != this._autoRenewAccountId ? this._autoRenewAccountId._toProtobuf() : null, autoRenewPeriod: null != this._autoRenewPeriod ? this._autoRenewPeriod._toProtobuf() : null, customFees: null != this._customFees ? { fees: this._customFees.map(((e39) => e39._toTopicFeeProtobuf())) } : null, expirationTime: null != this._expirationTime ? this._expirationTime._toProtobuf() : null };
  }
  _getLogId() {
    return `TopicUpdateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("consensusUpdateTopic", l16._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/account/HbarTransferMap.js
var n23 = class _n extends t3 {
  constructor() {
    super(((t35) => y3.fromString(t35)));
  }
  static _fromProtobuf(r41) {
    const s26 = new _n();
    for (const n31 of null != r41.accountAmounts ? r41.accountAmounts : []) {
      const r42 = y3._fromProtobuf(n31.accountID);
      s26._set(r42, e4.fromTinybars(n31.amount));
    }
    return s26;
  }
};

// node_modules/@hashgraph/sdk/lib/account/TransferTransaction.js
var T2 = class _T extends u11 {
  constructor(t35 = {}) {
    super(), this._hbarTransfers = [], this._defaultMaxTransactionFee = new e4(1);
    for (const r41 of null != t35.hbarTransfers ? t35.hbarTransfers : []) this.addHbarTransfer(r41.accountId, r41.amount);
  }
  static _fromProtobuf(r41, t35, s26, o32, f4) {
    const i17 = f4[0].cryptoTransfer, u22 = new _T();
    return u22._tokenTransfers = n12._fromProtobuf(null != i17.tokenTransfers ? i17.tokenTransfers : []), u22._hbarTransfers = n7._fromProtobuf(null != i17.transfers && null != i17.transfers.accountAmounts ? i17.transfers.accountAmounts : []), u22._nftTransfers = t17._fromProtobuf(null != i17.tokenTransfers ? i17.tokenTransfers : []), P._fromProtobufTransactions(u22, r41, t35, s26, o32, f4);
  }
  get hbarTransfers() {
    const r41 = new n23();
    for (const t35 of this._hbarTransfers) r41._set(t35.accountId, t35.amount);
    return r41;
  }
  get hbarTransfersList() {
    return this._hbarTransfers;
  }
  _addHbarTransfer(t35, n31, o32) {
    this._requireNotFrozen();
    const e39 = t35 instanceof y3 ? t35.clone() : y3.fromString(t35), f4 = n31 instanceof e4 ? n31 : new e4(n31);
    for (const t36 of this._hbarTransfers) if (0 === t36.accountId.compare(e39)) return t36.amount = e4.fromTinybars(t36.amount.toTinybars().add(f4.toTinybars())), this;
    return this._hbarTransfers.push(new n7({ accountId: e39, amount: f4, isApproved: o32 })), this;
  }
  addHbarTransfer(r41, t35) {
    return this._addHbarTransfer(r41, t35, false);
  }
  addApprovedHbarTransfer(r41, t35) {
    return this._addHbarTransfer(r41, t35, true);
  }
  _validateChecksums(r41) {
    for (const t35 of this._hbarTransfers) t35.accountId.validateChecksum(r41);
    for (const t35 of this._tokenTransfers) t35.tokenId.validateChecksum(r41), t35.accountId.validateChecksum(r41);
    for (const t35 of this._nftTransfers) t35.tokenId.validateChecksum(r41), t35.senderAccountId.validateChecksum(r41), t35.receiverAccountId.validateChecksum(r41);
  }
  setHbarTransferApproval(r41, t35) {
    const n31 = "string" == typeof r41 ? y3.fromString(r41) : r41;
    for (const r42 of this._hbarTransfers) 0 === r42.accountId.compare(n31) && (r42.isApproved = t35);
    return this;
  }
  setTokenTransferApproval(r41, n31, o32) {
    const a23 = "string" == typeof r41 ? c4.fromString(r41) : r41, e39 = "string" == typeof n31 ? y3.fromString(n31) : n31;
    for (const r42 of this._tokenTransfers) 0 === r42.tokenId.compare(a23) && 0 === r42.accountId.compare(e39) && (r42.isApproved = o32);
    return this;
  }
  setNftTransferApproval(r41, t35) {
    const s26 = "string" == typeof r41 ? e9.fromString(r41) : r41;
    for (const r42 of this._nftTransfers) 0 === r42.tokenId.compare(s26.tokenId) && 0 === r42.serialNumber.compare(s26.serial) && (r42.isApproved = t35);
    return this;
  }
  _execute(r41, t35) {
    return r41.crypto.cryptoTransfer(t35);
  }
  _getTransactionDataCase() {
    return "cryptoTransfer";
  }
  _makeTransactionData() {
    const { tokenTransfers: r41 } = super._makeTransactionData();
    return this._hbarTransfers.sort(((r42, t35) => r42.accountId.compare(t35.accountId))), { transfers: { accountAmounts: this._hbarTransfers.map(((r42) => ({ accountID: r42.accountId._toProtobuf(), amount: r42.amount.toTinybars(), isApproval: r42.isApproved }))) }, tokenTransfers: r41 };
  }
  _getLogId() {
    return `TransferTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("cryptoTransfer", T2._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/exports.js
var import_pino = __toESM(require_browser(), 1);

// node_modules/@hashgraph/sdk/lib/logger/LogLevel.js
var e27 = class _e {
  constructor(e39) {
    this._name = e39, Object.freeze(this);
  }
  toString() {
    switch (this) {
      case _e.Silent:
        return "silent";
      case _e.Trace:
        return "trace";
      case _e.Debug:
        return "debug";
      case _e.Info:
        return "info";
      case _e.Warn:
        return "warn";
      case _e.Error:
        return "error";
      case _e.Fatal:
        return "fatal";
      default:
        return `Unknown log level (${this._name})`;
    }
  }
  static _fromString(r41) {
    switch (r41) {
      case "silent":
        return _e.Silent;
      case "trace":
        return _e.Trace;
      case "debug":
        return _e.Debug;
      case "info":
        return _e.Info;
      case "warn":
        return _e.Warn;
      case "error":
        return _e.Error;
      case "fatal":
        return _e.Fatal;
      default:
        throw new Error(`Unknown log level: ${r41}`);
    }
  }
};
e27.Silent = new e27("silent"), e27.Trace = new e27("trace"), e27.Debug = new e27("debug"), e27.Info = new e27("info"), e27.Warn = new e27("warn"), e27.Error = new e27("error"), e27.Fatal = new e27("fatal");

// node_modules/@hashgraph/sdk/lib/token/TokenUpdateNftsTransaction.js
var s17 = class _s extends P {
  constructor(t35 = {}) {
    super(), this._tokenId = null, this._serialNumbers = [], this._metadata = null, null != t35.tokenId && this.setTokenId(t35.tokenId), null != t35.serialNumbers && this.setSerialNumbers(t35.serialNumbers), null != t35.metadata && this.setMetadata(t35.metadata);
  }
  static _fromProtobuf(a23, r41, n31, o32, i17) {
    const u22 = i17[0].tokenUpdateNfts;
    return P._fromProtobufTransactions(new _s({ tokenId: null != u22.token ? c4._fromProtobuf(u22.token) : void 0, serialNumbers: null != u22.serialNumbers ? u22.serialNumbers : [], metadata: null != u22.metadata && Object.hasOwn(u22.metadata, "value") ? u22.metadata.value : void 0 }), a23, r41, n31, o32, i17);
  }
  setTokenId(e39) {
    return this._requireNotFrozen(), this._tokenId = "string" == typeof e39 ? c4.fromString(e39) : e39.clone(), this;
  }
  setSerialNumbers(t35) {
    return this._requireNotFrozen(), this._serialNumbers = t35, this;
  }
  setMetadata(t35) {
    return this._requireNotFrozen(), this._metadata = t35, this;
  }
  _validateChecksums(t35) {
    null != this._tokenId && this._tokenId.validateChecksum(t35);
  }
  _execute(t35, e39) {
    return t35.token.pauseToken(e39);
  }
  _getTransactionDataCase() {
    return "tokenUpdateNfts";
  }
  _makeTransactionData() {
    return { token: null != this._tokenId ? this._tokenId._toProtobuf() : null, serialNumbers: null != this._serialNumbers ? this._serialNumbers : [], ...null != this._metadata ? { metadata: { value: this._metadata } } : null };
  }
  _getLogId() {
    return `TokenUpdateNftsTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("tokenUpdateNfts", s17._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/node/ServiceEndpoint.js
var t25 = class _t {
  constructor(t35) {
    this._ipAddressV4 = null != (t35 == null ? void 0 : t35.ipAddressV4) ? t35.ipAddressV4 : null, this._port = null != (t35 == null ? void 0 : t35.port) ? t35.port : null, this._domainName = null != (t35 == null ? void 0 : t35.domainName) ? t35.domainName : null;
  }
  setIpAddressV4(t35) {
    if (null != this._domainName) throw new Error("Cannot set IP address when domain name is already set.");
    return this._ipAddressV4 = t35, this;
  }
  get getIpAddressV4() {
    return this._ipAddressV4;
  }
  setPort(t35) {
    return this._port = t35, this;
  }
  get getPort() {
    return this._port;
  }
  setDomainName(t35) {
    if (null != this._ipAddressV4) throw new Error("Cannot set domain name when IP address is already set.");
    return this._domainName = t35, this;
  }
  get getDomainName() {
    return this._domainName;
  }
  static _fromProtobuf(s26) {
    return new _t({ ipAddressV4: null != s26.ipAddressV4 ? s26.ipAddressV4 : void 0, port: null != s26.port ? s26.port : void 0, domainName: null != s26.domainName ? s26.domainName : void 0 });
  }
  _toProtobuf() {
    return { ipAddressV4: this._ipAddressV4, port: this._port, domainName: this._domainName };
  }
};

// node_modules/@hashgraph/sdk/lib/node/NodeCreateTransaction.js
var s18 = class _s extends P {
  constructor(t35) {
    super(), this._accountId = null != (t35 == null ? void 0 : t35.accountId) ? t35.accountId : null, this._description = null != (t35 == null ? void 0 : t35.description) ? t35.description : null, this._gossipEndpoints = null != (t35 == null ? void 0 : t35.gossipEndpoints) ? t35.gossipEndpoints : null, this._serviceEndpoints = null != (t35 == null ? void 0 : t35.serviceEndpoints) ? t35.serviceEndpoints : null, this._gossipCaCertificate = null != (t35 == null ? void 0 : t35.gossipCaCertificate) ? t35.gossipCaCertificate : null, this._grpcCertificateHash = null != (t35 == null ? void 0 : t35.grpcCertificateHash) ? t35.grpcCertificateHash : null, this._grpcWebProxyEndpoint = (t35 == null ? void 0 : t35.grpcWebProxyEndpoint) || null, this._adminKey = null != (t35 == null ? void 0 : t35.adminKey) ? t35.adminKey : null, this._declineReward = null != (t35 == null ? void 0 : t35.declineReward) ? t35.declineReward : null;
  }
  static _fromProtobuf(n31, o32, c17, a23, d18) {
    const p3 = d18[0].nodeCreate;
    return P._fromProtobufTransactions(new _s({ accountId: null != p3.accountId ? y3._fromProtobuf(p3.accountId) : void 0, description: null != p3.description ? p3.description : void 0, gossipEndpoints: null != p3.gossipEndpoint ? p3.gossipEndpoint.map(((t35) => t25._fromProtobuf(t35))) : void 0, serviceEndpoints: null != p3.serviceEndpoint ? p3.serviceEndpoint.map(((t35) => t25._fromProtobuf(t35))) : void 0, gossipCaCertificate: null != p3.gossipCaCertificate ? p3.gossipCaCertificate : void 0, grpcCertificateHash: null != p3.grpcCertificateHash ? p3.grpcCertificateHash : void 0, adminKey: null != p3.adminKey ? t2._fromProtobufKey(p3.adminKey) : void 0, declineReward: null != p3.declineReward ? p3.declineReward : void 0, grpcWebProxyEndpoint: null != p3.grpcProxyEndpoint ? t25._fromProtobuf(p3.grpcProxyEndpoint) : void 0 }), n31, o32, c17, a23, d18);
  }
  setAccountId(i17) {
    return this._requireNotFrozen(), this._accountId = i17 instanceof y3 ? i17 : y3.fromString(i17), this;
  }
  get accountId() {
    return this._accountId;
  }
  setDescription(t35) {
    if (this._requireNotFrozen(), t35.length > 100) throw new Error("Description must be at most 100 characters.");
    return this._description = t35, this;
  }
  get description() {
    return this._description;
  }
  setGossipEndpoints(t35) {
    if (this._requireNotFrozen(), 0 == t35.length) throw new Error("GossipEndpoints list must not be empty.");
    if (t35.length > 10) throw new Error("GossipEndpoints list must not contain more than 10 entries.");
    return this._gossipEndpoints = [...t35], this;
  }
  get gossipEndpoints() {
    return this._gossipEndpoints;
  }
  addGossipEndpoint(t35) {
    return null != this._gossipEndpoints && this._gossipEndpoints.push(t35), this;
  }
  setServiceEndpoints(t35) {
    if (this._requireNotFrozen(), 0 == t35.length) throw new Error("ServiceEndpoints list must not be empty.");
    if (t35.length > 8) throw new Error("ServiceEndpoints list must not contain more than 8 entries.");
    return this._serviceEndpoints = [...t35], this;
  }
  get serviceEndpoints() {
    return this._serviceEndpoints;
  }
  addServiceEndpoint(t35) {
    return null != this._serviceEndpoints && this._serviceEndpoints.push(t35), this;
  }
  setGossipCaCertificate(t35) {
    if (this._requireNotFrozen(), 0 == t35.length) throw new Error("GossipCaCertificate must not be empty.");
    return this._gossipCaCertificate = t35, this;
  }
  get gossipCaCertificate() {
    return this._gossipCaCertificate;
  }
  setCertificateHash(t35) {
    return this._requireNotFrozen(), this._grpcCertificateHash = t35, this;
  }
  get certificateHash() {
    return this._grpcCertificateHash;
  }
  setGrpcWebProxyEndpoint(t35) {
    return this._requireNotFrozen(), this._grpcWebProxyEndpoint = t35, this;
  }
  get grpcWebProxyEndpoint() {
    return this._grpcWebProxyEndpoint;
  }
  setAdminKey(t35) {
    return this._requireNotFrozen(), this._adminKey = t35, this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setDeclineReward(t35) {
    return this._requireNotFrozen(), this._declineReward = t35, this;
  }
  get declineReward() {
    return this._declineReward;
  }
  _execute(t35, i17) {
    return t35.addressBook.createNode(i17);
  }
  _getTransactionDataCase() {
    return "nodeCreate";
  }
  _makeTransactionData() {
    return { accountId: null != this._accountId ? this._accountId._toProtobuf() : null, description: null != this._description ? this._description : null, gossipEndpoint: null != this._gossipEndpoints ? this._gossipEndpoints.map(((t35) => t35._toProtobuf())) : null, serviceEndpoint: null != this._serviceEndpoints ? this._serviceEndpoints.map(((t35) => t35._toProtobuf())) : null, gossipCaCertificate: null != this._gossipCaCertificate ? this._gossipCaCertificate : null, grpcCertificateHash: null != this._grpcCertificateHash ? this._grpcCertificateHash : null, adminKey: null != this._adminKey ? this._adminKey._toProtobufKey() : null, declineReward: null != this._declineReward ? this._declineReward : null, grpcProxyEndpoint: null != this._grpcWebProxyEndpoint ? this._grpcWebProxyEndpoint._toProtobuf() : null };
  }
  _getLogId() {
    return `NodeCreateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("nodeCreate", s18._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/node/NodeDeleteTransaction.js
var n24 = class _n extends P {
  constructor(e39) {
    super(), this._nodeId = null != (e39 == null ? void 0 : e39.nodeId) ? e39.nodeId : null;
  }
  static _fromProtobuf(t35, o32, r41, d18, s26) {
    const a23 = s26[0].nodeDelete;
    return P._fromProtobufTransactions(new _n({ nodeId: null != a23.nodeId ? a23.nodeId : void 0 }), t35, o32, r41, d18, s26);
  }
  setNodeId(e39) {
    return this._nodeId = e39, this;
  }
  get nodeId() {
    return this._nodeId;
  }
  freezeWith(e39) {
    if (null == this.nodeId) throw new Error("NodeDeleteTransaction: 'nodeId' must be explicitly set before calling freeze().");
    return super.freezeWith(e39);
  }
  _execute(e39, t35) {
    return e39.addressBook.deleteNode(t35);
  }
  _getTransactionDataCase() {
    return "nodeDelete";
  }
  _makeTransactionData() {
    return { nodeId: null != this._nodeId ? this._nodeId : null };
  }
  _getLogId() {
    return `NodeDeleteTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("nodeDelete", n24._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/node/NodeUpdateTransaction.js
var s19 = class _s extends P {
  constructor(t35) {
    super(), this._nodeId = null != (t35 == null ? void 0 : t35.nodeId) ? t35.nodeId : null, this._accountId = null != (t35 == null ? void 0 : t35.accountId) ? t35.accountId : null, this._description = null != (t35 == null ? void 0 : t35.description) ? t35.description : null, this._gossipEndpoints = null != (t35 == null ? void 0 : t35.gossipEndpoints) ? t35.gossipEndpoints : null, this._serviceEndpoints = null != (t35 == null ? void 0 : t35.serviceEndpoints) ? t35.serviceEndpoints : null, this._gossipCaCertificate = null != (t35 == null ? void 0 : t35.gossipCaCertificate) ? t35.gossipCaCertificate : null, this._grpcCertificateHash = null != (t35 == null ? void 0 : t35.grpcCertificateHash) ? t35.grpcCertificateHash : null, this._grpcWebProxyEndpoint = (t35 == null ? void 0 : t35.grpcWebProxyEndpoint) || null, this._adminKey = null != (t35 == null ? void 0 : t35.adminKey) ? t35.adminKey : null, this._declineReward = null != (t35 == null ? void 0 : t35.declineReward) ? t35.declineReward : null;
  }
  static _fromProtobuf(n31, o32, d18, a23, c17) {
    var _a2;
    const p3 = c17[0].nodeUpdate;
    return P._fromProtobufTransactions(new _s({ nodeId: null != p3.nodeId ? p3.nodeId : void 0, accountId: null != p3.accountId ? y3._fromProtobuf(p3.accountId) : void 0, description: null != p3.description && Object.hasOwn(p3.description, "value") ? p3.description.value : void 0, gossipEndpoints: null != p3.gossipEndpoint ? p3.gossipEndpoint.map(((t35) => t25._fromProtobuf(t35))) : void 0, serviceEndpoints: null != p3.serviceEndpoint ? p3.serviceEndpoint.map(((t35) => t25._fromProtobuf(t35))) : void 0, gossipCaCertificate: null != p3.gossipCaCertificate && Object.hasOwn(p3.gossipCaCertificate, "value") ? p3.gossipCaCertificate.value : void 0, grpcCertificateHash: null != p3.grpcCertificateHash && Object.hasOwn(p3.grpcCertificateHash, "value") ? p3.grpcCertificateHash.value : void 0, grpcWebProxyEndpoint: null != p3.grpcProxyEndpoint ? t25._fromProtobuf(p3.grpcProxyEndpoint) : void 0, adminKey: null != p3.adminKey ? t2._fromProtobufKey(p3.adminKey) : void 0, declineReward: null != ((_a2 = p3.declineReward) == null ? void 0 : _a2.value) ? p3.declineReward.value : void 0 }), n31, o32, d18, a23, c17);
  }
  setNodeId(t35) {
    return this._requireNotFrozen(), this._nodeId = t35, this;
  }
  get nodeId() {
    return this._nodeId;
  }
  setAccountId(e39) {
    return this._requireNotFrozen(), this._accountId = e39 instanceof y3 ? e39 : y3.fromString(e39), this;
  }
  get accountId() {
    return this._accountId;
  }
  setDescription(t35) {
    if (this._requireNotFrozen(), t35.length > 100) throw new Error("Description must be at most 100 characters.");
    return this._description = t35, this;
  }
  clearDescription() {
    this._description = "";
  }
  get description() {
    return this._description;
  }
  setGossipEndpoints(t35) {
    if (this._requireNotFrozen(), 0 == t35.length) throw new Error("GossipEndpoints list must not be empty.");
    if (t35.length > 10) throw new Error("GossipEndpoints list must not contain more than 10 entries.");
    return this._gossipEndpoints = [...t35], this;
  }
  get gossipEndpoints() {
    return this._gossipEndpoints;
  }
  addGossipEndpoint(t35) {
    return this._requireNotFrozen(), null != this._gossipEndpoints && this._gossipEndpoints.push(t35), this;
  }
  setServiceEndpoints(t35) {
    if (this._requireNotFrozen(), 0 == t35.length) throw new Error("ServiceEndpoints list must not be empty.");
    if (t35.length > 8) throw new Error("ServiceEndpoints list must not contain more than 8 entries.");
    return this._serviceEndpoints = [...t35], this;
  }
  get serviceEndpoints() {
    return this._serviceEndpoints;
  }
  addServiceEndpoint(t35) {
    return this._requireNotFrozen(), null != this._serviceEndpoints && this._serviceEndpoints.push(t35), this;
  }
  setGossipCaCertificate(t35) {
    if (this._requireNotFrozen(), 0 == t35.length) throw new Error("GossipCaCertificate must not be empty.");
    return this._gossipCaCertificate = t35, this;
  }
  get gossipCaCertificate() {
    return this._gossipCaCertificate;
  }
  setCertificateHash(t35) {
    return this._requireNotFrozen(), this._grpcCertificateHash = t35, this;
  }
  get certificateHash() {
    return this._grpcCertificateHash;
  }
  setGrpcWebProxyEndpoint(t35) {
    return this._requireNotFrozen(), this._grpcWebProxyEndpoint = t35, this;
  }
  get grpcWebProxyEndpoint() {
    return this._grpcWebProxyEndpoint;
  }
  setAdminKey(t35) {
    return this._requireNotFrozen(), this._adminKey = t35, this;
  }
  get adminKey() {
    return this._adminKey;
  }
  setDeclineReward(t35) {
    return this._requireNotFrozen(), this._declineReward = t35, this;
  }
  get declineReward() {
    return this._declineReward;
  }
  deleteGrpcWebProxyEndpoint() {
    return this._grpcWebProxyEndpoint = new t25(), this;
  }
  freezeWith(t35) {
    if (null == this.nodeId) throw new Error("NodeUpdateTransaction: 'nodeId' must be explicitly set before calling freeze().");
    return super.freezeWith(t35);
  }
  _execute(t35, e39) {
    return t35.addressBook.updateNode(e39);
  }
  _getTransactionDataCase() {
    return "nodeUpdate";
  }
  _makeTransactionData() {
    return { accountId: null != this._accountId ? this._accountId._toProtobuf() : null, description: { value: null != this._description ? this._description : null }, gossipEndpoint: null != this._gossipEndpoints ? this._gossipEndpoints.map(((t35) => t35._toProtobuf())) : null, serviceEndpoint: null != this._serviceEndpoints ? this._serviceEndpoints.map(((t35) => t35._toProtobuf())) : null, gossipCaCertificate: null != this._gossipCaCertificate ? { value: this._gossipCaCertificate } : null, grpcCertificateHash: null != this._grpcCertificateHash ? { value: this._grpcCertificateHash } : null, grpcProxyEndpoint: null != this._grpcWebProxyEndpoint ? this._grpcWebProxyEndpoint._toProtobuf() : null, adminKey: null != this._adminKey ? this._adminKey._toProtobufKey() : null, nodeId: null != this._nodeId ? this._nodeId : null, declineReward: null != this._declineReward ? { value: this._declineReward } : null };
  }
  _getLogId() {
    return `NodeUpdateTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};
B.set("nodeUpdate", s19._fromProtobuf);

// node_modules/@hashgraph/sdk/lib/address_book/IPv4AddressPart.js
var t26 = class {
  constructor(t35 = {}) {
    this._left = null, null != t35.left && this.setLeft(t35.left), this._right = null, null != t35.right && this.setRight(t35.right);
  }
  get left() {
    return this._left;
  }
  setLeft(t35) {
    return this._left = t35, this;
  }
  get right() {
    return this._right;
  }
  setRight(t35) {
    return this._right = t35, this;
  }
  toString() {
    return null != this._left && null != this._right ? `${this._left.toString()}.${this._right.toString()}` : "";
  }
};

// node_modules/@hashgraph/sdk/lib/address_book/IPv4Address.js
var s20 = class _s {
  constructor(t35 = {}) {
    this._network = null, null != t35.network && this.setNetwork(t35.network), this._host = null, null != t35.host && this.setHost(t35.host);
  }
  get newtork() {
    return this._network;
  }
  setNetwork(t35) {
    return this._network = t35, this;
  }
  get host() {
    return this._host;
  }
  setHost(t35) {
    return this._host = t35, this;
  }
  static _fromProtobuf(r41) {
    return new _s({ network: new t26().setLeft(r41[0]).setRight(r41[1]), host: new t26().setLeft(r41[2]).setRight(r41[3]) });
  }
  _toProtobuf() {
    return Uint8Array.of(null != this._network && null != this._network._left ? this._network._left : 0, null != this._network && null != this._network.right ? this._network.right : 0, null != this._host && null != this._host.left ? this._host.left : 0, null != this._host && null != this._host.right ? this._host.right : 0);
  }
  static _fromString(r41) {
    const e39 = r41.split(".");
    if (4 !== e39.length) throw new Error("Invalid IPv4 address format");
    const o32 = new t26().setLeft(Number(e39[0])).setRight(Number(e39[1])), n31 = new t26().setLeft(Number(e39[2])).setRight(Number(e39[3]));
    return new _s({ network: o32, host: n31 });
  }
  toString() {
    return null != this._network && null != this._host ? `${this._network.toString()}.${this._host.toString()}` : "";
  }
};

// node_modules/@hashgraph/sdk/lib/address_book/Endpoint.js
var s21 = class _s {
  constructor(t35 = {}) {
    this._address = null, null != t35.address && this.setAddress(t35.address), this._port = null, null != t35.port && this.setPort(t35.port);
  }
  get address() {
    return this._address;
  }
  setAddress(t35) {
    return this._address = t35, this;
  }
  get port() {
    return this._port;
  }
  setPort(t35) {
    return this._port = t35, this;
  }
  static _fromProtobuf(r41) {
    let d18;
    return r41.domainName ? d18 = r41.domainName : r41.ipAddressV4 && (d18 = s20._fromProtobuf(r41.ipAddressV4)), new _s({ address: d18, port: null != r41.port ? r41.port : void 0 });
  }
  _toProtobuf() {
    return "string" != typeof this._address ? { ipAddressV4: null != this._address ? this._address._toProtobuf() : null, port: this._port } : { domainName: this._address, port: this._port };
  }
  static fromJSON(t35) {
    return new _s({ address: t35.address || void 0, port: null != t35.port ? parseInt(t35.port, 10) : void 0 });
  }
  toString() {
    return `${null != this._address ? this._address.toString() : ""}:${null != this._port ? this._port.toString() : ""}`;
  }
  toJSON() {
    return { address: null != this._address ? this._address.toString() : null, port: null != this._port ? this._port.toString() : null };
  }
};

// node_modules/@hashgraph/sdk/lib/address_book/NodeAddress.js
var d14 = class _d {
  constructor(t35 = {}) {
    this._publicKey = null, null != t35.publicKey && this.setPublicKey(t35.publicKey), this._nodeId = null, null != t35.nodeId && this.setNodeId(t35.nodeId), this._accountId = null, null != t35.accountId && this.setAccountId(t35.accountId), this._certHash = null, null != t35.certHash && this.setCertHash(t35.certHash), this._addresses = [], null != t35.addresses && this.setAddresses(t35.addresses), this._description = null, null != t35.description && this.setDescription(t35.description), this._stake = null, null != t35.stake && this.setStake(t35.stake);
  }
  get publicKey() {
    return this._publicKey;
  }
  setPublicKey(t35) {
    return this._publicKey = t35, this;
  }
  get nodeId() {
    return this._nodeId;
  }
  setNodeId(t35) {
    return this._nodeId = t35, this;
  }
  get accountId() {
    return this._accountId;
  }
  setAccountId(s26) {
    return this._accountId = "string" == typeof s26 ? y3.fromString(s26) : s26.clone(), this;
  }
  get certHash() {
    return this._certHash;
  }
  setCertHash(t35) {
    return this._certHash = t35, this;
  }
  get addresses() {
    return this._addresses;
  }
  setAddresses(t35) {
    return this._addresses = t35, this;
  }
  get description() {
    return this._description;
  }
  setDescription(t35) {
    return this._description = t35, this;
  }
  get stake() {
    return this._stake;
  }
  setStake(t35) {
    return this._stake = t35, this;
  }
  static _fromProtobuf(e39) {
    return new _d({ publicKey: null != e39.RSA_PubKey ? e39.RSA_PubKey : void 0, nodeId: null != e39.nodeId ? e39.nodeId : void 0, accountId: null != e39.nodeAccountId ? y3._fromProtobuf(e39.nodeAccountId) : void 0, certHash: null != e39.nodeCertHash ? e39.nodeCertHash : void 0, addresses: null != e39.serviceEndpoint ? e39.serviceEndpoint.map(((t35) => s21._fromProtobuf(t35))) : void 0, description: null != e39.description ? e39.description : void 0, stake: null != e39.stake ? e39.stake : void 0 });
  }
  _toProtobuf() {
    return { RSA_PubKey: this._publicKey, nodeId: this._nodeId, nodeAccountId: null != this._accountId ? this._accountId._toProtobuf() : null, nodeCertHash: this._certHash, serviceEndpoint: this._addresses.map(((t35) => t35._toProtobuf())), description: this._description, stake: this._stake };
  }
  static fromJSON(i17) {
    return new _d({ publicKey: i17.publicKey ?? void 0, nodeId: null != i17.nodeId ? long_default.fromString(i17.nodeId) : void 0, accountId: i17.accountId ? y3.fromString(i17.accountId) : void 0, certHash: null != i17.certHash ? n8(i17.certHash) : void 0, addresses: null != i17.addresses ? i17.addresses.map(((t35) => s21.fromJSON(t35))) : void 0, description: i17.description ?? void 0, stake: null != i17.stake ? long_default.fromString(i17.stake) : void 0 });
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return { publicKey: this._publicKey, nodeId: null != this._nodeId ? this._nodeId.toString() : null, accountId: null != this._accountId ? this._accountId.toString() : null, certHash: null != this._certHash ? e8(this._certHash) : null, addresses: this._addresses.map(((t35) => t35.toJSON())), description: this._description, stake: null != this._stake ? this._stake.toString() : null };
  }
};

// node_modules/@hashgraph/sdk/lib/address_book/NodeAddressBook.js
var e28 = __toESM(require_lib(), 1);
var o25 = class _o {
  constructor(s26 = {}) {
    this._nodeAddresses = [], null != s26.nodeAddresses && this.setNodeAddresses(s26.nodeAddresses);
  }
  get nodeAddresses() {
    return this._nodeAddresses;
  }
  setNodeAddresses(s26) {
    return this._nodeAddresses = s26, this;
  }
  static fromBytes(s26) {
    return _o._fromProtobuf(e28.proto.NodeAddressBook.decode(s26));
  }
  static _fromProtobuf(e39) {
    return new _o({ nodeAddresses: null != e39.nodeAddress ? e39.nodeAddress.map(((e40) => d14._fromProtobuf(e40))) : void 0 });
  }
  _toProtobuf() {
    return { nodeAddress: this._nodeAddresses.map(((s26) => s26._toProtobuf())) };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
  toJSON() {
    return { nodeAddresses: this._nodeAddresses.map(((s26) => s26.toJSON())) };
  }
  toBytes() {
    return e28.proto.NodeAddressBook.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/address_book/AddressBooks.js
var c14 = __toESM(require_lib(), 1);
var d15 = o25._fromProtobuf(c14.proto.NodeAddressBook.decode(r("0ad0070a0e33352e3233312e3230382e31343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340acf070a0d332e3231312e3234382e31373210a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ace070a0c34302e3132312e36342e343810a388031a05302e302e3322cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039663166386131323163326664366337366664353038643365343239663063363462636234346338326137303537333535326161646361643037313536396537323139353866356135643039663935383766666166636662653533343161326630313134616361653334366566336339303231336433343336656262323766343335306339393063356338633366386531653336373037626330386434323536303832336533663234653039613033616430393535613530393830313936323964643034623237623235316463653035356633646463623061343164363666303934316230623837636466653334393864343630333861623564663036663632613561646530383539383537336138386338663538363064633134393261366531383634383561396231333235306536643137623830636433396335633831393130396537336361373332646232336566386261613737366563383563653030393162656362326564656662616135656433653564626662643166383835613466613838316166336631343461386135363538353335333364383933393335393230383662326431643336326534356266653166623435363833616261366336343039373961643662343638373731383437323663366562643538623265616538356337636665336662616265663566366363656438353030333462333834373230366332643637386333363138373630323662386433353165303032616635653066666536663562316632393566646332663436396361613264323338316561306234386361393837636332633865363335653862313963653565313732613933373631613864343930613961343531386437323535383830613134643737623762613737343839326239326134306262383133363265333466633664353137386439623330313132393334323035636237376662396132383234323733393435363461383535346561343732383661343766383632333965373563393437383963653938633939383434373832343632393434663631333136376437623530323033303130303031320218033a606666643661646137346133613334613930346265613437363033303836663862656633623662653138616265643434633464343065313266623133306239376264366238353561656335643062393062306238633733353464356633623065340ad1070a0d33352e3139392e31352e31373710a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad1070a0d332e3133332e3231332e31343610a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad0070a0c34302e37302e31312e32303210a388031a05302e302e3422cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633535376166353739666138333530316265383939623238393037373635626664666364353261623433326230313935613166316563643836666330306162366335353039623066646439376564643363623563656135366132393566333132616262353530383331646266393633663435303131386234666363366532326366343637363230306365396363386564666262663535386463363966303234323634616437643364616232336265643231333363323734653639333434383931353564623130383766393033373039303563363431383561363231316463373432666239613639303964383231383639343762323737343633646662336666306163643437656666313265616431663639373265663263313230333739336334356537373537356265346661313130633765343066613864623963363138376431313366343730343031343137393037316162663539626537643262306465383264653432313564633235353036623163396332366534393137343031633939373530366533373765366266303362363838373237653739343066616436396335653064613363643563626432626537373733353061656132643064343765393761343438633834626536636531333464363462656530393835633239313632663463316535363763636139336430366133633162653861626365333562353537666237376634666536373161363664656337393037353664306538383138313635663262616361613839316161653761633734333766633731373562366562366465623734373233373837353162623662663962306531343833663936363865396664626435363034633339623134643965326265646565633834366139383064373034643137316537626134623766636431613330643934356361313266343761333235643933393861613138663937303636303534643464313566633839393465326465626537336539323731643534383638336636316561343466623235303731653335313861373865643365623337653731613036393166323637303230333031303030312801320218043a606630643934616363663664666633373238373463396462643864373939326562333137616635303031636134313936616261323635383039636233643230306261393631613534333863336135656430356338336264663963643131356432320ad2070a0e33352e3232352e3230312e31393510a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d35322e31352e3130352e31333010a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad1070a0d3130342e34332e3234382e363310a388031a05302e302e3522cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396261343537623733333035663034613931636334366231623936356334653834313735316162633862313431356130626164666431663332633234383233383661323237323565623765633734646561323165353036313764363438656135616333393337343161623031623865666233323132333962386434666462316466626562396533663339616134363538306464303435643138636134346430303263333764646235323763636534646463333262666337333431393637316634636134343634613366326138346663383563373161636630653561383936323664663639613831343734656431363532396638303161386166613937653433356334653034613936346133353735323732383838343365353866306130356366353135336565343530376232633638623364376662353461653661393561393539633837613132663633306539356337623162336333363935653835383636323431373932366437366331363938336661663631323235303338373435393037653963663133643637633261636435303363613435316338353933336163343131386163633237393830316362393638333439393033313435636564323736323964643038393136333137303933353837613737633232303563666135323534336235336333623665613135623834653364326333306331656437353261343633336333366232356239383933656130326164353632656239623738363862336234663437663461323565333536303634393632616337623235653538323934346630306433303739386132363266393231346438633565373464306138333736636332643662613634653138663565346134306166616336323530363264326361323363643238303037303833323164333833343331346630653538343438353932333236373361333265373061653064373131653331303538316263646231346538373133343639346336653039333066343662333762393664343961363435373339343733333165376535303764396535366465356536313436663266303230333031303030312802320218053a606361363738656263626433646338363438663765643033666235396630653231616636373531336561656535313331386536623534396265356163653930366564633166666132366439336135376163656339626537376634306561656564370ad2070a0e33352e3234372e3130392e31333510a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b35342e3234312e33382e3110a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330acf070a0b31332e38382e32322e343710a388031a05302e302e3622cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633432636361633566626336393166626265626461383766666431653735626463643839323234393463663434666462636365653439373838353231633337386266373764623039333465633064323138336437633531646236366638363463313161623764653161633363346366646331663039336132643666333765326233346362653463383133316639363833616434323837386338336433353534633634356161313637626366623036346138336463343563356231313538343939663964393235383766666637616263643566323231636438313530353438343133303030666136653536353930383962316466643635373636656137386561656466636136623435343535666438616235393834646265333565353739356432633633356561373937346434336538656165346665626666653439326537303762343862316230666336343831616539653039643339313333303039623764323634303265366535326535653931623262333830643838663062653766623462333033653730323139373835303537616139346365393234633439323665393136353639323836653836623362613635316361326130613633646634663639303766656665333438336439336234636531643464303363373134323131313337356232633263353164346562383339653337616635333062326362643666353064346362333665323739333731373064396364646163306163653263633234623830346230613237333531636638333062373635323565323664666239646266343961303536363234613736383632343934653732363364306437306365626165393532393433653535383432663563616431336663663630613265366463663761316435333366336135626235346563323139313863373665353235626132393134363637353833316531376533366336316665383534393838323864303962373632303135343132623265353237383439626165633163666663373764653463323934633535303831316535393866663234646131356133343536396464303230333031303030312803320218063a603234373166336665383134303638316665393139313364326363303633663036356534343930616536326666356435343861356162653133316432616639366362653361633235626265323433363663613466386630653736636639343566330ad0070a0c33352e3233352e36352e353110a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d35342e3137372e35312e31323710a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad0070a0c31332e36342e3137302e343010a388031a05302e302e3722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393032663034393061396237663564326364316330643936633661363939306635373362356630656235626462626133393636316566303233303932343139333434363639393639613638613463373037316433323939393066623137393265393030316362353539386561373163326436363736383234333230656534636162663164643335376165376632616462656463316231623061396439353632333737396234633463376234376334373837613136656537313838633732313731373736323461393236346162333963343166376666306234356138396264613430633461643037633464353936643566303964373035366263623561333566343466393561353963323636653039383932646362653436616435316632643262336539393161386636363538653166326362393463373733656234346334346538393264316535356331303736663136303833313965653635376534306631393239363735343361623432616232323233383664313735383665323533373438646162643032356535306235306165363035303732306532333964363465653666623435303763303631346464346265376166646231333330383930666633613665313736353237633331313661663132396139616335653333366439663630316537313237613664376438323061643266393032646163396232343836363861316261623038643130333432656136396137303937313332666637313230636336346663646537383430633635366261313733326261393565396333363735313137356534656333643834613765306432383834326234316262626264366632386534366333613636333365313832373936356335353832306435306461653262303436356363306434326531393562396431353332653632323565623939386436613439303739613861316364346430313735646533633837663937363134383437623363626231376161333462653832306237623361643938616333666165663939336136373738393734373832633063346165336661626263633433303230333031303030312804320218073a606633353738373364343131346131616566303361646336626136396566616632363930653232376162633136613666633665353034396136336662643936383830303462313465343633633230653338343336613361323464333138326464380ad1070a0d33342e3130362e3234372e363510a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33352e38332e38392e31373110a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad1070a0d31332e37382e3233322e31393210a388031a05302e302e3822cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393164376466666637386634656662653538393034353063356263396533353334626666616461643933666237616662313562633762636636376433643362343133626439393934306464383235363461646130346162326534656466306131633062386662376531613830393265393133386539363062653263633638623562393766353764323831633538373265393761343739666338343833363331363065333836336235376233336534383639623138356163653565333662643433616535666136373863396562363666316634303134373836383236623266386661376530303630663434303563306138663964613732303566663436383361323433666130663331356631616662623461346431343064303232333465343437336662393266636233386633656232386336306366376362666236346530363963313830383665346464363139333839323061653066643763313933653665313034653635623831376564393339386532333232333766646630383332326339636563303964343039393237326137633031356432326234646363393639663665613166353138393032313035646636303039326235356134316234663332623935376235376438346535623232333930356538363938393531373333656139663265323436316563306436353232656538313664353835306661636665623431326366663962393939343361383764633064303436343437636539336239376531366437336239366234323633393632663831666366393435386535373537376337383061366631363135616137613132333236373338653236396262373331663839653839313632326535373765613534343230626630636134366265366663346637316366323638316163303235326161383835653133626536373263643238343539303432376463643133376366333131363235653862656533623038666463616166343635623338376365376362333338313666326331346136623939616337643733343331386366633539623765643933396261666566383739303230333031303030312805320218083a603439333161373832303264353566313062333135373537383563336634333964623638313962643131303033646637626332636539326532396135313762376332313838306465623463303137393537343462353736636434336238343938640ad0070a0c33342e3132352e32332e343910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390acf070a0b35302e31382e31372e393310a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a603634653039383631356266343035663765643561343031333434366238396334383863666364366262323561346136373664633737656561313164333364373032363832663061363961383033306538633537373764306534323230333739390ad1070a0d32302e3135302e3133362e383910a388031a05302e302e3922cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633665313863386662663463643465623130343534326362323061616161323532643935663035326631303836643538316334346164373337626636363736633063336637383961663532363562386166623739623530393132646138346530616663663735343763623166666630386430353237303137656236646335636466383362353139363964343433333661363338376364373062393462663463396261663230323938343065356634663836336437303831663066613831653038363361646564623862383961356461633262623535326436653762396662613232326163323863353730373535333866633935373939323934326433343166613238373665366235303765396365376564353732653863666461356465666133363466646638643865323338323961346363626234373866313165656533623332616238356530373239353163356439343230313135666261333237303733343934663433623566366265626638343135326533353665376231366261373634623761336235326362323733343634303136336265313436356536643166613463366536663636363834613633356339613535366161373130306462653634356466386634633432336165343561303863623335623462633138373838366532323939623563303231306135666261336239343439663438336566393465643932326531653938633131336265313636623839633733353832323433313335643434323330366162653561373162373730313866663333356436646437393534323639376231363832333862393637323766643133333962356638326133623661353937643937363033376165323530363435366338623334653966626633626333323431303434316334626663386562613538353937323534656665626661613738383039613563383835343732396135626137386563653139666338343037646438383934613662633738343430333764383738636163653663313532633265383965386136346230363861366332333765303939393362653830363839303230333031303030312806320218093a60363465303938363135626634303566376564356134303133343436623839633438386366636436626232356134613637366463373765656131316433336437303236383266306136396138303330653863353737376430653432323033373939")));
var o26 = o25._fromProtobuf(c14.proto.NodeAddressBook.decode(r("0a7f0a0c33342e39342e3130362e363110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a80010a0d35302e31382e3133322e32313110a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a81010a0e3133382e39312e3134322e32313910a388031a05302e302e33320218033a606131373165336261383334373637343761656232653261633464306531313563616161623931383230336230646665316364656162343433343338666332383961626338626138613661666638336462356631623333343034366461383863380a82010a0d33352e3233372e3131392e353510a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a7f0a0a332e3231322e362e313310a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d35322e3136382e37362e32343110a388031a05302e302e342801320218043a603734303964656332653439346236323765653439633639623239346265316365616562636133666463616633363738396538386663376435623065656635353631663532623832643335313931613339633266626564363032373236373136360a82010a0d33352e3234352e32372e31393310a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a80010a0b35322e32302e31382e383610a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a81010a0c34302e37392e38332e31323410a388031a05302e302e352802320218053a603962313431363538346134613338306262383661366337643732303764386165646462633362363365613330353939383235356263653833353162613462356463613532633932383261353461366265643630646536336365303361616132340a82010a0d33342e38332e3131322e31313610a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35342e37302e3139322e333310a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a81010a0c35322e3138332e34352e363510a388031a05302e302e362803320218063a603634383636383562346536653063623936333437326330316665393939333166643965346334343838376261383334323361653766656564323264363438343834636638613362633563636361366133373338376266393664333836373238300a80010a0b33342e39342e3136302e3410a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e35342e3137362e3139392e31303910a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a82010a0d31332e36342e3138312e31333610a388031a05302e302e372804320218073a603339653930393931356138353238303330313534613663373730393530633762343737376261343031333537633065363138373635343231356363323061616363646438653566663239653963346439356366343130316661363862653435630a83010a0e33342e3130362e3130322e32313810a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a82010a0d33352e3135352e34392e31343710a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a81010a0c31332e37382e3233382e333210a388031a05302e302e382805320218083a606134343837346137616131623337373431613037316164616165373866623135326236393664316335386438646566626531643832333034353332613063303139656539366363313964373536383635373864333961316536633331613165650a83010a0e33342e3133332e3139372e32333010a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e31342e3235322e32303710a388031a05302e302e392806320218093a603639383332613733613336303265386431666265356164353864316332363337613162363732643731656538376166313064623634386562393161666232323832353362316634376535376433643461343466663534376233333934616132320a82010a0d35322e3136352e31372e32333110a388031a05302e302e392806320218093a60363938333261373361333630326538643166626535616435386431633236333761316236373264373165653837616631306462363438656239316166623232383235336231663437653537643364346134346666353437623333393461613232")));
var b4 = o25._fromProtobuf(c14.proto.NodeAddressBook.decode(r("0ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030633435363165336332373863643635306538306334313363613434343233633163336331336366313437356636663639373664353937616534333262343961623432303836623739623834313332363035346238623364636635376438666364373962666330353831383363613234636434633163626335373465643131313765326635623762336336336365376230366439623465666366373337353633376234316665366635336338313162396465363134336633613532393537636466393536373735313230623333373033666635373632313430376162393537356263326433356330643434663039383366633165663633613466663532303966303730633932616631303632393536303163393662636564303634656331393031393730313963363831316334633864643830636234663461633731663961643736653761633839343536666266346630313166393061626432643930353336653832333436353166366265663932376533643564386237626634353930353039383362656361336162656632613964393761663334353737326137373430653936393932373562303138656130646632383661646436636539323365663930386662653736326137356632313131363836326462343464336463613164343462346432653864633130363663353030366262356137643935346164323535643462363033323733343735653531316165623438356430363961303637633061623563323435333863393333633036623561366165666139343030356332393135323133653463636461653663393432663632373266396464353238326436623839306631663230656664323339396364363734393234666135373034366163366461333265373339353161373331313365393166633262376666323965343835316238336666333966383362613965633666303863656664626236636262626666616266646661613931643933306637323030646134383133376333393463626431336537303165636463323631366664323162616436383161613466303031303230333031303030312804320218073a603665396138616263646364653665313134396133656265313766643538643839303538333961383664623732623036613365613230616131373666383638623235343838353261653432336437613963366237636666396537313436323961320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613163343037373135343330336363373263346662373639326333663934323531626465633132333961316637613839373261626539316133353332336662656361363235613766666165363430366338353564633261663231313039303062306466306536653664623736333634646661316666653835656461353637393336653239383562383536333461333261613532613635393964643663333062653166376136633562386635656563616632363231643861343539363832666364326462616164313536316431316633336663636237663535303061633536386431363564626561616365333238366432383934663634313239643738316436633732666437643539396339653164336166346161343333633233623931306661653463343834313634316636313532366164373837656265613533393837343136376539643361373363633066623135363432396431356563373633613664306630363131356137396239616637383364373762393864383330393661613437343366393734303864396531346263663464646666653435393137363838343762343063623864613763613337353235366432623933356430393566653235326661653831666636653337663834643761393064376535373061346638656633633764373636656564613437326630393230313939303135613839303832353961383733633534353466636262646361643265353238646538353435356234303833633764633461646335613938386530636464666463313539643564373132616264353434616137336563303239303839383134633938613434663236666330363434363539633138336533313834616132373266386431646330626661336530613536303438346362303535626134646262356363333339656338306264313164363432646333613730326538633730336162323139333038346439626436336630646665313261343333633235373665616637383163666164383637656637306264613631373638623262656631346635306336633362386230393666303230333031303030312805320218083a606464336233653763643361323537643832373665343635333533363162303138623730303931663438363635653832303031306538316563303539326236396264346265316662643765636435303964303730313364643034313238343266640ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623263636163363561643066633736343561383137626661626334383761643765343133313165376133313938623337666238343264383463333935623366363764366264383438663130633666303363323930653866376461613864303031613834343164633335326131393136306133313933653638623832656466313961653637363933613961333364346362383765373839613130373037313535313565613737326361613862383661353639623931633534353038333564396333353466306461636563393766653737303931623435623134373639386237663836303134323264636432323631653932386465346461633963343264636261666466393663303732333362613330323730373666333763393639653865643330623662356438663530333462653764393263353936663862653836316535316663633361323432626639643862653965326139653865306631353565626366663233656666613763643537633130353432383131643830373736633935383535323666646230656161333465653139353564353131313933393066653837336534633034646564643239313635383834623938623436333038373838616537666334643461613461386663396263323637346261333231343933623632343435356164343130633164653731626339356431643931666130663230313431386137393565333039656166323937623639396266323763396661323736336364353963656230323165313662383230306331303630663238313766643833636663373637313833343839343631653335393932393162333830643665393339626161346231393233326136613237326464653635316638303436666463333464623237366137373764366662326265633332353562326363323434623461663536366231303566333063363530366464616530656233646564646366393437626362396336306530303039383466336234613863366334656434626639306263313933326237663934646333616536623336303030386562393032303430663962303230333031303030312802320218053a603561383634313561303861306138323566336232656237353031303135353230326533313234336665343161303333333834653738633138633131653565386632303964343933623062326664343565303662333734663262363964663564370ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613365333762373663366364356636363232643639323434343464313263363737633339356632623539303266336262393862386138623530353561373037373036636130323863643735303630613264383730326432643862303439343762646366653061386331343161613238343462316530366536363139303031326538623633323661623066613331373937336263376362346432393439663231303861613034633462306339316261613537323866356235363232656337356162663537386131663762343165646532613637656264363963313865353831666466396336303230616330646539636132633331663063363436393030333331316662623563653764623439633738376531613764323761613432356565376238346461376536363933396639633830643065383266636535356530326466633862356337383431386132366161343336353036393837313962616663656366306264343930303061646463666134303537303862646265666262313937343964323264616230303765343464343565613233623130366638383334633135326532353036326434636632346666323533353663376562333732393130353339336662343962616239303461303266306630626234313763643931396433353238393031323865366262666634666163396639306465313138613937346632613664643031653033326137396231373866363066613166636262643032623537303466623436323935633135313930383136333733656464363633356338353639373866316239353033663166373362346230626538616261326564316665656164353939353362663832656664653933613334373161626435356364613362613861363733666262333739393734396662303036643030336630653633663636356333343631643261376232396463386232303462613539613635363638613436616532383738663030643166393439306466396532383066656266343331356561303465616135363861336139666434386336326336336236656364613639303230333031303030312803320218063a606434363430333938303337393230373965636364356134343331316361306463323262353065633839356235366535336431326232396637326463366462613363616665326535623831303466626461303338616635623434376430666231320ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393361323135636334613761373232636165396331336162643633366466393963636565633661663964623436623639666135313637313665663530636532343930613938316530396162303139636132636234363831316235623631396431626431643565653666343661343263373737636264656536343261313438346563646635646464333732393634326333386336643433613838353838373434373566353832343434333636346330346466656439623839303435666230383565323563336566636234383431373333656666376335323963313339653639333530633263643739623263386431393637396137313265346538636166643332363735343162383332623365313061303132353564656636396466316539643362386438656166303331316465363764356531326232366464303164626264396433653432643335643964653237313330326530663166363964383763626337616361396538383637653964343238643363616230363636656234393064356662616233306266663366373835643033663230373261343362623962356535343635366135393263623631656166643561356566323834633763616563363666376634373332356363306434633164323766363631643861373438636135303731633036656631333464666639366634303836363838333636643436386132343738303031376530623536616261376661623433623362376330623737393036666165353438326633323831316332393265366231343435346531346238393438303161383661303363633437373934646430643734353237613732653432346564336166613034383939656362396136336632613961653732626537666139383961646630643635613332633835316439383031666334313034386466333335363466633762333137303765633866623830313430666537623761316661313230626131636236363033323463656666623462636332643962623764653063663534633831396632646433626365616465633963323566356531396463396231303230333031303030312806320218093a603365303261363732306334343636353965383633303564353562666565383230623335653635306665636163633535333039373435356532633465303332636339646564313662316262343464336235393262626163623663326266663165360ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303930323539663465336439663066333934323536353438653963373330386231306237333430336363393039346439376164313531623737303631373062393737326365623634643636326563656639303161386437643135643331396135396338623731303731616363643839356237633933363130646336393736663637633465313732396261383337336162376535326133663363386632363534393164646536396436653039393934373065373434353938313133316264393663333665363836353230336662326562643564353065616461666237323633393664656331643931373438393862346539626530346337346433303466656164643963626433323334633362376633333036633939636230633333396663323539363962343164353861326237636663313833326532323664383163313936333939336532323535613038376431363938633033643432313062643634353830363434643039356361373661613137393465646434306331633837623566383261386533396636303365393731313662613034353738653765383033343634393564373835643465663763663737313462396562366635663965306239613934663462373338383436313962393237346434613935656631353735346138396439376566356331613838623664363933653061383065626435333766633963663063613931643163363264393135646537656438313862393532653634633230303239336565386532383461343136613732613365313266633764343233623135386639623439363630636263323436366662656430666564326532346531303266646539343265623463666439346265633436643364393066633038633339666563626130336530636132343634616536363462393739353135626132396531663730326333666537303262653739333739366438656462313761613438633039323930623032343534396630363131663561653233656437653136343432646637643164616432323836633262623039643535323264643365643639386332663032303330313030303128093202180c3a606339373462623938326338313931336237333236643561336639646363343836313261313566376161643032663230376230663130636432303137613666626666353830336537636139626662343730396162323862366230396435623133660ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130303962646438653834666164616133353332666334636530316138613137643463336232333266353061393739306532363236383465646334383233653831356131626435623230656365613762663536653239663662623762383331666233626636656663643134373566306238656435666662306231333835623936643136366236323966303339366138666566356630366534626361323565653461313334306565323633613464396262303230643866343732333036663364383836313338646537613031396530353962643061666339303263636261316132313361653264616136306338613031333735356665306134386530333466356234303233613264616465616138386335343836383335336163376137613364663132623266623634313837373465396231346265366561623863633237623838303132616436313632646137346530656562313631333539303566343337333734646162383538366437353061323662626433616332346165643837386334643533653635313037326338373165393464376163633537356339363733383137333461353366656166346437626136626364643234316363363435386336303837643836333032616132353163303466366435366239633332643764393636323437353065643035353738356430373733663433646330393962323863393232383131343865366338316632393766663964313636653030306163303462333132343138363737356663656637356635656261306331303332626631333064663663643761343632313164306466336530353834643932656136373334396438343930353038656234656638386635346338633364343836646538373139663130666139366665623835636337393630373663613738313331386565326439656439303363613133333630343063353961643931613464326636393865393130386165306564623962316362393561643333623139376666623138626431626138623536636265653261616539353835656365323038613165313462343835363436333032303330313030303128083202180b3a603937303834333033333130373866353638326337663332343464383263336233653238316139313837393537386465656163646363326132656265353431616631383831313561643265383338363565356635643234376234613138633165650ab50722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039303938383635646566326632616233373663376630663733386331643837613237616330316166643030383632306333356362366562666362623063333330303331393361333838633334366433303233313732373031323139336262373666643330303462383634333132633638396566353231336362623930313130313530396465616239346632366137333265363337393239646134633463623332353137653361646262333831316435306163346337376331666365386236353136303632313566333437303766336537323635353435653538633839343630396532383337366264623737373566653330343339653065313539326664636230633365653163333035373733643037326136623839353765616663653161313162653936356564616666333834333336366362366134346563323561383930313036653632343735363766373662353530666461343832626165633633303764363938656338383834316664363666323366323130653437623861396463626136626134653166613731366462333363383065333038313934393664636235653536303966623665376336313533373962646465643432376539323331623932353463326261663934333630386138366436393861653961336338363339646638383764366636623561373133383564323433333864393131613231326266373166316532616363386231383662393665633865363963383662366430353832313737373661303963396336383935336564623539313635373862356132363362326634363965336230633037656164613731613434376565613766386663316262383037343235353536376237663062643165366166623033353837313863393862343239653234623232393835393666633736636636616633393663613934333464373932366563376433376434623932616635366434356665666638313936303935323234613931366331666665366236363765323535666333616338636363656639323064633034346232353030333133326238373830363734326630323033303130303031320218033a603333373339306438666561313434616663313265383132353461323864616336656138323839333833366163303732656666643835653061373734383538306566323830393636343863356137663864626234636538313437363831353133370ab70722cc063330383230316132333030643036303932613836343838366637306430313031303130353030303338323031386630303330383230313861303238323031383130306335376564623966663237366530323362323830323163623164383763646631393636623639386366343865346561616137633639323037376365656538636362323339613463393231353937653865383966376363303564336633313331353738393736633465333134343035643461346530336137323431306335633039636135323761643561383562393938363337653732613332653166626330643535343662323436356539653830366332646435303965623035306162356662323730363366643932383135623164643236383965323131316361656236663534396539346139663030663038323164346361366336613631313766356135333363393236336266303734613330643563626566353064316338633233383762636139373265646564613039383362356430613662353764636230303230303036383238623430653430373662343837306232346261643834303536656535326235663432326538383430303238633235303036333832643865396336363132323566346637366561373265333430363037653966633666336332303433333037366131636138636231356564303361633839363664303530376263646536383165346530323331656539663837643131316537623438616338663934643264383432623532646637336635373363633534313439363437393763363236393638666661653734313866336236313039623561306630396533323233663461346435653335303964643235303133386636626331376266366365636531373539343433306466313830613338653930616466326166666266616430633662386331623837663137386130363164636662666638623932633931363664383734633166663561663466626364626665386539643039393337306464663630626537343736333364333665653465623563643531663665336333333965313531653431626462356135636532633863393761306134336233636434636330383138383463383739663964326633373438343238633835373366313763393066336362643032303330313030303128073202180a3a603734306166366266373339653838336338386633333434633961306638623330316533396463393831633531363365306465326133666634326239396534323665643765353662363766343231383530333834356466363266343963396662300ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030393133316161333638663933343532323966393762363235396363636166666561323365303063643565616430326533663639366331653731346565333933396461643836306533386266393561323937346639656234386539333433663861616334303565613935356430353332336531313762336231633934383133613361663432666538303832633364343362616631626434643833363765393364623030616436393665363237613130333661653533346630313165616435653536663337613666666534346236623965303939343031313932616435363061303334366234316138313030393566356632643766643332643665656236353562613735386336623532366331323933383661663731393763376135336165363033643632323833323235343936316631366430656661383037396137363835363138383862653733333439323231373935366262636166616562623631333563356662623234383464356234613566646630333336616330326532366331363532633162643865616633306461653164366433656230306637623466616238643634373866653864393565623931316466393636613064656134653532326462373662383936363537306563633561663039353136343234663061663566386565363665333836643536353037313339393731363961633337353733626635326664303538646539356162326666363865363831313161623233343035656139363462326262383864303263306631636165643731656364643465346534303835393438373666646238353030626335356337626130323036366530356162393864396637653034363664393730326562353765653337323266386663633835613735353035666633323632313730323838623738383732336164623937653464653536323063633930656164313338326663643735373138383966656662313165363737316263336636663366656231396337616335343238373864303361393032373035323663336565643234393465666635346531353363613966363839303230333031303030312801320218043a603765616236393661623935343336363538626331346666366234626534643932356364353162323230646632613164356336656531363061646166323961353165363934646533656531383463653232656164386437646239333231383266330ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038326465373330363566333466666332393334306435393439643232323062316534333636656435636637633665626436313663663934313661353365613030313766366262313136626664336633646566636331356237613464646630653434643032666536393536383830353365373961373730653230316263663731393333393030333965653866303836643466613734366337653035363931383330316639623565383465333932363238323830383561373962333232626361306235643835666539373232316132366262646532353863363230663064636561303261623165646431366363343961336632616239323838653364643166333764633462366136663731333366663932653534316337316237306432613266363664353537323561623138626638366430303965633364323466356431326530623565363830326431313531333732643462373634656265636234616638326636343934383565633537623561303164633637393538663561303363636161623763626139333534613137333732633133313662613437633935336161663934393031623366386332346536613361666436373538653766336231343363653264643363623037316232613734633932316365653934396134623561366265383739663163373930613662386436336231393264376565323961393439316664643638396139386330613763336436303332306631623461633264363232396466643934653432663361363034386137366265316562393538633861313837336265386433333861656339666335396162376633373632363738393430326331666435393566313930383735373565306265383237666334633061346662336433393361643734613934396363393836626662363463616264646165353339333566366463353630373464623933643737656133623831366264643662653533343439373237323238393835396666333463653531383630616666623632316431303438376463333834336631663836643534303334613633653438613161306430323033303130303031280a3202180d3a606132656363316232616539386264323862633161303864386633373161306434663734356337363864306337373339363235363265333433623235643833343235656565613765663865613134323935333432623865623738643332656333660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303039383735356134303862353332316532363330353230303064366437643461326333613535346435653133383461396362356562663437346165383832633633623438366264303864313434646466316139346365396137643632353139363330303661666461616334353838343666313736343031393566653235333961363536393330656661383534663231343865363865633161303863316334396432303063336633303435666537313437663036643533346334626432363231303063623164643339373339643736306438316130626432306638336632353564323530376434636362313130366235333631386336613934343039633838376361653236326434636565396338363233323134376365633134303465306335376262613733313731333065653339363433383838616633643539386564643832623863363165363561653831613465316135366263303664333937313433613938643431636138376433656634333365663061656162363830313139316233653338343830393638663636623665383836363261663435613965323132393934663638623238386562393637626562393834373863323433653231333663316131353931663036316635626330346232316666326261343862323966313834333130383838373362646665393966386135326539343038393731383536653830346465613630326133313137383663393835363532393633633361333737303332396234303966373466646663373436623232613566383431383931323037316334636538343663396234623332306665646636653962363465326362653338346639613832623661616164346232303930373433316466316133336636393230376135363536303062653831303730643038333239303039393538353961343439386435623539333135626365626566656538303765623061336139343266316364663333363764643434343466646232393838366566636464306265346162653961313838383033393533383735656461333364623732393839663736336230323033303130303031280b3202180e3a603139366237623132303739376364623361396430303362393833643537646131303331303662313733306531376636376532633762616161646234333738396166313639366461313031316232353362636263383630333333383566303332380ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061396462376638626161313236383938666162373839313135613362356438393734346631393765323830343161653039386633653838366336393837313732316531316262306164313166336365393132346161393631643661306463383435663439373635633366616231393935383430323637366635363434363262663238316462613535383837383066303365393035373938653138343236396161613630663761313437323333316532666231646561646438373763383463626362363431636139653563386164366534356263313539636230373966636230643434396364636438643932333963316130343765376234343864613063646361323636313061323566323936643936653734363962363736643461343434353136653761353965383532393361383038366638343063303532383534653032613863623230303264616433353832356265346438336235326661393165386337336666303439373436313438383632373837633131313866393234643331636261633162343466656666323264343336623339373965616466396234336134626661373265313562343735356663616232363065303661323739633362623733626337663136613036306434643532326664343930353830333838616135393564383034343733366535323266363432343931356637383033623735383365303935636466373863333235313936393764653831623839666235303035343735336231613137663961616662303634643834633939326639616231316363626338636231303831346463616635323634616134356632316264656661633832636361636161663335386533313337336565316261346537343032666438613730656130633238636135636337346463343235313063393639636432633435396231656333363838613031656133396139393237313063643232393763393861383462363334386135373738303466646332333464336665313930336532633231653137326461323862353961653665346337653865646438623731633439643730323033303130303031280c3202180f3a603538343661353366343437353239666439636462373830346364333136383865643665656265336236336461326635663231316666626337333731393763663366316366626664613631626537643135313066306539323339383131376637340ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061386365616333363765623166316465356630643965663365616630646639623938343438666532303830383437363536326130363063353163323839373730623463616366653932636236353536393832336539363263326132633966656435336264333663613361313232646531633532356135383266323561346437643632386331613364356264623839333661656365373531306537353534656537303333303235633039326338323865656235373338626530326564393633646138316135393230353633346365393435343537376162383266343066313366316565353565306165373237653233633330323834623166343462393961636534646463356639616337616438386439666132323535393335623234646362613834303036343265313663663235333263306230643638393239303436303837313563343037366634366438346130653066656433366537366363646339363335356537613236313630393435633262353461653236636330306664303832333236333436656565656137646437356639313931316539396462636239396561346163366261303536633333323238643838316438353833316439636338373935393364613137343664643065653935646332623936666539336261666366663263643764393239353864373864663333663230356437313135656439666163346462366634636336306535366135343431646135623562353566613539393939303265393538613662366334346438313064646335363138313234316238376632326630353961363838306538303231373336643031383937646236353434396365383137613233373564303335353163623064653530376336303961306338303330656366346266646562323133633033646161373634613138323162373234333334663731663736386437616563623237373035326137303333373635663037323138303536633738663261383761663138333836643866363161356366636233663262613464643539393135663133643338363334643136393537353730323033303130303031280d320218103a603030306162636435396133306135333838633530306265363832663663613239343034363239356339323735383831633230643334626230643639306564613762333862366262643037613364643166646662366137303434626230396366660ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303061663062393134323537626637613436353563346135306430636164356530613165343538316564363632336630653837333066373936623866323963353831373862636363363933326331666333316633396566343462383264336334336233393837333733373366656362313239353232386130346664353061313466333634366438346665316634363763616562393864343633653239373565393935623864326531653339663362663661646463323561653335643635643032363038653033343535333739363665326162636534396238313462656164336331623735373137346165333063303062306334336539396238303439366237326433633133316631633665346663646130356632383131376566396532386334333033626534643863376530343264353862383363633132313934356132633635653739363263616139313835393338663337353764663763636139356366303262356533313934346133613631396130616333663165333462396230313364346332323463346631653730666439666433363938336566383661646535313833363263633833323263306637623631613961633735666238326537623836643638626330663039396130396131346361633561316438643338663961386137306363333766663563633362626432373432666664313436323535633137316536613137383038333237316463653066646536383165643439326362353962303739366432373031373538333864633539303831303765336136656133663961343036623364313133306363656333623437393165343962626332333136303362343661623264306639336434336265373561623961346437313065613934306532383561376231353362306361376364646565366439646365306164383335306334316439306332313562393538383531356166613061633333363561653037653831663362626233366264626561633462333162636231616134653832353635623937376639646164383564363236656566396161613965663864376533666230323033303130303031280e320218113a603933653238313031303462326231376230303935326235613431303264333365646230343363623136646533616433643364363832363066353562623065353837333765613539343463333338663763386362383863373833336663383630630ab70722cc0633303832303161323330306430363039326138363438383666373064303130313031303530303033383230313866303033303832303138613032383230313831303038633037626533303561643630623930626132646162333962306565373736306531613232663835373532323534306437306230336233663965343837356133613239616230383038386631343466353765623235326534366261353933383564306536643432373031313764613061626331623362383036393463396135303538623836643631646661303665373136373039633838653866656163376333613065316432356663306165626636613866373666636239396638343566653138313436316361623638353862393763336134303237666233373132623134653663303738396465313764343137363435373765353131343137656231363236393265623037616531653733353532333565396262343339303437623663303136313337383265376464366636303464616134363734363631643533393631663436633366616136623765373637363264333733623562353432623739656139363365666266333361633638313938626232623636316366663637363931366566333732616434633236633231366334626334373837633834656333326431383464373763373531383663303963663364396639313433336361393835333131396261623331666136616432366634353365353936643962646563613638613537363962633866656537613533356438306338633666336566623164666232383861623661393739383534623763653833313234656330643130326166663934633362373466396333373839353863323565623933336464353363316538303561313836353464366439313836393930663635373034323966393630663334653862346637666439393732646362666539323430653037346461326433353561356637656639633161663632656635393832613831373435373862396331356334396563353636626461636233306363666365663039636466653730386164343837343234653963316265363533663965653736363065376439343263316566613564613238366531616464616230366139613333663964653934363739356230323033303130303031280f320218123a603934383235313739643163333934303137306233356432363665346366613830643737386335653966356261653764653833666638636334373431663362653336616336336431653761653439373261656466366263316533636632303638390ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030626531376339393634376365633635613434343037623533353835366233633362616566356235346635363561663538623834353662613863376365353335643561633732633631633434633736623363353763386538363438343136333762653130613833636665333963303932343736643064626534643663646364636437323061333062356266656235316130316131386635383263343566366338363939336663663764663138323933356465316438363930363034346463663335313836393335643962643765656137393532333532626562623465663961653066373636316537306134323337616661393839393636383763613438666366633562303064333830376630353462653066613863336266613432353033386265366566323935313634663232663733623765383863393465613962653861613466336132343563383962396431666435313932663761353062393538623265663831303462333666316266386664326366623238633134323138303063316334376534656639386166313530303730636336643639643137653865623932663138613661613161363532363661343935323338643130336638663639356235376563663337333635306130353230303837343537323162656138313536323739363763383037363336356466386334633761376434646438663263333835306331386662613731656236306536653864666264313936653035333766643730623334346563626363353330646663383364613666656466343964353161393034313935303262613964373063643335663163663363303639346532333534663930363466646266353335656232336332376330613433643062373863316638363763363164393836393564386465663762633261313062623636373463323266363661616230613931383133646466323763646238353263353965663739653162396531613037356661366565323761376533373734646266346232363436353432376536643561623931666537663066336137313738346563613138326235303230333031303030312810320218133a603038393039376465663031623037633764393734613537353532353161366161613061666236623332613534353334336432393138653732626164303433323163313131633234643432373538306633626131653236616139643735653632360ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030613561643262373634336130346330353564326638636432353131623135313339666334353537353632313338386534396331313962326633393861636131313066363133393662306338363664653530363335323262623835343032373365313366366439346365316536303433386636616662303061616136343631326637313435653962636538626331613533623934313931336161373663396633613238333366616437636632383563376163326433376639396633633263646234396465346431353165363136373835363466323831663534313432346234316661376335316232613936303232383363376433326565303065623833386461313563333861666339366530363164393763656465323231363566663161613935396631633432373562326430393863343035383661353537396662623363623930303732373034313230613861363661353237306634666366643130383663393233363930613335653766643434356533336163303366313339633638363835353635373063646334616166323231303761366331613434323435366137633663373965653034303930653765356434663636626361363063613166343762366466623534336461633363626631396137373139613866353562366638336234613362386136366436303235366430613436353531666137303234626430353633316238613535383038373732353463326632663236386364633333643264626263666237333365396662653233336262396362353961623331613031343862323365386334323638306666313061663463373961346430383334366662373961393364393632393534386561663162623132343639386661656661346364643732343432633033613034623733333433326637343839303361333235633238336434353661623961653932316165376564333339316535643137383765666463323335343061376238356336393161653837306130376639306231316331336233326365343365616564313562333639363835636534393137376363393835303230333031303030312811320218143a603939666162633461646534653636326336653238323366346139366562323134343034383465356136643064333132623730633036386432326236323936333830376332333361343964626239383361376562623330653737303637373261340ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030386434356332316330633935656636356130323964353263393537666430663835663230313233646130333465363136373164646565353437356630373338326136366336366362346463353035303464646664333735383130383364663864313735373733306564386436663336346466346333366132363531353931393535646132303161323430376661386162396232333133383131323235613064613233306662653338306530393061613536656661346632303265633962343832336636353031643936616336393865626632366161636633656532643166333261373231633934376531303736636633356233373364613164383761333661313532653030653731303131373932323832653832356666313731633538333362383835373062666336646138343439653666393566386231323635616235353531393430333135353364316435373666393363343263306361363061616261633463386464313632643831313466326232313531313538336337323533396665353663343939613932396465336134306130643435633137633538396332643739383863653236656166633932613364333762376561303034326434336530336166613632373162323632353561366363636661653533373138323164383165306230356332353062353966306139303734316130653065383861303965643536633562393738306430393566303930366630623831643531323633393832616165303131333663303732643834346131316436646134623261363163363434653161623137663136666634386565323366656465383435326631653432653264333061303739306332356434323036306531643434613637316132656232336431313466363863373165333366313736646235386136386234333030353462633164323938336132336133326561366666393566613763346438653338306562323936653938623739363865636638343534643831376337333765656135646439323165623836633136633762323933303461346137656362653561336131303230333031303030312812320218153a606537396165396337313933643164326263393433383436346338616135663632323461653835323936366134336239383235383833663766373432633533393562643330393935383761393638363662393233396431656666336165353037610ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030623035616265326162303066646430366339353565383637313062306530366631613932363234613438616431636263386466633666323231323936326230633330666462643238346133376335613337363538623633633336656138313632353631613865346639343663626535373232633032383830316630663238316337306638643838633763303061326632653239663539376237393938363965643833353664663537633437626539393434613261616666363530663962346262613064626335336463383830666462623639656134353139303564323830323230326638653239633034613736643237616632656237633534383438356266336634363934633930633431383130383838383433373932383438383335663738313637303764336538643736663465363766353738306263663038383133633535656336333961396264363234313738663565623134376435303061663335316539656631623165333432343834636132363064623763636261653438366631336366323635623562316162363838303636303038303533623230633364656463653737316339613038613033323061613963653435316562396439383361376234396361613130393666386164633039383331386463333865306537636566306438653564353537613036373536383561316339653235366132626339646261333232623362623331373263663731343037376263333830663861306134333361386266613766626663353966366230393365633862663665393339376330396231386531383034306331623536363836343733376338666137653239373935663361343538386464613763326261623439353636356363346139623833366532656239306336326133666361663539316662356638313830346337363138306536323666613236343461376465333435313164366334363637643938393337653237373333663464316539313338383333353465353466643733353137323165373666376235366333343833333838663461366238376232386165626562303230333031303030312813320218163a603962343038383566313362366163316337353336393262613366313739303061333838333165363934613061663937343934623834333838323039636235656662646339386136646162623265316337313833393166633133356264616163330ab70722cc06333038323031613233303064303630393261383634383836663730643031303130313035303030333832303138663030333038323031386130323832303138313030396463643863306135336539306333353539353734663636323034313137643362353033653530613336643330393766616338343239653663656364333762623534303731383038663265653938323033356638353161306339626532313736333833613232653338633161626131363866333266393035373063623332333363666536323539383736363661663637623531346361656632316662386466366430666364333363663236303662393264646561353533366236303638643836373832653339626435633338343435393931643431396237643165633038353939343132633039343964316332343062333563313464633535323734646261373166666165393336313235613566383139663534313332653234333964346163353539373939366563653835653133646666333336316639313331663536636561633562396635353262343963663666396139616336653564636532646233363934363266393361663830653562353662366538626566613136326130363162346137363839326264633834363437333036633630303835386664643237303332373663326337303434303139386566643766653335343563663261623538306337346366643634343561616637626437663734356363323532656162643236356561626565383632343137313034653639343861353537353666646332323264663061313031353234646531633363303863636630343330313165633766653936346564643834353161313330313437633037333633613335663131666465656638663261326237363137353762343335386666383962373561343864363762646336303930363933653062623836373965636262393366666462336633656439366265633933656634363536653337313661623837636534366361386531323539633866656464653866326631656130663365623263343865393635353164653132333330333435373235663435656436396338353735623531363833616661343732363231383236646232326262326431633466316533363436346139303230333031303030312814320218173a60346630613033333466393737363738313632663830643936376637323139313431333630633062376637663033316233376336396536323137333933336564616434366263626139373636376565373262666435613933346261313532326330")));

// node_modules/@hashgraph/sdk/lib/constants/ClientConstants.js
var n25 = { "node00.swirldslabs.com:443": new y3(3), "node01-00-grpc.swirlds.com:443": new y3(4), "node03.swirldslabs.com:443": new y3(6), "node04.swirldslabs.com:443": new y3(7), "node05.swirldslabs.com:443": new y3(8), "node06.swirldslabs.com:443": new y3(9), "node07.swirldslabs.com:443": new y3(10), "node09.swirldslabs.com:443": new y3(12), "node10.swirldslabs.com:443": new y3(13), "node11.swirldslabs.com:443": new y3(14), "node12.swirldslabs.com:443": new y3(15), "node14.swirldslabs.com:443": new y3(17), "node15.swirldslabs.com:443": new y3(18), "node16.swirldslabs.com:443": new y3(19), "node17.swirldslabs.com:443": new y3(20), "node18.swirldslabs.com:443": new y3(21), "node19.swirldslabs.com:443": new y3(22), "node20.swirldslabs.com:443": new y3(23), "node21.swirldslabs.com:443": new y3(24), "node22.swirldslabs.com:443": new y3(25), "node24.swirldslabs.com:443": new y3(27), "node25.swirldslabs.com:443": new y3(28), "node26.swirldslabs.com:443": new y3(29), "node27.swirldslabs.com:443": new y3(30), "node28.swirldslabs.com:443": new y3(31), "node29.swirldslabs.com:443": new y3(32), "node30.swirldslabs.com:443": new y3(33), "node31.swirldslabs.com:443": new y3(34) };
var o27 = { "testnet-node00-00-grpc.hedera.com:443": new y3(3), "testnet-node01-00-grpc.hedera.com:443": new y3(4), "testnet-node02-00-grpc.hedera.com:443": new y3(5), "testnet-node03-00-grpc.hedera.com:443": new y3(6), "testnet-node04-00-grpc.hedera.com:443": new y3(7), "testnet-node05-00-grpc.hedera.com:443": new y3(8), "testnet-node06-00-grpc.hedera.com:443": new y3(9) };
var s22 = { "previewnet-node00-00-grpc.hedera.com:443": new y3(3), "previewnet-node01-00-grpc.hedera.com:443": new y3(4), "previewnet-node02-00-grpc.hedera.com:443": new y3(5), "previewnet-node03-00-grpc.hedera.com:443": new y3(6), "previewnet-node04-00-grpc.hedera.com:443": new y3(7), "previewnet-node05-00-grpc.hedera.com:443": new y3(8), "previewnet-node06-00-grpc.hedera.com:443": new y3(9) };
var d16 = { ...n25, ...o27, ...s22 };
var w4 = { MAINNET: ["mainnet-public.mirrornode.hedera.com:443"], TESTNET: ["testnet.mirrornode.hedera.com:443"], PREVIEWNET: ["previewnet.mirrornode.hedera.com:443"], LOCAL_NODE: ["127.0.0.1:5600"] };
var c15 = { MAINNET: n25, TESTNET: o27, PREVIEWNET: s22 };

// node_modules/@hashgraph/sdk/lib/exports.js
var e29 = { Mainnet: "mainnet", Testnet: "testnet", Previewnet: "previewnet" };

// node_modules/@hashgraph/sdk/lib/ManagedNodeAddress.js
var t27 = /^(\S+):(\d+)$/;
var r33 = class _r {
  constructor(r41 = {}) {
    if (null != r41.address) {
      const s26 = t27.exec(r41.address);
      if (null == s26) throw new Error(`failed to parse address: ${r41.address}`);
      this._address = s26[1], this._port = null != s26[2] ? parseInt(s26[2]) : null;
    } else {
      if (null == r41.host || null == r41.port) throw new Error(`failed to create a managed node address: ${JSON.stringify(r41)}`);
      this._address = r41.host, this._port = r41.port;
    }
    Object.freeze(this);
  }
  static fromString(t35) {
    return new _r({ address: t35 });
  }
  toInsecure() {
    let t35 = 50212 === this.port ? 50211 : this.port;
    return new _r({ host: this.address, port: t35 });
  }
  toSecure() {
    let t35 = 50211 === this.port ? 50212 : this.port;
    return new _r({ host: this.address, port: t35 });
  }
  get address() {
    return this._address;
  }
  get port() {
    return this._port;
  }
  isTransportSecurity() {
    return 50212 == this._port || 443 == this._port;
  }
  toString() {
    return null == this.port ? this.address : `${this.address}:${this.port}`;
  }
};

// node_modules/@hashgraph/sdk/lib/ManagedNode.js
var t28 = class {
  constructor(t35 = {}) {
    if (null != t35.newNode) this._address = "string" == typeof t35.newNode.address ? r33.fromString(t35.newNode.address) : t35.newNode.address, this._cert = void 0, this._channel = null, this._channelInitFunction = t35.newNode.channelInitFunction, this._lastUsed = Date.now(), this._readmitTime = Date.now(), this._useCount = 0, this._badGrpcStatusCount = 0, this._minBackoff = 8e3, this._maxBackoff = 36e5, this._currentBackoff = this._minBackoff;
    else {
      if (null == t35.cloneNode) throw new Error(`failed to create ManagedNode: ${JSON.stringify(t35)}`);
      this._address = t35.cloneNode.address, this._cert = t35.cloneNode.node._cert, this._channel = t35.cloneNode.node._channel, this._channelInitFunction = t35.cloneNode.node._channelInitFunction, this._currentBackoff = t35.cloneNode.node._currentBackoff, this._lastUsed = t35.cloneNode.node._lastUsed, this._readmitTime = t35.cloneNode.node._readmitTime, this._useCount = t35.cloneNode.node._useCount, this._badGrpcStatusCount = t35.cloneNode.node._badGrpcStatusCount, this._minBackoff = t35.cloneNode.node._minBackoff, this._maxBackoff = t35.cloneNode.node._minBackoff;
    }
  }
  getKey() {
    throw new Error("not implemented");
  }
  setCert(e39) {
    return this;
  }
  get address() {
    return this._address;
  }
  get attempts() {
    return this._badGrpcStatusCount;
  }
  get minBackoff() {
    return this._minBackoff;
  }
  setMinBackoff(e39) {
    return this._currentBackoff <= e39 && (this._currentBackoff = e39), this._minBackoff = e39, this;
  }
  get maxBackoff() {
    return this._maxBackoff;
  }
  setMaxBackoff(e39) {
    return this._currentBackoff <= e39 && (this._currentBackoff = e39), this._maxBackoff = e39, this;
  }
  getChannel() {
    return this._useCount++, this.__lastUsed = Date.now(), null != this._channel || (this._channel = this._channelInitFunction(this.address.toString(), this._cert)), this._channel;
  }
  isHealthy() {
    return this._readmitTime <= Date.now();
  }
  increaseBackoff() {
    this._currentBackoff = Math.min(2 * this._currentBackoff, this._maxBackoff), this._readmitTime = Date.now() + this._currentBackoff;
  }
  decreaseBackoff() {
    this._currentBackoff = Math.max(this._currentBackoff / 2, this._minBackoff);
  }
  getRemainingTime() {
    return this._readmitTime - this._lastUsed;
  }
  backoff() {
    return new Promise(((e39) => setTimeout(e39, this.getRemainingTime())));
  }
  compare(e39) {
    let t35 = this.getRemainingTime() - e39.getRemainingTime();
    return 0 != t35 ? t35 : (t35 = this._currentBackoff - e39._currentBackoff, 0 != t35 ? t35 : (t35 = this._badGrpcStatusCount - e39._badGrpcStatusCount, 0 != t35 ? t35 : (t35 = this._useCount - e39._useCount, 0 != t35 ? t35 : this._lastUsed - e39._lastUsed)));
  }
  close() {
    null != this._channel && this._channel.close(), this._channel = null;
  }
};

// node_modules/@hashgraph/sdk/lib/Node.js
var d17 = class _d extends t28 {
  constructor(e39 = {}) {
    if (super(e39), null != e39.newNode) this._accountId = e39.newNode.accountId, this._nodeAddress = null;
    else {
      if (null == e39.cloneNode) throw new Error(`failed to create node: ${JSON.stringify(e39)}`);
      this._accountId = e39.cloneNode.node._accountId, this._nodeAddress = e39.cloneNode.node._nodeAddress;
    }
  }
  getKey() {
    return this._accountId.toString();
  }
  toInsecure() {
    return new _d({ cloneNode: { node: this, address: this._address.toInsecure() } });
  }
  toSecure() {
    return new _d({ cloneNode: { node: this, address: this._address.toSecure() } });
  }
  get accountId() {
    return this._accountId;
  }
  get nodeAddress() {
    return this._nodeAddress;
  }
  setNodeAddress(e39) {
    return this._nodeAddress = e39, this;
  }
};

// node_modules/@hashgraph/sdk/lib/client/ManagedNetwork.js
var o28 = class {
  constructor(e39) {
    this._network = /* @__PURE__ */ new Map(), this._nodes = [], this._healthyNodes = [], this._createNetworkChannel = e39, this._ledgerId = null, this._minBackoff = 8e3, this._maxBackoff = 36e5, this._maxNodeAttempts = -1, this._nodeMinReadmitPeriod = this._minBackoff, this._nodeMaxReadmitPeriod = this._maxBackoff, this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod;
  }
  setNetworkName(e39) {
    return console.warn("Deprecated: Use `setLedgerId` instead"), this.setLedgerId(e39);
  }
  get networkName() {
    return console.warn("Deprecated: Use `ledgerId` instead"), null != this.ledgerId ? this.ledgerId.toString() : null;
  }
  setLedgerId(t35) {
    return this._ledgerId = "string" == typeof t35 ? r15.fromString(t35) : t35, this;
  }
  get ledgerId() {
    return null != this._ledgerId ? this._ledgerId : null;
  }
  _createNodeFromNetworkEntry(e39) {
    throw new Error("not implemented");
  }
  _getNodesToRemove(e39) {
    throw new Error("not implemented");
  }
  _removeDeadNodes() {
    if (this._maxNodeAttempts > 0) for (let e39 = this._nodes.length - 1; e39 >= 0; e39--) {
      this._nodes[e39]._badGrpcStatusCount < this._maxNodeAttempts || this._closeNode(e39);
    }
  }
  _readmitNodes() {
    const e39 = Date.now();
    if (this._earliestReadmitTime <= e39) {
      let t35 = Number.MAX_SAFE_INTEGER, o32 = true;
      e: for (let s26 = 0; s26 < this._nodes.length; s26++) {
        for (let i17 = 0; i17 < this._healthyNodes.length; i17++) if (o32 && this._nodes[s26]._readmitTime > e39 && (t35 = Math.min(this._nodes[s26]._readmitTime, t35)), this._nodes[s26] == this._healthyNodes[i17]) continue e;
        o32 = false, this._nodes[s26]._readmitTime <= e39 && this._healthyNodes.push(this._nodes[s26]);
      }
      this._earliestReadmitTime = Math.min(Math.max(t35, this._nodeMinReadmitPeriod), this._nodeMaxReadmitPeriod);
    }
  }
  _getNumberOfMostHealthyNodes(e39) {
    this._removeDeadNodes(), this._readmitNodes();
    const t35 = [];
    let o32 = this._healthyNodes.slice();
    e39 = Math.min(e39, o32.length);
    for (let s26 = 0; s26 < e39; s26++) {
      const e40 = o32[Math.floor(Math.random() * o32.length)];
      if (!e40) break;
      t35.push(e40), o32 = o32.filter(((t36) => t36.getKey() !== e40.getKey()));
    }
    return t35;
  }
  _closeNode(e39) {
    const t35 = this._nodes[e39];
    t35.close(), this._removeNodeFromNetwork(t35), this._nodes.splice(e39, 1);
  }
  _removeNodeFromNetwork(e39) {
    const t35 = this._network.get(e39.getKey());
    for (let o32 = 0; o32 < t35.length; o32++) if (t35[o32] === e39) {
      t35.splice(o32, 1);
      break;
    }
    0 === t35.length && this._network.delete(e39.getKey());
  }
  _setNetwork(e39) {
    const o32 = [], s26 = /* @__PURE__ */ new Set(), i17 = /* @__PURE__ */ new Set(), r41 = [], n31 = /* @__PURE__ */ new Map();
    for (const t35 of this._getNodesToRemove(e39)) this._closeNode(t35);
    for (const e40 of this._nodes) o32.push(e40), s26.add(e40.getKey()), i17.add(e40.address.toString());
    for (const [t35, r42] of e39) s26.has(r42.toString()) && i17.has(t35) || o32.push(this._createNodeFromNetworkEntry([t35, r42]));
    T(o32);
    for (const e40 of o32) {
      if (!e40.isHealthy()) continue;
      r41.push(e40);
      const t35 = n31.has(e40.getKey()) ? n31.get(e40.getKey()) : [];
      t35.push(e40), n31.set(e40.getKey(), t35);
    }
    return this._nodes = o32, this._healthyNodes = r41, this._network = n31, this;
  }
  get maxNodeAttempts() {
    return this._maxNodeAttempts;
  }
  setMaxNodeAttempts(e39) {
    return this._maxNodeAttempts = e39, this;
  }
  get minBackoff() {
    return this._minBackoff;
  }
  setMinBackoff(e39) {
    this._minBackoff = e39;
    for (const t35 of this._nodes) t35.setMinBackoff(e39);
    return this;
  }
  get maxBackoff() {
    return this._maxBackoff;
  }
  setMaxBackoff(e39) {
    this._maxBackoff = e39;
    for (const t35 of this._nodes) t35.setMaxBackoff(e39);
    return this;
  }
  get nodeMinReadmitPeriod() {
    return this._nodeMinReadmitPeriod;
  }
  setNodeMinReadmitPeriod(e39) {
    return this._nodeMinReadmitPeriod = e39, this._earliestReadmitTime = Date.now() + this._nodeMinReadmitPeriod, this;
  }
  get nodeMaxReadmitPeriod() {
    return this._nodeMaxReadmitPeriod;
  }
  setNodeMaxReadmitPeriod(e39) {
    return this._nodeMaxReadmitPeriod = e39, this;
  }
  getNode(e39) {
    if (this._readmitNodes(), null != e39 && null != e39) {
      const t35 = this._network.get(e39.toString());
      if (t35) {
        return t35[Math.floor(Math.random() * t35.length)];
      }
      {
        const e40 = Array.from(this._network.keys()), t36 = e40[Math.floor(Math.random() * e40.length)], o32 = this._network.get(t36);
        return o32[Math.floor(Math.random() * o32.length)];
      }
    }
    if (0 == this._healthyNodes.length) throw new Error("failed to find a healthy working node");
    return this._healthyNodes[Math.floor(Math.random() * this._healthyNodes.length)];
  }
  increaseBackoff(e39) {
    e39.increaseBackoff();
    for (let t35 = 0; t35 < this._healthyNodes.length; t35++) this._healthyNodes[t35] == e39 && this._healthyNodes.splice(t35, 1);
  }
  decreaseBackoff(e39) {
    e39.decreaseBackoff();
  }
  close() {
    for (const e39 of this._nodes) e39.close();
    this._network.clear(), this._nodes = [];
  }
};

// node_modules/@hashgraph/sdk/lib/client/Network.js
var i13 = class extends o28 {
  constructor(t35) {
    super(t35), this._maxNodesPerTransaction = -1, this._addressBook = null, this._transportSecurity = false;
  }
  setNetwork(e39) {
    this._setNetwork(new Map(Object.entries(e39).map((([e40, s26]) => [e40, "string" == typeof s26 ? y3.fromString(s26) : s26]))));
  }
  setNetworkFromAddressBook(t35) {
    const e39 = {}, s26 = this.isTransportSecurity() ? 50212 : 50211;
    for (const r41 of t35.nodeAddresses) for (const t36 of r41.addresses) t36.port === s26 && null != r41.accountId && (e39[t36.toString()] = r41.accountId);
    return this.setNetwork(e39), this;
  }
  get network() {
    var t35 = {};
    for (const e39 of this._nodes) t35[e39.address.toString()] = e39.accountId;
    return t35;
  }
  setNetworkName(t35) {
    switch (super.setLedgerId(t35), t35) {
      case "mainnet":
        this._addressBook = b4;
        break;
      case "testnet":
        this._addressBook = o26;
        break;
      case "previewnet":
        this._addressBook = d15;
    }
    if (null != this._addressBook) for (const t36 of this._nodes) for (const e39 of this._addressBook.nodeAddresses) null != e39.accountId && e39.accountId.toString() === t36.accountId.toString() && t36.setNodeAddress(e39);
    return this;
  }
  get networkName() {
    return null != this._ledgerId ? this._ledgerId.toString() : null;
  }
  _createNodeFromNetworkEntry(s26) {
    const r41 = "string" == typeof s26[1] ? y3.fromString(s26[1]) : s26[1];
    return new d17({ newNode: { address: s26[0], accountId: r41, channelInitFunction: this._createNetworkChannel } }).setMinBackoff(this._minBackoff);
  }
  _getNodesToRemove(t35) {
    const e39 = [];
    for (let s26 = this._nodes.length - 1; s26 >= 0; s26--) {
      const r41 = this._nodes[s26], o32 = t35.get(r41.address.toString());
      null != o32 && o32.toString() === r41.accountId.toString() || e39.push(s26);
    }
    return e39;
  }
  _checkNetworkContainsEntry(t35) {
    for (const e39 of this._nodes) if (e39.address.toString() === t35[0]) return true;
    return false;
  }
  get maxNodesPerTransaction() {
    return this._maxNodesPerTransaction;
  }
  setMaxNodesPerTransaction(t35) {
    return this._maxNodesPerTransaction = t35, this;
  }
  get maxNodeAttempts() {
    return this._maxNodeAttempts;
  }
  setMaxNodeAttempts(t35) {
    return this._maxNodeAttempts = t35, this;
  }
  isTransportSecurity() {
    return this._transportSecurity;
  }
  setTransportSecurity(t35) {
    if (this._transportSecurity == t35) return this;
    this._network.clear();
    for (let e39 = 0; e39 < this._nodes.length; e39++) {
      let s26 = this._nodes[e39];
      s26.close(), s26 = t35 ? s26.toSecure().setCert(null != this._ledgerId ? this._ledgerId.toString() : "") : s26.toInsecure(), this._nodes[e39] = s26;
      const r41 = null != this._network.get(s26.getKey()) ? this._network.get(s26.getKey()) : [];
      r41.push(s26), this._network.set(s26.getKey(), r41);
    }
    return this._healthyNodes = [...this._nodes], this._transportSecurity = t35, this;
  }
  getNumberOfNodesForTransaction() {
    return this._maxNodesPerTransaction > 0 ? this._maxNodesPerTransaction : this._nodes.length <= 9 ? this._nodes.length : Math.floor((this._nodes.length + 3 - 1) / 3);
  }
  getNodeAccountIdsForExecute() {
    return this._getNumberOfMostHealthyNodes(this.getNumberOfNodesForTransaction()).map(((t35) => t35.accountId));
  }
};

// node_modules/@hashgraph/sdk/lib/MirrorNode.js
var t29 = class extends t28 {
  constructor(e39 = {}) {
    super(e39);
  }
  getKey() {
    return this._address.toString();
  }
};

// node_modules/@hashgraph/sdk/lib/client/MirrorNetwork.js
var r34 = class extends o28 {
  constructor(e39) {
    super(e39);
  }
  setNetwork(e39) {
    this._setNetwork(new Map(e39.map(((e40) => [e40, e40]))));
  }
  get network() {
    var e39 = [];
    for (const t35 of this._nodes) e39.push(t35.address.toString());
    return e39;
  }
  _createNodeFromNetworkEntry(t35) {
    return new t29({ newNode: { address: t35[1], channelInitFunction: this._createNetworkChannel } }).setMinBackoff(this._minBackoff);
  }
  _getNodesToRemove(e39) {
    const t35 = [], r41 = Object.values(e39);
    for (let e40 = this._nodes.length - 1; e40 >= 0; e40--) {
      const o32 = this._nodes[e40];
      r41.includes(o32.address.toString()) || t35.push(e40);
    }
    return t35;
  }
  getNextMirrorNode() {
    return this._getNumberOfMostHealthyNodes(1)[0];
  }
};

// node_modules/@hashgraph/sdk/lib/client/Client.js
var import_pino2 = __toESM(require_browser(), 1);

// node_modules/@hashgraph/sdk/lib/network/AddressBookQueryWeb.js
var a16 = class extends h3 {
  constructor(t35 = {}) {
    super(), this._fileId = null, null != t35.fileId && this.setFileId(t35.fileId), this._limit = null, null != t35.limit && this.setLimit(t35.limit), this._retryHandler = (t36) => {
      if (null != t36) {
        if (t36 instanceof Error) return true;
        switch (t36.code) {
          case 13:
            return a5.test(t36.details.toString());
          case 5:
          case 8:
          case 14:
          case 17:
            return true;
          default:
            return false;
        }
      }
      return false;
    }, this._addresses = [];
  }
  get fileId() {
    return this._fileId;
  }
  setFileId(t35) {
    return this._fileId = "string" == typeof t35 ? c3.fromString(t35) : t35.clone(), this;
  }
  get limit() {
    return this._limit;
  }
  setLimit(t35) {
    return this._limit = t35, this;
  }
  setMaxAttempts(t35) {
    return this._maxAttempts = t35, this;
  }
  setMaxBackoff(t35) {
    return this._maxBackoff = t35, this;
  }
  execute(t35, e39) {
    if (0 === t35._network._network.size && !t35._timer) throw new Error("The client's network update period is required. Please set it using the setNetworkUpdatePeriod method.");
    return new Promise(((r41, s26) => {
      this._makeFetchRequest(t35, r41, s26, e39);
    }));
  }
  async _makeFetchRequest(t35, r41, s26, o32) {
    const { port: n31, address: d18 } = t35._mirrorNetwork.getNextMirrorNode().address;
    let a23 = `${d18.includes("127.0.0.1") || d18.includes("localhost") ? "http" : "https"}://${d18}`;
    n31 && (a23 = `${a23}:${n31}`);
    const l19 = new URL(`${a23}/api/v1/network/nodes`);
    null != this._fileId && l19.searchParams.append("file.id", this._fileId.toString()), null != this._limit && l19.searchParams.append("limit", this._limit.toString());
    for (let n32 = 0; n32 <= this._maxAttempts; n32++) try {
      const s27 = await fetch(l19.toString(), { method: "GET", headers: { Accept: "application/json" }, signal: o32 ? AbortSignal.timeout(o32) : void 0 });
      if (!s27.ok) throw new Error(`HTTP error! status: ${s27.status}`);
      const n33 = (await s27.json()).nodes || [];
      this._addresses = n33.map(((e39) => d14.fromJSON({ nodeId: e39.node_id.toString(), accountId: e39.node_account_id, addresses: this._handleAddressesFromGrpcProxyEndpoint(e39, t35), certHash: e39.node_cert_hash, publicKey: e39.public_key, description: e39.description, stake: e39.stake.toString() })));
      return void r41(new o25({ nodeAddresses: this._addresses }));
    } catch (e39) {
      console.error("Error in _makeFetchRequest:", e39);
      const r42 = e39 instanceof Error ? e39.message : String(e39);
      if (n32 < this._maxAttempts && !t35.isClientShutDown && this._retryHandler(e39)) {
        const t36 = Math.min(250 * 2 ** n32, this._maxBackoff);
        this._logger && this._logger.debug(`Error getting nodes from mirror for file ${null != this._fileId ? this._fileId.toString() : "UNKNOWN"} during attempt ${n32 + 1}. Waiting ${t36} ms before next attempt: ${r42}`), await new Promise(((e40) => setTimeout(e40, t36)));
        continue;
      }
      const i17 = n32 >= this._maxAttempts ? `Failed to query address book after ${this._maxAttempts + 1} attempts. Last error: ${r42}` : `Failed to query address book: ${r42}`;
      return void s26(new Error(i17));
    }
    s26(new Error("failed to query address book"));
  }
  _handleAddressesFromGrpcProxyEndpoint(t35, e39) {
    const r41 = t35.grpc_proxy_endpoint;
    if (r41 && r41.domain_name && r41.port) return [{ address: r41.domain_name, port: r41.port.toString() }];
    let s26;
    const i17 = e39._network.ledgerId;
    if (i17 && i17.isMainnet()) s26 = n25;
    else if (i17 && i17.isTestnet()) s26 = o27;
    else {
      if (!i17 || !i17.isPreviewnet()) return [];
      s26 = s22;
    }
    const a23 = t35.node_account_id;
    for (const [t36, e40] of Object.entries(s26)) if (e40.toString() === a23) {
      const [e41, r42] = t36.split(":");
      return [{ address: e41, port: r42 }];
    }
    return [];
  }
};

// node_modules/@hashgraph/sdk/lib/client/Client.js
var l17 = class {
  constructor(t35) {
    this._mirrorNetwork = new r34(this._createMirrorNetworkChannel()), this._network = new i13(this._createNetworkChannel()), this._operator = null, this._defaultMaxTransactionFee = null, this._defaultMaxQueryPayment = new e4(1), null != t35 && null != t35.operator && this.setOperator(t35.operator.accountId, t35.operator.privateKey), this._maxAttempts = null, this._signOnDemand = false, this._autoValidateChecksums = false, this._minBackoff = 250, this._maxBackoff = 8e3, this._defaultRegenerateTransactionId = true, this._requestTimeout = null, this._isUpdatingNetwork = false, this._networkUpdatePeriod = 864e5, this._isShutdown = false, this._shard = 0, this._realm = 0, null != t35 && false !== t35.scheduleNetworkUpdate && this._scheduleNetworkUpdate(), null != t35 && null != t35.shard && (this._shard = t35.shard), null != t35 && null != t35.realm && (this._realm = t35.realm), this._timer, this._logger = null;
  }
  setNetworkName(t35) {
    return console.warn("Deprecated: Use `setLedgerId` instead"), this.setLedgerId(t35);
  }
  get networkName() {
    return console.warn("Deprecated: Use `ledgerId` instead"), null != this.ledgerId ? this.ledgerId.toString() : null;
  }
  setLedgerId(t35) {
    return this._network.setLedgerId("string" == typeof t35 ? r15.fromString(t35) : t35), this;
  }
  get ledgerId() {
    return null != this._network._ledgerId ? this._network.ledgerId : null;
  }
  setNetwork(t35) {
    throw new Error("not implemented");
  }
  setNetworkFromAddressBook(t35) {
    return this._network.setNetworkFromAddressBook(t35), this;
  }
  get network() {
    return this._network.network;
  }
  get shard() {
    return this._shard;
  }
  get realm() {
    return this._realm;
  }
  setMirrorNetwork(t35) {
    throw new Error("not implemented");
  }
  get mirrorNetwork() {
    return this._mirrorNetwork.network;
  }
  get signOnDemand() {
    return this._signOnDemand;
  }
  setSignOnDemand(t35) {
    this._signOnDemand = t35;
  }
  isTransportSecurity() {
    return this._network.isTransportSecurity();
  }
  setTransportSecurity(t35) {
    return this._network.setTransportSecurity(t35), this;
  }
  setOperator(t35, e39) {
    const r41 = "string" == typeof e39 ? g3.fromStringDer(e39) : e39;
    return this.setOperatorWith(t35, r41.publicKey, ((t36) => Promise.resolve(r41.sign(t36))));
  }
  getOperator() {
    return this._operator;
  }
  setOperatorWith(e39, r41, n31) {
    const s26 = e39 instanceof y3 ? e39 : y3.fromString(e39);
    return null != this._network._ledgerId && s26.validateChecksum(this), this._operator = { transactionSigner: n31, accountId: s26, publicKey: r41 instanceof i ? r41 : i.fromString(r41) }, this;
  }
  setAutoValidateChecksums(t35) {
    return this._autoValidateChecksums = t35, this;
  }
  isAutoValidateChecksumsEnabled() {
    return this._autoValidateChecksums;
  }
  get operatorAccountId() {
    return null != this._operator ? this._operator.accountId : null;
  }
  get operatorPublicKey() {
    return null != this._operator ? this._operator.publicKey : null;
  }
  get defaultMaxTransactionFee() {
    return this._defaultMaxTransactionFee;
  }
  get maxTransactionFee() {
    return this.defaultMaxTransactionFee;
  }
  setDefaultMaxTransactionFee(t35) {
    if (t35.toTinybars().toInt() < 0) throw new Error("defaultMaxTransactionFee must be non-negative");
    return this._defaultMaxTransactionFee = t35, this;
  }
  setMaxTransactionFee(t35) {
    return this.setDefaultMaxTransactionFee(t35);
  }
  get defaultRegenerateTransactionId() {
    return this._defaultRegenerateTransactionId;
  }
  setDefaultRegenerateTransactionId(t35) {
    return this._defaultRegenerateTransactionId = t35, this;
  }
  get defaultMaxQueryPayment() {
    return this._defaultMaxQueryPayment;
  }
  get maxQueryPayment() {
    return this.defaultMaxQueryPayment;
  }
  setDefaultMaxQueryPayment(t35) {
    if (d(t35.toTinybars()) < 0) throw new Error("defaultMaxQueryPayment must be non-negative");
    return this._defaultMaxQueryPayment = t35, this;
  }
  setMaxQueryPayment(t35) {
    return this.setDefaultMaxQueryPayment(t35);
  }
  get maxAttempts() {
    return null != this._maxAttempts ? this._maxAttempts : 10;
  }
  setMaxAttempts(t35) {
    return this._maxAttempts = t35, this;
  }
  get maxNodeAttempts() {
    return this._network.maxNodeAttempts;
  }
  setMaxNodeAttempts(t35) {
    return this._network.setMaxNodeAttempts(t35), this;
  }
  get nodeWaitTime() {
    return this._network.minBackoff;
  }
  setNodeWaitTime(t35) {
    return this._network.setMinBackoff(t35), this;
  }
  get maxNodesPerTransaction() {
    return this._network.maxNodesPerTransaction;
  }
  setMaxNodesPerTransaction(t35) {
    return this._network.setMaxNodesPerTransaction(t35), this;
  }
  setMinBackoff(t35) {
    if (null == t35) throw new Error("minBackoff cannot be null.");
    if (t35 > this._maxBackoff) throw new Error("minBackoff cannot be larger than maxBackoff.");
    return this._minBackoff = t35, this;
  }
  get minBackoff() {
    return this._minBackoff;
  }
  setMaxBackoff(t35) {
    if (null == t35) throw new Error("maxBackoff cannot be null.");
    if (t35 < this._minBackoff) throw new Error("maxBackoff cannot be smaller than minBackoff.");
    return this._maxBackoff = t35, this;
  }
  get maxBackoff() {
    return this._maxBackoff;
  }
  setNodeMinBackoff(t35) {
    return this._network.setMinBackoff(t35), this;
  }
  get nodeMinBackoff() {
    return this._network.minBackoff;
  }
  setNodeMaxBackoff(t35) {
    return this._network.setMaxBackoff(t35), this;
  }
  get nodeMaxBackoff() {
    return this._network.maxBackoff;
  }
  setNodeMinReadmitPeriod(t35) {
    return this._network.setNodeMinReadmitPeriod(t35), this;
  }
  get nodeMinReadmitPeriod() {
    return this._network.nodeMinReadmitPeriod;
  }
  setNodeMaxReadmitPeriod(t35) {
    return this._network.setNodeMaxReadmitPeriod(t35), this;
  }
  get nodeMaxReadmitPeriod() {
    return this._network.nodeMaxReadmitPeriod;
  }
  setRequestTimeout(t35) {
    return this._requestTimeout = t35, this;
  }
  get requestTimeout() {
    return this._requestTimeout;
  }
  get networkUpdatePeriod() {
    return this._networkUpdatePeriod;
  }
  setNetworkUpdatePeriod(t35) {
    return clearTimeout(this._timer), this._networkUpdatePeriod = t35, this._scheduleNetworkUpdate(), this;
  }
  setLogger(t35) {
    return this._logger = t35, this;
  }
  get logger() {
    return this._logger;
  }
  async ping(r41) {
    await new e13({ accountId: r41 }).setNodeAccountIds([r41 instanceof y3 ? r41 : y3.fromString(r41)]).execute(this);
  }
  async pingAll() {
    for (const t35 of Object.values(this._network.network)) await this.ping(t35);
  }
  async updateNetwork() {
    if (this._isUpdatingNetwork) return this;
    this._isUpdatingNetwork = true;
    try {
      const t35 = await new a16().setFileId(c3.getAddressBookFileIdFor(this._shard, this._realm)).execute(this);
      this.setNetworkFromAddressBook(t35);
    } catch (t35) {
      this._logger && this._logger.trace(`failed to update client address book: ${t35.toString()}`);
    } finally {
      this._isUpdatingNetwork = false;
    }
    return this;
  }
  close() {
    this._network.close(), this._mirrorNetwork.close(), this._isShutdown = true, clearTimeout(this._timer);
  }
  _createNetworkChannel() {
    throw new Error("not implemented");
  }
  _createMirrorNetworkChannel() {
    throw new Error("not implemented");
  }
  _scheduleNetworkUpdate() {
    this._timer = setTimeout((async () => {
      await this.updateNetwork(), this._isShutdown || this._scheduleNetworkUpdate();
    }), this._networkUpdatePeriod);
  }
  get isClientShutDown() {
    return this._isShutdown;
  }
  static _validateNetworkConsistency(t35) {
    if (0 === Object.keys(t35).length) return;
    const [, e39] = Object.entries(t35)[0], r41 = e39.toString(), [n31, s26] = r41.split(".").map(Number), o32 = Object.values(t35).every(((t36) => {
      const e40 = t36.toString(), [r42, o33] = e40.split(".").map(Number);
      return r42 === n31 && o33 === s26;
    }));
    if (!o32) throw new Error("Network is not valid, all nodes must be in the same shard and realm");
  }
  static _extractShardRealm(t35) {
    const e39 = Object.entries(t35);
    if (0 === e39.length) return { shard: 0, realm: 0 };
    const [, r41] = e39[0], n31 = r41.toString(), [s26, o32] = n31.split(".").map(Number);
    return { shard: s26, realm: o32 };
  }
};

// node_modules/@hashgraph/sdk/lib/http/HttpStatus.js
var t30 = class _t {
  constructor(t35) {
    this._code = t35, Object.freeze(this);
  }
  static _fromValue(e39) {
    return new _t(e39);
  }
  toString() {
    return this._code.toString();
  }
  valueOf() {
    return this._code;
  }
};

// node_modules/@hashgraph/sdk/lib/version.js
var o29 = "hiero-sdk-js";
var s23 = "2.71.1";

// node_modules/@hashgraph/sdk/lib/channel/Channel.js
var e30 = __toESM(require_lib(), 1);
var { proto: r35 } = e30;
var n26 = class {
  constructor() {
    this._crypto = null, this._smartContract = null, this._file = null, this._consensus = null, this._freeze = null, this._network = null, this._token = null, this._schedule = null, this._util = null, this._addressBook = null;
  }
  close() {
    throw new Error("not implemented");
  }
  get crypto() {
    return null != this._crypto || (this._crypto = r35.CryptoService.create(this._createUnaryClient("CryptoService"))), this._crypto;
  }
  get smartContract() {
    return null != this._smartContract || (this._smartContract = r35.SmartContractService.create(this._createUnaryClient("SmartContractService"))), this._smartContract;
  }
  get file() {
    return null != this._file || (this._file = r35.FileService.create(this._createUnaryClient("FileService"))), this._file;
  }
  get consensus() {
    return null != this._consensus || (this._consensus = r35.ConsensusService.create(this._createUnaryClient("ConsensusService"))), this._consensus;
  }
  get freeze() {
    return null != this._freeze || (this._freeze = r35.FreezeService.create(this._createUnaryClient("FreezeService"))), this._freeze;
  }
  get network() {
    return null != this._network || (this._network = r35.NetworkService.create(this._createUnaryClient("NetworkService"))), this._network;
  }
  get token() {
    return null != this._token || (this._token = r35.TokenService.create(this._createUnaryClient("TokenService"))), this._token;
  }
  get schedule() {
    return null != this._schedule || (this._schedule = r35.ScheduleService.create(this._createUnaryClient("ScheduleService"))), this._schedule;
  }
  get util() {
    return null != this._util || (this._util = r35.UtilService.create(this._createUnaryClient("UtilService"))), this._util;
  }
  get addressBook() {
    return null != this._addressBook || (this._addressBook = r35.AddressBookService.create(this._createUnaryClient("AddressBookService"))), this._addressBook;
  }
  _createUnaryClient(e39) {
    throw new Error("not implemented");
  }
};
function s24(e39) {
  const t35 = new ArrayBuffer(e39.byteLength + 5);
  return new DataView(t35, 1, 4).setUint32(0, e39.length), new Uint8Array(t35, 5).set(e39), t35;
}
function i14(e39, r41 = 0, n31 = e39.byteLength) {
  const s26 = new DataView(e39, r41, n31);
  let i17 = 0, o32 = null, l19 = 0;
  for (; i17 < s26.byteLength; ) {
    const r42 = s26.getUint8(i17 + 0) >> 7, n32 = s26.getUint32(i17 + 1), c17 = i17 + 5;
    if (c17 + n32 > s26.byteLength) throw new Error("(BUG) unexpected frame length past the boundary");
    const a23 = new Uint8Array(e39, s26.byteOffset + c17, n32);
    if (0 === r42) {
      if (null != o32) throw new Error("(BUG) unexpectedly received more than one data frame");
      o32 = a23;
    } else {
      if (1 !== r42) throw new Error(`(BUG) unexpected frame type: ${r42}`);
      {
        const e40 = e8(a23), [r43, n33] = e40.split(":");
        if ("grpc-status" !== r43) throw new Error(`(BUG) unhandled trailer, ${e40}`);
        l19 = parseInt(n33);
      }
    }
    i17 += n32 + 5;
  }
  if (0 !== l19) throw new Error(`(BUG) unhandled grpc-status: ${l19}`);
  if (null == o32) throw new Error("(BUG) unexpectedly received no response");
  return o32;
}

// node_modules/@hashgraph/sdk/lib/channel/WebChannel.js
var l18 = class extends n26 {
  constructor(t35) {
    super(), this._address = t35;
  }
  close() {
  }
  _createUnaryClient(p3) {
    return async (l19, d18, m6) => {
      var _a2, _b, _c, _d;
      try {
        const u22 = !(this._address.includes("localhost") || this._address.includes("127.0.0.1")) ? `https://${this._address}` : `http://${this._address}`, h8 = await fetch(`${u22}/proto.${p3}/${l19.name}`, { method: "POST", headers: { "content-type": "application/grpc-web+proto", "x-user-agent": `${o29}/${s23}`, "x-grpc-web": "1" }, body: s24(d18) });
        if (!h8.ok) {
          m6(new r8(t30._fromValue(h8.status)), null);
        }
        const f4 = h8.headers.get("grpc-status"), g5 = h8.headers.get("grpc-message");
        if (null != f4 && null != g5) {
          const e39 = new r7(e6._fromValue(parseInt(f4)), (_b = (_a2 = d16) == null ? void 0 : _a2[this._address]) == null ? void 0 : _b.toString());
          e39.message = g5, m6(e39, null);
        }
        const _4 = await h8.arrayBuffer();
        m6(null, i14(_4));
      } catch (e39) {
        m6(new r7(e6._fromValue(18), (_d = (_c = d16) == null ? void 0 : _c[this._address]) == null ? void 0 : _d.toString()), null);
      }
    };
  }
};

// node_modules/@hashgraph/sdk/lib/client/WebClient.js
var a17 = class _a2 extends l17 {
  constructor(e39) {
    if (super(e39), null != e39) {
      if ("string" == typeof e39.network) switch (e39.network) {
        case "mainnet":
          this.setNetwork(c15.MAINNET), this.setLedgerId(r15.MAINNET), this.setMirrorNetwork(w4.MAINNET);
          break;
        case "testnet":
          this.setNetwork(c15.TESTNET), this.setLedgerId(r15.TESTNET), this.setMirrorNetwork(w4.TESTNET);
          break;
        case "previewnet":
          this.setNetwork(c15.PREVIEWNET), this.setLedgerId(r15.PREVIEWNET), this.setMirrorNetwork(w4.PREVIEWNET);
          break;
        default:
          throw new Error(`unknown network: ${e39.network}`);
      }
      else if (null != e39.network) {
        l17._validateNetworkConsistency(e39.network);
        const { shard: r41, realm: s26 } = l17._extractShardRealm(e39.network);
        this._shard = r41, this._realm = s26, this.setNetwork(e39.network);
      }
    }
  }
  static fromConfig(t35) {
    return new _a2("string" == typeof t35 ? JSON.parse(t35) : t35);
  }
  static forNetwork(t35) {
    return new _a2({ network: t35 });
  }
  static forName(t35) {
    return new _a2({ network: t35 });
  }
  static forMainnet() {
    return new _a2({ network: "mainnet" });
  }
  static forTestnet() {
    return new _a2({ network: "testnet" });
  }
  static forPreviewnet() {
    return new _a2({ network: "previewnet" });
  }
  static async forMainnetAsync() {
    return new _a2({ network: "mainnet" }).updateNetwork();
  }
  static async forTestnetAsync() {
    return new _a2({ network: "testnet" }).updateNetwork();
  }
  static async forPreviewnetAsync() {
    return new _a2({ network: "previewnet" }).updateNetwork();
  }
  static async forNameAsync(t35) {
    const e39 = new _a2({ network: t35 });
    return "local-node" !== t35 && await e39.updateNetwork(), e39;
  }
  static async forMirrorNetwork(t35) {
    const e39 = new _a2({ mirrorNetwork: t35 });
    return await e39.updateNetwork(), e39;
  }
  setNetwork(t35) {
    if ("string" == typeof t35) switch (t35) {
      case "previewnet":
        this._network.setNetwork(c15.PREVIEWNET);
        break;
      case "testnet":
        this._network.setNetwork(c15.TESTNET);
        break;
      case "mainnet":
        this._network.setNetwork(c15.MAINNET);
    }
    else this._network.setNetwork(t35);
  }
  setMirrorNetwork(t35) {
    if ("string" == typeof t35) switch (t35) {
      case "local-node":
        this._mirrorNetwork.setNetwork(w4.LOCAL_NODE);
        break;
      case "previewnet":
        this._mirrorNetwork.setNetwork(w4.PREVIEWNET);
        break;
      case "testnet":
        this._mirrorNetwork.setNetwork(w4.TESTNET);
        break;
      case "mainnet":
        this._mirrorNetwork.setNetwork(w4.MAINNET);
        break;
      default:
        this._mirrorNetwork.setNetwork([t35]);
    }
    else this._mirrorNetwork.setNetwork(t35);
    return this;
  }
  async updateNetwork() {
    if (this._isUpdatingNetwork) return this;
    this._isUpdatingNetwork = true;
    try {
      const t35 = await new a16().setFileId(c3.getAddressBookFileIdFor(this.shard, this.realm)).execute(this), e39 = {};
      for (const r41 of t35.nodeAddresses) for (const t36 of r41.addresses) null != r41.accountId && (e39[t36.toString()] = r41.accountId);
      this.setNetwork(e39);
    } catch (t35) {
      if (this._logger) {
        const e39 = t35 instanceof Error ? t35.message : String(t35);
        this._logger.trace(`failed to update client address book: ${e39}`);
      }
    } finally {
      this._isUpdatingNetwork = false;
    }
    return this;
  }
  _createNetworkChannel() {
    return (t35) => new l18(t35);
  }
  _createMirrorNetworkChannel() {
    return () => {
      throw new Error("mirror support is not supported in browsers");
    };
  }
};

// node_modules/@hashgraph/sdk/lib/account/AccountAllowanceAdjustTransaction.js
var u20 = class extends P {
  constructor(e39 = {}) {
    super(), this._hbarAllowances = null != e39.hbarAllowances ? e39.hbarAllowances : [], this._tokenAllowances = null != e39.tokenAllowances ? e39.tokenAllowances : [], this._nftAllowances = null != e39.nftAllowances ? e39.nftAllowances : [];
  }
  get hbarAllowances() {
    return this._hbarAllowances;
  }
  addHbarAllowance(e39, n31) {
    const t35 = n31 instanceof e4 ? n31 : new e4(n31);
    return this._adjustHbarAllowance(null, e39, y(t35));
  }
  _adjustHbarAllowance(e39, r41, o32) {
    return this._requireNotFrozen(), this._hbarAllowances.push(new o11({ spenderAccountId: "string" == typeof r41 ? y3.fromString(r41) : r41 instanceof g4 ? y3.fromEvmAddress(r41.shard, r41.realm, r41.toEvmAddress()) : r41, ownerAccountId: "string" == typeof e39 ? y3.fromString(e39) : e39 instanceof g4 ? y3.fromEvmAddress(e39.shard, e39.realm, e39.toEvmAddress()) : e39, amount: o32 })), this;
  }
  grantHbarAllowance(e39, n31, t35) {
    const r41 = t35 instanceof e4 ? t35 : new e4(t35);
    return this._adjustHbarAllowance(e39, n31, y(r41));
  }
  revokeHbarAllowance(e39, n31, t35) {
    const r41 = t35 instanceof e4 ? t35 : new e4(t35);
    return this._adjustHbarAllowance(e39, n31, y(r41).negated());
  }
  get tokenAllowances() {
    return this._tokenAllowances;
  }
  addTokenAllowance(e39, n31, t35) {
    return this._adjustTokenAllowance(e39, null, n31, y(long_default.fromValue(t35)));
  }
  _adjustTokenAllowance(e39, o32, a23, l19) {
    return this._requireNotFrozen(), this._tokenAllowances.push(new e12({ tokenId: "string" == typeof e39 ? c4.fromString(e39) : e39, spenderAccountId: "string" == typeof a23 ? y3.fromString(a23) : a23 instanceof g4 ? y3.fromEvmAddress(a23.shard, a23.realm, a23.toEvmAddress()) : a23, ownerAccountId: "string" == typeof o32 ? y3.fromString(o32) : o32 instanceof g4 ? y3.fromEvmAddress(o32.shard, o32.realm, o32.toEvmAddress()) : o32, amount: "number" == typeof l19 ? long_default.fromNumber(l19) : l19 })), this;
  }
  grantTokenAllowance(e39, n31, t35, r41) {
    return this._adjustTokenAllowance(e39, n31, t35, y(long_default.fromValue(r41)));
  }
  revokeTokenAllowance(e39, n31, t35, r41) {
    return this._adjustTokenAllowance(e39, n31, t35, y(long_default.fromValue(r41)));
  }
  addTokenNftAllowance(e39, n31) {
    const t35 = "string" == typeof e39 ? e9.fromString(e39) : e39;
    return this._adjustTokenNftAllowance(t35, null, n31);
  }
  _adjustTokenNftAllowance(e39, r41, o32) {
    this._requireNotFrozen();
    const s26 = "string" == typeof o32 ? y3.fromString(o32) : o32 instanceof g4 ? y3.fromEvmAddress(o32.shard, o32.realm, o32.toEvmAddress()) : o32, a23 = "string" == typeof r41 ? y3.fromString(r41) : r41 instanceof g4 ? y3.fromEvmAddress(r41.shard, r41.realm, r41.toEvmAddress()) : r41;
    let l19 = false;
    for (const n31 of this._nftAllowances) if (0 === n31.tokenId.compare(e39.tokenId) && null != n31.spenderAccountId && 0 === n31.spenderAccountId.compare(s26)) {
      null != n31.serialNumbers && n31.serialNumbers.push(e39.serial), l19 = true;
      break;
    }
    return l19 || this._nftAllowances.push(new o12({ tokenId: e39.tokenId, spenderAccountId: s26, serialNumbers: [e39.serial], ownerAccountId: a23, allSerials: false, delegatingSpender: null })), this;
  }
  grantTokenNftAllowance(e39, n31, t35) {
    const r41 = "string" == typeof e39 ? e9.fromString(e39) : e39;
    return y(r41.serial), this._adjustTokenNftAllowance(r41, n31, t35);
  }
  revokeTokenNftAllowance(e39, n31, t35) {
    const r41 = "string" == typeof e39 ? e9.fromString(e39) : e39;
    return y(r41.serial), this._adjustTokenNftAllowance(new e9(r41.tokenId, r41.serial.negate()), n31, t35);
  }
  addAllTokenNftAllowance(e39, n31) {
    return this._adjustTokenNftAllowanceAllSerials(e39, null, n31, true);
  }
  grantTokenNftAllowanceAllSerials(e39, n31, t35) {
    return this._adjustTokenNftAllowanceAllSerials(e39, n31, t35, true);
  }
  revokeTokenNftAllowanceAllSerials(e39, n31, t35) {
    return this._adjustTokenNftAllowanceAllSerials(e39, n31, t35, false);
  }
  _adjustTokenNftAllowanceAllSerials(e39, o32, s26, a23) {
    return this._requireNotFrozen(), this._nftAllowances.push(new o12({ tokenId: "string" == typeof e39 ? c4.fromString(e39) : e39, ownerAccountId: null != o32 ? "string" == typeof o32 ? y3.fromString(o32) : o32 instanceof g4 ? y3.fromEvmAddress(o32.shard, o32.realm, o32.toEvmAddress()) : o32 : null, spenderAccountId: "string" == typeof s26 ? y3.fromString(s26) : s26 instanceof g4 ? y3.fromEvmAddress(s26.shard, s26.realm, s26.toEvmAddress()) : s26, serialNumbers: null, allSerials: a23, delegatingSpender: null })), this;
  }
  _validateChecksums(e39) {
    this._hbarAllowances.map(((n31) => n31._validateChecksums(e39))), this._tokenAllowances.map(((n31) => n31._validateChecksums(e39))), this._nftAllowances.map(((n31) => n31._validateChecksums(e39)));
  }
  _execute(e39, n31) {
    return Promise.reject(new Error("This feature has been deprecated for this class."));
  }
  _getTransactionDataCase() {
    throw new Error("This feature has been deprecated for this class.");
  }
  _makeTransactionData() {
    throw new Error("This feature has been deprecated.");
  }
  _getLogId() {
    return `AccountAllowanceAdjustTransaction:${this._transactionIds.current.validStart.toString()}`;
  }
};

// node_modules/@hashgraph/sdk/lib/account/AccountInfoFlow.js
var n27 = class {
  static async verifySignature(n31, i17, c17, a23) {
    const r41 = await new c9().setAccountId(i17).execute(n31);
    return !(r41.key instanceof s4) && r41.key.verify(c17, a23);
  }
  static async verifyTransaction(n31, i17, c17) {
    const a23 = await new c9().setAccountId(i17).execute(n31);
    return !(a23.key instanceof s4) && a23.key.verifyTransaction(c17);
  }
  static async verifySignatureWithSigner(n31, i17, c17, a23) {
    const r41 = await new c9().setAccountId(i17).executeWithSigner(n31);
    return !(r41.key instanceof s4) && r41.key.verify(c17, a23);
  }
  static async verifyTransactionWithSigner(n31, i17, c17) {
    const a23 = await new c9().setAccountId(i17).executeWithSigner(n31);
    return !(a23.key instanceof s4) && a23.key.verifyTransaction(c17);
  }
};

// node_modules/@hashgraph/sdk/lib/contract/ContractCreateFlow.js
var c16 = class {
  constructor() {
    this._bytecode = null, this._contractCreate = new d10(), this._signerPublicKeys = /* @__PURE__ */ new Set(), this._publicKeys = [], this._transactionSigners = [], this._maxChunks = null;
  }
  get maxChunks() {
    return this._maxChunks;
  }
  setMaxChunks(t35) {
    return this._maxChunks = t35, this;
  }
  get bytecode() {
    return this._bytecode;
  }
  setBytecode(t35) {
    return this._bytecode = t35 instanceof Uint8Array ? t35 : n8(t35), this;
  }
  get adminKey() {
    return this._contractCreate.adminKey;
  }
  setAdminKey(t35) {
    return this._contractCreate.setAdminKey(t35), this;
  }
  get gas() {
    return this._contractCreate.gas;
  }
  setGas(t35) {
    return this._contractCreate.setGas(t35), this;
  }
  get initialBalance() {
    return this._contractCreate.initialBalance;
  }
  setInitialBalance(t35) {
    return this._contractCreate.setInitialBalance(t35), this;
  }
  get proxyAccountId() {
    return this._contractCreate.proxyAccountId;
  }
  setProxyAccountId(t35) {
    return this._contractCreate.setProxyAccountId(t35), this;
  }
  get autoRenewPeriod() {
    return this._contractCreate.autoRenewPeriod;
  }
  setAutoRenewPeriod(t35) {
    return this._contractCreate.setAutoRenewPeriod(t35), this;
  }
  get constructorParameters() {
    return this._contractCreate.constructorParameters;
  }
  setConstructorParameters(t35) {
    return this._contractCreate.setConstructorParameters(t35), this;
  }
  get contractMemo() {
    return this._contractCreate.contractMemo;
  }
  setContractMemo(t35) {
    return this._contractCreate.setContractMemo(t35), this;
  }
  get maxAutomaticTokenAssociation() {
    return this._contractCreate.maxAutomaticTokenAssociations;
  }
  setMaxAutomaticTokenAssociations(t35) {
    return this._contractCreate.setMaxAutomaticTokenAssociations(t35), this;
  }
  get stakedAccountId() {
    return this._contractCreate.stakedAccountId;
  }
  setStakedAccountId(t35) {
    return this._contractCreate.setStakedAccountId(t35), this;
  }
  get stakedNodeId() {
    return this._contractCreate.stakedNodeId;
  }
  setStakedNodeId(t35) {
    return this._contractCreate.setStakedNodeId(t35), this;
  }
  get declineStakingRewards() {
    return this._contractCreate.declineStakingRewards;
  }
  setDeclineStakingReward(t35) {
    return this._contractCreate.setDeclineStakingReward(t35), this;
  }
  get autoRenewAccountId() {
    return this._contractCreate.autoRenewAccountId;
  }
  setAutoRenewAccountId(t35) {
    return this._contractCreate.setAutoRenewAccountId(t35), this;
  }
  sign(t35) {
    return this.signWith(t35.publicKey, ((e39) => Promise.resolve(t35.sign(e39))));
  }
  signWith(t35, e39) {
    const i17 = t35.toBytesRaw(), n31 = n(i17);
    return this._signerPublicKeys.has(n31) || (this._publicKeys.push(t35), this._transactionSigners.push(e39)), this;
  }
  async execute(n31, r41) {
    if (null == this._bytecode) throw new Error("cannot create contract with no bytecode");
    const a23 = n31.operatorPublicKey, s26 = new l11().setKeys(null != a23 ? [a23] : []).setContents(this._bytecode.subarray(0, Math.min(this._bytecode.length, 2048))).freezeWith(n31);
    await o30(s26, this._publicKeys, this._transactionSigners);
    let c17 = await s26.execute(n31, r41);
    const h8 = (await c17.getReceipt(n31)).fileId;
    if (this._bytecode.length > 2048) {
      const t35 = new c11().setFileId(h8).setContents(this._bytecode.subarray(2048)).freezeWith(n31);
      await o30(t35, this._publicKeys, this._transactionSigners), await t35.execute(n31, r41);
    }
    if (this._contractCreate.setBytecodeFileId(h8).freezeWith(n31), await o30(this._contractCreate, this._publicKeys, this._transactionSigners), c17 = await this._contractCreate.execute(n31, r41), await c17.getReceipt(n31), null != a23) {
      const t35 = new r17().setFileId(h8).freezeWith(n31);
      await o30(t35, this._publicKeys, this._transactionSigners), await (await t35.execute(n31, r41)).getReceipt(n31);
    }
    return c17;
  }
  async executeWithSigner(n31) {
    if (null == this._bytecode) throw new Error("cannot create contract with no bytecode");
    if (null == n31.getAccountKey) throw new Error("`Signer.getAccountKey()` is not implemented, but is required for `ContractCreateFlow`");
    const r41 = await n31.getAccountKey();
    let a23;
    if (r41 instanceof i) a23 = r41;
    else {
      const t35 = Object.values(r41._key._key._keyData), e39 = new Uint8Array(t35);
      a23 = i.fromBytes(e39);
    }
    const c17 = await new l11().setKeys(null != a23 ? [a23] : []).setContents(this._bytecode.subarray(0, Math.min(this._bytecode.length, 2048))).freezeWithSigner(n31);
    await c17.signWithSigner(n31), await o30(c17, this._publicKeys, this._transactionSigners);
    let h8 = await c17.executeWithSigner(n31);
    const u22 = (await h8.getReceiptWithSigner(n31)).fileId;
    if (this._bytecode.length > 2048) {
      let t35 = new c11().setFileId(u22).setContents(this._bytecode.subarray(2048));
      null != this._maxChunks && t35.setMaxChunks(this._maxChunks), t35 = await t35.freezeWithSigner(n31), await t35.signWithSigner(n31), await o30(t35, this._publicKeys, this._transactionSigners), await t35.executeWithSigner(n31);
    }
    if (this._contractCreate = await this._contractCreate.setBytecodeFileId(u22).freezeWithSigner(n31), this._contractCreate = await this._contractCreate.signWithSigner(n31), await o30(this._contractCreate, this._publicKeys, this._transactionSigners), h8 = await this._contractCreate.executeWithSigner(n31), await h8.getReceiptWithSigner(n31), null != r41) {
      const t35 = await new r17().setFileId(u22).freezeWithSigner(n31);
      await t35.signWithSigner(n31), await o30(t35, this._publicKeys, this._transactionSigners), await (await t35.executeWithSigner(n31)).getReceiptWithSigner(n31);
    }
    return h8;
  }
};
async function o30(t35, e39, i17) {
  for (let n31 = 0; n31 < e39.length; n31++) await t35.signWith(e39[n31], i17[n31]);
}

// node_modules/@hashgraph/sdk/lib/EthereumFlow.js
var r36 = class {
  constructor(t35 = {}) {
    this._ethereumData = null, this._callDataFileId = null, this._maxGasAllowance = null, null != t35.ethereumData && this.setEthereumData(t35.ethereumData), null != t35.maxGasAllowance && this.setMaxGasAllowanceHbar(t35.maxGasAllowance), this._maxChunks = null;
  }
  get maxChunks() {
    return this._maxChunks;
  }
  setMaxChunks(t35) {
    return this._maxChunks = t35, this;
  }
  get ethereumData() {
    return this._ethereumData;
  }
  setEthereumData(t35) {
    return this._ethereumData = t35 instanceof Uint8Array ? e19.fromBytes(t35) : t35, this;
  }
  get maxGasAllowance() {
    return this._maxGasAllowance;
  }
  setMaxGasAllowance(t35) {
    return this.setMaxGasAllowanceHbar(t35);
  }
  setMaxGasAllowanceHbar(e39) {
    return this._maxGasAllowance = e39 instanceof e4 ? e39 : new e4(e39), this;
  }
  async execute(t35) {
    if (null == this._ethereumData) throw new Error("cannot submit ethereum transaction with no ethereum data");
    const a23 = new r19(), r41 = this._ethereumData.toBytes();
    if (null != this._maxGasAllowance && a23.setMaxGasAllowanceHbar(this._maxGasAllowance), null != this._callDataFileId) {
      if (0 === this._ethereumData.callData.length) throw new Error("call data file ID provided, but ethereum data already contains call data");
      a23.setEthereumData(r41).setCallDataFileId(this._callDataFileId);
    } else if (r41.length <= 128e3) a23.setEthereumData(r41);
    else {
      const e39 = await (async function(t36, e40, a24) {
        const r42 = n(t36), i17 = (await (await new l11().setContents(r42.substring(0, 4096)).setKeys(e40.operatorPublicKey ? [e40.operatorPublicKey] : []).execute(e40)).getReceipt(e40)).fileId;
        if (t36.length > 4096) {
          let t37 = new c11().setFileId(i17).setContents(r42.substring(4096, r42.length));
          null != a24 && t37.setMaxChunks(a24), await (await t37.execute(e40)).getReceipt(e40);
        }
        return i17;
      })(this._ethereumData.callData, t35, this._maxChunks);
      this._ethereumData.callData = new Uint8Array(), a23.setEthereumData(this._ethereumData.toBytes()).setCallDataFileId(e39);
    }
    return a23.execute(t35);
  }
};

// node_modules/@hashgraph/sdk/lib/ExchangeRates.js
var e31 = __toESM(require_lib(), 1);
var { proto: r37 } = e31;
var o31 = class _o {
  constructor(t35) {
    this.currentRate = t35.currentRate, this.nextRate = t35.nextRate, Object.freeze(this);
  }
  static _fromProtobuf(e39) {
    return new _o({ currentRate: t11._fromProtobuf(e39.currentRate), nextRate: t11._fromProtobuf(e39.nextRate) });
  }
  _toProtobuf() {
    return { currentRate: this.currentRate._toProtobuf(), nextRate: this.nextRate._toProtobuf() };
  }
  static fromBytes(t35) {
    return _o._fromProtobuf(r37.ExchangeRateSet.decode(t35));
  }
};

// node_modules/@hashgraph/sdk/lib/FeeComponents.js
var t31 = __toESM(require_lib(), 1);
var n28 = class _n {
  constructor(t35 = {}) {
    this.min = t35.min, this.max = t35.max, this.constant = t35.constant, this.transactionBandwidthByte = t35.transactionBandwidthByte, this.transactionVerification = t35.transactionVerification, this.transactionRamByteHour = t35.transactionRamByteHour, this.transactionStorageByteHour = t35.transactionStorageByteHour, this.contractTransactionGas = t35.contractTransactionGas, this.transferVolumeHbar = t35.transferVolumeHbar, this.responseMemoryByte = t35.responseMemoryByte, this.responseDiskByte = t35.responseDiskByte;
  }
  static fromBytes(o32) {
    return _n._fromProtobuf(t31.proto.FeeComponents.decode(o32));
  }
  static _fromProtobuf(t35) {
    return new _n({ min: null != t35.min ? t35.min : void 0, max: null != t35.max ? t35.max : void 0, constant: null != t35.constant ? t35.constant : void 0, transactionBandwidthByte: null != t35.bpt ? t35.bpt : void 0, transactionVerification: null != t35.vpt ? t35.vpt : void 0, transactionRamByteHour: null != t35.rbh ? t35.rbh : void 0, transactionStorageByteHour: null != t35.sbh ? t35.sbh : void 0, contractTransactionGas: null != t35.gas ? t35.gas : void 0, transferVolumeHbar: null != t35.tv ? t35.tv : void 0, responseMemoryByte: null != t35.bpr ? t35.bpr : void 0, responseDiskByte: null != t35.sbpr ? t35.sbpr : void 0 });
  }
  _toProtobuf() {
    return { min: null != this.min ? this.min : void 0, max: null != this.max ? this.max : void 0, constant: null != this.constant ? this.constant : void 0, bpt: null != this.transactionBandwidthByte ? this.transactionBandwidthByte : void 0, vpt: null != this.transactionVerification ? this.transactionVerification : void 0, rbh: null != this.transactionRamByteHour ? this.transactionRamByteHour : void 0, sbh: null != this.transactionStorageByteHour ? this.transactionStorageByteHour : void 0, gas: null != this.contractTransactionGas ? this.contractTransactionGas : void 0, tv: null != this.transferVolumeHbar ? this.transferVolumeHbar : void 0, bpr: null != this.responseMemoryByte ? this.responseMemoryByte : void 0, sbpr: null != this.responseDiskByte ? this.responseDiskByte : void 0 };
  }
  toBytes() {
    return t31.proto.FeeComponents.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/FeeData.js
var t32 = __toESM(require_lib(), 1);
var a18 = class _a2 {
  constructor(t35 = {}) {
    this.nodedata = t35.nodedata, this.networkdata = t35.networkdata, this.servicedata = t35.servicedata, this.feeDataType = t35.feeDataType;
  }
  static fromBytes(o32) {
    return _a2._fromProtobuf(t32.proto.FeeData.decode(o32));
  }
  static _fromProtobuf(t35) {
    return new _a2({ nodedata: null != t35.nodedata ? n28._fromProtobuf(t35.nodedata) : void 0, networkdata: null != t35.networkdata ? n28._fromProtobuf(t35.networkdata) : void 0, servicedata: null != t35.servicedata ? n28._fromProtobuf(t35.servicedata) : void 0, feeDataType: null != t35.subType ? e21._fromCode(t35.subType) : void 0 });
  }
  _toProtobuf() {
    return { nodedata: null != this.nodedata ? this.nodedata._toProtobuf() : void 0, networkdata: null != this.networkdata ? this.networkdata._toProtobuf() : void 0, servicedata: null != this.servicedata ? this.servicedata._toProtobuf() : void 0, subType: null != this.feeDataType ? this.feeDataType.valueOf() : void 0 };
  }
  toBytes() {
    return t32.proto.FeeData.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/FeeSchedule.js
var e33 = __toESM(require_lib(), 1);

// node_modules/@hashgraph/sdk/lib/TransactionFeeSchedule.js
var e32 = __toESM(require_lib(), 1);
var a19 = class _a2 {
  constructor(e39 = {}) {
    this.hederaFunctionality = e39.hederaFunctionality, this.feeData = e39.feeData, this.fees = e39.fees;
  }
  static fromBytes(t35) {
    return _a2._fromProtobuf(e32.proto.TransactionFeeSchedule.decode(t35));
  }
  static _fromProtobuf(e39) {
    return new _a2({ hederaFunctionality: null != e39.hederaFunctionality ? e22._fromCode(e39.hederaFunctionality) : void 0, feeData: null != e39.feeData ? a18._fromProtobuf(e39.feeData) : void 0, fees: null != e39.fees ? e39.fees.map(((e40) => a18._fromProtobuf(e40))) : void 0 });
  }
  _toProtobuf() {
    return { hederaFunctionality: null != this.hederaFunctionality ? this.hederaFunctionality.valueOf() : void 0, feeData: null != this.feeData ? this.feeData._toProtobuf() : void 0, fees: null != this.fees ? this.fees.map(((e39) => e39._toProtobuf())) : void 0 };
  }
  toBytes() {
    return e32.proto.TransactionFeeSchedule.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/FeeSchedule.js
var r38 = class _r {
  constructor(e39 = {}) {
    this.transactionFeeSchedule = e39.transactionFeeSchedule, this.expirationTime = e39.expirationTime;
  }
  static fromBytes(t35) {
    return _r._fromProtobuf(e33.proto.FeeSchedule.decode(t35));
  }
  static _fromProtobuf(e39) {
    return new _r({ transactionFeeSchedule: null != e39.transactionFeeSchedule ? e39.transactionFeeSchedule.map(((e40) => a19._fromProtobuf(e40))) : void 0, expirationTime: null != e39.expiryTime ? s3._fromProtobuf(e39.expiryTime) : void 0 });
  }
  _toProtobuf() {
    return { transactionFeeSchedule: null != this.transactionFeeSchedule ? this.transactionFeeSchedule.map(((e39) => e39._toProtobuf())) : void 0, expiryTime: null != this.expirationTime ? this.expirationTime._toProtobuf() : void 0 };
  }
  toBytes() {
    return e33.proto.FeeSchedule.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/FeeSchedules.js
var e34 = __toESM(require_lib(), 1);
var r39 = class _r {
  constructor(e39 = {}) {
    this.current = e39.currentFeeSchedule, this.next = e39.nextFeeSchedule;
  }
  static fromBytes(t35) {
    return _r._fromProtobuf(e34.proto.CurrentAndNextFeeSchedule.decode(t35));
  }
  static _fromProtobuf(e39) {
    return new _r({ currentFeeSchedule: null != e39.currentFeeSchedule ? r38._fromProtobuf(e39.currentFeeSchedule) : void 0, nextFeeSchedule: null != e39.nextFeeSchedule ? r38._fromProtobuf(e39.nextFeeSchedule) : void 0 });
  }
  _toProtobuf() {
    return { currentFeeSchedule: null != this.current ? this.current._toProtobuf() : void 0, nextFeeSchedule: null != this.next ? this.next._toProtobuf() : void 0 };
  }
  toBytes() {
    return e34.proto.CurrentAndNextFeeSchedule.encode(this._toProtobuf()).finish();
  }
};

// node_modules/@hashgraph/sdk/lib/query/MirrorNodeContractQuery.js
var e35 = class {
  constructor() {
    this._contractId = null, this._contractEvmAddress = null, this._sender = null, this._senderEvmAddress = null, this._functionName = null, this._functionParameters = null, this._value = null, this._gasLimit = null, this._gasPrice = null, this._blockNumber = null;
  }
  setContractId(t35) {
    return this._contractId = t35, this;
  }
  setSender(t35) {
    return this._sender = t35, this;
  }
  setSenderEvmAddress(t35) {
    return this._senderEvmAddress = t35, this;
  }
  setFunction(e39, r41) {
    return this._functionParameters = null != r41 ? r41._build(e39) : new _2()._build(e39), this;
  }
  setValue(t35) {
    return this._value = t35, this;
  }
  setGasLimit(t35) {
    return this._gasLimit = t35, this;
  }
  setGasPrice(t35) {
    return this._gasPrice = t35, this;
  }
  setBlockNumber(t35) {
    return this._blockNumber = t35, this;
  }
  get contractId() {
    return this._contractId;
  }
  get contractEvmAddress() {
    var _a2;
    const t35 = (_a2 = this._contractId) == null ? void 0 : _a2.toEvmAddress();
    if (null == t35) throw new Error("Contract ID is not set");
    return t35;
  }
  get sender() {
    return this._sender;
  }
  get senderEvmAddress() {
    return this._senderEvmAddress;
  }
  get callData() {
    return this._functionParameters;
  }
  get value() {
    return this._value;
  }
  get gasLimit() {
    return this._gasLimit;
  }
  get gasPrice() {
    return this._gasPrice;
  }
  get blockNumber() {
    return this._blockNumber;
  }
  async performMirrorNodeRequest(t35, e39) {
    var _a2;
    if (null == this.contractId) throw new Error("Contract ID is not set");
    this._fillEvmAddress();
    let r41 = t35.mirrorNetwork[0];
    const s26 = "/api/v1/contracts/call";
    if (!t35.ledgerId || ((_a2 = t35.ledgerId) == null ? void 0 : _a2.isLocalNode())) r41 = "http://".concat(t35.mirrorNetwork[0].replace("5600", "8545")).concat(s26);
    else {
      let e40 = t35.mirrorNetwork[0].split(":");
      r41 = "https://".concat(e40[0]).concat(s26);
    }
    const n31 = await fetch(r41, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(e39) });
    if (!n31.ok) throw new Error(`HTTP error! status: ${n31.status}`);
    return await n31.json();
  }
  _fillEvmAddress() {
    null == this.senderEvmAddress && null != this.sender && (this._senderEvmAddress = this.sender.toEvmAddress());
  }
  get JSONPayload() {
    throw new Error("JSONPayload getter is not implemented. Please implement this method in the subclass.");
  }
};

// node_modules/@hashgraph/sdk/lib/query/MirrorNodeContractCallQuery.js
var e36 = class extends e35 {
  get JSONPayload() {
    var _a2, _b, _c, _d;
    if (null == this.callData) throw new Error("Call data is required.");
    return { data: n(this.callData), from: this.senderEvmAddress, to: this.contractEvmAddress, estimate: false, gasPrice: (_a2 = this.gasPrice) == null ? void 0 : _a2.toString(), gas: (_b = this.gasLimit) == null ? void 0 : _b.toString(), blockNumber: (_c = this.blockNumber) == null ? void 0 : _c.toString(), value: (_d = this.value) == null ? void 0 : _d.toString() };
  }
  async execute(t35) {
    return (await this.performMirrorNodeRequest(t35, this.JSONPayload)).result;
  }
};

// node_modules/@hashgraph/sdk/lib/query/MirrorNodeContractEstimateQuery.js
var e37 = class extends e35 {
  get JSONPayload() {
    var _a2, _b, _c, _d;
    if (null == this.callData) throw new Error("Call data is required.");
    return { data: n(this.callData), from: this.senderEvmAddress, to: this.contractEvmAddress, estimate: true, gasPrice: (_a2 = this.gasPrice) == null ? void 0 : _a2.toString(), gas: (_b = this.gasLimit) == null ? void 0 : _b.toString(), blockNumber: (_c = this.blockNumber) == null ? void 0 : _c.toString(), value: (_d = this.value) == null ? void 0 : _d.toString() };
  }
  async execute(t35) {
    const r41 = await this.performMirrorNodeRequest(t35, this.JSONPayload);
    return Number(r41.result);
  }
};

// node_modules/@hashgraph/sdk/lib/account/ProxyStaker.js
var n29 = class _n {
  constructor(t35) {
    this.accountId = t35.accountId, this.amount = t35.amount instanceof e4 ? t35.amount : new e4(t35.amount), Object.freeze(this);
  }
  static _fromProtobuf(u22) {
    return new _n({ accountId: y3._fromProtobuf(u22.accountID), amount: e4.fromTinybars(null != u22.amount ? u22.amount : 0) });
  }
  _toProtobuf() {
    return { accountID: this.accountId._toProtobuf(), amount: this.amount.toTinybars() };
  }
};

// node_modules/@hashgraph/sdk/lib/SignerSignature.js
var t33 = class {
  constructor(t35) {
    this.publicKey = t35.publicKey, this.signature = t35.signature, this.accountId = t35.accountId;
  }
};

// node_modules/@hashgraph/sdk/lib/topic/SubscriptionHandle.js
var s25 = class {
  constructor() {
    this._call = null, this._unsubscribed = false;
  }
  _setCall(s26) {
    this._call = s26;
  }
  unsubscribe() {
    null != this._call && (this._unsubscribed = true, this._call());
  }
};

// node_modules/@hashgraph/sdk/lib/token/TokenRejectFlow.js
var i15 = class {
  constructor() {
    this._ownerId = null, this._tokenIds = [], this._nftIds = [], this._freezeWithClient = null, this._signPrivateKey = null, this._signPublicKey = null, this._transactionSigner = null;
  }
  setOwnerId(t35) {
    return this.requireNotFrozen(), this._ownerId = t35, this;
  }
  get ownerId() {
    return this._ownerId;
  }
  setTokenIds(t35) {
    return this.requireNotFrozen(), this._tokenIds = t35, this;
  }
  addTokenId(t35) {
    return this.requireNotFrozen(), this._tokenIds.push(t35), this;
  }
  get tokenIds() {
    return this._tokenIds;
  }
  setNftIds(t35) {
    return this.requireNotFrozen(), this._nftIds = t35, this;
  }
  addNftId(t35) {
    return this.requireNotFrozen(), this._nftIds.push(t35), this;
  }
  get nftIds() {
    return this._nftIds;
  }
  sign(t35) {
    return this._signPrivateKey = t35, this._signPublicKey = null, this._transactionSigner = null, this;
  }
  signWith(t35, e39) {
    return this._signPublicKey = t35, this._transactionSigner = e39, this._signPrivateKey = null, this;
  }
  signWithOperator(t35) {
    const e39 = t35.getOperator();
    if (null == e39) throw new Error("Client operator must be set");
    return this._signPublicKey = e39.publicKey, this._transactionSigner = e39.transactionSigner, this._signPrivateKey = null, this;
  }
  fillOutTransaction(t35) {
    this._freezeWithClient && t35.freezeWith(this._freezeWithClient), this._signPrivateKey ? t35.sign(this._signPrivateKey) : this._signPublicKey && this._transactionSigner && t35.signWith(this._signPublicKey, this._transactionSigner);
  }
  freezeWith(t35) {
    return this._freezeWithClient = t35, this;
  }
  async execute(i17) {
    const n31 = new o23().setTokenIds(this.tokenIds).setNftIds(this.nftIds);
    this.ownerId && n31.setOwnerId(this.ownerId), this.fillOutTransaction(n31);
    const s26 = this.nftIds.map(((t35) => t35.tokenId)).filter((function(t35, e39, i18) {
      return i18.indexOf(t35) === e39;
    })), r41 = new r25().setTokenIds([...this.tokenIds, ...s26]);
    null != this.ownerId && r41.setAccountId(this.ownerId), this.fillOutTransaction(r41);
    const o32 = await n31.execute(i17);
    await o32.getReceipt(i17);
    const h8 = await r41.execute(i17);
    return await h8.getReceipt(i17), o32;
  }
  requireNotFrozen() {
    if (null != this._freezeWithClient) throw new Error("Transaction is already frozen and cannot be modified");
  }
};

// node_modules/@hashgraph/sdk/lib/topic/TopicMessageChunk.js
var n30 = class _n {
  constructor(e39) {
    this.consensusTimestamp = e39.consensusTimestamp, this.contents = e39.contents, this.runningHash = e39.runningHash, this.sequenceNumber = e39.sequenceNumber, Object.freeze(this);
  }
  static _fromProtobuf(t35) {
    return new _n({ consensusTimestamp: s3._fromProtobuf(t35.consensusTimestamp), contents: null != t35.message ? t35.message : new Uint8Array(), runningHash: null != t35.runningHash ? t35.runningHash : new Uint8Array(), sequenceNumber: null != t35.sequenceNumber ? t35.sequenceNumber instanceof long_default ? t35.sequenceNumber : long_default.fromValue(t35.sequenceNumber) : long_default.ZERO });
  }
  _toProtobuf() {
    return { consensusTimestamp: this.consensusTimestamp._toProtobuf(), message: this.contents, runningHash: this.runningHash, sequenceNumber: this.sequenceNumber };
  }
};

// node_modules/@hashgraph/sdk/lib/topic/TopicMessage.js
var t34 = class _t {
  constructor(n31) {
    this.consensusTimestamp = n31.consensusTimestamp, this.contents = n31.contents, this.runningHash = n31.runningHash, this.sequenceNumber = n31.sequenceNumber, this.chunks = n31.chunks, this.initialTransactionId = n31.initialTransactionId, Object.freeze(this);
  }
  static _ofSingle(o32) {
    return new _t({ consensusTimestamp: s3._fromProtobuf(o32.consensusTimestamp), contents: null != o32.message ? o32.message : new Uint8Array(), runningHash: null != o32.runningHash ? o32.runningHash : new Uint8Array(), sequenceNumber: null != o32.sequenceNumber ? o32.sequenceNumber instanceof long_default ? o32.sequenceNumber : long_default.fromNumber(o32.sequenceNumber) : long_default.ZERO, initialTransactionId: null != o32.chunkInfo && null != o32.chunkInfo.initialTransactionID ? i4._fromProtobuf(o32.chunkInfo.initialTransactionID) : null, chunks: [n30._fromProtobuf(o32)] });
  }
  static _ofMany(o32) {
    const r41 = o32[o32.length - 1], i17 = s3._fromProtobuf(r41.consensusTimestamp), a23 = r41.runningHash, c17 = null != r41.sequenceNumber ? r41.sequenceNumber instanceof long_default ? r41.sequenceNumber : long_default.fromValue(r41.sequenceNumber) : long_default.ZERO;
    o32.sort(((n31, e39) => (null != n31 && null != n31.chunkInfo && null != n31.chunkInfo.number ? n31.chunkInfo.number : 0) < (null != e39 && null != e39.chunkInfo && null != e39.chunkInfo.number ? e39.chunkInfo.number : 0) ? -1 : 1));
    const m6 = o32.map(((n31) => n30._fromProtobuf(n31))), l19 = m6.map(((n31) => n31.contents.length)).reduce(((n31, e39) => n31 + e39), 0), f4 = new Uint8Array(l19);
    let h8 = 0;
    o32.forEach(((n31) => {
      f4.set(n31.message, h8), h8 += n31.message.length;
    }));
    let b5 = null;
    return o32.length > 0 && null != o32[0].chunkInfo && null != o32[0].chunkInfo.initialTransactionID && (b5 = i4._fromProtobuf(o32[0].chunkInfo.initialTransactionID)), new _t({ consensusTimestamp: i17, contents: f4, runningHash: a23, sequenceNumber: c17, chunks: m6, initialTransactionId: b5 });
  }
};

// node_modules/@hashgraph/sdk/lib/topic/TopicMessageQuery.js
var i16 = __toESM(require_lib(), 1);
var a20 = class {
  constructor(t35 = {}) {
    this._topicId = null, null != t35.topicId && this.setTopicId(t35.topicId), this._startTime = null, null != t35.startTime && this.setStartTime(t35.startTime), this._endTime = null, null != t35.endTime && this.setEndTime(t35.endTime), this._limit = null, null != t35.limit && this.setLimit(t35.limit), this._errorHandler = (t36, e39) => {
      console.error(`Error attempting to subscribe to topic: ${null != this._topicId ? this._topicId.toString() : ""}`);
    }, null != t35.errorHandler && (this._errorHandler = t35.errorHandler), this._listener = null, this._completionHandler = () => {
      console.log(`Subscription to topic ${null != this._topicId ? this._topicId.toString() : ""} complete`);
    }, null != t35.completionHandler && (this._completionHandler = t35.completionHandler), this._maxAttempts = 20, this._maxBackoff = 8e3, this._retryHandler = (t36) => {
      if (null != t36) {
        if (t36 instanceof Error) return true;
        switch (t36.code) {
          case 13:
            return a5.test(t36.details.toString());
          case 5:
          case 8:
          case 14:
          case 17:
            return true;
          default:
            return false;
        }
      }
      return false;
    }, null != t35.retryHandler && (this._retryHandler = t35.retryHandler), this._attempt = 0, this._handle = null, this.setMaxBackoff(8e3);
  }
  get topicId() {
    return this._topicId;
  }
  setTopicId(t35) {
    return this.requireNotSubscribed(), this._topicId = "string" == typeof t35 ? d4.fromString(t35) : t35.clone(), this;
  }
  get startTime() {
    return this._startTime;
  }
  setStartTime(t35) {
    return this.requireNotSubscribed(), this._startTime = t35 instanceof s3 ? t35 : t35 instanceof Date ? s3.fromDate(t35) : new s3(t35, 0), this;
  }
  get endTime() {
    return this._endTime;
  }
  setEndTime(t35) {
    return this.requireNotSubscribed(), this._endTime = t35 instanceof s3 ? t35 : t35 instanceof Date ? s3.fromDate(t35) : new s3(t35, 0), this;
  }
  get limit() {
    return this._limit;
  }
  setLimit(t35) {
    return this.requireNotSubscribed(), this._limit = t35 instanceof long_default ? t35 : long_default.fromValue(t35), this;
  }
  setErrorHandler(t35) {
    return this._errorHandler = t35, this;
  }
  setCompletionHandler(t35) {
    return this.requireNotSubscribed(), this._completionHandler = t35, this;
  }
  setMaxAttempts(t35) {
    return this.requireNotSubscribed(), this._maxAttempts = t35, this;
  }
  setMaxBackoff(t35) {
    return this.requireNotSubscribed(), this._maxBackoff = t35, this;
  }
  subscribe(t35, r41, i17) {
    return this._handle = new s25(), this._listener = i17, null != r41 && (this._errorHandler = r41), this._makeServerStreamRequest(t35), this._handle;
  }
  _makeServerStreamRequest(t35) {
    const e39 = this._buildConsensusRequest(), r41 = /* @__PURE__ */ new Map(), i17 = t35._mirrorNetwork.getNextMirrorNode().getChannel().makeServerStreamRequest("ConsensusService", "subscribeTopic", e39, ((t36) => this._handleMessage(t36, r41)), ((e40) => this._handleError(e40, t35)), this._completionHandler);
    null != this._handle && this._handle._setCall((() => i17()));
  }
  requireNotSubscribed() {
    if (null != this._handle) throw new Error("Cannot change fields on an already subscribed query");
  }
  _passTopicMessage(t35) {
    try {
      if (null == this._listener) throw new Error("(BUG) listener is unexpectedly not set");
      this._listener(t35);
    } catch (e39) {
      this._errorHandler(t35, e39);
    }
  }
  _buildConsensusRequest() {
    var _a3, _b, _c;
    return i16.com.hedera.mirror.api.proto.ConsensusTopicQuery.encode({ topicID: ((_a3 = this._topicId) == null ? void 0 : _a3._toProtobuf()) ?? null, consensusStartTime: ((_b = this._startTime) == null ? void 0 : _b._toProtobuf()) ?? null, consensusEndTime: ((_c = this._endTime) == null ? void 0 : _c._toProtobuf()) ?? null, limit: this._limit }).finish();
  }
  _handleMessage(t35, e39) {
    var _a3;
    const s26 = i16.com.hedera.mirror.api.proto.ConsensusTopicResponse.decode(t35);
    ((_a3 = this._limit) == null ? void 0 : _a3.gt(0)) && (this._limit = this._limit.sub(1)), this._startTime = s3._fromProtobuf(s26.consensusTimestamp).plusNanos(1), null == s26.chunkInfo || null != s26.chunkInfo && 1 === s26.chunkInfo.total ? this._passTopicMessage(t34._ofSingle(s26)) : this._handleChunkedMessage(s26, e39);
  }
  _handleChunkedMessage(e39, i17) {
    const s26 = e39.chunkInfo, n31 = s26.initialTransactionID, o32 = s26.total, l19 = i4._fromProtobuf(n31).toString();
    let a23 = [];
    const h8 = i17.get(l19);
    if (null == h8 ? i17.set(l19, a23) : a23 = h8, a23.push(e39), a23.length === o32) {
      const t35 = t34._ofMany(a23);
      i17.delete(l19), this._passTopicMessage(t35);
    }
  }
  _handleError(t35, e39) {
    var _a3;
    const r41 = t35 instanceof Error ? t35.message : t35.details;
    ((_a3 = this._handle) == null ? void 0 : _a3._unsubscribed) || (this.shouldRetry(t35) ? this._scheduleRetry(e39, r41) : this._errorHandler(null, new Error(r41)));
  }
  shouldRetry(t35) {
    return this._attempt < this._maxAttempts && this._retryHandler(t35);
  }
  _scheduleRetry(t35, e39) {
    var _a3;
    const r41 = Math.min(250 * 2 ** this._attempt, this._maxBackoff);
    console.warn(`Error subscribing to topic ${((_a3 = this._topicId) == null ? void 0 : _a3.toString()) ?? "UNKNOWN"} during attempt ${this._attempt}. Waiting ${r41} ms before next attempt: ${e39}`), this._attempt += 1, setTimeout((() => this._makeServerStreamRequest(t35)), r41);
  }
};

// node_modules/@hashgraph/sdk/lib/Wallet.js
var u21 = class _u {
  constructor(r41, n31, o32) {
    let c17;
    c17 = "string" == typeof n31 && g3.isDerKey(n31) ? g3.fromStringDer(n31) : "string" == typeof n31 ? g3.fromString(n31) : n31, this.publicKey = c17.publicKey, this.signer = (t35) => Promise.resolve(c17.sign(t35)), this.provider = o32, this.accountId = "string" == typeof r41 ? y3.fromString(r41) : r41;
  }
  static createRandomED25519() {
    const e39 = g3.generateED25519(), r41 = e39.publicKey.toAccountId(0, 0);
    return Promise.resolve(new _u(r41, e39));
  }
  static createRandomECDSA() {
    const e39 = g3.generateECDSA(), r41 = e39.publicKey.toAccountId(0, 0);
    return Promise.resolve(new _u(r41, e39));
  }
  getProvider() {
    return this.provider;
  }
  getAccountId() {
    return this.accountId;
  }
  getAccountKey() {
    return this.publicKey;
  }
  getLedgerId() {
    return null == this.provider ? null : this.provider.getLedgerId();
  }
  getNetwork() {
    return null == this.provider ? {} : this.provider.getNetwork();
  }
  getMirrorNetwork() {
    return null == this.provider ? [] : this.provider.getMirrorNetwork();
  }
  async sign(t35) {
    const e39 = [];
    for (const n31 of t35) e39.push(new t33({ publicKey: this.publicKey, signature: await this.signer(n31), accountId: this.accountId }));
    return e39;
  }
  getAccountBalance() {
    return this.call(new e13().setAccountId(this.accountId));
  }
  getAccountInfo() {
    return this.call(new c9().setAccountId(this.accountId));
  }
  getAccountRecords() {
    return this.call(new e14().setAccountId(this.accountId));
  }
  signTransaction(t35) {
    return t35.signWith(this.publicKey, this.signer);
  }
  checkTransaction(t35) {
    const e39 = t35.transactionId;
    if (null != e39 && null != e39.accountId && 0 != e39.accountId.compare(this.accountId)) throw new Error("transaction's ID constructed with a different account ID");
    if (null == this.provider) return Promise.resolve(t35);
    const r41 = (null != t35.nodeAccountIds ? t35.nodeAccountIds : []).map(((t36) => t36.toString())), n31 = Object.values(this.provider.getNetwork()).map(((t36) => t36.toString()));
    if (!r41.reduce(((t36, e40) => t36 && n31.includes(e40)), true)) throw new Error("Transaction already set node account IDs to values not within the current network");
    return Promise.resolve(t35);
  }
  populateTransaction(t35) {
    if (t35._freezeWithAccountId(this.accountId), null == t35.transactionId && t35.setTransactionId(i4.generate(this.accountId)), null != t35.nodeAccountIds && 0 != t35.nodeAccountIds.length) return Promise.resolve(t35.freeze());
    if (null == this.provider) return Promise.resolve(t35);
    const r41 = Object.values(this.provider.getNetwork()).map(((t36) => "string" == typeof t36 ? y3.fromString(t36) : t36));
    return T(r41), t35.setNodeAccountIds(r41.slice(0, (r41.length + 3 - 1) / 3)), Promise.resolve(t35.freeze());
  }
  call(t35) {
    if (null == this.provider) throw new Error("cannot send request with an wallet that doesn't contain a provider");
    return this.provider.call(t35._setOperatorWith(this.accountId, this.publicKey, this.signer));
  }
};

// node_modules/@hashgraph/sdk/lib/logger/Logger.js
var import_pino3 = __toESM(require_browser(), 1);
var r40 = class {
  constructor(t35, r41 = "", i17 = true, l19 = true, s26 = true, o32 = 0) {
    const g5 = r41 ? import_pino3.default.destination({ dest: r41, sync: i17, fsync: l19, mkdir: s26, minLength: o32 }) : null, n31 = g5 ? { level: t35.toString(), timestamp: import_pino3.default.stdTimeFunctions.isoTime, formatters: { bindings: () => ({}), level: (e39) => ({ level: e39.toUpperCase() }) } } : { level: t35.toString(), transport: { target: "pino-pretty", options: { translateTime: "SYS:dd-mm-yyyy HH:MM:ss", ignore: "pid,hostname" } } };
    this._logger = g5 ? (0, import_pino3.default)(n31, g5) : (0, import_pino3.default)(n31), this._previousLevel = t35;
  }
  setLogger(e39) {
    return this._logger = e39, this;
  }
  setLevel(e39) {
    return this._previousLevel = e27._fromString(this._logger.level), this._logger.level = e39.toString(), this;
  }
  get level() {
    return e27._fromString(this._logger.level);
  }
  get levels() {
    return this._logger.levels.labels;
  }
  setSilent(e39) {
    return this._logger.level = e39 ? e27.Silent.toString() : this._previousLevel.toString(), this;
  }
  get silent() {
    return this._logger.level == e27.Silent.toString();
  }
  trace(e39) {
    this._logger.trace(e39);
  }
  debug(e39) {
    this._logger.debug(e39);
  }
  info(e39) {
    this._logger.info(e39);
  }
  warn(e39) {
    this._logger.warn(e39);
  }
  error(e39) {
    this._logger.error(e39);
  }
  fatal(e39) {
    this._logger.fatal(e39);
  }
};

// node_modules/@hashgraph/sdk/lib/Provider.js
var a21 = {};

// node_modules/@hashgraph/sdk/lib/Signer.js
var a22 = {};
export {
  u20 as AccountAllowanceAdjustTransaction,
  c6 as AccountAllowanceApproveTransaction,
  r13 as AccountAllowanceDeleteTransaction,
  a7 as AccountBalance,
  e13 as AccountBalanceQuery,
  h7 as AccountCreateTransaction,
  c7 as AccountDeleteTransaction,
  y3 as AccountId,
  d8 as AccountInfo,
  n27 as AccountInfoFlow,
  c9 as AccountInfoQuery,
  e14 as AccountRecordsQuery,
  s13 as AccountUpdateTransaction,
  a16 as AddressBookQuery,
  n11 as AssessedCustomFee,
  BadKeyError,
  BadMnemonicError,
  BadMnemonicReason_default as BadMnemonicReason,
  o14 as BatchTransaction,
  t as Cache,
  a17 as Client,
  o15 as ContractByteCodeQuery,
  l10 as ContractCallQuery,
  c16 as ContractCreateFlow,
  d10 as ContractCreateTransaction,
  a9 as ContractDeleteTransaction,
  i8 as ContractExecuteTransaction,
  _2 as ContractFunctionParameters,
  l4 as ContractFunctionResult,
  i7 as ContractFunctionSelector,
  g4 as ContractId,
  d11 as ContractInfo,
  e17 as ContractInfoQuery,
  o8 as ContractLogInfo,
  c5 as ContractNonceInfo,
  d12 as ContractUpdateTransaction,
  e10 as CustomFee,
  o10 as CustomFeeLimit,
  l6 as CustomFixedFee,
  r26 as CustomFractionalFee,
  l14 as CustomRoyaltyFee,
  o17 as DelegateContractId,
  EntityIdHelper_exports as EntityIdHelper,
  r36 as EthereumFlow,
  r19 as EthereumTransaction,
  e19 as EthereumTransactionData,
  e20 as EthereumTransactionDataEip1559,
  a11 as EthereumTransactionDataEip2930,
  a10 as EthereumTransactionDataLegacy,
  i3 as EvmAddress,
  t11 as ExchangeRate,
  o31 as ExchangeRates,
  u3 as Executable,
  e18 as FeeAssessmentMethod,
  n28 as FeeComponents,
  a18 as FeeData,
  e21 as FeeDataType,
  r38 as FeeSchedule,
  r39 as FeeSchedules,
  c11 as FileAppendTransaction,
  n17 as FileContentsQuery,
  l11 as FileCreateTransaction,
  r17 as FileDeleteTransaction,
  c3 as FileId,
  f3 as FileInfo,
  o18 as FileInfoQuery,
  l13 as FileUpdateTransaction,
  l8 as FreezeTransaction,
  e15 as FreezeType,
  HEDERA_PATH,
  e4 as Hbar,
  o11 as HbarAllowance,
  e3 as HbarUnit,
  t2 as Key,
  s4 as KeyList,
  r15 as LedgerId,
  s10 as LiveHash,
  i9 as LiveHashAddTransaction,
  a12 as LiveHashDeleteTransaction,
  o19 as LiveHashQuery,
  e27 as LogLevel,
  r40 as Logger,
  long_default as Long,
  t10 as MaxAttemptsOrTimeoutError,
  e7 as MaxQueryPaymentExceeded,
  e36 as MirrorNodeContractCallQuery,
  e37 as MirrorNodeContractEstimateQuery,
  a as Mnemonic,
  e29 as NetworkName,
  e23 as NetworkVersionInfo,
  o21 as NetworkVersionInfoQuery,
  e9 as NftId,
  o25 as NodeAddressBook,
  s18 as NodeCreateTransaction,
  n24 as NodeDeleteTransaction,
  s19 as NodeUpdateTransaction,
  t13 as PendingAirdropId,
  n5 as PrecheckStatusError,
  g3 as PrivateKey,
  e24 as PrngTransaction,
  a21 as Provider,
  n29 as ProxyStaker,
  i as PublicKey,
  h3 as Query,
  r6 as ReceiptStatusError,
  e22 as RequestType,
  SLIP44_ECDSA_ETH_PATH,
  SLIP44_ECDSA_HEDERA_PATH,
  u14 as ScheduleCreateTransaction,
  u15 as ScheduleDeleteTransaction,
  o6 as ScheduleId,
  c12 as ScheduleInfo,
  r22 as ScheduleInfoQuery,
  u16 as ScheduleSignTransaction,
  o20 as SemanticVersion,
  t25 as ServiceEndpoint,
  e2 as SignatureMap,
  a22 as Signer,
  t33 as SignerSignature,
  e5 as Status,
  t9 as StatusError,
  s25 as SubscriptionHandle,
  n18 as SystemDeleteTransaction,
  o22 as SystemUndeleteTransaction,
  s3 as Timestamp,
  s8 as TokenAirdropTransaction,
  e12 as TokenAllowance,
  r23 as TokenAssociateTransaction,
  r24 as TokenBurnTransaction,
  e11 as TokenCancelAirdropTransaction,
  i6 as TokenClaimAirdropTransaction,
  _3 as TokenCreateTransaction,
  n19 as TokenDeleteTransaction,
  r25 as TokenDissociateTransaction,
  u17 as TokenFeeScheduleUpdateTransaction,
  r27 as TokenFreezeTransaction,
  r28 as TokenGrantKycTransaction,
  c4 as TokenId,
  d13 as TokenInfo,
  r29 as TokenInfoQuery,
  t24 as TokenKeyValidation,
  r30 as TokenMintTransaction,
  o12 as TokenNftAllowance,
  n20 as TokenNftInfo,
  u18 as TokenNftInfoQuery,
  n21 as TokenPauseTransaction,
  i15 as TokenRejectFlow,
  o23 as TokenRejectTransaction,
  r31 as TokenRevokeKycTransaction,
  e26 as TokenSupplyType,
  e25 as TokenType,
  r32 as TokenUnfreezeTransaction,
  o24 as TokenUnpauseTransaction,
  s17 as TokenUpdateNftsTransaction,
  a15 as TokenUpdateTransaction,
  s16 as TokenWipeTransaction,
  c13 as TopicCreateTransaction,
  i11 as TopicDeleteTransaction,
  d4 as TopicId,
  l15 as TopicInfo,
  n22 as TopicInfoQuery,
  t34 as TopicMessage,
  n30 as TopicMessageChunk,
  a20 as TopicMessageQuery,
  u19 as TopicMessageSubmitTransaction,
  l16 as TopicUpdateTransaction,
  P as Transaction,
  a19 as TransactionFeeSchedule,
  i4 as TransactionId,
  d5 as TransactionReceipt,
  l3 as TransactionReceiptQuery,
  b3 as TransactionRecord,
  h5 as TransactionRecordQuery,
  h6 as TransactionResponse,
  n7 as Transfer,
  T2 as TransferTransaction,
  u21 as Wallet,
  a17 as WebClient
};
/*! Bundled license information:

long/umd/index.js:
long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

pvtsutils/build/index.es.js:
  (*!
   * MIT License
   * 
   * Copyright (c) 2017-2024 Peculiar Ventures, LLC
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   * 
   *)

pvutils/build/utils.es.js:
  (*!
   Copyright (c) Peculiar Ventures, LLC
  *)

asn1js/build/index.es.js:
  (*!
   * Copyright (c) 2014, GMO GlobalSign
   * Copyright (c) 2015-2022, Peculiar Ventures
   * All rights reserved.
   * 
   * Author 2014-2019, Yury Strozhevsky
   * 
   * Redistribution and use in source and binary forms, with or without modification,
   * are permitted provided that the following conditions are met:
   * 
   * * Redistributions of source code must retain the above copyright notice, this
   *   list of conditions and the following disclaimer.
   * 
   * * Redistributions in binary form must reproduce the above copyright notice, this
   *   list of conditions and the following disclaimer in the documentation and/or
   *   other materials provided with the distribution.
   * 
   * * Neither the name of the copyright holder nor the names of its
   *   contributors may be used to endorse or promote products derived from
   *   this software without specific prior written permission.
   * 
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   * 
   *)
*/
//# sourceMappingURL=@hashgraph_sdk.js.map
