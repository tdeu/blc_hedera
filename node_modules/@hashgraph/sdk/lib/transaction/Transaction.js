import t from"../Hbar.js";import n from"./TransactionResponse.js";import s from"./TransactionId.js";import i from"./TransactionHashMap.js";import e from"./SignatureMap.js";import o from"./SignatureMapLegacy.js";import r,{ExecutionState as a}from"../Executable.js";import c from"../Status.js";import h from"long";import{digest as u}from"../cryptography/sha384.js";import{encode as d}from"../encoding/hex.js";import*as l from"@hashgraph/proto";import g from"../PrecheckStatusError.js";import _ from"../account/AccountId.js";import f from"../PublicKey.js";import p from"./List.js";import m from"../Timestamp.js";import{compare as y}from"../util.js";import T from"./CustomFeeLimit.js";import b from"../Key.js";import I from"./SignableNodeTransactionBodyBytes.js";const w=h.fromValue(7776e3),S=t.fromTinybars(h.fromString("9223372036854775807")),A=new _(0,0,0),k=1024,B=new Map;class P extends r{constructor(){super(),this._transactions=new p,this._signedTransactions=new p,this._signerPublicKeys=new Set,this._transactionValidDuration=120,this._defaultMaxTransactionFee=new t(2),this._customFeeLimits=[],this._maxTransactionFee=null,this._transactionMemo="",this._transactionIds=new p,this._publicKeys=[],this._transactionSigners=[],this._regenerateTransactionId=null,this._batchKey=null,this._isThrottled=!1}static fromBytes(t){const n=[],i=[],e=[],o=[],r=[],a=[],c=l.proto.TransactionList.decode(t).transactionList;if(0===c.length){const n=l.proto.Transaction.decode(t);0!==n.signedTransactionBytes.length?c.push(n):c.push({signedTransactionBytes:l.proto.SignedTransaction.encode({sigMap:n.sigMap,bodyBytes:n.bodyBytes}).finish()})}for(const t of c){if(null==t.bodyBytes&&null==t.signedTransactionBytes)throw new Error("bodyBytes and signedTransactionBytes are null");if(t.bodyBytes&&0!=t.bodyBytes.length){const n=l.proto.TransactionBody.decode(t.bodyBytes);if(null!=n.transactionID){const t=s._fromProtobuf(n.transactionID);o.includes(t.toString())||(i.push(t),o.push(t.toString()))}if(null!=n.nodeAccountID){const t=_._fromProtobuf(n.nodeAccountID);r.includes(t.toString())||(e.push(t),r.push(t.toString()))}if(null==n.data)throw new Error("(BUG) body.data was not set in the protobuf");a.push(n)}if(t.signedTransactionBytes&&0!=t.signedTransactionBytes.length){const c=l.proto.SignedTransaction.decode(t.signedTransactionBytes);n.push(c);const h=l.proto.TransactionBody.decode(c.bodyBytes);if(null!=h.transactionID){const t=s._fromProtobuf(h.transactionID);o.includes(t.toString())||(i.push(t),o.push(t.toString()))}if(null!=h.nodeAccountID){const t=_._fromProtobuf(h.nodeAccountID);r.includes(t.toString())||(e.push(t),r.push(t.toString()))}if(null==h.data)throw new Error("(BUG) body.data was not set in the protobuf");a.push(h)}}const h=a[0];if(null==h||null==h.data)throw new Error("No transaction found in bytes or failed to decode TransactionBody");const u=B.get(h.data);if(null==u)throw new Error(`(BUG) Transaction.fromBytes() not implemented for type ${h.data}`);return u(c,n,i,e,a)}schedule(){if(this._requireNotFrozen(),1!=F.length)throw new Error("ScheduleCreateTransaction has not been loaded yet");return F[0]()._setScheduledTransaction(this)}async batchify(t,n){return this._requireNotFrozen(),this.setBatchKey(n),await this.signWithOperator(t)}static _fromProtobufTransactions(n,s,i,e,o,r){const a=r[0];for(let t=0;t<e.length;t++)for(let n=0;n<o.length-1;n++)if(!y(r[t*o.length+n],r[t*o.length+n+1],new Set(["nodeAccountID"])))throw new Error("failed to validate transaction bodies");const c=new _(0);for(let t=0;t<o.length;t++)o[t].equals(c)&&o.splice(t--,1);n._transactions.setList(s),n._signedTransactions.setList(i),n._transactionIds.setList(e),n._nodeAccountIds.setList(o),n._transactionValidDuration=null!=a.transactionValidDuration&&null!=a.transactionValidDuration.seconds?h.fromValue(a.transactionValidDuration.seconds).toInt():120,n._maxTransactionFee=null!=a.transactionFee&&a.transactionFee>new h(0,0,!0)?t.fromTinybars(a.transactionFee):null,n._customFeeLimits=null!=a.maxCustomFees?a.maxCustomFees?.map((t=>T._fromProtobuf(t))):[],n._batchKey=null!=a.batchKey?b._fromProtobufKey(a?.batchKey):null,n._transactionMemo=null!=a.memo?a.memo:"";for(let t=0;t<o.length;t++){const e=i[t]||s[t];if(null!=e.sigMap&&null!=e.sigMap.sigPair)for(const t of e.sigMap.sigPair)n._signerPublicKeys.add(d(t.pubKeyPrefix)),n._publicKeys.push(f.fromBytes(t.pubKeyPrefix)),n._transactionSigners.push(null)}return n}setNodeAccountIds(t){return this._requireNotFrozen(),super.setNodeAccountIds(t),this}get transactionValidDuration(){return this._transactionValidDuration}get size(){return this._requireFrozen(),this._makeRequestAsync().then((t=>l.proto.Transaction.encode(t).finish().length))}get bodySize(){const t=this._makeTransactionBody(_.fromString("0.0.0"));return l.proto.TransactionBody.encode(t).finish().length}setTransactionValidDuration(t){return this._requireNotFrozen(),this._transactionValidDuration=t,this}get maxTransactionFee(){return this._maxTransactionFee}setMaxTransactionFee(n){return this._requireNotFrozen(),this._maxTransactionFee=n instanceof t?n:new t(n),this}get regenerateTransactionId(){return this._regenerateTransactionId}setRegenerateTransactionId(t){return this._requireNotFrozen(),this._regenerateTransactionId=t,this}get transactionMemo(){return this._transactionMemo}setTransactionMemo(t){return this._requireNotFrozen(),this._transactionMemo=t,this}get transactionId(){return this._transactionIds.isEmpty?null:(this._transactionIds.setLocked(),this._transactionIds.current)}setTransactionId(t){return this._requireNotFrozen(),this._transactionIds.setList([t]).setLocked(),this}getRequiredChunks(){return 1}get bodySizeAllChunks(){const t=[];for(let n=0;n<this.getRequiredChunks();n++)this._transactionIds.index=n,t.push(this.bodySize);return this._transactionIds.index=0,t}sign(t){return this.signWith(t.publicKey,(n=>Promise.resolve(t.sign(n))))}async signWith(t,n){this._signOnDemand||this._requireFrozen();const s=t.toBytesRaw(),i=d(s);if(this._signerPublicKeys.has(i))return this;if(this._transactions.clear(),this._signerPublicKeys.add(i),this._publicKeys.push(t),this._transactionSigners.push(n),this._signOnDemand)return this;this._transactionIds.setLocked(),this._nodeAccountIds.setLocked();for(const s of this._signedTransactions.list){const i=s.bodyBytes,e=await n(i);null==s.sigMap&&(s.sigMap={}),null==s.sigMap.sigPair&&(s.sigMap.sigPair=[]),s.sigMap.sigPair.push(t._toProtobufSignature(e))}return this}signWithOperator(t){const n=t._operator;if(null==n)throw new Error("`client` must have an operator to sign with the operator");return this._isFrozen()||this.freezeWith(t),this.signWith(n.publicKey,n.transactionSigner)}_resetTransaction(t){if(!t.operatorAccountId)throw new Error("Client must have an operator account ID");this.logger?.info("Resetting transaction id and resigning");const n=s.generate(t.operatorAccountId);this._transactionIds.clear(),this._signedTransactions.clear(),this._transactionIds.setList([n]),this._isThrottled=!0}addSignature(t,n){if(!(n instanceof e))return this._addSignatureLegacy(t,n);this.isFrozen()||this.freeze();const i=t.toBytesRaw(),o=d(i);if(this._signerPublicKeys.has(o))return this;this._transactions.clear(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),this._signedTransactions.setLocked();for(let i=0;i<this._signedTransactions.length;i++){const e=this._signedTransactions.get(i);if(null==e.sigMap&&(e.sigMap={}),null==e.sigMap.sigPair&&(e.sigMap.sigPair=[]),e.bodyBytes){const{transactionID:i,nodeAccountID:o}=l.proto.TransactionBody.decode(e.bodyBytes);if(!i||!o)throw new Error("Transaction ID or Node Account ID not found in the signed transaction");const r=s._fromProtobuf(i),a=_._fromProtobuf(o),c=n.get(a),h=c?.get(r),u=h?.get(t);if(!u)throw new Error("Signature not found for the transaction and public key");const d=t._toProtobufSignature(u);e.sigMap?.sigPair?.push(d)}}return this._signerPublicKeys.add(o),this._publicKeys.push(t),this._transactionSigners.push(null),this}_addSignatureLegacy(t,n){const s=n instanceof Uint8Array,i=Array.isArray(n);if(this.getRequiredChunks()>1)throw new Error("Add signature is not supported for chunked transactions");if(s&&1!==this._signedTransactions.length)throw new Error("Signature array must match the number of transactions");if(i&&n.length!==this._signedTransactions.length)throw new Error("Signature array must match the number of transactions");this.isFrozen()||this.freeze();const e=t.toBytesRaw(),o=d(e);if(this._signerPublicKeys.has(o))return this;this._transactions.clear(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),this._signedTransactions.setLocked();const r=s?[n]:n;for(let n=0;n<this._signedTransactions.length;n++){const s=this._signedTransactions.get(n);null==s.sigMap&&(s.sigMap={}),null==s.sigMap.sigPair&&(s.sigMap.sigPair=[]),s.sigMap.sigPair.push(t._toProtobufSignature(r[n]))}return this._signerPublicKeys.add(o),this._publicKeys.push(t),this._transactionSigners.push(null),this}getSignaturesLegacy(){return this._requireFrozen(),this._requireNotSignOnDemand(),this._buildAllTransactions(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),o._fromTransaction(this)}removeSignature(t){this.isFrozen()||this.freeze();const n=t.toBytesRaw(),s=d(n);if(!this._signerPublicKeys.has(s))throw new Error("The public key has not signed this transaction");const i=[];for(const t of this._signedTransactions.list){const n=this._removeSignaturesFromTransaction(t,s);i.push(...n)}return this._signerPublicKeys.delete(s),this._publicKeys=this._publicKeys.filter((n=>!n.equals(t))),this._transactionSigners.pop(),i}removeAllSignatures(){this.isFrozen()||this.freeze();const t=this._collectSignaturesByPublicKey();for(const t of this._signedTransactions.list)t.sigMap&&t.sigMap.sigPair&&(t.sigMap.sigPair=[]);return this._signerPublicKeys.clear(),this._publicKeys=[],this._transactionSigners=[],t}getSignatures(t){return t?this.getSignaturesLegacy():(this._requireFrozen(),this._requireNotSignOnDemand(),this._buildAllTransactions(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),e._fromTransaction(this))}async getSignaturesAsync(){return this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),this._transactions.setLocked(),this._signedTransactions.setLocked(),e._fromTransaction(this)}_setTransactionId(){if(null==this._operatorAccountId&&this._transactionIds.isEmpty)throw new Error("`transactionId` must be set or `client` must be provided with `freezeWith`")}_setNodeAccountIds(t){if(this._nodeAccountIds.isEmpty){if(null==t)throw new Error("`nodeAccountId` must be set or `client` must be provided with `freezeWith`");this._nodeAccountIds.setList(t._network.getNodeAccountIdsForExecute())}}setBatchKey(t){return this._requireNotFrozen(),this._batchKey=t,this}get batchKey(){return this._batchKey}get signableNodeBodyBytesList(){return this._requireFrozen(),this._signedTransactions.list.map((t=>{if(!t.bodyBytes)throw new Error("Missing bodyBytes in signed transaction.");const n=l.proto.TransactionBody.decode(t.bodyBytes);if(!n.nodeAccountID)throw new Error("Missing nodeAccountID in transaction body.");const i=_._fromProtobuf(n.nodeAccountID);if(!n.transactionID)throw new Error("Missing transactionID in transaction body.");const e=s._fromProtobuf(n.transactionID);return new I(i,e,t.bodyBytes)}))}_buildSignedTransactions(){this._signedTransactions.locked||this._signedTransactions.setList(this._nodeAccountIds.list.map((t=>this._makeSignedTransaction(t))))}_buildIncompleteTransactions(){0==this._nodeAccountIds.length?this._transactions.setList([this._makeSignedTransaction(null)]):this._transactions.setList(this._nodeAccountIds.list.map((t=>this._makeSignedTransaction(t))))}freeze(){return this.freezeWith(null)}_freezeWithAccountId(t){null==this._operatorAccountId&&(this._operatorAccountId=t)}freezeWith(t){if(this._signOnDemand=null!=t&&t.signOnDemand,this._operator=null!=t?t._operator:null,this._freezeWithAccountId(null!=t?t.operatorAccountId:null),this._maxTransactionFee=null==this._maxTransactionFee?null!=t&&null!=t.defaultMaxTransactionFee?t.defaultMaxTransactionFee:this._defaultMaxTransactionFee:this._maxTransactionFee,this._regenerateTransactionId=null!=t&&null==this._regenerateTransactionId?t.defaultRegenerateTransactionId:this._regenerateTransactionId,this.batchKey?this._nodeAccountIds.setList([A]):this._setNodeAccountIds(t),this._setTransactionId(),null!=t)for(const n of this._transactionIds.list)null!=n.accountId&&n.accountId.validateChecksum(t);return this._buildNewTransactionIdList(),this._signOnDemand||this._buildSignedTransactions(),this}async signWithSigner(t){return await t.signTransaction(this),this}async freezeWithSigner(t){return await t.populateTransaction(this),this.freeze(),this}toBytes(){return this._requireNotSignOnDemand(),this._isFrozen()?(this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),this._buildAllTransactions()):this._buildIncompleteTransactions(),l.proto.TransactionList.encode({transactionList:this._transactions.list}).finish()}async toBytesAsync(){return this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),this._transactions.setLocked(),this._signedTransactions.setLocked(),l.proto.TransactionList.encode({transactionList:this._transactions.list}).finish()}async getTransactionHash(){return this._requireFrozen(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),this._transactions.setLocked(),this._signedTransactions.setLocked(),u(this._transactions.get(0).signedTransactionBytes)}async getTransactionHashPerNode(){return this._requireFrozen(),this._transactionIds.setLocked(),this._nodeAccountIds.setLocked(),await this._buildAllTransactionsAsync(),await i._fromTransaction(this)}isFrozen(){return this._signedTransactions.length>0}_getTransactionId(){const t=this.transactionId;if(null==t)throw new Error("transaction must have been frozen before getting the transaction ID, try calling `freeze`");return t}_validateChecksums(t){}async _beforeExecute(t){this.transactionNodeIds=Object.values(t.network).map((t=>t.toString())),this._logger&&this._logger.info(`Network used: ${t._network.networkName}`),this._isFrozen()||this.freezeWith(t),t.isAutoValidateChecksumsEnabled()&&this._validateChecksums(t),null!=this._operator&&null!=this._operator||(this._operator=null!=t?t._operator:null),null!=this._operatorAccountId&&null!=this._operatorAccountId||(this._operatorAccountId=null!=t&&null!=t._operator?t._operator.accountId:null),null!=this._operator&&await this.signWith(this._operator.publicKey,this._operator.transactionSigner)}async _makeRequestAsync(){const t=this._transactionIds.index*this._nodeAccountIds.length+this._nodeAccountIds.index;return this._signOnDemand||this._isThrottled?await this._buildTransactionAsync():(this._buildTransaction(t),this._transactions.get(t))}async _signTransaction(){const t=this._makeSignedTransaction(this._nodeAccountIds.next),n=t.bodyBytes;for(let s=0;s<this._publicKeys.length;s++){const i=this._publicKeys[s],e=this._transactionSigners[s];if(null==e)continue;const o=await e(n);null==t.sigMap&&(t.sigMap={}),null==t.sigMap.sigPair&&(t.sigMap.sigPair=[]),t.sigMap.sigPair.push(i._toProtobufSignature(o))}return t}_buildNewTransactionIdList(){if(this._transactionIds.locked||null==this._operatorAccountId)return;const t=s.withValidStart(this._operatorAccountId,m.generate());this._transactionIds.set(this._transactionIds.index,t)}_buildAllTransactions(){for(let t=0;t<this._signedTransactions.length;t++)this._buildTransaction(t)}async _buildAllTransactionsAsync(){if(this._signOnDemand){if(this._buildSignedTransactions(),!this._transactions.locked)for(let t=0;t<this._signedTransactions.length;t++)this._transactions.push(await this._buildTransactionAsync())}else this._buildAllTransactions()}_buildTransaction(t){if(this._transactions.length<t)for(let n=this._transactions.length;n<t;n++)this._transactions.push(null);null!=this._transactions.list[t]&&this._transactions.set(t,{signedTransactionBytes:l.proto.SignedTransaction.encode(this._signedTransactions.get(t)).finish()}),this._transactions.setIfAbsent(t,(()=>({signedTransactionBytes:l.proto.SignedTransaction.encode(this._signedTransactions.get(t)).finish()})))}async _buildTransactionAsync(){return{signedTransactionBytes:l.proto.SignedTransaction.encode(await this._signTransaction()).finish()}}_shouldRetry(t,n){const{nodeTransactionPrecheckCode:s}=n,i=c._fromCode(null!=s?s:l.proto.ResponseCodeEnum.OK);switch(this._logger&&(this._logger.debug(`[${this._getLogId()}] received status ${i.toString()}`),this._logger.info(`SDK Transaction Status Response: ${i.toString()}`)),i){case c.Busy:case c.Unknown:case c.PlatformTransactionNotCreated:case c.PlatformNotActive:return[i,a.Retry];case c.Ok:return[i,a.Finished];case c.TransactionExpired:return this._transactionIds.locked||null!=this._regenerateTransactionId&&!this._regenerateTransactionId?[i,a.Error]:(this._buildNewTransactionIdList(),[i,a.Retry]);default:return[i,a.Error]}}_mapStatusError(t,n,s){const{nodeTransactionPrecheckCode:i}=n,e=c._fromCode(null!=i?i:l.proto.ResponseCodeEnum.OK);return this._logger&&this._logger.info(`Transaction Error Info: ${e.toString()}, ${this.transactionId.toString()}`),new g({nodeId:s,status:e,transactionId:this._getTransactionId(),contractFunctionResult:null})}async _mapResponse(t,s,i){const e=await u(i.signedTransactionBytes),o=this._getTransactionId();return this._transactionIds.advance(),this._logger&&this._logger.info(`Transaction Info: ${JSON.stringify(new n({nodeId:s,transactionHash:e,transactionId:o,logger:this._logger}).toJSON())}`),new n({nodeId:s,transactionHash:e,transactionId:o,transaction:this,logger:this._logger})}_makeSignedTransaction(t){const n=this._makeTransactionBody(t);this._logger&&this._logger.info(`Transaction Body: ${JSON.stringify(n)}`);return{sigMap:{sigPair:[]},bodyBytes:l.proto.TransactionBody.encode(n).finish()}}isBatchedAndNotBatchTransaction(){return null!=this.batchKey&&"atomicBatch"!=this._getTransactionDataCase()}_makeTransactionBody(t){return{[this._getTransactionDataCase()]:this._makeTransactionData(),transactionFee:null!=this._maxTransactionFee?this._maxTransactionFee.toTinybars():null,memo:this._transactionMemo,transactionID:null!=this._transactionIds.current?this._transactionIds.current._toProtobuf():null,nodeAccountID:null!=t?t._toProtobuf():null,transactionValidDuration:{seconds:h.fromNumber(this._transactionValidDuration)},maxCustomFees:null!=this._customFeeLimits?this._customFeeLimits.map((t=>t._toProtobuf())):null,batchKey:this.batchKey?._toProtobufKey()}}_getTransactionDataCase(){throw new Error("not implemented")}_getScheduledTransactionBody(){return{memo:this.transactionMemo,transactionFee:null==this._maxTransactionFee?this._defaultMaxTransactionFee.toTinybars():this._maxTransactionFee.toTinybars(),[this._getTransactionDataCase()]:this._makeTransactionData()}}_makeTransactionData(){throw new Error("not implemented")}_isFrozen(){return this._signOnDemand||this._signedTransactions.length>0}_requireNotFrozen(){if(this._isFrozen())throw new Error("transaction is immutable; it has at least one signature or has been explicitly frozen")}_requireNotSignOnDemand(){if(this._signOnDemand)throw new Error("Please use `toBytesAsync()` if `signOnDemand` is enabled")}_requireFrozen(){if(!this._isFrozen())throw new Error("transaction must have been frozen before calculating the hash will be stable, try calling `freeze`")}_requireOneNodeAccountId(){if(1!=this._nodeAccountIds.length)throw"transaction did not have exactly one node ID set"}_requestToBytes(t){return l.proto.Transaction.encode(t).finish()}_responseToBytes(t){return l.proto.TransactionResponse.encode(t).finish()}_removeSignaturesFromTransaction(t,n){const s=[];return t.sigMap&&t.sigMap.sigPair?(t.sigMap.sigPair=t.sigMap.sigPair.filter((t=>{const i=this._shouldRemoveSignature(t,n),e=t.ed25519??t.ECDSASecp256k1;return i&&e&&s.push(e),!i})),s):[]}_shouldRemoveSignature=(t,n)=>d(t?.pubKeyPrefix||new Uint8Array)===n;_collectSignaturesByPublicKey(){const t=new Map,n={};for(const s of this._signedTransactions.list){if(!s.sigMap||!s.sigMap.sigPair)return new Map;for(const i of s.sigMap.sigPair){const s=i.ed25519??i.ECDSASecp256k1;if(!s||!i.pubKeyPrefix)return new Map;const e=d(i.pubKeyPrefix);let o=n[e];o||(o=f.fromString(e),n[e]=o),t.has(o)||t.set(o,[]);const r=t.get(o);r&&r.push(s)}}return t}}const F=[];export{k as CHUNK_SIZE,w as DEFAULT_AUTO_RENEW_PERIOD,S as DEFAULT_RECORD_THRESHOLD,F as SCHEDULE_CREATE_TRANSACTION,B as TRANSACTION_REGISTRY,P as default};
//# sourceMappingURL=Transaction.js.map
