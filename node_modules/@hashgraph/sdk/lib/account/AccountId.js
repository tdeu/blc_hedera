import t from"long";import{constructor as s,fromStringSplitter as e,fromEvmAddress as r,validateChecksum as i,fromSolidityAddress as n,toSolidityAddress as l,toEvmAddress as a,toStringWithChecksum as o}from"../EntityIdHelper.js";import*as m from"@hashgraph/proto";import u from"../Key.js";import h from"../PublicKey.js";import d from"../Cache.js";import c from"../EvmAddress.js";import{decode as f}from"../encoding/hex.js";import{isLongZeroAddress as v}from"../util.js";class y{constructor(t,e,r,i,n){const l=s(t,e,r);this.shard=l.shard,this.realm=l.realm,this.num=l.num,this.aliasKey=null!=i?i:null,this.evmAddress=null!=n?n:null,this._checksum=null}static fromString(s){let r,i,n=t.ZERO,l=t.ZERO,a=t.ZERO;if(s.startsWith("0x")&&42==s.length||40==s.length)i=c.fromString(s);else{const o=e(s);if(Number.isNaN(o.shard)||Number.isNaN(o.realm))throw new Error("invalid format for entity ID");null!=o.shard&&(n=t.fromString(o.shard)),null!=o.realm&&(l=t.fromString(o.realm)),o.numOrHex.length<20?a=t.fromString(o.numOrHex):40==o.numOrHex.length?i=c.fromString(o.numOrHex):r=h.fromString(o.numOrHex)}return new y(n,l,a,r,i)}static fromEvmAddress(t,s,e){const i="string"==typeof e?c.fromString(e):e,[n,l,a,o]=r(t,s,i.toString());return new y(n,l,a,void 0,o||void 0)}static fromEvmPublicAddress(t){return new y(0,0,0,void 0,t)}static _fromProtobuf(t){let s,e;return null!=t.alias&&(20===t.alias.length?e=c.fromBytes(t.alias):s=u._fromProtobufKey(m.proto.Key.decode(t.alias))),s instanceof h||(s=void 0),new y(null!=t.shardNum?t.shardNum:0,null!=t.realmNum?t.realmNum:0,null!=t.accountNum?t.accountNum:0,s,e)}get checksum(){return this._checksum}getEvmAddress(){return this.evmAddress}async populateAccountNum(s){if(null===this.evmAddress)throw new Error("field `evmAddress` should not be null");const e=s.mirrorNetwork[0].slice(0,s.mirrorNetwork[0].indexOf(":"));await new Promise((t=>{setTimeout(t,3e3)}));const r=`https://${e}/api/v1/accounts/${this.evmAddress.toString()}`,i=await fetch(r),n=(await i.json()).account;return this.num=t.fromString(n.slice(n.lastIndexOf(".")+1)),this}async populateAccountEvmAddress(t){if(null===this.num)throw new Error("field `num` should not be null");const s=t.mirrorNetwork[0].slice(0,t.mirrorNetwork[0].indexOf(":"));await new Promise((t=>{setTimeout(t,3e3)}));const e=`https://${s}/api/v1/accounts/${this.num.toString()}`,r=await fetch(e),i=(await r.json()).evm_address;return this.evmAddress=c.fromString(i),this}validate(t){console.warn("Deprecated: Use `validateChecksum` instead"),this.validateChecksum(t)}validateChecksum(t){if(null!=this.aliasKey)throw new Error("cannot calculate checksum with an account ID that has a aliasKey");i(this.shard,this.realm,this.num,this._checksum,t)}static fromBytes(t){return y._fromProtobuf(m.proto.AccountID.decode(t))}static fromSolidityAddress(t){return v(f(t))?new y(...n(t)):this.fromEvmAddress(0,0,t)}toSolidityAddress(){return null!=this.evmAddress?this.evmAddress.toString():null!=this.aliasKey&&"secp256k1"==this.aliasKey._key._type?this.aliasKey.toEvmAddress():l([this.shard,this.realm,this.num])}toEvmAddress(){return null!=this.evmAddress?a(this.evmAddress.toBytes()):a(this.num)}_toProtobuf(){let s=null;null!=this.aliasKey?s=m.proto.Key.encode(this.aliasKey._toProtobufKey()).finish():null!=this.evmAddress&&(s=this.evmAddress._bytes);const e=this.num.eq(t.fromBigInt(0n))&&s;return s?{alias:e?s:null,accountNum:e?null:this.num,shardNum:this.shard,realmNum:this.realm}:{alias:null,accountNum:this.num,shardNum:this.shard,realmNum:this.realm}}toBytes(){return m.proto.AccountID.encode(this._toProtobuf()).finish()}toString(){let t=this.num.toString();return null!=this.aliasKey?t=this.aliasKey.toString():null!=this.evmAddress&&(t=this.evmAddress.toString()),`${this.shard.toString()}.${this.realm.toString()}.${t}`}toStringWithChecksum(t){if(null!=this.aliasKey)throw new Error("cannot calculate checksum with an account ID that has a aliasKey");return o(this.toString(),t)}equals(t){let s=!1;return null!=this.aliasKey&&null!=t.aliasKey?s=this.aliasKey.equals(t.aliasKey):null!=this.evmAddress&&null!=t.evmAddress?s=this.evmAddress.equals(t.evmAddress):null==this.aliasKey&&null==t.aliasKey&&null==this.evmAddress&&null==t.evmAddress&&(s=this.num.eq(t.num)),this.shard.eq(t.shard)&&this.realm.eq(t.realm)&&s}clone(){const t=new y(this);return t._checksum=this._checksum,t.aliasKey=this.aliasKey,t.evmAddress=this.evmAddress,t}compare(t){let s=this.shard.compare(t.shard);if(0!=s)return s;if(s=this.realm.compare(t.realm),0!=s)return s;if(null!=this.aliasKey&&null!=t.aliasKey){const s=this.aliasKey.toString(),e=t.aliasKey.toString();return s>e?1:s<e?-1:0}if(null!=this.evmAddress&&null!=t.evmAddress){const s=this.evmAddress.toString(),e=t.evmAddress.toString();return s>e?1:s<e?-1:0}return null==this.aliasKey&&null==t.aliasKey&&null==this.evmAddress&&null==t.evmAddress?this.num.compare(t.num):1}}d.setAccountIdConstructor(((s,e,r)=>new y(s,e,t.ZERO,r)));export{y as default};
//# sourceMappingURL=AccountId.js.map
