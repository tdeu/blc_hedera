import{constructor as r,fromEvmAddress as t,fromStringSplitter as s,validateChecksum as e,fromSolidityAddress as o,toSolidityAddress as m,toEvmAddress as i,toStringWithChecksum as n,compare as h}from"../EntityIdHelper.js";import d from"../Key.js";import*as u from"@hashgraph/proto";import a from"../Cache.js";import{decode as l,encode as c}from"../encoding/hex.js";import{arrayEqual as f}from"../array.js";import v from"long";import{isLongZeroAddress as A}from"../util.js";import p from"../EvmAddress.js";class g extends d{constructor(t,s,e,o){super();const m=r(t,s,e);this.shard=m.shard,this.realm=m.realm,this.num=m.num,this.evmAddress=null!=o?o:null,this._checksum=null}static fromEvmAddress(r,s,e){const o=p.fromString(e),[m,i,n,h]=t(r,s,o.toString());return new g(m,i,n,h?.toBytes())}static fromString(r){const t=s(r);if(Number.isNaN(t.shard)||Number.isNaN(t.realm))throw new Error("invalid format for entity ID");const e=null!=t.shard?v.fromString(t.shard):v.ZERO,o=null!=t.realm?v.fromString(t.realm):v.ZERO,[m,i]=t.numOrHex.length<40?[v.fromString(t.numOrHex),void 0]:[v.ZERO,l(t.numOrHex)];return new g(e,o,m,i)}static _fromProtobuf(r){return new g(null!=r.shardNum?r.shardNum:0,null!=r.realmNum?r.realmNum:0,null!=r.contractNum?r.contractNum:0)}get checksum(){return this._checksum}async populateAccountNum(r){if(null===this.evmAddress)throw new Error("field `evmAddress` should not be null");const t=`https://${r.mirrorNetwork[0].slice(0,r.mirrorNetwork[0].indexOf(":"))}/api/v1/contracts/${c(this.evmAddress)}`,s=await fetch(t),e=(await s.json()).contract_id;return this.num=v.fromString(e.slice(e.lastIndexOf(".")+1)),this}validate(r){console.warn("Deprecated: Use `validateChecksum` instead"),this.validateChecksum(r)}validateChecksum(r){e(this.shard,this.realm,this.num,this._checksum,r)}static fromBytes(r){return g._fromProtobuf(u.proto.ContractID.decode(r))}static fromSolidityAddress(r){return A(l(r))?new g(...o(r)):this.fromEvmAddress(0,0,r)}toSolidityAddress(){return null!=this.evmAddress?c(this.evmAddress):m([this.shard,this.realm,this.num])}toEvmAddress(){return null!=this.evmAddress?i(this.evmAddress):i(this.num)}_toProtobuf(){return{contractNum:this.num,shardNum:this.shard,realmNum:this.realm,evmAddress:this.evmAddress}}toString(){return null!=this.evmAddress?`${this.shard.toString()}.${this.realm.toString()}.${c(this.evmAddress)}`:`${this.shard.toString()}.${this.realm.toString()}.${this.num.toString()}`}toStringWithChecksum(r){return n(this.toString(),r)}toBytes(){return u.proto.ContractID.encode(this._toProtobuf()).finish()}clone(){const r=new g(this);return r._checksum=this._checksum,r.evmAddress=this.evmAddress,r}compare(r){return h([this.shard,this.realm,this.num],[r.shard,r.realm,r.num])}equals(r){let t=!1;return null!=this.evmAddress&&null!=r.evmAddress&&(t=f(this.evmAddress,r.evmAddress)),this.shard.eq(r.shard)&&this.realm.eq(r.realm)&&this.num.eq(r.num)&&t}_toProtobufKey(){return{contractID:this._toProtobuf()}}static __fromProtobufKey(r){return g._fromProtobuf(r)}}a.setContractId((r=>g.__fromProtobufKey(r)));export{g as default};
//# sourceMappingURL=ContractId.js.map
