{"version":3,"file":"AddressBookQueryWeb.js","sources":["../../src/network/AddressBookQueryWeb.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\n\nimport Query from \"../query/Query.js\";\nimport NodeAddressBook from \"../address_book/NodeAddressBook.js\";\nimport FileId from \"../file/FileId.js\";\nimport { RST_STREAM } from \"../Executable.js\";\nimport NodeAddress from \"../address_book/NodeAddress.js\";\nimport {\n    MAINNET,\n    WEB_TESTNET,\n    WEB_PREVIEWNET,\n} from \"../constants/ClientConstants.js\";\n\n/**\n * @typedef {import(\"../channel/Channel.js\").default} Channel\n * @typedef {import(\"../channel/MirrorChannel.js\").default} MirrorChannel\n * @typedef {import(\"../channel/MirrorChannel.js\").MirrorError} MirrorError\n */\n\n/**\n * @template {Channel} ChannelT\n * @typedef {import(\"../client/Client.js\").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>\n */\n\n/**\n * @typedef {object} EndpointWebResponse\n * @property {string} domain_name\n * @property {string} ip_address_v4\n * @property {number} port\n */\n\n/**\n * @typedef {object} AddressBookQueryWebResponse\n * @property {Array<{\n *   admin_key: {\n *     key: string,\n *     _type: string,\n *   },\n *   decline_reward: boolean,\n *   grpc_proxy_endpoint: EndpointWebResponse,\n *   file_id: string,\n *   memo: string,\n *   public_key: string,\n *   node_id: number,\n *   node_account_id: string,\n *   node_cert_hash: string,\n *   address: string,\n *   service_endpoints: EndpointWebResponse[],\n *   description: string,\n *   stake: number\n * }>} nodes\n */\n\n/**\n * Web-compatible query to get a list of Hedera network node addresses from a mirror node.\n * Uses fetch API instead of gRPC for web environments.\n *\n * This query can be used to retrieve node addresses either from a specific file ID\n * or from the most recent address book if no file ID is specified. The response\n * contains node metadata including IP addresses and ports for both node and mirror\n * node services.\n * @augments {Query<NodeAddressBook>}\n */\nexport default class AddressBookQueryWeb extends Query {\n    /**\n     * @param {object} props\n     * @param {FileId | string} [props.fileId]\n     * @param {number} [props.limit]\n     */\n    constructor(props = {}) {\n        super();\n\n        /**\n         * @private\n         * @type {?FileId}\n         */\n        this._fileId = null;\n        if (props.fileId != null) {\n            this.setFileId(props.fileId);\n        }\n\n        /**\n         * Page limit for the query\n         * @private\n         * @type {?number}\n         */\n        this._limit = null;\n        if (props.limit != null) {\n            this.setLimit(props.limit);\n        }\n\n        /**\n         * @private\n         * @type {(error: MirrorError | Error | null) => boolean}\n         */\n        this._retryHandler = (error) => {\n            if (error != null) {\n                if (error instanceof Error) {\n                    // Retry on all errors which are not `MirrorError` because they're\n                    // likely lower level HTTP errors\n                    return true;\n                } else {\n                    // Retry on `NOT_FOUND`, `RESOURCE_EXHAUSTED`, `UNAVAILABLE`, and conditionally on `INTERNAL`\n                    // if the message matches the right regex.\n                    switch (error.code) {\n                        // INTERNAL\n                        // eslint-disable-next-line no-fallthrough\n                        case 13:\n                            return RST_STREAM.test(error.details.toString());\n                        // NOT_FOUND\n                        // eslint-disable-next-line no-fallthrough\n                        case 5:\n                        // RESOURCE_EXHAUSTED\n                        // eslint-disable-next-line no-fallthrough\n                        case 8:\n                        // UNAVAILABLE\n                        // eslint-disable-next-line no-fallthrough\n                        case 14:\n                        case 17:\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n            }\n\n            return false;\n        };\n\n        /** @type {NodeAddress[]} */\n        this._addresses = [];\n    }\n\n    /**\n     * @returns {?FileId}\n     */\n    get fileId() {\n        return this._fileId;\n    }\n\n    /**\n     * @param {FileId | string} fileId\n     * @returns {AddressBookQueryWeb}\n     */\n    setFileId(fileId) {\n        this._fileId =\n            typeof fileId === \"string\"\n                ? FileId.fromString(fileId)\n                : fileId.clone();\n\n        return this;\n    }\n\n    /**\n     * Page limit for the query\n     * @returns {?number}\n     */\n    get limit() {\n        return this._limit;\n    }\n\n    /**\n     * Set the page limit for the query\n     * @param {number} limit\n     * @returns {AddressBookQueryWeb}\n     */\n    setLimit(limit) {\n        this._limit = limit;\n\n        return this;\n    }\n\n    /**\n     * @param {number} attempts\n     * @returns {this}\n     */\n    setMaxAttempts(attempts) {\n        this._maxAttempts = attempts;\n        return this;\n    }\n\n    /**\n     * @param {number} backoff\n     * @returns {this}\n     */\n    setMaxBackoff(backoff) {\n        this._maxBackoff = backoff;\n        return this;\n    }\n\n    /**\n     * @param {Client<Channel>} client\n     * @param {number=} requestTimeout\n     * @returns {Promise<NodeAddressBook>}\n     */\n    execute(client, requestTimeout) {\n        // Extra validation when initializing the client with only a mirror network\n        if (client._network._network.size === 0 && !client._timer) {\n            throw new Error(\n                \"The client's network update period is required. Please set it using the setNetworkUpdatePeriod method.\",\n            );\n        }\n\n        return new Promise((resolve, reject) => {\n            void this._makeFetchRequest(\n                client,\n                resolve,\n                reject,\n                requestTimeout,\n            );\n        });\n    }\n\n    /**\n     * @private\n     * @param {Client<Channel>} client\n     * @param {(value: NodeAddressBook) => void} resolve\n     * @param {(error: Error) => void} reject\n     * @param {number=} requestTimeout\n     */\n    async _makeFetchRequest(client, resolve, reject, requestTimeout) {\n        const { port, address } =\n            client._mirrorNetwork.getNextMirrorNode().address;\n\n        let baseUrl = `${address.includes(\"127.0.0.1\") || address.includes(\"localhost\") ? \"http\" : \"https\"}://${address}`;\n\n        if (port) {\n            baseUrl = `${baseUrl}:${port}`;\n        }\n\n        const url = new URL(`${baseUrl}/api/v1/network/nodes`);\n\n        if (this._fileId != null) {\n            url.searchParams.append(\"file.id\", this._fileId.toString());\n        }\n        if (this._limit != null) {\n            url.searchParams.append(\"limit\", this._limit.toString());\n        }\n\n        for (let attempt = 0; attempt <= this._maxAttempts; attempt++) {\n            try {\n                // eslint-disable-next-line n/no-unsupported-features/node-builtins\n                const response = await fetch(url.toString(), {\n                    method: \"GET\",\n                    headers: {\n                        Accept: \"application/json\",\n                    },\n                    signal: requestTimeout\n                        ? AbortSignal.timeout(requestTimeout)\n                        : undefined,\n                });\n\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const data = /** @type {AddressBookQueryWebResponse} */ (\n                    await response.json()\n                );\n\n                const nodes = data.nodes || [];\n\n                // eslint-disable-next-line ie11/no-loop-func\n                this._addresses = nodes.map((node) =>\n                    NodeAddress.fromJSON({\n                        nodeId: node.node_id.toString(),\n                        accountId: node.node_account_id,\n                        addresses: this._handleAddressesFromGrpcProxyEndpoint(\n                            node,\n                            client,\n                        ),\n                        certHash: node.node_cert_hash,\n                        publicKey: node.public_key,\n                        description: node.description,\n                        stake: node.stake.toString(),\n                    }),\n                );\n\n                const addressBook = new NodeAddressBook({\n                    nodeAddresses: this._addresses,\n                });\n\n                resolve(addressBook);\n                return;\n            } catch (error) {\n                console.error(\"Error in _makeFetchRequest:\", error);\n                const message =\n                    error instanceof Error ? error.message : String(error);\n\n                // Check if we should retry\n                if (\n                    attempt < this._maxAttempts &&\n                    !client.isClientShutDown &&\n                    this._retryHandler(\n                        /** @type {MirrorError | Error | null} */ (error),\n                    )\n                ) {\n                    const delay = Math.min(\n                        250 * 2 ** attempt,\n                        this._maxBackoff,\n                    );\n\n                    if (this._logger) {\n                        this._logger.debug(\n                            `Error getting nodes from mirror for file ${\n                                this._fileId != null\n                                    ? this._fileId.toString()\n                                    : \"UNKNOWN\"\n                            } during attempt ${\n                                attempt + 1\n                            }. Waiting ${delay} ms before next attempt: ${message}`,\n                        );\n                    }\n\n                    // Wait before next attempt\n                    // eslint-disable-next-line ie11/no-loop-func\n                    await new Promise((resolve) => setTimeout(resolve, delay));\n                    continue;\n                }\n\n                // If we shouldn't retry or have exhausted attempts, reject\n                const maxAttemptsReached = attempt >= this._maxAttempts;\n                const errorMessage = maxAttemptsReached\n                    ? `Failed to query address book after ${this._maxAttempts + 1} attempts. Last error: ${message}`\n                    : `Failed to query address book: ${message}`;\n                reject(new Error(errorMessage));\n                return;\n            }\n        }\n\n        // This should never be reached, but just in case\n        reject(new Error(\"failed to query address book\"));\n    }\n\n    /**\n     * Handles the grpc_proxy_endpoint fallback logic for a node.\n     * @param {AddressBookQueryWebResponse['nodes'][number]} node - The node object from the mirror node response.\n     * @param {Client<Channel>} client - The client instance.\n     * @returns {Array<{address: string, port: string}>}\n     */\n    _handleAddressesFromGrpcProxyEndpoint(node, client) {\n        const grpcProxyEndpoint = node.grpc_proxy_endpoint;\n\n        if (\n            grpcProxyEndpoint &&\n            grpcProxyEndpoint.domain_name &&\n            grpcProxyEndpoint.port\n        ) {\n            return [\n                {\n                    address: grpcProxyEndpoint.domain_name,\n                    port: grpcProxyEndpoint.port.toString(),\n                },\n            ];\n        }\n\n        let networkConstant;\n        const ledgerId = client._network.ledgerId;\n\n        if (ledgerId && ledgerId.isMainnet()) {\n            networkConstant = MAINNET;\n        } else if (ledgerId && ledgerId.isTestnet()) {\n            networkConstant = WEB_TESTNET;\n        } else if (ledgerId && ledgerId.isPreviewnet()) {\n            networkConstant = WEB_PREVIEWNET;\n        } else {\n            return [];\n        }\n\n        const nodeAccountId = node.node_account_id;\n\n        for (const [address, accountIdObj] of Object.entries(networkConstant)) {\n            if (accountIdObj.toString() === nodeAccountId) {\n                const [domain_name, port] = address.split(\":\");\n\n                return [\n                    {\n                        address: domain_name,\n                        port,\n                    },\n                ];\n            }\n        }\n\n        return [];\n    }\n}\n"],"names":["AddressBookQueryWeb","Query","constructor","props","super","this","_fileId","fileId","setFileId","_limit","limit","setLimit","_retryHandler","error","Error","code","RST_STREAM","test","details","toString","_addresses","FileId","fromString","clone","setMaxAttempts","attempts","_maxAttempts","setMaxBackoff","backoff","_maxBackoff","execute","client","requestTimeout","_network","size","_timer","Promise","resolve","reject","_makeFetchRequest","port","address","_mirrorNetwork","getNextMirrorNode","baseUrl","includes","url","URL","searchParams","append","attempt","response","fetch","method","headers","Accept","signal","AbortSignal","timeout","undefined","ok","status","nodes","json","map","node","NodeAddress","fromJSON","nodeId","node_id","accountId","node_account_id","addresses","_handleAddressesFromGrpcProxyEndpoint","certHash","node_cert_hash","publicKey","public_key","description","stake","NodeAddressBook","nodeAddresses","console","message","String","isClientShutDown","delay","Math","min","_logger","debug","setTimeout","errorMessage","grpcProxyEndpoint","grpc_proxy_endpoint","domain_name","networkConstant","ledgerId","isMainnet","MAINNET","isTestnet","WEB_TESTNET","isPreviewnet","WEB_PREVIEWNET","nodeAccountId","accountIdObj","Object","entries","split"],"mappings":"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"}