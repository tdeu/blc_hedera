import t from"../query/Query.js";import e from"../address_book/NodeAddressBook.js";import r from"../file/FileId.js";import{RST_STREAM as s}from"../Executable.js";import i from"../address_book/NodeAddress.js";import{MAINNET as o,WEB_TESTNET as n,WEB_PREVIEWNET as d}from"../constants/ClientConstants.js";class a extends t{constructor(t={}){super(),this._fileId=null,null!=t.fileId&&this.setFileId(t.fileId),this._limit=null,null!=t.limit&&this.setLimit(t.limit),this._retryHandler=t=>{if(null!=t){if(t instanceof Error)return!0;switch(t.code){case 13:return s.test(t.details.toString());case 5:case 8:case 14:case 17:return!0;default:return!1}}return!1},this._addresses=[]}get fileId(){return this._fileId}setFileId(t){return this._fileId="string"==typeof t?r.fromString(t):t.clone(),this}get limit(){return this._limit}setLimit(t){return this._limit=t,this}setMaxAttempts(t){return this._maxAttempts=t,this}setMaxBackoff(t){return this._maxBackoff=t,this}execute(t,e){if(0===t._network._network.size&&!t._timer)throw new Error("The client's network update period is required. Please set it using the setNetworkUpdatePeriod method.");return new Promise(((r,s)=>{this._makeFetchRequest(t,r,s,e)}))}async _makeFetchRequest(t,r,s,o){const{port:n,address:d}=t._mirrorNetwork.getNextMirrorNode().address;let a=`${d.includes("127.0.0.1")||d.includes("localhost")?"http":"https"}://${d}`;n&&(a=`${a}:${n}`);const l=new URL(`${a}/api/v1/network/nodes`);null!=this._fileId&&l.searchParams.append("file.id",this._fileId.toString()),null!=this._limit&&l.searchParams.append("limit",this._limit.toString());for(let n=0;n<=this._maxAttempts;n++)try{const s=await fetch(l.toString(),{method:"GET",headers:{Accept:"application/json"},signal:o?AbortSignal.timeout(o):void 0});if(!s.ok)throw new Error(`HTTP error! status: ${s.status}`);const n=(await s.json()).nodes||[];this._addresses=n.map((e=>i.fromJSON({nodeId:e.node_id.toString(),accountId:e.node_account_id,addresses:this._handleAddressesFromGrpcProxyEndpoint(e,t),certHash:e.node_cert_hash,publicKey:e.public_key,description:e.description,stake:e.stake.toString()})));return void r(new e({nodeAddresses:this._addresses}))}catch(e){console.error("Error in _makeFetchRequest:",e);const r=e instanceof Error?e.message:String(e);if(n<this._maxAttempts&&!t.isClientShutDown&&this._retryHandler(e)){const t=Math.min(250*2**n,this._maxBackoff);this._logger&&this._logger.debug(`Error getting nodes from mirror for file ${null!=this._fileId?this._fileId.toString():"UNKNOWN"} during attempt ${n+1}. Waiting ${t} ms before next attempt: ${r}`),await new Promise((e=>setTimeout(e,t)));continue}const i=n>=this._maxAttempts?`Failed to query address book after ${this._maxAttempts+1} attempts. Last error: ${r}`:`Failed to query address book: ${r}`;return void s(new Error(i))}s(new Error("failed to query address book"))}_handleAddressesFromGrpcProxyEndpoint(t,e){const r=t.grpc_proxy_endpoint;if(r&&r.domain_name&&r.port)return[{address:r.domain_name,port:r.port.toString()}];let s;const i=e._network.ledgerId;if(i&&i.isMainnet())s=o;else if(i&&i.isTestnet())s=n;else{if(!i||!i.isPreviewnet())return[];s=d}const a=t.node_account_id;for(const[t,e]of Object.entries(s))if(e.toString()===a){const[e,r]=t.split(":");return[{address:e,port:r}]}return[]}}export{a as default};
//# sourceMappingURL=AddressBookQueryWeb.js.map
