import{J as g,_ as h,K as p,bN as l,be as u,k as v,t as m}from"./index-DokNjuN4.js";const w=["constructor(address _adminManager, address _bondToken)","function DISPUTE_BOND_AMOUNT() external view returns (uint256)","function DISPUTE_PERIOD_HOURS() external view returns (uint256)","function adminManager() external view returns (address)","function bondToken() external view returns (address)","function getDispute(uint256 _disputeId) external view returns (tuple(uint256 id, address disputer, address marketAddress, uint256 bondAmount, string evidence, string reason, bytes32 evidenceHash, uint256 createdAt, uint256 resolveBy, uint8 status, uint8 outcome, address resolvedBy, uint256 resolvedAt, string adminNotes))","function getActiveDisputes() external view returns (uint256[])","function getMarketDisputes(address _marketAddress) external view returns (uint256[])","function getUserDisputes(address _user) external view returns (uint256[])","function hasActiveDisputes(address _marketAddress) external view returns (bool)","function createDispute(address _marketAddress, string calldata _reason, string calldata _evidence, bytes32 _evidenceHash) external returns (uint256)","function resolveDispute(uint256 _disputeId, uint8 _outcome, string calldata _adminNotes) external","event DisputeCreated(uint256 indexed disputeId, address indexed disputer, address indexed marketAddress, uint256 bondAmount, string evidence)","event DisputeResolved(uint256 indexed disputeId, address indexed resolver, uint8 outcome, bool bondReturned)"];class D{contract=null;provider=null;signer=null;async initialize(t){try{if(!t?.isConnected)throw new Error("Wallet not connected");if(this.provider=new g("https://testnet.hashio.io/api"),t.signer)this.signer=t.signer;else{const r=new h(window.ethereum);this.signer=await r.getSigner()}this.contract=new p(l.DISPUTE_MANAGER_CONTRACT,w,this.signer),console.log("✅ DisputeManagerService initialized with contract:",l.DISPUTE_MANAGER_CONTRACT)}catch(r){throw console.error("❌ Failed to initialize DisputeManagerService:",r),r}}async getBondRequirement(){try{if(!this.contract)throw new Error("DisputeManager contract not initialized");const t=await this.contract.DISPUTE_BOND_AMOUNT();return parseFloat(u(t))}catch(t){return console.error("❌ Error getting bond requirement:",t),1}}async createDispute(t,r,n){try{if(!this.contract||!this.signer)throw new Error("DisputeManager contract not initialized");if(console.log("🏛️ Creating dispute for market contract:",t),console.log("📋 Evidence length:",n.length),console.log("📋 Reason:",r),!t||t==="0x0000000000000000000000000000000000000000")throw new Error("Invalid market address");if(!n||n.trim().length<20)throw new Error("Evidence must be at least 20 characters");if(!r||r.trim().length<5)throw new Error("Reason must be at least 5 characters");const e=await this.getBondRequirement();console.log("💰 Required bond amount:",e,"CAST");const s=v(m(n));console.log("🔐 Evidence hash:",s),console.log("📤 Submitting dispute transaction...");const o=await this.contract.createDispute(t,r,n,s);console.log("⏳ Waiting for dispute transaction confirmation...");const i=await o.wait();let a="";if(i.logs)for(const c of i.logs)try{const d=this.contract.interface.parseLog(c);if(d&&d.name==="DisputeCreated"){a=d.args.disputeId.toString();break}}catch{continue}if(!a){const c=await this.getActiveDisputes();a=c.length>0?c[c.length-1].id:"0"}return console.log("✅ Dispute created successfully!"),console.log("🆔 Dispute ID:",a),console.log("🔗 Transaction hash:",i.hash),{disputeId:a,transactionHash:i.hash,bondAmount:e.toString()}}catch(e){throw console.error("❌ Error creating dispute:",e),new Error(`Failed to create dispute: ${e.message||e}`)}}async resolveDispute(t,r,n="Resolved by admin"){try{if(!this.contract)throw new Error("DisputeManager contract not initialized");console.log("🏛️ Resolving dispute:",t),console.log("⚖️ Outcome:",r);const e=r==="Upheld"?1:2,s=n.length>=5?n:"Resolved by admin",o=await this.contract.resolveDispute(t,e,s);console.log("⏳ Waiting for resolution transaction...");const i=await o.wait();console.log("✅ Dispute resolved successfully!"),console.log("🔗 Transaction hash:",i.hash)}catch(e){throw console.error("❌ Error resolving dispute:",e),new Error(`Failed to resolve dispute: ${e.message||e}`)}}async getActiveDisputes(){try{if(!this.contract)throw new Error("DisputeManager contract not initialized");const t=await this.contract.getActiveDisputes();console.log("📊 Found",t.length,"active disputes");const r=[];for(const n of t)try{const e=await this.contract.getDispute(n),s={id:n.toString(),disputer:e.disputer,marketAddress:e.marketAddress,bondAmount:u(e.bondAmount),evidence:e.evidence,reason:e.reason,evidenceHash:e.evidenceHash,createdAt:new Date(Number(e.createdAt)*1e3),resolvedAt:e.resolvedAt>0?new Date(Number(e.resolvedAt)*1e3):void 0,status:["Active","Resolved","Rejected","Expired"][e.status],outcome:["Pending","Upheld","Rejected"][e.outcome]};r.push(s)}catch{console.warn("⚠️ Failed to fetch dispute details for ID:",n.toString())}return r.sort((n,e)=>e.createdAt.getTime()-n.createdAt.getTime())}catch(t){return console.error("❌ Error getting active disputes:",t),[]}}async hasActiveDisputes(t){try{return this.contract?await this.contract.hasActiveDisputes(t):!1}catch(r){return console.error("❌ Error checking active disputes:",r),!1}}async getDisputesByMarket(t){try{if(!this.contract)return[];const r=await this.contract.getMarketDisputes(t),n=[];for(const e of r)try{const s=await this.contract.getDispute(e),o={id:e.toString(),disputer:s.disputer,marketAddress:s.marketAddress,bondAmount:u(s.bondAmount),evidence:s.evidence,reason:s.reason,evidenceHash:s.evidenceHash,createdAt:new Date(Number(s.createdAt)*1e3),resolvedAt:s.resolvedAt>0?new Date(Number(s.resolvedAt)*1e3):void 0,status:["Active","Resolved","Rejected","Expired"][s.status],outcome:["Pending","Upheld","Rejected"][s.outcome]};n.push(o)}catch{console.warn("⚠️ Failed to fetch dispute details for ID:",e.toString())}return n.sort((e,s)=>s.createdAt.getTime()-e.createdAt.getTime())}catch(r){return console.error("❌ Error getting disputes for market:",r),[]}}}const E=new D;export{E as disputeManagerService};
