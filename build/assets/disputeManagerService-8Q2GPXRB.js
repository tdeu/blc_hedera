import{J as g,B as h,C as v,T as l,f as u}from"./index-DgoscINn.js";const D=["constructor(address _adminManager, address _bondToken)","function DISPUTE_BOND_AMOUNT() external view returns (uint256)","function DISPUTE_PERIOD_HOURS() external view returns (uint256)","function adminManager() external view returns (address)","function bondToken() external view returns (address)","function getDispute(uint256 _disputeId) external view returns (tuple(uint256 id, address disputer, address marketAddress, uint256 bondAmount, string evidence, string reason, bytes32 evidenceHash, uint256 createdAt, uint256 resolvedAt, uint8 status, uint8 outcome))","function getActiveDisputes() external view returns (uint256[])","function getDisputesByMarket(address _marketAddress) external view returns (uint256[])","function getDisputesByUser(address _user) external view returns (uint256[])","function hasActiveDisputes(address _marketAddress) external view returns (bool)","function canCreateDispute(address _marketAddress) external view returns (bool)","function createDispute(address _marketAddress, string calldata _evidence, string calldata _reason) external returns (uint256)","function resolveDispute(uint256 _disputeId, uint8 _outcome) external","event DisputeCreated(uint256 indexed disputeId, address indexed disputer, address indexed marketAddress, uint256 bondAmount, string evidence)","event DisputeResolved(uint256 indexed disputeId, address indexed resolver, uint8 outcome, bool bondReturned)"];class w{contract=null;provider=null;signer=null;async initialize(t){try{if(!t?.isConnected)throw new Error("Wallet not connected");if(this.provider=new g("https://testnet.hashio.io/api"),t.signer)this.signer=t.signer;else{const s=new h(window.ethereum);this.signer=await s.getSigner()}this.contract=new v(l.DISPUTE_MANAGER_CONTRACT,D,this.signer),console.log("✅ DisputeManagerService initialized with contract:",l.DISPUTE_MANAGER_CONTRACT)}catch(s){throw console.error("❌ Failed to initialize DisputeManagerService:",s),s}}async getBondRequirement(){try{if(!this.contract)throw new Error("DisputeManager contract not initialized");const t=await this.contract.DISPUTE_BOND_AMOUNT();return parseFloat(u(t))}catch(t){return console.error("❌ Error getting bond requirement:",t),100}}async createDispute(t,s,n,e){try{if(!this.contract||!this.signer)throw new Error("DisputeManager contract not initialized");if(console.log("🏛️ Creating dispute for market:",t),console.log("📋 Evidence length:",n.length),console.log("📋 Reason:",e),!await this.contract.canCreateDispute(s))throw new Error("Cannot create dispute for this market at this time");const a=await this.getBondRequirement();console.log("💰 Required bond amount:",a,"CAST"),console.log("📤 Submitting dispute transaction...");const p=await this.contract.createDispute(s,n,e);console.log("⏳ Waiting for dispute transaction confirmation...");const c=await p.wait();let i="";if(c.logs)for(const o of c.logs)try{const d=this.contract.interface.parseLog(o);if(d&&d.name==="DisputeCreated"){i=d.args.disputeId.toString();break}}catch{continue}if(!i){const o=await this.getActiveDisputes();i=o.length>0?o[o.length-1].id:"0"}return console.log("✅ Dispute created successfully!"),console.log("🆔 Dispute ID:",i),console.log("🔗 Transaction hash:",c.hash),{disputeId:i,transactionHash:c.hash,bondAmount:a.toString()}}catch(r){throw console.error("❌ Error creating dispute:",r),new Error(`Failed to create dispute: ${r.message||r}`)}}async resolveDispute(t,s){try{if(!this.contract)throw new Error("DisputeManager contract not initialized");console.log("🏛️ Resolving dispute:",t),console.log("⚖️ Outcome:",s);const n=s==="Upheld"?1:2,e=await this.contract.resolveDispute(t,n);console.log("⏳ Waiting for resolution transaction...");const r=await e.wait();console.log("✅ Dispute resolved successfully!"),console.log("🔗 Transaction hash:",r.hash)}catch(n){throw console.error("❌ Error resolving dispute:",n),new Error(`Failed to resolve dispute: ${n.message||n}`)}}async getActiveDisputes(){try{if(!this.contract)throw new Error("DisputeManager contract not initialized");const t=await this.contract.getActiveDisputes();console.log("📊 Found",t.length,"active disputes");const s=[];for(const n of t)try{const e=await this.contract.getDispute(n),r={id:n.toString(),disputer:e.disputer,marketAddress:e.marketAddress,bondAmount:u(e.bondAmount),evidence:e.evidence,reason:e.reason,evidenceHash:e.evidenceHash,createdAt:new Date(Number(e.createdAt)*1e3),resolvedAt:e.resolvedAt>0?new Date(Number(e.resolvedAt)*1e3):void 0,status:["Active","Resolved","Rejected","Expired"][e.status],outcome:["Pending","Upheld","Rejected"][e.outcome]};s.push(r)}catch{console.warn("⚠️ Failed to fetch dispute details for ID:",n.toString())}return s.sort((n,e)=>e.createdAt.getTime()-n.createdAt.getTime())}catch(t){return console.error("❌ Error getting active disputes:",t),[]}}async hasActiveDisputes(t){try{return this.contract?await this.contract.hasActiveDisputes(t):!1}catch(s){return console.error("❌ Error checking active disputes:",s),!1}}async canCreateDispute(t){try{return this.contract?await this.contract.canCreateDispute(t):!1}catch(s){return console.error("❌ Error checking if dispute can be created:",s),!1}}async getDisputesByMarket(t){try{if(!this.contract)return[];const s=await this.contract.getDisputesByMarket(t),n=[];for(const e of s)try{const r=await this.contract.getDispute(e),a={id:e.toString(),disputer:r.disputer,marketAddress:r.marketAddress,bondAmount:u(r.bondAmount),evidence:r.evidence,reason:r.reason,evidenceHash:r.evidenceHash,createdAt:new Date(Number(r.createdAt)*1e3),resolvedAt:r.resolvedAt>0?new Date(Number(r.resolvedAt)*1e3):void 0,status:["Active","Resolved","Rejected","Expired"][r.status],outcome:["Pending","Upheld","Rejected"][r.outcome]};n.push(a)}catch{console.warn("⚠️ Failed to fetch dispute details for ID:",e.toString())}return n.sort((e,r)=>r.createdAt.getTime()-e.createdAt.getTime())}catch(s){return console.error("❌ Error getting disputes for market:",s),[]}}}const f=new w;export{f as disputeManagerService};
